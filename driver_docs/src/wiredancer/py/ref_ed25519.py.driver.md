# Purpose
This Python script is a reference implementation of the Ed25519 digital signature algorithm, as specified in RFC 8032. The code provides a comprehensive set of functions to perform key generation, signing, and verification of messages using the Ed25519 elliptic curve. The script includes functions for cryptographic operations such as hashing with SHA-512, modular arithmetic, and point operations on the elliptic curve. It defines key components like the base field \( Z_p \), the curve constant \( d \), and the group order \( q \). The script is structured to handle point addition, multiplication, compression, and decompression, which are essential for elliptic curve cryptography.

The script is designed to be executed as a standalone program, as indicated by the `if __name__ == '__main__':` block, which includes test vectors to validate the implementation against known correct values. These test vectors ensure the correctness of the signature generation and verification processes. The script does not define a public API for external use, but rather serves as a self-contained implementation for educational or testing purposes. The inclusion of test vectors and detailed print statements for each test case provides a clear demonstration of the algorithm's functionality and correctness.
# Imports and Dependencies

---
- `hashlib`


# Global Variables

---
### p
- **Type**: `int`
- **Description**: The variable `p` is a large prime number defined as `2**255 - 19`. It is used as the modulus for arithmetic operations in the finite field Z_p, which is a key component in elliptic curve cryptography, specifically for the Ed25519 signature scheme.
- **Use**: `p` is used as the modulus in various mathematical operations to ensure results remain within the finite field Z_p.


---
### d
- **Type**: `int`
- **Description**: The variable `d` is a constant used in the implementation of the Ed25519 elliptic curve. It is calculated as the product of -121665 and the modular inverse of 121666, modulo the prime number `p`, which defines the base field Z_p for the curve.
- **Use**: This variable is used as a curve constant in elliptic curve point operations, particularly in the point addition and point multiplication functions.


---
### q
- **Type**: `int`
- **Description**: The variable `q` is an integer representing the group order used in the Ed25519 elliptic curve cryptography. It is defined as `2**252 + 27742317777372353535851937790883648493`, which is a large prime number.
- **Use**: This variable is used in cryptographic operations to ensure the security and integrity of the Ed25519 signature scheme.


---
### modp\_sqrt\_m1
- **Type**: `int`
- **Description**: The variable `modp_sqrt_m1` is an integer that represents the square root of -1 in the finite field defined by the prime `p`, which is `2**255 - 19`. It is calculated using the modular exponentiation function `pow` with the base 2, exponent `(p-1) // 4`, and modulus `p`. This calculation is based on the properties of quadratic residues in modular arithmetic.
- **Use**: This variable is used in the `recover_x` function to compute the square root of a value in the field, which is necessary for recovering the x-coordinate of a point on the elliptic curve.


---
### g\_y
- **Type**: `int`
- **Description**: `g_y` is a global variable representing the y-coordinate of the base point on the elliptic curve used in the Ed25519 signature scheme. It is calculated as `4 * modp_inv(5) % p`, where `modp_inv` computes the modular inverse and `p` is the prime number defining the base field Z_p.
- **Use**: This variable is used as part of the base point `G` in elliptic curve operations for cryptographic functions such as signing and verification.


---
### g\_x
- **Type**: `int`
- **Description**: `g_x` is a global variable that stores the x-coordinate of the base point on the elliptic curve used in the Ed25519 signature scheme. It is calculated by calling the `recover_x` function with `g_y` and a sign bit of 0, which attempts to compute the x-coordinate corresponding to the given y-coordinate `g_y`. The value of `g_x` is crucial for defining the base point `G` used in elliptic curve operations.
- **Use**: `g_x` is used to define the base point `G` for elliptic curve operations in the Ed25519 signature scheme.


---
### G
- **Type**: `tuple`
- **Description**: The variable `G` is a tuple representing a point on the elliptic curve used in the Ed25519 digital signature algorithm. It is defined using the x-coordinate `g_x`, the y-coordinate `g_y`, a constant value `1`, and the product of `g_x` and `g_y` modulo `p`. This tuple is in the extended coordinates format (X, Y, Z, T) where x = X/Z, y = Y/Z, and x*y = T/Z.
- **Use**: `G` is used as the base point for elliptic curve operations such as point addition and scalar multiplication in the Ed25519 signature scheme.


# Functions

---
### sha512<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.sha512}} -->
The `sha512` function computes the SHA-512 hash of a given input and returns its binary digest.
- **Inputs**:
    - `s`: A byte string input for which the SHA-512 hash is to be computed.
- **Control Flow**:
    - The function calls `hashlib.sha512(s)` to create a SHA-512 hash object for the input `s`.
    - It then calls the `digest()` method on the hash object to obtain the binary digest of the hash.
- **Output**: The function returns the binary digest of the SHA-512 hash of the input `s`.


---
### modp\_inv<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.modp_inv}} -->
The `modp_inv` function computes the modular inverse of a given integer `x` in the finite field defined by the prime `p`.
- **Inputs**:
    - `x`: An integer for which the modular inverse is to be calculated.
- **Control Flow**:
    - The function uses the `pow` function to compute the modular inverse by raising `x` to the power of `p-2` modulo `p`.
- **Output**: The function returns the modular inverse of `x` modulo `p`, which is an integer.


---
### sha512\_modq<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.sha512_modq}} -->
The `sha512_modq` function computes the SHA-512 hash of a given input and reduces it modulo a predefined group order `q`.
- **Inputs**:
    - `s`: A byte string input for which the SHA-512 hash will be computed and reduced modulo `q`.
- **Control Flow**:
    - The function calls the [`sha512`](#sha512) function with the input `s` to compute its SHA-512 hash.
    - The resulting hash is converted from bytes to an integer using little-endian byte order.
    - The integer is then reduced modulo `q` to ensure it fits within the group order.
- **Output**: An integer representing the SHA-512 hash of the input `s`, reduced modulo `q`.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512`](#sha512)


---
### point\_add<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_add}} -->
The `point_add` function performs addition of two points on an elliptic curve using extended coordinates.
- **Inputs**:
    - `P`: A tuple representing a point on the elliptic curve in extended coordinates (X, Y, Z, T).
    - `Q`: A tuple representing another point on the elliptic curve in extended coordinates (X, Y, Z, T).
- **Control Flow**:
    - Calculate intermediate values A and B using the coordinates of points P and Q, and the modulus p.
    - Calculate intermediate values C and D using the coordinates of points P and Q, the curve constant d, and the modulus p.
    - Compute E, F, G, and H as differences and sums of the previously calculated intermediate values A, B, C, and D, modulo p.
    - Return a new point as a tuple of four values, each calculated as a product of two of the intermediate values (E, F, G, H) modulo p.
- **Output**: A tuple representing the resulting point on the elliptic curve in extended coordinates (X, Y, Z, T).


---
### point\_mul<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_mul}} -->
The `point_mul` function performs scalar multiplication of a point on an elliptic curve using the double-and-add method.
- **Inputs**:
    - `s`: An integer representing the scalar by which the point P is to be multiplied.
    - `P`: A tuple representing a point on the elliptic curve in extended coordinates (X, Y, Z, T).
- **Control Flow**:
    - Initialize Q as the neutral element (0, 1, 1, 0).
    - While the scalar s is greater than 0, check if the least significant bit of s is 1.
    - If the least significant bit of s is 1, add the point P to Q using the point_add function.
    - Double the point P by adding it to itself using the point_add function.
    - Right shift the scalar s by 1 bit to process the next bit.
    - Return the point Q with each coordinate reduced modulo p.
- **Output**: A tuple representing the resulting point on the elliptic curve after scalar multiplication, with each coordinate reduced modulo p.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_add`](#point_add)


---
### point\_equal<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_equal}} -->
The `point_equal` function checks if two points in extended coordinates are equal by comparing their x and y coordinates after normalizing by their z coordinates.
- **Inputs**:
    - `P`: A tuple representing a point in extended coordinates (X, Y, Z, T).
    - `Q`: A tuple representing another point in extended coordinates (X, Y, Z, T).
- **Control Flow**:
    - Calculate the difference between the cross products of the x and z coordinates of P and Q, and check if it is divisible by p.
    - If the result is not zero, return False, indicating the points are not equal.
    - Calculate the difference between the cross products of the y and z coordinates of P and Q, and check if it is divisible by p.
    - If the result is not zero, return False, indicating the points are not equal.
    - If both checks pass, return True, indicating the points are equal.
- **Output**: A boolean value indicating whether the two points are equal.


---
### recover\_x<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.recover_x}} -->
The `recover_x` function computes the x-coordinate of a point on an elliptic curve given a y-coordinate and a sign bit, or returns None if the computation fails.
- **Inputs**:
    - `y`: The y-coordinate of the point on the elliptic curve, an integer.
    - `sign`: A boolean indicating the desired parity of the x-coordinate (0 for even, 1 for odd).
- **Control Flow**:
    - Check if y is greater than or equal to p, return None if true.
    - Calculate x2 using the formula (y*y-1) * modp_inv(d*y*y+1).
    - If x2 is zero, return None if sign is true, otherwise return 0.
    - Compute the square root of x2 using modular exponentiation.
    - If the square of the computed x does not match x2 modulo p, adjust x using modp_sqrt_m1.
    - If the square of the adjusted x still does not match x2 modulo p, return None.
    - Check the parity of x against the sign; if they do not match, adjust x by subtracting it from p.
    - Return the computed x-coordinate.
- **Output**: The function returns the x-coordinate as an integer if successful, or None if the computation fails.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.modp_inv`](#modp_inv)


---
### point\_compress<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_compress}} -->
The `point_compress` function compresses a point on an elliptic curve from extended coordinates to a 32-byte representation.
- **Inputs**:
    - `P`: A tuple representing a point in extended coordinates (X, Y, Z, T) on an elliptic curve, where x = X/Z and y = Y/Z.
- **Control Flow**:
    - Calculate the modular inverse of the Z coordinate using `modp_inv(P[2])`.
    - Compute the x-coordinate by multiplying the X coordinate by the inverse of Z and taking modulo p.
    - Compute the y-coordinate by multiplying the Y coordinate by the inverse of Z and taking modulo p.
    - Combine the y-coordinate with the least significant bit of the x-coordinate shifted left by 255 bits.
    - Convert the result to a 32-byte little-endian representation using `int.to_bytes`.
- **Output**: A 32-byte little-endian byte string representing the compressed point.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.modp_inv`](#modp_inv)


---
### point\_decompress<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_decompress}} -->
The `point_decompress` function attempts to reconstruct a point on an elliptic curve from a compressed 32-byte representation.
- **Inputs**:
    - `s`: A 32-byte string representing the compressed form of a point on the elliptic curve.
- **Control Flow**:
    - Check if the length of input `s` is 32 bytes; if not, raise an exception.
    - Convert the byte string `s` into an integer `y` using little-endian byte order.
    - Extract the sign bit from `y` by right-shifting 255 bits and store it in `sign`.
    - Mask `y` to remove the sign bit, leaving only the y-coordinate value.
    - Call [`recover_x`](#recover_x) with `y` and `sign` to compute the corresponding x-coordinate `x`.
    - If [`recover_x`](#recover_x) returns `None`, return `None` indicating decompression failure.
    - If [`recover_x`](#recover_x) returns a valid `x`, return a tuple `(x, y, 1, x*y % p)` representing the point in extended coordinates.
- **Output**: Returns a tuple `(x, y, 1, x*y % p)` representing the decompressed point in extended coordinates, or `None` if decompression fails.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.recover_x`](#recover_x)


---
### secret\_expand<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.secret_expand}} -->
The `secret_expand` function processes a 32-byte secret key to derive a scalar and a hash suffix for cryptographic operations.
- **Inputs**:
    - `secret`: A 32-byte secret key used for cryptographic operations.
- **Control Flow**:
    - Check if the length of the secret is 32 bytes; if not, raise an exception.
    - Compute the SHA-512 hash of the secret.
    - Extract the first 32 bytes of the hash and convert it to an integer using little-endian byte order.
    - Apply bitwise operations to the integer to ensure it fits within a specific range for cryptographic use.
    - Return a tuple containing the processed integer and the remaining bytes of the hash.
- **Output**: A tuple containing a processed integer derived from the secret and the remaining bytes of the SHA-512 hash.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512`](#sha512)


---
### secret\_to\_public<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.secret_to_public}} -->
The `secret_to_public` function converts a private key into a public key using elliptic curve point multiplication and compression.
- **Inputs**:
    - `secret`: A 32-byte private key that needs to be converted into a public key.
- **Control Flow**:
    - The function first calls [`secret_expand`](#secret_expand) with the `secret` to derive a scalar `a` and a dummy value.
    - It then performs elliptic curve point multiplication of `a` with the base point `G` using the [`point_mul`](#point_mul) function.
    - The resulting point is compressed into a public key format using the [`point_compress`](#point_compress) function.
    - Finally, the compressed public key is returned.
- **Output**: A 32-byte public key derived from the given private key.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.secret_expand`](#secret_expand)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_compress`](#point_compress)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](#point_mul)


---
### sign<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.sign}} -->
The `sign` function generates a digital signature for a given message using a secret key based on the Ed25519 algorithm.
- **Inputs**:
    - `secret`: A 32-byte private key used to generate the signature.
    - `msg`: The message to be signed, provided as a byte string.
- **Control Flow**:
    - The function begins by expanding the secret key using the [`secret_expand`](#secret_expand) function, which derives a scalar `a` and a prefix from the secret key.
    - The public key `A` is computed by multiplying the scalar `a` with the base point `G` and compressing the resulting point.
    - A random value `r` is generated by hashing the concatenation of the prefix and the message, and then reducing the hash modulo `q`.
    - The point `R` is computed by multiplying `r` with the base point `G`, and then compressed to `Rs`.
    - A hash `h` is computed by hashing the concatenation of `Rs`, `A`, and the message, and then reducing the hash modulo `q`.
    - The scalar `s` is calculated as `(r + h * a) % q`.
    - The function returns the concatenation of `Rs` and the little-endian byte representation of `s`.
- **Output**: The function returns a 64-byte signature, which is the concatenation of the compressed point `Rs` and the scalar `s`.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.secret_expand`](#secret_expand)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_compress`](#point_compress)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](#point_mul)
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512_modq`](#sha512_modq)


---
### verify2<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.verify2}} -->
The `verify2` function checks the validity of a given signature against a public key and message using elliptic curve cryptography.
- **Inputs**:
    - `public`: A 32-byte public key used to verify the signature.
    - `msg`: The message that was signed, provided as a byte sequence.
    - `signature`: A 64-byte signature that needs to be verified.
    - `h`: An optional precomputed hash value; if not provided, it will be computed within the function.
- **Control Flow**:
    - Check if the length of the public key is 32 bytes; if not, raise an exception.
    - Check if the length of the signature is 64 bytes; if not, raise an exception.
    - Decompress the public key to obtain point A; if decompression fails, return False.
    - Extract the first 32 bytes of the signature as Rs and decompress it to obtain point R; if decompression fails, return False.
    - Convert the remaining 32 bytes of the signature to an integer s; if s is greater than or equal to q, return False.
    - If h is not provided, compute it using the sha512_modq function on the concatenation of Rs, public, and msg.
    - Compute sB by multiplying s with the base point G using point_mul.
    - Compute hA by multiplying h with point A using point_mul.
    - Add points R and hA using point_add and check if the result is equal to sB using point_equal.
    - Return the result of the point_equal check.
- **Output**: Returns a boolean indicating whether the signature is valid (True) or not (False).
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_decompress`](#point_decompress)
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512_modq`](#sha512_modq)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](#point_mul)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_equal`](#point_equal)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_add`](#point_add)


---
### verify<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.verify}} -->
The `verify` function checks the validity of a given signature against a public key and message using elliptic curve cryptography.
- **Inputs**:
    - `public`: A 32-byte public key used to verify the signature.
    - `msg`: The message that was signed, provided as a byte sequence.
    - `signature`: A 64-byte signature that needs to be verified.
    - `h`: An optional precomputed hash value; if not provided, it is computed within the function.
- **Control Flow**:
    - Check if the length of the public key is 32 bytes, raising an exception if not.
    - Check if the length of the signature is 64 bytes, raising an exception if not.
    - Decompress the public key to obtain point A; return False if decompression fails.
    - Extract the first 32 bytes of the signature as Rs and decompress it to obtain point R; return False if decompression fails.
    - Convert the remaining 32 bytes of the signature to an integer s and check if it is less than the group order q; return False if not.
    - If h is not provided, compute it using the SHA-512 hash of Rs, public key, and message, reduced modulo q.
    - Compute P0 as the scalar multiplication of s and the base point G.
    - Compute P1 as the scalar multiplication of h and point A.
    - Add P0 and P1 to get P0P1.
    - Compute An as the negation of point A in the elliptic curve context.
    - Compute T as the addition of the base point G and An.
    - Initialize Z as the neutral element (0, 1, 1, 0) and iterate over each bit of s and h from 255 to 0.
    - For each bit, double Z and conditionally add G, An, or T based on the bits of s and h.
    - Finally, check if the computed point Z is equal to R and return the result.
- **Output**: Returns a boolean indicating whether the signature is valid (True) or not (False).
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_decompress`](#point_decompress)
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512_modq`](#sha512_modq)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](#point_mul)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_add`](#point_add)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_equal`](#point_equal)


---
### TEST\_VERIF<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.TEST_VERIF}} -->
The `TEST_VERIF` function prints details of a test case and verifies a digital signature using a public key, message, and signature.
- **Inputs**:
    - `n`: An integer representing the test case number.
    - `keyP`: A byte array representing the public key used for verification.
    - `msg`: A byte array representing the message that was signed.
    - `sigt`: A byte array representing the signature to be verified.
- **Control Flow**:
    - Prints a blank line for separation.
    - Prints the test number using the input `n`.
    - Prints the public key in hexadecimal format, split into two lines for readability.
    - Prints the message in hexadecimal format, splitting it into lines of 16 bytes each for readability.
    - Prints the signature in hexadecimal format, splitting it into lines of 16 bytes each for readability.
    - Calls the [`verify`](#verify) function with the public key, message, and signature to check if the signature is valid.
    - Prints whether the verification passed or failed based on the result from the [`verify`](#verify) function.
    - Asserts that the verification result is true, raising an exception if it is not.
- **Output**: The function does not return any value; it prints the verification result and raises an assertion error if the verification fails.
- **Functions called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.verify`](#verify)


