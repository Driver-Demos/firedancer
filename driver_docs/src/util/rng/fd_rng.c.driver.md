# Purpose
This C source code file provides a collection of functions for generating random numbers with specific statistical distributions, including uniform, exponential, and normal distributions. The code is designed to be part of a larger library, as indicated by the inclusion of a header file "fd_rng.h" and the use of functions like `fd_rng_uint`, `fd_rng_ulong`, and `fd_rng_coin_tosses`, which are likely defined elsewhere in the library. The file includes both single-precision (float) and double-precision (double) implementations of these random number generators, demonstrating a focus on precision and flexibility.

The key technical components of this file are the implementations of the Ziggurat algorithm for generating normally distributed random numbers and the use of bit manipulation to efficiently generate random numbers with specific properties. The Ziggurat method is a well-known technique for generating random numbers from a normal distribution, and it is implemented here with precomputed tables (`zig_x` and `zig_y`) to optimize performance. The file also includes detailed comments and a section of autogenerated code, which suggests that some parts of the implementation are generated by a tool to ensure accuracy and efficiency. The presence of conditional compilation directives (`#if FD_HAS_DOUBLE`) indicates that the code is designed to be portable and adaptable to different environments, supporting both float and double precision as needed.
# Imports and Dependencies

---
- `fd_rng.h`
- `math.h`


# Functions

---
### fd\_rng\_float\_robust<!-- {{#callable:fd_rng_float_robust}} -->
The `fd_rng_float_robust` function generates a robust random floating-point number in the range [1,2] using a specified random number generator.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is the random number generator used to produce random values.
- **Control Flow**:
    - A 32-bit uniform random number `u` is generated using [`fd_rng_uint`](fd_rng.h.driver.md#fd_rng_uint).
    - A trapezoidal random number `m` is calculated from `u` by right-shifting `u` by 9 bits and adding the least significant bit of `u`.
    - A floating-point number `f` is computed as 1 plus `m` multiplied by `FLT_EPSILON`, ensuring it is an exact representation in the range [1,2].
    - The function applies an exponent to `f` using `ldexpf`, with the exponent determined by the negative of the number of coin tosses from [`fd_rng_coin_tosses`](fd_rng.h.driver.md#fd_rng_coin_tosses), to yield the final result.
- **Output**: A floating-point number in the range [1,2], generated with robust precision.
- **Functions called**:
    - [`fd_rng_uint`](fd_rng.h.driver.md#fd_rng_uint)
    - [`fd_rng_coin_tosses`](fd_rng.h.driver.md#fd_rng_coin_tosses)


---
### fd\_rng\_float\_exp<!-- {{#callable:fd_rng_float_exp}} -->
The `fd_rng_float_exp` function generates a random floating-point number following an exponential distribution using the ziggurat algorithm.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is a random number generator state.
- **Control Flow**:
    - Enter an infinite loop to repeatedly attempt generating a valid random number.
    - Generate a 32-bit random number `u` using [`fd_rng_uint`](fd_rng.h.driver.md#fd_rng_uint).
    - Extract a 7-bit ziggurat level `l` and a 24-bit trapezoidal random number `m` from `u`.
    - Calculate a potential random number `x` using the ziggurat level and trapezoidal random number.
    - Check if `x` is less than or equal to the ziggurat level threshold; if so, accept `x` and break the loop.
    - If `x` is not immediately accepted, check if `l` is less than the maximum ziggurat level.
    - If `l` is less than the maximum, generate a random `y` and check against `expf(-x)` for acceptance.
    - If `l` is the maximum level, adjust `x` using the exponential tail method and break the loop.
    - If none of the conditions are met, the random number is rejected and the loop continues.
- **Output**: A floating-point number that follows an exponential distribution.
- **Functions called**:
    - [`fd_rng_uint`](fd_rng.h.driver.md#fd_rng_uint)
    - [`fd_rng_float_c0`](fd_rng.h.driver.md#fd_rng_float_c0)


---
### fd\_rng\_float\_norm<!-- {{#callable:fd_rng_float_norm}} -->
The `fd_rng_float_norm` function generates a normally distributed random float using the ziggurat algorithm.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is used as the random number generator state.
- **Control Flow**:
    - Initialize static arrays and constants for the ziggurat algorithm, including `zig_x`, `zig_y`, `zig_level_cnt`, `zig_r`, `zig_rcp_r`, `zig_half_r`, and `zig_tail`.
    - Enter an infinite loop to generate a random float until a valid one is accepted.
    - Generate a 32-bit random number `u` and derive the sign bit `s`, ziggurat level `l`, and trapezoidal random number `m` from it.
    - Calculate a uniform random float `x` within the current ziggurat level using `zig_x` and `m`.
    - If `x` is less than or equal to `zig_x[l]`, accept `x` and break the loop (quick accept).
    - If not, generate another random float `y` and check if `l` is less than `zig_level_cnt-1`.
    - If `l` is less, calculate `y` within the ziggurat strip using `zig_y` values and check acceptance condition.
    - If `l` is not less, calculate `x` and `y` for the exponential tail and check acceptance condition.
    - If `y` is less than `expf((-0.5f)*(x*x))`, accept `x` and break the loop (slow accept).
    - If rejected, repeat the loop to try again.
- **Output**: Returns a normally distributed random float, which is either `x` or `-x` based on the sign bit `s`.
- **Functions called**:
    - [`fd_rng_uint`](fd_rng.h.driver.md#fd_rng_uint)
    - [`fd_rng_float_c`](fd_rng.h.driver.md#fd_rng_float_c)


---
### fd\_rng\_double\_robust<!-- {{#callable:fd_rng_double_robust}} -->
The `fd_rng_double_robust` function generates a robust double-precision floating-point random number in the range [1, 2) with a uniformly distributed exponent.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is the random number generator state.
- **Control Flow**:
    - Generate a 64-bit unsigned random number `u` using [`fd_rng_ulong`](fd_rng.h.driver.md#fd_rng_ulong) with the provided `rng`.
    - Calculate `m` as the sum of the right-shifted `u` by 12 bits and the least significant bit of `u`.
    - Compute `d` as 1 plus `m` multiplied by `DBL_EPSILON`, which is the smallest difference between two representable double-precision numbers.
    - Return the result of `ldexp` applied to `d` and the negation of the integer result from [`fd_rng_coin_tosses`](fd_rng.h.driver.md#fd_rng_coin_tosses), effectively scaling `d` by a power of two.
- **Output**: A double-precision floating-point number in the range [1, 2) with a uniformly distributed exponent.
- **Functions called**:
    - [`fd_rng_ulong`](fd_rng.h.driver.md#fd_rng_ulong)
    - [`fd_rng_coin_tosses`](fd_rng.h.driver.md#fd_rng_coin_tosses)


---
### fd\_rng\_double\_exp<!-- {{#callable:fd_rng_double_exp}} -->
The `fd_rng_double_exp` function generates a double-precision floating-point number that follows an exponential distribution using a random number generator.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which represents the random number generator state.
- **Control Flow**:
    - Generate a 64-bit unsigned integer `u` by calling `fd_rng_ulong(rng)` and shifting the result right by 1, then adding 1 to ensure `u` is in the range (0, 2^63].
    - Convert `u` to a double `d` by multiplying it by the reciprocal of 2^63, effectively scaling `u` to a uniform distribution in the range (0, 1].
    - Return the negative natural logarithm of `d`, which transforms the uniform distribution into an exponential distribution.
- **Output**: A double-precision floating-point number representing a random value from an exponential distribution.
- **Functions called**:
    - [`fd_rng_ulong`](fd_rng.h.driver.md#fd_rng_ulong)


---
### fd\_rng\_double\_norm<!-- {{#callable:fd_rng_double_norm}} -->
The `fd_rng_double_norm` function generates a normally distributed random double using the ziggurat algorithm.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is used as the source of randomness.
- **Control Flow**:
    - Initialize static constants and arrays for the ziggurat algorithm.
    - Enter an infinite loop to generate a random number until it is accepted.
    - Generate a 64-bit random number `u` and derive `s`, `l`, and `m` from it.
    - Calculate `x` using the ziggurat level `l` and the trapezoidal random number `m`.
    - If `x` is less than or equal to the ziggurat level `l`, break the loop and accept `x`.
    - Generate a random double `y` and adjust it based on the ziggurat level `l`.
    - If `l` is the last ziggurat level, adjust `x` and `y` using the exponential tail.
    - If `y` is less than the exponential of `-0.5 * x * x`, break the loop and accept `x`.
    - Return the final value of `x`, negated if `s` is set.
- **Output**: A double representing a normally distributed random number.
- **Functions called**:
    - [`fd_rng_ulong`](fd_rng.h.driver.md#fd_rng_ulong)
    - [`fd_rng_double_c`](fd_rng.h.driver.md#fd_rng_double_c)


