# Purpose
The provided C source code file is an implementation of arithmetic operations in the Montgomery domain for the BN254 elliptic curve, which is commonly used in cryptographic applications. The code is auto-generated and provides a comprehensive set of functions to perform arithmetic operations such as addition, subtraction, multiplication, and squaring of field elements in the Montgomery domain. It also includes functions for converting between Montgomery and non-Montgomery representations, as well as serialization and deserialization of field elements to and from byte arrays.

The file defines several key types and functions, including `fiat_bn254_montgomery_domain_field_element` and `fiat_bn254_non_montgomery_domain_field_element` for representing field elements in and out of the Montgomery domain, respectively. The arithmetic operations are implemented using 64-bit words, and the code ensures that all operations respect the bounds of the prime modulus specific to the BN254 curve. Additionally, the file includes utility functions for conditional moves and zero checks, which are essential for constant-time operations in cryptographic contexts. The code is designed to be used as a library, providing a set of APIs for performing efficient and secure arithmetic operations on the BN254 curve.
# Imports and Dependencies

---
- `stdint.h`


# Global Variables

---
### fiat\_bn254\_int128
- **Type**: ``typedef signed __int128 fiat_bn254_int128``
- **Description**: The `fiat_bn254_int128` is a type definition for a signed 128-bit integer, using the `__int128` type available in GCC and Clang compilers. This type is used to represent large integers that require more than the standard 64-bit integer size.
- **Use**: This variable is used in arithmetic operations that require handling of large integers, particularly in cryptographic computations involving the bn254 curve.


---
### fiat\_bn254\_uint128
- **Type**: `unsigned __int128`
- **Description**: The `fiat_bn254_uint128` is a typedef for an unsigned 128-bit integer type. This type is used to represent large integers that require more than the standard 64-bit integer size, allowing for operations on very large numbers.
- **Use**: This variable is used in arithmetic operations that require handling of large numbers, such as those found in cryptographic computations.


# Functions

---
### fiat\_bn254\_addcarryx\_u64<!-- {{#callable:fiat_bn254_addcarryx_u64}} -->
The function `fiat_bn254_addcarryx_u64` performs a 64-bit addition with carry, returning both the sum and the carry-out.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the result of the addition (sum) will be stored.
    - `out2`: A pointer to a fiat_bn254_uint1 where the carry-out of the addition will be stored.
    - `arg1`: A fiat_bn254_uint1 representing the initial carry-in for the addition.
    - `arg2`: A uint64_t representing the first operand of the addition.
    - `arg3`: A uint64_t representing the second operand of the addition.
- **Control Flow**:
    - Declare a 128-bit unsigned integer `x1` to hold the intermediate result of the addition.
    - Perform the addition of `arg1`, `arg2`, and `arg3`, storing the result in `x1`.
    - Extract the lower 64 bits of `x1` and store it in `x2`, which represents the sum modulo 2^64.
    - Extract the upper bits of `x1` (beyond 64 bits) and store it in `x3`, which represents the carry-out.
    - Store the sum `x2` in the location pointed to by `out1`.
    - Store the carry-out `x3` in the location pointed to by `out2`.
- **Output**: The function outputs the sum of the inputs modulo 2^64 in `out1` and the carry-out in `out2`.


---
### fiat\_bn254\_subborrowx\_u64<!-- {{#callable:fiat_bn254_subborrowx_u64}} -->
The function `fiat_bn254_subborrowx_u64` performs a subtraction of two 64-bit unsigned integers with an additional borrow input, and outputs the result along with a borrow flag.
- **Inputs**:
    - `out1`: A pointer to a 64-bit unsigned integer where the result of the subtraction will be stored.
    - `out2`: A pointer to a fiat_bn254_uint1 (unsigned char) where the borrow flag will be stored.
    - `arg1`: A fiat_bn254_uint1 (unsigned char) representing the initial borrow input.
    - `arg2`: A 64-bit unsigned integer, the minuend in the subtraction.
    - `arg3`: A 64-bit unsigned integer, the subtrahend in the subtraction.
- **Control Flow**:
    - The function begins by casting the minuend `arg2` and the initial borrow `arg1` to a 128-bit signed integer and performs the subtraction with the subtrahend `arg3`, storing the result in `x1`.
    - The borrow flag `x2` is calculated by right-shifting `x1` by 64 bits, effectively checking if the subtraction resulted in a negative value.
    - The result of the subtraction, `x3`, is obtained by masking `x1` with `0xffffffffffffffff` to ensure it fits within 64 bits.
    - The result `x3` is stored in the location pointed to by `out1`.
    - The borrow flag `x2` is negated and stored in the location pointed to by `out2`.
- **Output**: The function outputs the result of the subtraction in `out1` and the borrow flag in `out2`, indicating whether a borrow was needed.


---
### fiat\_bn254\_mulx\_u64<!-- {{#callable:fiat_bn254_mulx_u64}} -->
The function `fiat_bn254_mulx_u64` performs a 64-bit multiplication of two unsigned integers and returns the result as a double-width 128-bit integer split into two 64-bit parts.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the lower 64 bits of the result will be stored.
    - `out2`: A pointer to a uint64_t where the upper 64 bits of the result will be stored.
    - `arg1`: A uint64_t representing the first operand of the multiplication.
    - `arg2`: A uint64_t representing the second operand of the multiplication.
- **Control Flow**:
    - The function begins by declaring a 128-bit unsigned integer `x1` and two 64-bit unsigned integers `x2` and `x3`.
    - It calculates the product of `arg1` and `arg2`, storing the result in `x1`.
    - The lower 64 bits of `x1` are extracted and stored in `x2`.
    - The upper 64 bits of `x1` are extracted and stored in `x3`.
    - The values of `x2` and `x3` are then assigned to the memory locations pointed to by `out1` and `out2`, respectively.
- **Output**: The function outputs the result of the multiplication as two 64-bit unsigned integers, representing the lower and upper halves of the 128-bit product.


---
### fiat\_bn254\_cmovznz\_u64<!-- {{#callable:fiat_bn254_cmovznz_u64}} -->
The function `fiat_bn254_cmovznz_u64` performs a conditional move operation on two 64-bit unsigned integers based on a condition flag.
- **Inputs**:
    - `out1`: A pointer to a 64-bit unsigned integer where the result will be stored.
    - `arg1`: A condition flag of type `fiat_bn254_uint1` (unsigned char) that determines which of the two input values will be selected.
    - `arg2`: A 64-bit unsigned integer that will be selected if `arg1` is zero.
    - `arg3`: A 64-bit unsigned integer that will be selected if `arg1` is non-zero.
- **Control Flow**:
    - The function first evaluates the condition `x1 = (!(!arg1))`, which results in `x1` being 1 if `arg1` is non-zero and 0 if `arg1` is zero.
    - It then calculates `x2` as the bitwise AND of the negation of `x1` with the maximum 64-bit unsigned integer, effectively creating a mask that is all ones if `arg1` is non-zero and all zeros if `arg1` is zero.
    - The function computes `x3` as the bitwise OR of `x2 & arg3` and `(~x2) & arg2`, which selects `arg3` if `arg1` is non-zero and `arg2` if `arg1` is zero.
    - Finally, the result `x3` is stored in the location pointed to by `out1`.
- **Output**: The function outputs the selected 64-bit unsigned integer, either `arg2` or `arg3`, based on the value of `arg1`, and stores it in the location pointed to by `out1`.


---
### fiat\_bn254\_mul<!-- {{#callable:fiat_bn254_mul}} -->
The function `fiat_bn254_mul` performs multiplication of two field elements in the Montgomery domain for the bn254 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_bn254_montgomery_domain_field_element` where the result of the multiplication will be stored.
    - `arg1`: A constant pointer to a `fiat_bn254_montgomery_domain_field_element` representing the first operand in the Montgomery domain.
    - `arg2`: A constant pointer to a `fiat_bn254_montgomery_domain_field_element` representing the second operand in the Montgomery domain.
- **Control Flow**:
    - Initialize local variables to store intermediate results and carry bits.
    - Perform a series of multiplications using [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64) to compute partial products of the elements of `arg1` and `arg2`.
    - Use [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64) to accumulate the results of the partial products, handling carry bits appropriately.
    - Compute the Montgomery reduction by multiplying the intermediate result with a constant and reducing modulo the prime modulus using additional multiplications and additions.
    - Perform conditional subtraction using [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64) to ensure the result is within the field range.
    - Use [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64) to conditionally select the final result based on the carry from the subtraction.
    - Store the final result in `out1`.
- **Output**: The function outputs the result of the multiplication in the Montgomery domain, stored in `out1`.
- **Functions called**:
    - [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64)
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)


---
### fiat\_bn254\_square<!-- {{#callable:fiat_bn254_square}} -->
The function `fiat_bn254_square` computes the square of a field element in the Montgomery domain for the BN254 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_bn254_montgomery_domain_field_element` array where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_bn254_montgomery_domain_field_element` array representing the input field element to be squared.
- **Control Flow**:
    - Initialize local variables to store intermediate results and carry bits.
    - Extract individual components of the input field element `arg1`.
    - Perform a series of multiplications using [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64) to compute partial products of the input element with itself.
    - Use [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64) to accumulate the results of the multiplications, handling carry bits appropriately.
    - Multiply the accumulated result by a constant using [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64) to adjust for the Montgomery domain.
    - Perform additional additions with carry to finalize the result, ensuring it fits within the field's modulus.
    - Use [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64) to reduce the result modulo the field's prime if necessary.
    - Use [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64) to conditionally select the reduced result based on the borrow flag.
    - Store the final result in the output array `out1`.
- **Output**: The function outputs the squared field element in the Montgomery domain, stored in the `out1` array.
- **Functions called**:
    - [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64)
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)


---
### fiat\_bn254\_add<!-- {{#callable:fiat_bn254_add}} -->
The function `fiat_bn254_add` adds two field elements in the Montgomery domain and reduces the result modulo the prime modulus.
- **Inputs**:
    - `out1`: A pointer to a `fiat_bn254_montgomery_domain_field_element` array where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_bn254_montgomery_domain_field_element` array representing the first operand.
    - `arg2`: A constant pointer to a `fiat_bn254_montgomery_domain_field_element` array representing the second operand.
- **Control Flow**:
    - Initialize variables for intermediate results and carry flags.
    - Perform addition with carry for each of the four 64-bit words of the input arrays `arg1` and `arg2`, storing the results in temporary variables.
    - Perform subtraction with borrow to reduce the result modulo the prime modulus, using the temporary results from the addition step.
    - Use conditional move operations to select between the reduced result and the original addition result based on the borrow flag from the subtraction step.
    - Store the final result in the `out1` array.
- **Output**: The function outputs the result of the addition, reduced modulo the prime, in the `out1` array.
- **Functions called**:
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)


---
### fiat\_bn254\_sub<!-- {{#callable:fiat_bn254_sub}} -->
The function `fiat_bn254_sub` performs subtraction of two field elements in the Montgomery domain, ensuring the result is within the field's modulus.
- **Inputs**:
    - `out1`: A pointer to a `fiat_bn254_montgomery_domain_field_element` array where the result will be stored.
    - `arg1`: A constant `fiat_bn254_montgomery_domain_field_element` array representing the minuend.
    - `arg2`: A constant `fiat_bn254_montgomery_domain_field_element` array representing the subtrahend.
- **Control Flow**:
    - Initialize variables for intermediate results and carry/borrow flags.
    - Perform subtraction with borrow for each of the four 64-bit limbs of the input arrays `arg1` and `arg2` using [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64).
    - Check if the final borrow flag indicates a negative result, and conditionally set a mask to either zero or the maximum 64-bit value using [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64).
    - Add the modulus to the result if the subtraction resulted in a negative value, using [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64) to handle carry propagation.
    - Store the final result in the `out1` array.
- **Output**: The function outputs the result of the subtraction in the `out1` array, which is a `fiat_bn254_montgomery_domain_field_element`.
- **Functions called**:
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)


---
### fiat\_bn254\_opp<!-- {{#callable:fiat_bn254_opp}} -->
The function `fiat_bn254_opp` computes the negation of a field element in the Montgomery domain.
- **Inputs**:
    - `out1`: A pointer to an array of four 64-bit unsigned integers where the result will be stored.
    - `arg1`: A constant pointer to an array of four 64-bit unsigned integers representing the field element to be negated.
- **Control Flow**:
    - Initialize temporary variables for intermediate calculations.
    - Perform a series of subtraction operations with borrow to compute the negation of each element in the input array `arg1`.
    - Use a conditional move operation to handle the case where the subtraction results in a negative value, adjusting the result to ensure it is within the field's range.
    - Perform addition with carry to finalize the negation result, ensuring the output is a valid field element in the Montgomery domain.
    - Store the computed negated values in the output array `out1`.
- **Output**: The function outputs the negated field element in the Montgomery domain, stored in the array `out1`.
- **Functions called**:
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)


---
### fiat\_bn254\_from\_montgomery<!-- {{#callable:fiat_bn254_from_montgomery}} -->
The function `fiat_bn254_from_montgomery` converts a field element from the Montgomery domain to the standard representation.
- **Inputs**:
    - `out1`: A pointer to an array of 4 uint64_t elements where the result will be stored, representing the field element in the non-Montgomery domain.
    - `arg1`: A constant pointer to an array of 4 uint64_t elements representing the field element in the Montgomery domain to be converted.
- **Control Flow**:
    - Initialize local variables for intermediate calculations and carry flags.
    - Extract the first element of the input array `arg1` and perform a series of multiplications and additions to compute intermediate results using the Montgomery reduction technique.
    - Iteratively process each element of `arg1`, performing Montgomery reduction and addition operations to accumulate the result in the non-Montgomery domain.
    - After processing all elements, perform a subtraction to ensure the result is within the field's modulus.
    - Use conditional moves to select the correct result based on the final carry flag, ensuring the result is reduced modulo the field's prime.
    - Store the final result in the output array `out1`.
- **Output**: The function outputs the converted field element in the non-Montgomery domain, stored in the array `out1`.
- **Functions called**:
    - [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64)
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)


---
### fiat\_bn254\_to\_montgomery<!-- {{#callable:fiat_bn254_to_montgomery}} -->
The function `fiat_bn254_to_montgomery` converts a field element from the non-Montgomery domain to the Montgomery domain for the BN254 curve.
- **Inputs**:
    - `out1`: A pointer to an array of four 64-bit unsigned integers where the result will be stored, representing the field element in the Montgomery domain.
    - `arg1`: A constant pointer to an array of four 64-bit unsigned integers representing the field element in the non-Montgomery domain.
- **Control Flow**:
    - Extracts the four 64-bit words from the input array `arg1` into variables `x1`, `x2`, `x3`, and `x4`.
    - Performs a series of multiplications and additions using the extracted words and specific constants to compute intermediate results.
    - Uses the [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64) function to perform 64-bit multiplications and [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64) to handle additions with carry.
    - Computes the Montgomery reduction by multiplying the intermediate result with a constant and reducing modulo the prime modulus using a series of multiplications and additions.
    - Handles carry propagation and conditional moves to ensure the result is within the field's bounds.
    - Stores the final result in the `out1` array.
- **Output**: The function outputs the Montgomery domain representation of the input field element in the `out1` array.
- **Functions called**:
    - [`fiat_bn254_mulx_u64`](#fiat_bn254_mulx_u64)
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)


---
### fiat\_bn254\_nonzero<!-- {{#callable:fiat_bn254_nonzero}} -->
The function `fiat_bn254_nonzero` checks if a 256-bit integer, represented as an array of four 64-bit words, is non-zero and outputs a single non-zero word if it is, or zero otherwise.
- **Inputs**:
    - `out1`: A pointer to a 64-bit unsigned integer where the result will be stored.
    - `arg1`: An array of four 64-bit unsigned integers representing a 256-bit integer.
- **Control Flow**:
    - The function initializes a 64-bit unsigned integer `x1` to the bitwise OR of all elements in `arg1` array.
    - The result `x1` is assigned to the location pointed to by `out1`.
- **Output**: The function outputs a single 64-bit unsigned integer through the pointer `out1`, which is non-zero if any of the elements in `arg1` are non-zero, otherwise it is zero.


---
### fiat\_bn254\_selectznz<!-- {{#callable:fiat_bn254_selectznz}} -->
The function `fiat_bn254_selectznz` performs a conditional selection between two 4-element arrays based on a single-bit flag.
- **Inputs**:
    - `out1`: An array of four 64-bit unsigned integers where the result will be stored.
    - `arg1`: A single-bit flag (0 or 1) of type `fiat_bn254_uint1` that determines which array to select.
    - `arg2`: A 4-element array of 64-bit unsigned integers, representing one of the possible outputs.
    - `arg3`: A 4-element array of 64-bit unsigned integers, representing the other possible output.
- **Control Flow**:
    - The function initializes four local variables `x1`, `x2`, `x3`, and `x4` to store intermediate results.
    - It calls [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64) four times, each time passing one element from `arg2` and `arg3` along with `arg1` to conditionally select between the two elements based on `arg1`.
    - The results of these conditional moves are stored in `x1`, `x2`, `x3`, and `x4`.
    - The selected values are then assigned to the corresponding positions in the `out1` array.
- **Output**: The function outputs the selected 4-element array in `out1`, which is either `arg2` or `arg3` based on the value of `arg1`.
- **Functions called**:
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)


---
### fiat\_bn254\_to\_bytes<!-- {{#callable:fiat_bn254_to_bytes}} -->
The function `fiat_bn254_to_bytes` serializes a 256-bit field element, represented as an array of four 64-bit unsigned integers, into a 32-byte array in little-endian order.
- **Inputs**:
    - `out1`: A 32-byte array where the serialized output will be stored.
    - `arg1`: An array of four 64-bit unsigned integers representing the field element to be serialized.
- **Control Flow**:
    - Extract the least significant byte from the first 64-bit integer (arg1[0]) and store it in the first position of the output array (out1[0]).
    - Shift the first 64-bit integer right by 8 bits and repeat the extraction and storage process for the next 7 bytes.
    - Repeat the above steps for the second, third, and fourth 64-bit integers (arg1[1], arg1[2], arg1[3]), storing each byte sequentially in the output array.
    - The process results in a total of 32 bytes being extracted and stored in the output array, representing the original 256-bit field element in little-endian order.
- **Output**: The function outputs a 32-byte array (out1) containing the serialized representation of the input field element in little-endian order.


---
### fiat\_bn254\_from\_bytes<!-- {{#callable:fiat_bn254_from_bytes}} -->
The function `fiat_bn254_from_bytes` deserializes a 32-byte array into a 4-element array of 64-bit unsigned integers, representing a field element not in the Montgomery domain.
- **Inputs**:
    - `out1`: A 4-element array of 64-bit unsigned integers where the deserialized field element will be stored.
    - `arg1`: A 32-byte array representing the serialized field element in little-endian order.
- **Control Flow**:
    - Initialize multiple 64-bit unsigned integers to store intermediate results of bit-shifting and addition operations.
    - Extract each byte from the input array `arg1` and shift it to its appropriate position to form 64-bit integers.
    - Combine the shifted bytes using addition to form four 64-bit integers, each representing a part of the field element.
    - Store the resulting 64-bit integers into the output array `out1`.
- **Output**: The function outputs a 4-element array of 64-bit unsigned integers representing the deserialized field element.


---
### fiat\_bn254\_set\_one<!-- {{#callable:fiat_bn254_set_one}} -->
The function `fiat_bn254_set_one` initializes a field element in the Montgomery domain to represent the value one.
- **Inputs**:
    - `out1`: A `fiat_bn254_montgomery_domain_field_element` array of size 4, which will be set to represent the value one in the Montgomery domain.
- **Control Flow**:
    - The function directly assigns specific constant values to each of the four elements of the `out1` array.
    - These constants are precomputed values that represent the number one in the Montgomery domain for the bn254 curve.
- **Output**: The function does not return a value; it modifies the `out1` array in place to represent the number one in the Montgomery domain.


---
### fiat\_bn254\_msat<!-- {{#callable:fiat_bn254_msat}} -->
The function `fiat_bn254_msat` initializes an array with the saturated representation of the prime modulus for the BN254 curve.
- **Inputs**:
    - `out1`: An array of 5 uint64_t elements where the saturated representation of the prime modulus will be stored.
- **Control Flow**:
    - The function assigns the first four elements of the `out1` array with specific 64-bit unsigned integer constants representing parts of the prime modulus.
    - The fifth element of the `out1` array is set to 0, completing the representation.
- **Output**: The function does not return a value but modifies the `out1` array in place to contain the saturated representation of the prime modulus.


---
### fiat\_bn254\_divstep\_precomp<!-- {{#callable:fiat_bn254_divstep_precomp}} -->
The function `fiat_bn254_divstep_precomp` initializes a 4-element array with precomputed constants for the Bernstein-Yang inversion in Montgomery form.
- **Inputs**:
    - `out1`: A 4-element array of type uint64_t where the precomputed values will be stored.
- **Control Flow**:
    - The function assigns the first element of the array `out1` to the constant `0xd69e6dbc5a194eaa`.
    - The function assigns the second element of the array `out1` to the constant `0xe6d42dfd2028cab6`.
    - The function assigns the third element of the array `out1` to the constant `0xc95f7098b0c0869a`.
    - The function assigns the fourth element of the array `out1` to the constant `0x4945d89b45c32d8`.
- **Output**: The function does not return a value; it modifies the input array `out1` in place.


---
### fiat\_bn254\_divstep<!-- {{#callable:fiat_bn254_divstep}} -->
The function `fiat_bn254_divstep` performs a division step operation in the context of modular arithmetic, specifically for the BN254 curve, adjusting input parameters based on certain conditions and producing multiple outputs.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the result of the division step operation will be stored.
    - `out2`: An array of 5 uint64_t elements where the adjusted version of `arg2` or `arg3` will be stored based on conditions.
    - `out3`: An array of 5 uint64_t elements where the adjusted version of `arg3` or a combination of `arg2` and `arg3` will be stored based on conditions.
    - `out4`: An array of 4 uint64_t elements where the adjusted version of `arg4` or `arg5` will be stored based on conditions.
    - `out5`: An array of 4 uint64_t elements where the adjusted version of `arg5` or a combination of `arg4` and `arg5` will be stored based on conditions.
    - `arg1`: A uint64_t input representing a condition for the division step.
    - `arg2`: An array of 5 uint64_t elements representing one of the input parameters for the division step.
    - `arg3`: An array of 5 uint64_t elements representing another input parameter for the division step.
    - `arg4`: An array of 4 uint64_t elements representing one of the input parameters for the division step.
    - `arg5`: An array of 4 uint64_t elements representing another input parameter for the division step.
- **Control Flow**:
    - Initialize variables and perform a bitwise operation to determine a condition based on `arg1` and the least significant bit of `arg3[0]`.
    - Use conditional moves to select between `arg1` and its negation, and between `arg2` and `arg3`, storing results in temporary variables.
    - Compute the negation of `arg2` and use conditional moves to select between `arg3` and this negation, storing results in temporary variables.
    - Use conditional moves to select between `arg4` and `arg5`, storing results in temporary variables.
    - Double the selected values from `arg4` or `arg5` and perform modular subtraction with a constant modulus, storing results in temporary variables.
    - Compute the negation of `arg4` and use conditional moves to select between zero and a constant, storing results in temporary variables.
    - Add the selected values from `arg5` or the computed values from the previous step, storing results in temporary variables.
    - Use conditional moves to select between zero and the selected values from `arg2` or `arg3`, storing results in temporary variables.
    - Add the selected values from `arg5` or the computed values from the previous step, storing results in temporary variables.
    - Perform modular subtraction with a constant modulus on the results from the previous step, storing results in temporary variables.
    - Compute the increment of `arg1` and perform bitwise shifts on the results from previous steps, storing results in temporary variables.
    - Use conditional moves to select between the results of modular subtraction and the doubled values, storing results in `out4`.
    - Use conditional moves to select between the results of modular subtraction and the added values, storing results in `out5`.
    - Store the final results in `out1`, `out2`, `out3`, `out4`, and `out5`.
- **Output**: The function outputs a modified version of the inputs based on the division step logic, stored in `out1`, `out2`, `out3`, `out4`, and `out5`.
- **Functions called**:
    - [`fiat_bn254_addcarryx_u64`](#fiat_bn254_addcarryx_u64)
    - [`fiat_bn254_cmovznz_u64`](#fiat_bn254_cmovznz_u64)
    - [`fiat_bn254_subborrowx_u64`](#fiat_bn254_subborrowx_u64)


