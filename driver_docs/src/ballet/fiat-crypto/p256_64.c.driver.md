# Purpose
The provided C code is an implementation of arithmetic operations for the P-256 elliptic curve using the Montgomery representation. This code is part of a cryptographic library that performs operations such as addition, subtraction, multiplication, and squaring of field elements within the finite field defined by the prime modulus \( m = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 \). The code is auto-generated and optimized for 64-bit architectures, leveraging inline assembly for performance improvements where possible.

The file defines several key functions that operate on field elements in both Montgomery and non-Montgomery domains. These include conversion functions (`from_montgomery`, `to_montgomery`), arithmetic operations (`add`, `sub`, `mul`, `square`, `opp`), and utility functions (`nonzero`, `selectznz`, `to_bytes`, `from_bytes`). The code also includes functions for cryptographic operations such as `divstep` and `divstep_precomp`, which are used in modular inversion algorithms. The use of conditional move operations (`cmovznz`) ensures constant-time execution, which is crucial for cryptographic security to prevent timing attacks. The file is intended to be part of a larger cryptographic library, providing essential arithmetic operations for elliptic curve cryptography on the P-256 curve.
# Imports and Dependencies

---
- `stdint.h`


# Global Variables

---
### fiat\_p256\_int128
- **Type**: `signed __int128`
- **Description**: The `fiat_p256_int128` is a typedef for a signed 128-bit integer type, which is an extension provided by some compilers like GCC or Clang. This type allows for operations on 128-bit signed integers, which are larger than the standard 64-bit integer types.
- **Use**: This variable is used to perform arithmetic operations that require 128-bit signed integer precision, particularly in cryptographic computations involving the P-256 curve.


---
### fiat\_p256\_uint128
- **Type**: `unsigned __int128`
- **Description**: The `fiat_p256_uint128` is a typedef for an unsigned 128-bit integer type, which is an extension provided by some compilers like GCC or Clang. This type allows for operations on 128-bit wide integers, which are not natively supported by standard C.
- **Use**: This variable is used to perform arithmetic operations that require 128-bit precision, such as in cryptographic computations involving the P-256 curve.


# Functions

---
### fiat\_p256\_value\_barrier\_u64<!-- {{#callable:fiat_p256_value_barrier_u64}} -->
The function `fiat_p256_value_barrier_u64` acts as a compiler barrier for a 64-bit unsigned integer, ensuring that the value of the variable is not optimized away by the compiler.
- **Inputs**:
    - `a`: A 64-bit unsigned integer whose value is to be preserved across compiler optimizations.
- **Control Flow**:
    - The function uses an inline assembly statement with an empty string to create a compiler barrier.
    - The assembly statement uses the '+r' constraint to indicate that the variable 'a' is both an input and an output, preventing the compiler from optimizing it away.
    - The function returns the value of 'a' after the assembly statement.
- **Output**: The function returns the same 64-bit unsigned integer value that was passed as input, ensuring it is not optimized away by the compiler.


---
### fiat\_p256\_addcarryx\_u64<!-- {{#callable:fiat_p256_addcarryx_u64}} -->
The function `fiat_p256_addcarryx_u64` performs a 64-bit addition with carry, returning both the sum and the carry-out.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the result of the addition (sum) will be stored.
    - `out2`: A pointer to a fiat_p256_uint1 where the carry-out of the addition will be stored.
    - `arg1`: A fiat_p256_uint1 representing the initial carry-in for the addition.
    - `arg2`: A uint64_t representing the first operand for the addition.
    - `arg3`: A uint64_t representing the second operand for the addition.
- **Control Flow**:
    - The function begins by calculating the sum of `arg1`, `arg2`, and `arg3`, storing the result in a 128-bit integer `x1` to handle potential overflow.
    - The lower 64 bits of `x1` are extracted and stored in `x2`, which represents the sum modulo 2^64.
    - The upper bits of `x1` are shifted right by 64 bits to obtain the carry-out, which is stored in `x3`.
    - The sum `x2` is stored in the location pointed to by `out1`, and the carry-out `x3` is stored in the location pointed to by `out2`.
- **Output**: The function outputs the sum of the inputs modulo 2^64 in `out1` and the carry-out in `out2`.


---
### fiat\_p256\_subborrowx\_u64<!-- {{#callable:fiat_p256_subborrowx_u64}} -->
The function `fiat_p256_subborrowx_u64` performs a subtraction of two 64-bit unsigned integers with an additional borrow input, and outputs the result along with a borrow flag.
- **Inputs**:
    - `out1`: A pointer to a 64-bit unsigned integer where the result of the subtraction will be stored.
    - `out2`: A pointer to a fiat_p256_uint1 (unsigned char) where the borrow flag will be stored.
    - `arg1`: A fiat_p256_uint1 (unsigned char) representing the initial borrow input, which can be either 0 or 1.
    - `arg2`: A 64-bit unsigned integer representing the minuend.
    - `arg3`: A 64-bit unsigned integer representing the subtrahend.
- **Control Flow**:
    - Calculate the intermediate result `x1` by subtracting `arg1` and `arg3` from `arg2`, using 128-bit integer arithmetic to handle potential overflow.
    - Extract the borrow flag `x2` by right-shifting `x1` by 64 bits, which indicates if the subtraction resulted in a negative value.
    - Extract the lower 64 bits of `x1` as `x3`, which represents the result of the subtraction modulo 2^64.
    - Store `x3` in the location pointed to by `out1`.
    - Store the negated value of `x2` in the location pointed to by `out2`, effectively converting the borrow flag to a 0 or 1 value.
- **Output**: The function outputs the result of the subtraction in `out1` and a borrow flag in `out2`, indicating whether a borrow was needed during the subtraction.


---
### fiat\_p256\_mulx\_u64<!-- {{#callable:fiat_p256_mulx_u64}} -->
The function `fiat_p256_mulx_u64` performs a 64-bit multiplication of two unsigned integers and returns the result as a 128-bit value split into two 64-bit parts.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the lower 64 bits of the product will be stored.
    - `out2`: A pointer to a uint64_t where the upper 64 bits of the product will be stored.
    - `arg1`: A uint64_t representing the first operand of the multiplication.
    - `arg2`: A uint64_t representing the second operand of the multiplication.
- **Control Flow**:
    - Declare a 128-bit unsigned integer `x1` to store the full product of `arg1` and `arg2`.
    - Calculate the product of `arg1` and `arg2` and store it in `x1`.
    - Extract the lower 64 bits of `x1` and store it in `x2`.
    - Extract the upper 64 bits of `x1` and store it in `x3`.
    - Assign the value of `x2` to the location pointed to by `out1`.
    - Assign the value of `x3` to the location pointed to by `out2`.
- **Output**: The function outputs the lower 64 bits of the product in `out1` and the upper 64 bits in `out2`.


---
### fiat\_p256\_cmovznz\_u64<!-- {{#callable:fiat_p256_cmovznz_u64}} -->
The function `fiat_p256_cmovznz_u64` performs a conditional move operation on two 64-bit unsigned integers based on a single-bit condition.
- **Inputs**:
    - `out1`: A pointer to a 64-bit unsigned integer where the result will be stored.
    - `arg1`: A single-bit unsigned integer (fiat_p256_uint1) that acts as the condition for the move operation.
    - `arg2`: A 64-bit unsigned integer that is selected if the condition (arg1) is zero.
    - `arg3`: A 64-bit unsigned integer that is selected if the condition (arg1) is non-zero.
- **Control Flow**:
    - The function begins by evaluating the condition `arg1` to determine if it is non-zero, storing the result in `x1`.
    - It calculates `x2` as the bitwise negation of `x1` subtracted from zero, effectively creating a mask of all ones if `arg1` is non-zero, or all zeros if `arg1` is zero.
    - The function uses [`fiat_p256_value_barrier_u64`](#fiat_p256_value_barrier_u64) to apply a value barrier to `x2` and its negation, ensuring that the compiler does not optimize away the conditional logic.
    - It computes `x3` by performing a bitwise AND between `x2` and `arg3`, and between the negation of `x2` and `arg2`, then combines the results using a bitwise OR.
    - Finally, the result `x3` is stored in the location pointed to by `out1`.
- **Output**: The function outputs the value of either `arg2` or `arg3` into `out1`, depending on whether `arg1` is zero or non-zero, respectively.
- **Functions called**:
    - [`fiat_p256_value_barrier_u64`](#fiat_p256_value_barrier_u64)


---
### fiat\_p256\_mul<!-- {{#callable:fiat_p256_mul}} -->
The function `fiat_p256_mul` performs multiplication of two field elements in the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result of the multiplication will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the first operand in the Montgomery domain.
    - `arg2`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the second operand in the Montgomery domain.
- **Control Flow**:
    - Initialize local variables to store intermediate results and carry bits.
    - Perform a series of multiplications using [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64) to compute partial products of the input elements.
    - Use [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64) to accumulate the results of the multiplications, handling carry bits appropriately.
    - Multiply the intermediate result by the constant `0xffffffff00000001` to adjust for the Montgomery reduction.
    - Perform additional multiplications and additions to complete the Montgomery reduction process.
    - Use [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64) to ensure the result is within the field by subtracting the modulus if necessary.
    - Use [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) to conditionally select the correct result based on the borrow flag.
    - Store the final result in the output parameter `out1`.
- **Output**: The function outputs the result of the multiplication in the Montgomery domain, stored in the `out1` parameter.
- **Functions called**:
    - [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64)
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)


---
### fiat\_p256\_square<!-- {{#callable:fiat_p256_square}} -->
The function `fiat_p256_square` computes the square of a field element in the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the input field element to be squared.
- **Control Flow**:
    - Initialize local variables to store intermediate results and carry bits.
    - Extract individual components of the input field element `arg1`.
    - Perform a series of multiplications using [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64) to compute partial products of the input element with itself.
    - Use [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64) to accumulate the results of the multiplications, handling carry bits appropriately.
    - Multiply the accumulated result by constants related to the P-256 curve to ensure the result is in the Montgomery domain.
    - Perform additional additions and carry operations to finalize the result.
    - Use [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64) to reduce the result modulo the P-256 prime, ensuring it is within the valid range.
    - Use [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) to conditionally select the correct result based on the borrow flag.
    - Store the final result in the output parameter `out1`.
- **Output**: The function outputs the square of the input field element `arg1` in the Montgomery domain, stored in `out1`.
- **Functions called**:
    - [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64)
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)


---
### fiat\_p256\_add<!-- {{#callable:fiat_p256_add}} -->
The function `fiat_p256_add` adds two field elements in the Montgomery domain and reduces the result modulo the prime modulus of the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the first operand.
    - `arg2`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the second operand.
- **Control Flow**:
    - Initialize temporary variables for intermediate results and carry/borrow flags.
    - Perform addition with carry for each of the four 64-bit limbs of the input field elements `arg1` and `arg2`, storing the results in temporary variables `x1`, `x3`, `x5`, and `x7`.
    - Perform subtraction with borrow to reduce the result modulo the prime modulus, using the temporary results from the addition step.
    - Use conditional move operations to select the correct result based on the borrow flag, ensuring the result is reduced modulo the prime.
    - Store the final reduced result in the output parameter `out1`.
- **Output**: The function outputs the result of the addition, reduced modulo the prime, in the `out1` parameter, which is a `fiat_p256_montgomery_domain_field_element`.
- **Functions called**:
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)


---
### fiat\_p256\_sub<!-- {{#callable:fiat_p256_sub}} -->
The function `fiat_p256_sub` subtracts two field elements in the Montgomery domain and ensures the result is within the field's bounds.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the minuend.
    - `arg2`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the subtrahend.
- **Control Flow**:
    - Initialize temporary variables for intermediate calculations.
    - Perform subtraction with borrow for each 64-bit limb of the input arrays `arg1` and `arg2`, storing results in temporary variables.
    - Check if the subtraction resulted in a borrow from the most significant limb.
    - If a borrow occurred, add the modulus to the result to ensure it is non-negative and within the field's bounds.
    - Store the final result in the output array `out1`.
- **Output**: The function outputs the result of the subtraction in the `out1` array, which is a `fiat_p256_montgomery_domain_field_element`.
- **Functions called**:
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)


---
### fiat\_p256\_opp<!-- {{#callable:fiat_p256_opp}} -->
The function `fiat_p256_opp` negates a field element in the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the input field element to be negated.
- **Control Flow**:
    - Initialize temporary variables for intermediate calculations.
    - Perform a series of subtraction operations using [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64) to compute the two's complement of `arg1`, effectively negating it.
    - Use [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) to conditionally select between zero and the maximum 64-bit unsigned integer based on the borrow flag from the last subtraction.
    - Add the conditional result to the negated values using [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64) to ensure the result is within the field's bounds.
    - Store the final result in `out1`.
- **Output**: The function outputs the negated field element in the Montgomery domain, stored in `out1`.
- **Functions called**:
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)


---
### fiat\_p256\_from\_montgomery<!-- {{#callable:fiat_p256_from_montgomery}} -->
The function `fiat_p256_from_montgomery` converts a field element from the Montgomery domain to the standard representation for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_non_montgomery_domain_field_element` array where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` array representing the input field element in the Montgomery domain.
- **Control Flow**:
    - Initialize local variables for intermediate calculations.
    - Extract the first element of `arg1` and perform a series of multiplications and additions to compute intermediate results.
    - Iteratively process each element of `arg1`, performing Montgomery reduction using the modulus `m = 2^256 - 2^224 + 2^192 + 2^96 - 1`.
    - Use [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64) and [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64) to handle carry and borrow operations during addition and subtraction.
    - Perform conditional moves using [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) to ensure the result is reduced modulo `m`.
    - Store the final result in `out1`.
- **Output**: The function outputs the converted field element in the standard representation, stored in the `out1` array.
- **Functions called**:
    - [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64)
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)


---
### fiat\_p256\_to\_montgomery<!-- {{#callable:fiat_p256_to_montgomery}} -->
The function `fiat_p256_to_montgomery` converts a field element from the non-Montgomery domain to the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` array where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_non_montgomery_domain_field_element` array representing the input field element in the non-Montgomery domain.
- **Control Flow**:
    - Initialize local variables to store intermediate results and carry flags.
    - Extract each element of the input array `arg1` into separate variables `x1`, `x2`, `x3`, and `x4`.
    - Perform a series of multiplications and additions using the [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64) and [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64) functions to compute the Montgomery representation of the input.
    - Use the [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64) function to ensure the result is reduced modulo the prime of the P-256 curve.
    - Use the [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) function to conditionally select the reduced result based on the borrow flag.
    - Store the final result in the `out1` array.
- **Output**: The function outputs the Montgomery domain representation of the input field element in the `out1` array.
- **Functions called**:
    - [`fiat_p256_mulx_u64`](#fiat_p256_mulx_u64)
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)


---
### fiat\_p256\_nonzero<!-- {{#callable:fiat_p256_nonzero}} -->
The function `fiat_p256_nonzero` computes a single non-zero word if the input array is non-zero, and zero otherwise.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the result will be stored.
    - `arg1`: An array of four uint64_t values representing a field element.
- **Control Flow**:
    - The function initializes a local variable `x1` to the bitwise OR of all elements in the input array `arg1`.
    - The result of the OR operation is stored in the location pointed to by `out1`.
- **Output**: The function outputs a single uint64_t value, which is non-zero if any element of `arg1` is non-zero, and zero otherwise.


---
### fiat\_p256\_selectznz<!-- {{#callable:fiat_p256_selectznz}} -->
The function `fiat_p256_selectznz` performs a conditional selection between two 4-element arrays based on a single-bit flag.
- **Inputs**:
    - `out1`: An array of four 64-bit unsigned integers where the result will be stored.
    - `arg1`: A single-bit flag (0 or 1) that determines which of the two input arrays will be selected.
    - `arg2`: A 4-element array of 64-bit unsigned integers, representing one of the possible outputs.
    - `arg3`: A 4-element array of 64-bit unsigned integers, representing the other possible output.
- **Control Flow**:
    - The function initializes four local variables `x1`, `x2`, `x3`, and `x4` to store the selected values from the input arrays.
    - It calls [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) four times, once for each element of the input arrays, to select between `arg2` and `arg3` based on `arg1`.
    - Each call to [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64) assigns the selected value to the corresponding local variable (`x1` to `x4`).
    - The selected values are then stored in the output array `out1`.
- **Output**: The function outputs the selected 4-element array in `out1`, which is either `arg2` or `arg3` based on the value of `arg1`.
- **Functions called**:
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)


---
### fiat\_p256\_to\_bytes<!-- {{#callable:fiat_p256_to_bytes}} -->
The function `fiat_p256_to_bytes` serializes a 256-bit field element, represented as an array of four 64-bit unsigned integers, into a 32-byte array in little-endian order.
- **Inputs**:
    - `out1`: A 32-byte array where the serialized bytes of the field element will be stored.
    - `arg1`: An array of four 64-bit unsigned integers representing the field element to be serialized.
- **Control Flow**:
    - Extracts each 64-bit integer from the input array `arg1` and processes them individually.
    - For each 64-bit integer, extracts each byte by masking and shifting operations to isolate each byte.
    - Stores each extracted byte into the corresponding position in the output array `out1`, ensuring little-endian order.
- **Output**: A 32-byte array `out1` containing the serialized bytes of the input field element in little-endian order.


---
### fiat\_p256\_from\_bytes<!-- {{#callable:fiat_p256_from_bytes}} -->
The function `fiat_p256_from_bytes` deserializes a 256-bit field element from a 32-byte array in little-endian order into a 4-element array of 64-bit unsigned integers.
- **Inputs**:
    - `out1`: A pointer to an array of four 64-bit unsigned integers where the deserialized field element will be stored.
    - `arg1`: A pointer to an array of 32 bytes representing the serialized field element in little-endian order.
- **Control Flow**:
    - Initialize multiple 64-bit unsigned integers to store intermediate results.
    - Extract each byte from the input array `arg1` and shift it to its correct position to form 64-bit integers.
    - Combine the shifted bytes to form four 64-bit integers, each representing a part of the field element.
    - Store the resulting 64-bit integers into the output array `out1`.
- **Output**: The function outputs a 4-element array of 64-bit unsigned integers representing the deserialized field element.


---
### fiat\_p256\_set\_one<!-- {{#callable:fiat_p256_set_one}} -->
The function `fiat_p256_set_one` initializes a field element in the Montgomery domain to represent the value one.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` array where the result will be stored.
- **Control Flow**:
    - The function directly assigns specific constant values to each element of the `out1` array.
    - `out1[0]` is set to `0x1`, representing the least significant part of the number one in the Montgomery domain.
    - `out1[1]` is set to `0xffffffff00000000`, a precomputed constant for the Montgomery representation.
    - `out1[2]` is set to `0xffffffffffffffff`, another precomputed constant for the Montgomery representation.
    - `out1[3]` is set to `0xfffffffe`, completing the representation of one in the Montgomery domain.
- **Output**: The function does not return a value; it modifies the `out1` array in place to represent the number one in the Montgomery domain.


---
### fiat\_p256\_msat<!-- {{#callable:fiat_p256_msat}} -->
The function `fiat_p256_msat` initializes an array with the saturated representation of the prime modulus for the P-256 curve.
- **Inputs**:
    - `out1`: An array of 5 uint64_t elements where the saturated representation of the prime modulus will be stored.
- **Control Flow**:
    - The function assigns the value 0xffffffffffffffff to the first element of the array `out1`.
    - The function assigns the value 0xffffffff to the second element of the array `out1`.
    - The function assigns the value 0x0 to the third element of the array `out1`.
    - The function assigns the value 0xffffffff00000001 to the fourth element of the array `out1`.
    - The function assigns the value 0x0 to the fifth element of the array `out1`.
- **Output**: The function outputs the array `out1` containing the saturated representation of the prime modulus for the P-256 curve.


---
### fiat\_p256\_divstep<!-- {{#callable:fiat_p256_divstep}} -->
The function `fiat_p256_divstep` performs a division step operation as part of the extended Euclidean algorithm for computing modular inverses, specifically tailored for the P-256 elliptic curve.
- **Inputs**:
    - `out1`: A pointer to a uint64_t where the result of the division step operation will be stored.
    - `out2`: An array of 5 uint64_t elements where the updated value of arg2 or arg3 will be stored based on the condition.
    - `out3`: An array of 5 uint64_t elements where the updated value of arg3 or a modified version of arg2 will be stored based on the condition.
    - `out4`: An array of 4 uint64_t elements where the updated value of arg4 or arg5 will be stored based on the condition.
    - `out5`: An array of 4 uint64_t elements where the updated value of arg5 or a modified version of arg4 will be stored based on the condition.
    - `arg1`: A uint64_t representing the current step's delta value.
    - `arg2`: An array of 5 uint64_t elements representing one of the inputs to the division step.
    - `arg3`: An array of 5 uint64_t elements representing another input to the division step.
    - `arg4`: An array of 4 uint64_t elements representing one of the inputs to the division step.
    - `arg5`: An array of 4 uint64_t elements representing another input to the division step.
- **Control Flow**:
    - Compute the negation of arg1 and determine if arg3[0] is odd to set a condition flag x3.
    - Use the condition flag x3 to select between arg1 and its negation, and between arg2 and arg3, storing results in x6 to x11.
    - Compute the negation of arg2 and use x3 to select between arg3 and the negated arg2, storing results in x22 to x26.
    - Use x3 to select between arg4 and arg5, storing results in x27 to x30.
    - Double the selected values from x27 to x30 and reduce them modulo the P-256 prime, storing results in x39 to x47.
    - Compute the negation of arg4 and conditionally add the P-256 prime to it, storing results in x62 to x68.
    - Use x3 to select between arg5 and the modified arg4, storing results in x70 to x73.
    - Check if x22 is odd and use this to conditionally add x7 to x22, x8 to x23, etc., storing results in x80 to x88.
    - Conditionally add x70 to x90, x71 to x91, etc., and reduce modulo the P-256 prime, storing results in x102 to x110.
    - Compute the new delta value by incrementing x6 and store it in out1.
    - Shift the results from x80 to x88 right by one bit and store them in out3.
    - Use the condition flags to select the final values for out4 and out5 from the intermediate results.
- **Output**: The function outputs the updated values of out1, out2, out3, out4, and out5, which represent the new state after a division step in the extended Euclidean algorithm.
- **Functions called**:
    - [`fiat_p256_addcarryx_u64`](#fiat_p256_addcarryx_u64)
    - [`fiat_p256_cmovznz_u64`](#fiat_p256_cmovznz_u64)
    - [`fiat_p256_subborrowx_u64`](#fiat_p256_subborrowx_u64)


---
### fiat\_p256\_divstep\_precomp<!-- {{#callable:fiat_p256_divstep_precomp}} -->
The function `fiat_p256_divstep_precomp` initializes a 4-element array with precomputed constants for use in the Bernstein-Yang inversion algorithm in the Montgomery domain.
- **Inputs**:
    - `out1`: A 4-element array of type `uint64_t` where the precomputed values will be stored.
- **Control Flow**:
    - The function assigns the constant value `0x67ffffffb8000000` to `out1[0]`.
    - The function assigns the constant value `0xc000000038000000` to `out1[1]`.
    - The function assigns the constant value `0xd80000007fffffff` to `out1[2]`.
    - The function assigns the constant value `0x2fffffffffffffff` to `out1[3]`.
- **Output**: The function does not return a value but modifies the `out1` array in place with precomputed constants.


