<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines data structures and functions for handling sanitized transaction ABI in the Firedancer codebase.

# Purpose
The code defines a set of data structures and functions for handling transaction data in a banking application. It includes several `typedef` structures that represent different components of a transaction, such as public keys, signatures, and message headers. These structures are aligned and packed to ensure compatibility with the Rust programming language's data layout, particularly for handling vectors and discriminated unions. The code also includes static assertions to verify the size and alignment of these structures.

The primary functionality of the code is to initialize and process transactions, as seen in the [`fd_bank_abi_txn_init`](<#fd_bank_abi_txn_init>) function. This function sets up transaction data, computes message hashes, and categorizes instructions based on their program IDs. It also resolves address lookup tables and checks for the presence of specific program IDs, such as upgradeable loaders. The code uses several helper functions and macros to manage transaction data, including perfect hashing for program ID categorization and handling of optional values with discriminated unions. The code is intended to be part of a larger system, as indicated by the inclusion of external headers and the use of external functions like [`fd_ext_bank_load_account`](<#fd_ext_bank_load_account>).
# Imports and Dependencies

---
- `fd_bank_abi.h`
- `../../flamenco/runtime/fd_system_ids_pp.h`
- `../../flamenco/runtime/fd_system_ids.h`
- `../../flamenco/types/fd_types.h`
- `../../disco/pack/fd_pack_unwritable.h`
- `../../disco/pack/fd_compute_budget_program.h`
- `../../util/tmpl/fd_map_perfect.c`


# Global Variables

---
### BPF\_UPGRADEABLE\_PROG\_ID1
- **Type**: ``uchar[32]``
- **Description**: A static constant array of unsigned characters with a size of 32, initialized with the value of `BPF_UPGRADEABLE_PROG_ID`. This array is used to store a specific program ID related to BPF (Berkeley Packet Filter) upgradeable programs.
- **Use**: Used to compare against other program IDs to check for the presence of a BPF upgradeable loader in transactions.


# Data Structures

---
### option\_u8\_u64\_t
- **Type**: ``union``
- **Members**:
    - ``discr``: Stores a discriminator value to determine the active member of the union.
    - ``_padding``: Provides padding to align the data structure.
    - ``_0``: Represents an 8-bit unsigned integer when `discr` is 1.
    - ``_1``: Represents a 64-bit unsigned integer when `discr` is 1.
- **Description**: `option_u8_u64_t` is a union that can represent either a 64-bit unsigned integer or a combination of an 8-bit unsigned integer and a 64-bit unsigned integer, depending on the value of the `discr` field. When `discr` is 1, the structure uses the `_0` and `_1` fields to store an 8-bit and a 64-bit unsigned integer, respectively. The union is aligned to 8 bytes and has a total size of 24 bytes, with padding included to ensure proper alignment.


---
### option\_u8\_u32\_t
- **Type**: ``union``
- **Members**:
    - ``discr``: Stores a discriminator value to determine which variant of the union is active.
    - ``_padding``: Provides padding to align the data structure correctly when `discr` is 1.
    - ``_0``: Holds an 8-bit unsigned character when `discr` is 1.
    - ``_1``: Holds a 32-bit unsigned integer when `discr` is 1.
- **Description**: Defines a union that can store either a 32-bit unsigned integer `discr` or a structure with padding, an 8-bit unsigned character, and a 32-bit unsigned integer, depending on the value of `discr`. When `discr` is 1, the structure with `_padding`, `_0`, and `_1` is used; otherwise, the union does not store any additional data.


---
### fd\_bank\_abi\_prog\_map\_t
- **Type**: ``struct``
- **Members**:
    - ``b``: An array of unsigned characters with size `FD_TXN_ACCT_ADDR_SZ`.
    - ``category``: An integer representing the category of the program.
- **Description**: Defines a mapping between a program's account address and its category, which can be used to classify programs into different types such as non-builtin, non-migratable, or migrating categories.


# Functions

---
### is\_key\_called\_as\_program<!-- {{#callable:is_key_called_as_program}} -->
[View Source →](<../../../../../src/discoh/bank/fd_bank_abi.c#L305>)

Checks if a given key index is used as a program ID in any instruction of a transaction.
- **Inputs**:
    - ``txn``: A pointer to a `fd_txn_t` structure representing the transaction to check.
    - ``key_index``: An unsigned short representing the key index to check against the program IDs in the transaction's instructions.
- **Logic and Control Flow**:
    - Iterates over each instruction in the transaction using a for loop.
    - For each instruction, checks if the `program_id` matches the `key_index`.
    - If a match is found, returns 1 immediately.
    - If no match is found after checking all instructions, returns 0.
- **Output**: Returns 1 if the `key_index` is found as a program ID in any instruction; otherwise, returns 0.


---
### is\_upgradeable\_loader\_present<!-- {{#callable:is_upgradeable_loader_present}} -->
[View Source →](<../../../../../src/discoh/bank/fd_bank_abi.c#L317>)

Checks if the upgradeable loader is present in the transaction's account addresses or loaded addresses.
- **Inputs**:
    - `txn`: A pointer to a `fd_txn_t` structure representing the transaction, which contains account address count and offset information.
    - `payload`: A pointer to an array of unsigned characters representing the transaction payload, which includes account addresses.
    - `loaded_addresses`: A pointer to an array of `sanitized_txn_abi_pubkey_t` structures representing loaded addresses.
- **Logic and Control Flow**:
    - Iterates over the account addresses in the transaction using a loop from 0 to `txn->acct_addr_cnt`.
    - For each account address, checks if it matches the `BPF_UPGRADEABLE_PROG_ID1` using `memcmp`.
    - If a match is found, returns 1 indicating the presence of the upgradeable loader.
    - If no match is found in the account addresses, iterates over the loaded addresses using a loop from 0 to `txn->addr_table_adtl_cnt`.
    - For each loaded address, checks if it matches the `BPF_UPGRADEABLE_PROG_ID1` using `memcmp`.
    - If a match is found, returns 1 indicating the presence of the upgradeable loader.
    - If no match is found in both account and loaded addresses, returns 0 indicating the absence of the upgradeable loader.
- **Output**: Returns an integer: 1 if the upgradeable loader is present, 0 otherwise.


---
### fd\_bank\_abi\_resolve\_address\_lookup\_tables<!-- {{#callable:fd_bank_abi_resolve_address_lookup_tables}} -->
[View Source →](<../../../../../src/discoh/bank/fd_bank_abi.c#L338>)

Resolves address lookup tables for a transaction by loading account data and verifying its validity.
- **Inputs**:
    - `bank`: A pointer to the bank data structure.
    - `fixed_root`: An integer indicating whether the root is fixed.
    - `slot`: An unsigned long representing the current slot number.
    - `txn`: A pointer to the transaction data structure.
    - `payload`: A pointer to the payload data.
    - `out_lut_accts`: A pointer to an array where resolved lookup table accounts will be stored.
- **Logic and Control Flow**:
    - Initialize `writable_idx` and `readable_idx` to zero.
    - Iterate over each address lookup table in the transaction.
    - For each lookup table, calculate the address offset and load the account data using `fd_ext_bank_load_account`.
    - Check if the account owner matches the expected program ID; return an error if not.
    - Verify the size of the account data; return an error if invalid.
    - Decode the account data to check if it is a valid lookup table; return an error if not.
    - Check the deactivation slot to ensure the account is still valid; return an error if not.
    - Determine the number of active addresses based on the current slot and the last extended slot.
    - Iterate over writable and readonly indices in the lookup table, validate them, and store the resolved addresses in `out_lut_accts`.
- **Output**: Returns `FD_BANK_ABI_TXN_INIT_SUCCESS` on success or an error code if any validation fails.


---
### fd\_bank\_abi\_txn\_init<!-- {{#callable:fd_bank_abi_txn_init}} -->
[View Source →](<../../../../../src/discoh/bank/fd_bank_abi.c#L459>)

Initializes a transaction structure with details from a given transaction and payload, including signature, message hash, and instruction data.
- **Inputs**:
    - `out_txn`: A pointer to an `fd_bank_abi_txn_t` structure where the transaction details will be stored.
    - `out_sidecar`: A pointer to a buffer where additional transaction data will be stored.
    - `bank`: A constant pointer to the bank data structure.
    - `slot`: An unsigned long integer representing the slot number.
    - `blake3`: A pointer to an `fd_blake3_t` structure used for hashing the transaction message.
    - `payload`: A pointer to the transaction payload data.
    - `payload_sz`: An unsigned long integer representing the size of the payload.
    - `txn`: A pointer to an `fd_txn_t` structure containing the transaction data.
    - `is_simple_vote`: An integer indicating if the transaction is a simple vote (non-zero) or not (zero).
- **Logic and Control Flow**:
    - Set the signature count and capacity in `out_txn` from `txn`.
    - Initialize the Blake3 hash and compute the message hash from the payload, storing it in `out_txn`.
    - Set the simple vote flags in `out_txn` based on `is_simple_vote`.
    - Initialize signature counters and instruction counters.
    - Initialize the compute budget program state.
    - Iterate over each instruction in `txn`, updating signature counters and instruction data size.
    - Check if the transaction version is legacy or version 0, and process accordingly.
    - For legacy transactions, set writable account cache and message details in `out_txn`.
    - For version 0 transactions, resolve address lookup tables and set writable account cache and message details in `out_txn`.
    - Return success or error code based on transaction version and processing results.
- **Output**: Returns an integer status code indicating success or failure of the initialization process.
- **Functions Called**:
    - [`is_upgradeable_loader_present`](<#is_upgradeable_loader_present>)
    - [`is_key_called_as_program`](<#is_key_called_as_program>)
    - [`fd_bank_abi_resolve_address_lookup_tables`](<#fd_bank_abi_resolve_address_lookup_tables>)


---
### fd\_bank\_abi\_get\_lookup\_addresses<!-- {{#callable:fd_bank_abi_get_lookup_addresses}} -->
[View Source →](<../../../../../src/discoh/bank/fd_bank_abi.c#L691>)

Returns the lookup addresses from a transaction if the discriminator is not set to the high bit.
- **Inputs**:
    - `txn`: A pointer to a `fd_bank_abi_txn_t` structure representing the transaction.
- **Logic and Control Flow**:
    - Check if the `discr` field of `txn->message` is equal to `ABI_HIGH_BIT`.
    - If it is equal, return `NULL`.
    - If it is not equal, return the `writable` field from `txn->message.v0.loaded_addresses.owned`.
- **Output**: A pointer to `fd_acct_addr_t` containing the lookup addresses, or `NULL` if the discriminator is set to the high bit.



---
Made with ❤️ by [Driver](https://www.driver.ai/)