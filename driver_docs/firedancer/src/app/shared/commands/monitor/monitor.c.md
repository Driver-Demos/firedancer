<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a terminal-based monitoring tool for a Firedancer instance, including command-line argument parsing and permission checks.

# Purpose
The code is a C source file that defines a monitoring tool for a Firedancer instance. It provides functionality to observe and report on the performance and status of various components within a Firedancer system. The file includes several headers, indicating dependencies on utility functions, shared development commands, configuration settings, platform capabilities, and metrics. The primary purpose of the code is to collect and display diagnostic information about the system's operation, such as transaction rates, memory usage, and system resource limits.

Key components of the code include functions for processing command-line arguments ([`monitor_cmd_args`](<#monitor_cmd_args>)), checking permissions (`monitor_cmd_perm`), and executing the main monitoring logic ([`run_monitor`](<#run_monitor>)). The code defines data structures like `tile_snap_t` and `link_snap_t` to store snapshots of system metrics. It also includes functions to capture these snapshots ([`tile_snap`](<#tile_snap>) and [`link_snap`](<#link_snap>)) and to print the collected data to the terminal. The monitoring tool can operate in different modes, such as with or without benchmarking, and it uses system calls to manage resources and handle signals for graceful termination. The file concludes with the definition of an `action_t` structure, `fd_action_monitor`, which encapsulates the monitoring action's name, argument processing function, execution function, permission requirements, and description.
# Imports and Dependencies

---
- `../../../../util/fd_util.h`
- `../../../shared_dev/commands/bench/bench.h`
- `../../fd_config.h`
- `../../../platform/fd_cap_chk.h`
- `../../../../disco/topo/fd_topo.h`
- `../../../../disco/metrics/fd_metrics.h`
- `helper.h`
- `unistd.h`
- `errno.h`
- `stdio.h`
- `stdlib.h`
- `signal.h`
- `sys/syscall.h`
- `sys/resource.h`
- `linux/capability.h`
- `sys/ioctl.h`
- `termios.h`
- `generated/monitor_seccomp.h`


# Global Variables

---
### monitor\_cmd\_perm
- **Type**: `function`
- **Description**: The `monitor_cmd_perm` function is responsible for setting up the necessary permissions and resource limits for the monitoring process. It adjusts the memory lock limit and checks for required capabilities to ensure the process can run in a sandboxed environment with the appropriate user and group IDs.
- **Use**: Used to configure permissions and resource limits for the monitoring process.


---
### stop1
- **Type**: ``int``
- **Description**: A static integer variable initialized to 0.
- **Use**: Used to control the termination of a monitoring loop in the `run_monitor` function.


---
### buffer
- **Type**: ``char[]``
- **Description**: A static character array with a size defined by the macro `FD_MONITOR_TEXT_BUF_SZ`. It is used to store text data temporarily.
- **Use**: Used as a buffer for storing and processing text data in the monitoring functions.


---
### buffer2
- **Type**: ``char[]``
- **Description**: A static character array with a size defined by the macro `FD_MONITOR_TEXT_BUF_SZ`. It is used to temporarily store data read from a file descriptor.
- **Use**: Used in the `drain_to_buffer` function to read data from a file descriptor into the buffer.


---
### termios\_backup
- **Type**: ``struct termios``
- **Description**: Stores a backup of the terminal's configuration settings. This structure is used to save the current terminal settings so they can be restored later.
- **Use**: Used to restore the terminal settings to their original state after modifications.


---
### fd\_action\_monitor
- **Type**: ``action_t``
- **Description**: Defines an action structure for monitoring a Firedancer instance. It includes the name of the action, argument processing function, execution function, configuration requirement, permission function, and a description of the action.
- **Use**: Used to configure and execute the monitoring of a Firedancer instance with a terminal GUI.


# Data Structures

---
### tile\_snap\_t
- **Type**: ``struct``
- **Members**:
    - ``pid``: Process identifier for the tile.
    - ``heartbeat``: Heartbeat value indicating the tile's activity status.
    - ``in_backp``: Flag indicating if the tile is in backpressure.
    - ``backp_cnt``: Count of backpressure events for the tile.
    - ``nvcsw``: Number of voluntary context switches.
    - ``nivcsw``: Number of involuntary context switches.
    - ``regime_ticks``: Array of tick counts for different operational regimes of the tile.
- **Description**: `tile_snap_t` is a data structure that captures a snapshot of a tile's operational metrics, including process ID, heartbeat status, backpressure status, context switch counts, and tick counts for various operational regimes. This structure is used to monitor and analyze the performance and status of individual tiles in a system.


---
### link\_snap\_t
- **Type**: ``struct``
- **Members**:
    - ``mcache_seq``: Stores the sequence number of the memory cache.
    - ``fseq_seq``: Stores the sequence number of the flow sequence.
    - ``fseq_diag_tot_cnt``: Stores the total count of diagnostics for the flow sequence.
    - ``fseq_diag_tot_sz``: Stores the total size of diagnostics for the flow sequence.
    - ``fseq_diag_filt_cnt``: Stores the count of filtered diagnostics for the flow sequence.
    - ``fseq_diag_filt_sz``: Stores the size of filtered diagnostics for the flow sequence.
    - ``fseq_diag_ovrnp_cnt``: Stores the count of overrun polling diagnostics for the flow sequence.
    - ``fseq_diag_ovrnr_cnt``: Stores the count of overrun reading diagnostics for the flow sequence.
    - ``fseq_diag_slow_cnt``: Stores the count of slow diagnostics for the flow sequence.
- **Description**: `link_snap_t` is a `struct` that holds various diagnostic and sequence information related to a link's memory cache and flow sequence. It includes fields for sequence numbers, total and filtered diagnostic counts and sizes, as well as counts for overrun and slow diagnostics. This data structure is used to capture a snapshot of the link's state for monitoring purposes.


# Functions

---
### monitor\_cmd\_args<!-- {{#callable:monitor_cmd_args}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L24>)

Parses and validates command-line arguments for monitoring configuration.
- **Inputs**:
    - ``pargc``: Pointer to the argument count, which may be modified by the function.
    - ``pargv``: Pointer to the argument vector, which may be modified by the function.
    - ``args``: Pointer to an `args_t` structure where parsed values are stored.
- **Logic and Control Flow**:
    - Sets `args->monitor.drain_output_fd` to -1, indicating it is only for development commands.
    - Uses `fd_env_strip_cmdline_long` to parse `--dt-min`, `--dt-max`, and `--duration` from the command line, with default values of 6666667, 133333333, and 0, respectively.
    - Uses `fd_env_strip_cmdline_uint` to parse `--seed` from the command line, defaulting to the current tick count.
    - Calculates `args->monitor.ns_per_tic` using `fd_tempo_tick_per_ns`.
    - Checks for the presence of `--bench` and `--sankey` flags using `fd_env_strip_cmdline_contains`.
    - Validates that `--dt-min` is positive, `--dt-max` is at least `--dt-min`, and `--duration` is non-negative, logging errors if these conditions are not met.
- **Output**: No return value; modifies the `args` structure with parsed and validated command-line arguments.


---
### tile\_total\_ticks<!-- {{#callable:tile_total_ticks}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L86>)

Calculates the total number of ticks from the `regime_ticks` array in a `tile_snap_t` structure.
- **Inputs**:
    - `snap`: A pointer to a `tile_snap_t` structure containing an array `regime_ticks` of tick counts.
- **Logic and Control Flow**:
    - Initialize a variable `total` to 0.
    - Iterate over the `regime_ticks` array of size 9 in the `snap` structure.
    - Add each element of the `regime_ticks` array to `total`.
    - Return the value of `total`.
- **Output**: Returns the sum of the elements in the `regime_ticks` array as an unsigned long integer.


---
### tile\_snap<!-- {{#callable:tile_snap}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L93>)

Captures a snapshot of metrics for each tile in a topology.
- **Inputs**:
    - ``snap_cur``: An array of `tile_snap_t` structures to store the snapshot data for each tile, indexed from 0 to `tile_cnt`.
    - ``topo``: A constant pointer to an `fd_topo_t` structure that contains the topology information, including the number of tiles and their metrics.
- **Logic and Control Flow**:
    - Iterates over each tile in the topology using a loop from 0 to `topo->tile_cnt`.
    - For each tile, retrieves the corresponding `tile_snap_t` structure from `snap_cur`.
    - Accesses the tile's metrics and updates the `heartbeat` field in the snapshot using `fd_metrics_tile`.
    - Registers the tile's metrics using `fd_metrics_register`.
    - Uses `FD_COMPILER_MFENCE` to ensure memory ordering before and after updating snapshot fields.
    - Updates various fields in the snapshot such as `pid`, `nvcsw`, `nivcsw`, `in_backp`, and `backp_cnt` using macros like `FD_MGAUGE_GET` and `FD_MCNT_GET`.
    - Iterates over a fixed range (0 to 8) to update the `regime_ticks` array in the snapshot using `fd_metrics_tl`.
    - Uses `FD_COMPILER_MFENCE` again to ensure memory ordering after all updates.
- **Output**: No return value; the function updates the `snap_cur` array with the current metrics snapshot for each tile.


---
### find\_producer\_out\_idx<!-- {{#callable:find_producer_out_idx}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L117>)

Finds the index of a specified consumer in the list of reliable consumers for a producer's primary output.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology of tiles.
    - ``producer``: A pointer to a `fd_topo_tile_t` structure representing the producer tile.
    - ``consumer``: A pointer to a `fd_topo_tile_t` structure representing the consumer tile.
    - ``consumer_in_idx``: An unsigned long integer representing the index of the consumer's input.
- **Logic and Control Flow**:
    - Initialize `reliable_cons_cnt` to 0 to count reliable consumers.
    - Iterate over each tile in the topology using index `i`.
    - For each tile, iterate over its inputs using index `j`.
    - For each input, iterate over the producer's outputs using index `k`.
    - Check if the consumer's input link ID matches the producer's output link ID and if the link is reliable.
    - If the current consumer tile and input index match the specified consumer and input index, return `reliable_cons_cnt`.
    - Increment `reliable_cons_cnt` for each reliable link found.
    - If no match is found, return `ULONG_MAX`.
- **Output**: Returns the index of the specified consumer in the list of reliable consumers, or `ULONG_MAX` if not found.


---
### link\_snap<!-- {{#callable:link_snap}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L149>)

Captures a snapshot of link metrics for each input link in a topology.
- **Inputs**:
    - ``snap_cur``: A pointer to an array of `link_snap_t` structures where the function will store the snapshot data for each link.
    - ``topo``: A constant pointer to an `fd_topo_t` structure that contains the topology information, including tiles and links.
- **Logic and Control Flow**:
    - Initialize `link_idx` to 0 to track the current link index in the snapshot array.
    - Iterate over each tile in the topology using `tile_idx`.
    - For each tile, iterate over its input links using `in_idx`.
    - For each input link, retrieve the corresponding `link_snap_t` structure from `snap_cur` using `link_idx`.
    - Retrieve the metadata cache (`mcache`) for the current link and query its sequence number, storing it in `snap->mcache_seq`.
    - Query the forward sequence (`fseq`) for the current link and store it in `snap->fseq_seq`.
    - If the link is polled, retrieve the input metrics and store them in `in_metrics`.
    - Find the producer of the current link and verify it is valid.
    - If the link is reliable, find the producer's output metrics and store them in `out_metrics`.
    - Use a memory fence (`FD_COMPILER_MFENCE`) to ensure memory operations are completed before proceeding.
    - If `in_metrics` is available, update the snapshot with various diagnostic counters from `in_metrics`; otherwise, set these counters to zero.
    - If `out_metrics` is available, update the snapshot with the slow count from `out_metrics`; otherwise, set it to zero.
    - Use another memory fence to ensure memory operations are completed.
    - Update the total count and size diagnostics by adding the filtered count and size to them.
    - Increment `link_idx` to move to the next link in the snapshot array.
- **Output**: The function does not return a value; it updates the `snap_cur` array with the current state of each link's metrics.
- **Functions Called**:
    - [`find_producer_out_idx`](<#find_producer_out_idx>)


---
### write\_stdout<!-- {{#callable:write_stdout}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L209>)

Writes a buffer to the standard output in a loop until all data is written, handling interruptions and errors.
- **Inputs**:
    - `buf`: A pointer to the buffer containing the data to write to standard output.
    - `buf_sz`: The size of the buffer, indicating the total number of bytes to write.
- **Logic and Control Flow**:
    - Initialize `written` to 0 and `total` to `buf_sz` to track the number of bytes written and the total bytes to write.
    - Enter a loop that continues until `written` is equal to `total`.
    - In each iteration, attempt to write the remaining bytes from the buffer to standard output using the `write` function.
    - If the `write` call returns a negative value, check if the error is `EINTR` (interrupted system call) and continue the loop if so.
    - If the error is not `EINTR`, log an error message and exit the loop.
    - If the `write` call is successful, add the number of bytes written to `written` to update the progress.
- **Output**: No return value; the function writes data to standard output and handles errors internally.


---
### drain\_to\_buffer<!-- {{#callable:drain_to_buffer}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L228>)

Reads data from a file descriptor into a buffer, handling newline characters and buffer overflow.
- **Inputs**:
    - ``buf``: A pointer to a character buffer where the function will store the read data.
    - ``buf_sz``: A pointer to an unsigned long representing the size of the buffer.
    - ``fd``: An integer file descriptor from which the function reads data.
- **Logic and Control Flow**:
    - Enter an infinite loop to continuously read data from the file descriptor `fd` into `buffer2` with a maximum size of `*buf_sz`.
    - Check if `read` returns -1 and `errno` is `EAGAIN`, indicating no data is available, and break the loop.
    - If `read` fails with an error other than `EAGAIN`, log an error and exit.
    - Search for newline characters in the read data using `memchr`.
    - For each newline found, calculate the length of the data segment before the newline.
    - If the buffer size is insufficient to store the data segment, write the current buffer contents to stdout and reset the buffer.
    - Copy the data segment to the buffer, update the buffer pointer and size.
    - If the buffer size is insufficient to store a newline, write the current buffer contents to stdout and reset the buffer.
    - Copy the newline character to the buffer, update the buffer pointer and size.
    - Continue processing the next segment of data after the newline.
- **Output**: No explicit return value; modifies the buffer and writes to stdout as needed.
- **Functions Called**:
    - [`write_stdout`](<#write_stdout>)


---
### restore\_terminal<!-- {{#callable:restore_terminal}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L266>)

Restores the terminal settings to their previous state using the `termios_backup` structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the `ioctl` function with `STDIN_FILENO`, `TCSETS`, and `&termios_backup` as arguments to restore terminal settings.
- **Output**: No output is returned.


---
### run\_monitor<!-- {{#callable:run_monitor}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L271>)

Monitors a system's diagnostic data and prints it to the terminal at regular intervals.
- **Inputs**:
    - ``config``: A pointer to a `config_t` structure containing the system's configuration and topology information.
    - ``drain_output_fd``: An integer file descriptor for draining output, or -1 if not used.
    - ``with_sankey``: An integer flag indicating whether to include Sankey diagram data in the output.
    - ``dt_min``: A long integer specifying the minimum time interval in nanoseconds between diagnostic snapshots.
    - ``dt_max``: A long integer specifying the maximum time interval in nanoseconds between diagnostic snapshots.
    - ``duration``: A long integer specifying the total duration in nanoseconds for which monitoring should occur.
    - ``seed``: An unsigned integer used to seed the random number generator for timing intervals.
    - ``ns_per_tic``: A double representing the number of nanoseconds per tic, used for timing calculations.
- **Logic and Control Flow**:
    - Initialize random number generator with the given seed.
    - Allocate memory for previous and current tile and link snapshots based on the topology's tile count.
    - Take initial diagnostic snapshots of tiles and links.
    - Log the monitoring parameters and calculate the stop time based on the duration.
    - Set up terminal attributes to disable character echo and line buffering, restoring them on exit.
    - Enter a loop to periodically take diagnostic snapshots and print comparisons to the terminal.
    - Use a random wait time between `dt_min` and `dt_max` before taking each snapshot.
    - Print diagnostic data for tiles and links, switching between panes with the TAB key.
    - If `with_sankey` is true, calculate and print additional transaction data.
    - Write the entire monitor output buffer to stdout.
    - Break the loop if the monitoring duration is reached or if a stop signal is received.
    - Swap the current and previous snapshots for the next iteration.
- **Output**: No return value; outputs diagnostic data to the terminal.
- **Functions Called**:
    - [`tile_snap`](<#tile_snap>)
    - [`link_snap`](<#link_snap>)
    - [`drain_to_buffer`](<#drain_to_buffer>)
    - [`write_stdout`](<#write_stdout>)
    - [`fd_getchar`](<helper.c.md#fd_getchar>)
    - [`printf_stale`](<helper.c.md#printf_stale>)
    - [`printf_heart`](<helper.c.md#printf_heart>)
    - [`printf_err_cnt`](<helper.c.md#printf_err_cnt>)
    - [`printf_err_bool`](<helper.c.md#printf_err_bool>)
    - [`printf_pct`](<helper.c.md#printf_pct>)
    - [`tile_total_ticks`](<#tile_total_ticks>)
    - [`printf_rate`](<helper.c.md#printf_rate>)
    - [`printf_seq`](<helper.c.md#printf_seq>)


---
### signal1<!-- {{#callable:signal1}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L538>)

Handles a signal by ignoring it and then exiting the program gracefully.
- **Inputs**:
    - `sig`: The signal number that the function receives, which is ignored in this implementation.
- **Logic and Control Flow**:
    - Casts the input parameter `sig` to void to indicate it is unused.
    - Calls the `exit` function with an argument of `0` to terminate the program gracefully.
- **Output**: No output is returned as the function exits the program.


---
### monitor\_cmd\_fn<!-- {{#callable:monitor_cmd_fn}} -->
[View Source →](<../../../../../../../src/app/shared/commands/monitor/monitor.c#L544>)

Sets up and runs a monitoring process for a Firedancer instance, handling signals, configuring sandboxing, and executing the monitoring loop.
- **Inputs**:
    - ``args``: A pointer to an `args_t` structure containing command-line arguments and monitoring options.
    - ``config``: A pointer to a `config_t` structure containing configuration settings for the monitoring process.
- **Logic and Control Flow**:
    - Checks if benchmarking is enabled in `args` and calls `add_bench_topo` to configure the topology accordingly.
    - Sets up signal handlers for `SIGTERM` and `SIGINT` to ensure graceful termination.
    - Initializes an array `allow_fds` to keep track of file descriptors that should remain open, including standard input/output and possibly a log file or drain output file descriptor.
    - Joins shared memory workspaces in read-only mode using `fd_topo_join_workspaces`.
    - Populates a seccomp filter policy using [`populate_sock_filter_policy_monitor`](<generated/monitor_seccomp.h.md#populate_sock_filter_policy_monitor>) to restrict system calls.
    - Closes the log lock file descriptor from `config`.
    - Checks if sandboxing is enabled in `config` and enters the sandbox using `fd_sandbox_enter`, or switches user and group IDs using `fd_sandbox_switch_uid_gid`.
    - Fills the topology configuration using `fd_topo_fill`.
    - Calls [`run_monitor`](<#run_monitor>) to start the monitoring process with the specified configuration and arguments.
    - Exits the process gracefully with `exit(0)` after the monitoring loop completes.
- **Output**: No return value; the function exits the process after execution.
- **Functions Called**:
    - [`populate_sock_filter_policy_monitor`](<generated/monitor_seccomp.h.md#populate_sock_filter_policy_monitor>)
    - [`run_monitor`](<#run_monitor>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)