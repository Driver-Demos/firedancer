<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements functions for configuring network devices using ethtool ioctls, including setting channels and features.

# Purpose
The code is a C library that provides an interface for configuring network devices using the `ethtool` utility through ioctl system calls. It is designed to interact with network interfaces on Linux systems, allowing users to query and modify various network device settings. The library includes functions to initialize and finalize the `fd_ethtool_ioctl_t` structure, which encapsulates the necessary data for performing ioctl operations on a network device.

Key functionalities provided by the code include setting and getting the number of channels on a network device, configuring the receive flow hash (RXFH) indirection table, managing network device features, and handling n-tuple filters for UDP destination ports. The code defines several constants and macros to facilitate these operations, such as `MAX_RXFH_KEY_SIZE`, `MAX_FEATURES`, and `ETHTOOL_CMD_SIZE`. The library is intended to be used as part of a larger system where network device configuration is required, and it provides a programmatic way to perform tasks that would typically be done using the `ethtool` command-line tool.
# Imports and Dependencies

---
- `errno.h`
- `unistd.h`
- `linux/ethtool.h`
- `linux/sockios.h`
- `net/if.h`
- `sys/ioctl.h`
- `sys/socket.h`
- `fd_ethtool_ioctl.h`
- `../../../../util/fd_util.h`


# Functions

---
### run\_ioctl<!-- {{#callable:run_ioctl}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L18>)

Executes an ioctl system call to configure a network device and logs errors if the operation fails.
- **Inputs**:
    - ``ioc``: A pointer to a `fd_ethtool_ioctl_t` structure that contains the file descriptor and interface request structure for the ioctl operation.
    - ``cmd``: A constant character pointer representing the command name for logging purposes.
    - ``data``: A pointer to the data that will be passed to the ioctl operation.
    - ``log``: An integer flag indicating whether to log errors.
    - ``log_notsupp``: An integer flag indicating whether to log errors when the operation is not supported.
- **Logic and Control Flow**:
    - Assigns the `data` pointer to the `ifr_data` field of the `ioc->ifr` structure.
    - Calls the `ioctl` function with the file descriptor, command `SIOCETHTOOL`, and the `ioc->ifr` structure.
    - Checks if the `ioctl` call fails using the `FD_UNLIKELY` macro.
    - If the call fails, retrieves the error number from `errno`.
    - Logs a warning message if logging is enabled and the error is not `EOPNOTSUPP` or if `log_notsupp` is enabled.
    - Returns the error number if the `ioctl` call fails.
    - Returns 0 if the `ioctl` call succeeds.
- **Output**: Returns 0 on success or the error number if the ioctl call fails.


---
### fd\_ethtool\_ioctl\_init<!-- {{#callable:fd_ethtool_ioctl_init}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L39>)

Initializes an `fd_ethtool_ioctl_t` structure for a specified network device.
- **Inputs**:
    - `ioc`: A pointer to an `fd_ethtool_ioctl_t` structure to initialize.
    - `device`: A constant character pointer to the name of the network device.
- **Logic and Control Flow**:
    - Check if the length of `device` is greater than or equal to `IF_NAMESIZE`; if true, log a warning and return `NULL`.
    - Check if the length of `device` is zero; if true, log a warning and return `NULL`.
    - Create a socket with `AF_INET`, `SOCK_DGRAM`, and protocol 0; if socket creation fails, log a warning and return `NULL`.
    - Initialize the `ifr` field of `ioc` to zero using `fd_memset`.
    - Copy the `device` name into `ioc->ifr.ifr_name` using `fd_cstr_append_cstr` and finalize with `fd_cstr_fini`.
    - Return the initialized `ioc` structure.
- **Output**: Returns a pointer to the initialized `fd_ethtool_ioctl_t` structure, or `NULL` if an error occurs.


---
### fd\_ethtool\_ioctl\_fini<!-- {{#callable:fd_ethtool_ioctl_fini}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L64>)

Closes the file descriptor in the `fd_ethtool_ioctl_t` structure and resets its fields.
- **Inputs**:
    - `ioc`: A pointer to an `fd_ethtool_ioctl_t` structure that contains the file descriptor and interface request structure to be finalized.
- **Logic and Control Flow**:
    - Checks if closing the file descriptor `ioc->fd` returns an error, and logs a warning if it does.
    - Sets `ioc->fd` to -1 to indicate that the file descriptor is no longer valid.
    - Resets the `ioc->ifr` structure to zero using `fd_memset`.
- **Output**: No return value; the function operates directly on the `fd_ethtool_ioctl_t` structure pointed to by `ioc`.


---
### fd\_ethtool\_ioctl\_channels\_set\_num<!-- {{#callable:fd_ethtool_ioctl_channels_set_num}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L74>)

Sets the number of channels for a network device using ethtool.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure representing the network device to configure.
    - ``num``: An unsigned integer specifying the desired number of channels; if zero, the function calculates the optimal number based on system resources.
- **Logic and Control Flow**:
    - Initialize an `ethtool_channels` structure with the command `ETHTOOL_GCHANNELS` to get current channel settings.
    - Call [`run_ioctl`](<#run_ioctl>) to execute the `ETHTOOL_GCHANNELS` command and check for errors.
    - If the command is not supported and `num` is 0 or 1, return 0; otherwise, return the error code.
    - Set the command in `ethtool_channels` to `ETHTOOL_SCHANNELS`.
    - If `num` is 0, calculate the optimal number of channels based on `max_combined` or `max_rx` and system CPU count.
    - If `max_combined` is available, set `combined_count` to `num` and `rx_count` and `tx_count` to 0, and log the action.
    - If `max_combined` is not available, set `rx_count` and `tx_count` to `num`, and `combined_count` to 0, and log the action.
    - Use `TRY_RUN_IOCTL` macro to execute the `ETHTOOL_SCHANNELS` command to set the new channel configuration.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success or an error code if the operation fails.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_channels\_get\_num<!-- {{#callable:fd_ethtool_ioctl_channels_get_num}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L104>)

Retrieves the number of supported, current, and maximum channels for a network device using the `ETHTOOL_GCHANNELS` command.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure, which contains the file descriptor and interface request structure for the network device.
    - ``channels``: A pointer to an `fd_ethtool_ioctl_channels_t` structure, which will store the supported, current, and maximum number of channels.
- **Logic and Control Flow**:
    - Initialize an `ethtool_channels` structure with the command `ETHTOOL_GCHANNELS`.
    - Call [`run_ioctl`](<#run_ioctl>) to execute the ioctl command with the initialized `ethtool_channels` structure.
    - If [`run_ioctl`](<#run_ioctl>) returns a non-zero value, check if the error is `EOPNOTSUPP`. If so, set `channels->supported` to 0, `channels->current` to 1, and `channels->max` to 1, then return 0.
    - If the error is not `EOPNOTSUPP`, return the error code.
    - If [`run_ioctl`](<#run_ioctl>) is successful, set `channels->supported` to 1.
    - Check if `ech.combined_count` is non-zero. If true, set `channels->current` to `ech.combined_count` and `channels->max` to the minimum of `ech.max_combined` and the number of CPUs, then return 0.
    - If `ech.rx_count` or `ech.tx_count` is non-zero, check if they are unequal and log a warning if so.
    - Set `channels->current` to `ech.rx_count` and `channels->max` to the minimum of `ech.max_rx` and the number of CPUs, then return 0.
    - If none of the above conditions are met, return `EINVAL`.
- **Output**: Returns 0 on success, or an error code if the ioctl command fails.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_rxfh\_set\_default<!-- {{#callable:fd_ethtool_ioctl_rxfh_set_default}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L138>)

Sets the RX flow hash indirection table to its default configuration for a specified network device.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure that contains information about the network device and the file descriptor for the ioctl operation.
- **Logic and Control Flow**:
    - Logs a notice indicating the execution of the `ethtool --set-rxfh-indir` command with the device name from `ioc->ifr.ifr_name`.
    - Initializes an `ethtool_rxfh_indir` structure with the command `ETHTOOL_SRXFHINDIR` and a size of 0 to indicate the default indirection table.
    - Calls the [`run_ioctl`](<#run_ioctl>) function with the `ioc` structure, the command string `ETHTOOL_SRXFHINDIR`, the `rxfh` structure, and logging parameters.
    - Checks if the return value from [`run_ioctl`](<#run_ioctl>) is `EOPNOTSUPP` (operation not supported) and returns 0 if true.
    - Returns the result of the [`run_ioctl`](<#run_ioctl>) function call.
- **Output**: Returns 0 if the operation is not supported, otherwise returns the result of the [`run_ioctl`](<#run_ioctl>) function call, which is 0 on success or an error code on failure.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_rxfh\_set\_suffix<!-- {{#callable:fd_ethtool_ioctl_rxfh_set_suffix}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L150>)

Configures the RX flow hash indirection table to distribute traffic across network channels starting from a specified index.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure, which contains information about the network device and is used for ioctl operations.
    - ``start_idx``: An unsigned integer specifying the starting index for the RX flow hash indirection table configuration.
- **Logic and Control Flow**:
    - Retrieve the current channel count using the `ETHTOOL_GCHANNELS` command and store it in `channels_cnt`.
    - Retrieve the current RXFH queue count using the `ETHTOOL_GRXRINGS` command and store it in `queue_cnt`.
    - Check if `start_idx` is greater than or equal to `queue_cnt` or if `queue_cnt` is greater than `channels_cnt`; return `EINVAL` if true.
    - Initialize a union `rxfh` to store the RXFH indirection table data.
    - Retrieve the size of the RXFH indirection table using the `ETHTOOL_GRXFHINDIR` command and store it in `table_ele_cnt`.
    - Check if `table_ele_cnt` is zero or greater than `FD_ETHTOOL_MAX_RXFH_TABLE_CNT`; return `EINVAL` if true.
    - Log the configuration command for setting the RXFH indirection table.
    - Set the RXFH indirection table to round-robin over all channels from `start_idx` to `queue_cnt` using the `ETHTOOL_SRXFHINDIR` command.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success or `EINVAL` if the input parameters are invalid or if the table size is incorrect.


---
### fd\_ethtool\_ioctl\_rxfh\_get\_queue\_cnt<!-- {{#callable:fd_ethtool_ioctl_rxfh_get_queue_cnt}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L197>)

Retrieves the number of receive flow hash (RXFH) queues for a network device using an ioctl call.
- **Inputs**:
    - `ioc`: A pointer to an `fd_ethtool_ioctl_t` structure, which contains information about the network device and is used to perform the ioctl operation.
    - `queue_cnt`: A pointer to an unsigned integer where the function will store the number of RXFH queues.
- **Logic and Control Flow**:
    - Initialize a `struct ethtool_rxnfc` with the command `ETHTOOL_GRXRINGS` to request the number of RXFH queues.
    - Call [`run_ioctl`](<#run_ioctl>) with the `ioc` structure, the command string "ETHTOOL_GRXRINGS", the `nfc` structure, and logging parameters to execute the ioctl operation.
    - Check if the return value `ret` from [`run_ioctl`](<#run_ioctl>) is not zero, indicating an error.
    - If the error is `EOPNOTSUPP`, set `*queue_cnt` to 1, indicating that the operation is not supported and the default queue count is 1, then return 0.
    - If the error is not `EOPNOTSUPP`, return the error code `ret`.
    - If no error occurred, set `*queue_cnt` to the value of `nfc.data`, which contains the number of RXFH queues.
    - Use `FD_TEST` to assert that `*queue_cnt` is greater than 0.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success, or an error code if the ioctl operation fails.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_rxfh\_get\_table<!-- {{#callable:fd_ethtool_ioctl_rxfh_get_table}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L215>)

Retrieves the indirection table and hash key size for a network device using the `ETHTOOL_GRSSH` command.
- **Inputs**:
    - `ioc`: A pointer to an `fd_ethtool_ioctl_t` structure, which contains the file descriptor and interface request structure for the network device.
    - `table`: A pointer to an array of unsigned integers where the function will store the indirection table contents.
    - `table_ele_cnt`: A pointer to an unsigned integer where the function will store the number of elements in the indirection table.
- **Logic and Control Flow**:
    - Initialize a union `rxfh` to store the `ethtool_rxfh` structure and additional data.
    - Set the command in `rxfh.m` to `ETHTOOL_GRSSH` to get the indirection table and hash key size.
    - Call [`run_ioctl`](<#run_ioctl>) with the `ETHTOOL_GRSSH` command to retrieve the indirection table and hash key size.
    - If [`run_ioctl`](<#run_ioctl>) returns an error, check if the error is `EOPNOTSUPP`; if so, set `*table_ele_cnt` to 0 and return 0, otherwise return the error code.
    - Check if the retrieved indirection table size or key size exceeds their maximum allowed values; if so, return `EINVAL`.
    - Set `*table_ele_cnt` to the retrieved indirection table size.
    - If `*table_ele_cnt` is not zero, call `TRY_RUN_IOCTL` to retrieve the table contents and copy them to `table` using `fd_memcpy`.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success, or an error code if the operation fails.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### get\_feature\_idx<!-- {{#callable:get_feature_idx}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L252>)

Finds the index of a specified feature name in the network device's feature set.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure, which contains information about the network device and is used for ioctl operations.
    - ``name``: A constant character pointer representing the name of the feature to find.
    - ``feature_idx``: A pointer to an unsigned integer where the function will store the index of the feature if found.
    - ``feature_cnt``: A pointer to an unsigned integer where the function will store the total number of features available.
- **Logic and Control Flow**:
    - Initialize a union `esi` to store the feature set information and set its command to `ETHTOOL_GSSET_INFO` with a mask for features.
    - Run an ioctl command to get the feature set information and check if the number of features is valid (not zero and not exceeding `MAX_FEATURES`).
    - Store the number of features in `feature_cnt`.
    - Initialize a union `egs` to store the feature strings and set its command to `ETHTOOL_GSTRINGS`.
    - Run an ioctl command to get the feature strings.
    - Iterate over the feature strings to find a match with `name`.
    - If a match is found, store the index in `feature_idx` and return 0.
    - If no match is found, return -1.
- **Output**: Returns 0 if the feature name is found and its index is stored in `feature_idx`; returns -1 if the feature name is not found; returns `EINVAL` if the feature count is invalid.


---
### fd\_ethtool\_ioctl\_feature\_set<!-- {{#callable:fd_ethtool_ioctl_feature_set}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L290>)

Configures a network device feature by enabling or disabling it using the ethtool interface.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure representing the network device to configure.
    - ``name``: A constant character pointer representing the name of the feature to configure.
    - ``enabled``: An integer indicating whether to enable (non-zero) or disable (zero) the feature.
- **Logic and Control Flow**:
    - Call [`get_feature_idx`](<#get_feature_idx>) to retrieve the index and count of the feature specified by `name`.
    - If [`get_feature_idx`](<#get_feature_idx>) returns an error, check if the feature is not enabled and return 0 if so; otherwise, return `EINVAL`.
    - Calculate `feature_block` and `feature_offset` from `feature_idx`.
    - Initialize an `ethtool_gfeatures` structure and set its command to `ETHTOOL_GFEATURES`.
    - Use `TRY_RUN_IOCTL` to execute the ioctl command to get current feature settings.
    - If the current feature state matches the desired state (`enabled`), return 0.
    - Log the command to change the feature state using `FD_LOG_NOTICE`.
    - Initialize an `ethtool_sfeatures` structure and set its command to `ETHTOOL_SFEATURES`.
    - Set the `valid` and `requested` fields in the `ethtool_sfeatures` structure based on `enabled`.
    - Execute the ioctl command to set the feature state and handle errors, logging warnings if necessary.
    - Return 0 if the feature state is successfully set.
- **Output**: Returns 0 on success, `EINVAL` on invalid input, or an error code if the ioctl operation fails.
- **Functions Called**:
    - [`get_feature_idx`](<#get_feature_idx>)


---
### fd\_ethtool\_ioctl\_feature\_test<!-- {{#callable:fd_ethtool_ioctl_feature_test}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L350>)

Tests if a specific network feature is enabled on a device using ethtool.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure representing the network device.
    - ``name``: A constant character pointer to the name of the feature to test.
    - ``enabled``: A pointer to an integer where the function will store the result indicating if the feature is enabled.
- **Logic and Control Flow**:
    - Call [`get_feature_idx`](<#get_feature_idx>) to retrieve the index and count of the feature specified by `name`.
    - If [`get_feature_idx`](<#get_feature_idx>) returns -1, set `*enabled` to 0 and return 0, indicating the feature is not found.
    - If [`get_feature_idx`](<#get_feature_idx>) returns any other non-zero value, return `EINVAL` indicating an error.
    - Calculate `feature_block` and `feature_offset` from `feature_idx`.
    - Initialize a union `egf` to store the ethtool features structure and set its command to `ETHTOOL_GFEATURES`.
    - Use `TRY_RUN_IOCTL` macro to execute the ioctl command to get the features.
    - Determine if the feature is enabled by checking the `active` field in the `egf.m.features` array using bitwise operations.
    - Store the result in `*enabled` and return 0.
- **Output**: Returns 0 on success, with `*enabled` set to 1 if the feature is enabled, or 0 if it is not. Returns `EINVAL` if an error occurs.
- **Functions Called**:
    - [`get_feature_idx`](<#get_feature_idx>)


---
### fd\_ethtool\_ioctl\_feature\_gro\_set<!-- {{#callable:fd_ethtool_ioctl_feature_gro_set}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L379>)

Configures the Generic Receive Offload (GRO) feature on a network device using the `ethtool` command.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure that contains the network interface information.
    - ``enabled``: An integer flag indicating whether to enable (non-zero) or disable (zero) the GRO feature.
- **Logic and Control Flow**:
    - Logs the action of enabling or disabling GRO using the `ethtool` command with the network interface name and the desired state ('on' or 'off').
    - Initializes an `ethtool_value` structure with the command `ETHTOOL_SGRO` and sets the `data` field to the boolean value of `enabled`.
    - Calls the [`run_ioctl`](<#run_ioctl>) function with the `ioc` structure, the command string "ETHTOOL_SGRO", the `ethtool_value` structure, and logging parameters.
    - Checks if the return value from [`run_ioctl`](<#run_ioctl>) is `EOPNOTSUPP` and `enabled` is false, in which case it returns 0, indicating success despite the operation not being supported.
    - Returns the result of the [`run_ioctl`](<#run_ioctl>) call.
- **Output**: Returns an integer indicating the success or failure of the operation, with 0 indicating success and a non-zero value indicating an error.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_feature\_gro\_test<!-- {{#callable:fd_ethtool_ioctl_feature_gro_test}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L393>)

Tests if the Generic Receive Offload (GRO) feature is enabled on a network device.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure representing the network device to query.
    - ``enabled``: A pointer to an integer where the function will store the result indicating if GRO is enabled (1) or not (0).
- **Logic and Control Flow**:
    - Initialize a `struct ethtool_value` named `gro` with the command `ETHTOOL_GGRO` to query the GRO status.
    - Call [`run_ioctl`](<#run_ioctl>) with `ioc`, the command string "ETHTOOL_GGRO", the `gro` structure, and logging parameters to execute the ioctl operation.
    - Check if the return value `ret` from [`run_ioctl`](<#run_ioctl>) is not zero, indicating an error.
    - If `ret` equals `EOPNOTSUPP`, set `*enabled` to 0 and return 0, indicating that GRO is not supported.
    - If `ret` is any other error, return `ret` as the error code.
    - If no error occurred, set `*enabled` to the boolean value of `gro.data`, indicating if GRO is enabled.
    - Return 0 to indicate successful execution.
- **Output**: Returns 0 on success, with `*enabled` set to indicate if GRO is enabled; returns an error code if the ioctl operation fails.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_ntuple\_clear<!-- {{#callable:fd_ethtool_ioctl_ntuple_clear}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L409>)

Clears all n-tuple rules from a network device using ethtool commands.
- **Inputs**:
    - `ioc`: A pointer to an `fd_ethtool_ioctl_t` structure that contains the network device information and file descriptor.
- **Logic and Control Flow**:
    - Initialize a union `efc` to store ethtool command data.
    - Set the command in `efc` to `ETHTOOL_GRXCLSRLCNT` to get the count of currently defined rules.
    - Call [`run_ioctl`](<#run_ioctl>) to execute the command and check for errors; return 0 if the operation is not supported or return the error code if any other error occurs.
    - Retrieve the rule count from `efc` and check if it exceeds `MAX_NTUPLE_RULES`; return `EINVAL` if it does.
    - Return 0 if no rules are defined.
    - Set the command in `efc` to `ETHTOOL_GRXCLSRLALL` to get the location indices of all rules.
    - Use `TRY_RUN_IOCTL` to execute the command and handle errors.
    - Iterate over each rule location, log the deletion command, and set up a `struct ethtool_rxnfc` to delete each rule using `ETHTOOL_SRXCLSRLDEL`.
    - Use `TRY_RUN_IOCTL` to execute the delete command for each rule and handle errors.
    - Return 0 after all rules are deleted.
- **Output**: Returns 0 on success, or an error code if an error occurs during the ioctl operations.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_ntuple\_set\_udp\_dport<!-- {{#callable:fd_ethtool_ioctl_ntuple_set_udp_dport}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L446>)

Configures a UDP destination port rule for a network device using ethtool.
- **Inputs**:
    - ``ioc``: A pointer to an `fd_ethtool_ioctl_t` structure representing the network device configuration.
    - ``rule_idx``: An unsigned integer specifying the rule index for the ntuple configuration.
    - ``dport``: A `ushort` representing the UDP destination port to set.
    - ``queue_idx``: An unsigned integer specifying the queue index to associate with the rule.
- **Logic and Control Flow**:
    - Logs the command to configure the ntuple with the specified UDP destination port and queue index.
    - Initializes an `ethtool_rxnfc` structure with the command `ETHTOOL_SRXCLSRLINS` and sets the flow type to `UDP_V4_FLOW`.
    - Sets the destination port in the `h_u` and `m_u` fields of the `ethtool_rxnfc` structure, with the `m_u` field set to match any port.
    - Sets the `ring_cookie` to the specified `queue_idx` and the `location` to the specified `rule_idx`.
    - Attempts to run the ioctl command with the specified rule index using [`run_ioctl`](<#run_ioctl>).
    - If the ioctl command fails, sets the `location` to `RX_CLS_LOC_ANY` and retries the ioctl command using `TRY_RUN_IOCTL`.
    - Returns 0 on success.
- **Output**: Returns 0 on success, or an error code if the ioctl command fails.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)


---
### fd\_ethtool\_ioctl\_ntuple\_validate\_udp\_dport<!-- {{#callable:fd_ethtool_ioctl_ntuple_validate_udp_dport}} -->
[View Source →](<../../../../../../../src/app/shared/commands/configure/fd_ethtool_ioctl.c#L474>)

Validates UDP destination port rules against expected ports and queue index.
- **Inputs**:
    - ``ioc``: Pointer to `fd_ethtool_ioctl_t` structure for ioctl operations.
    - ``dports``: Array of expected UDP destination ports.
    - ``num_dports``: Number of expected UDP destination ports.
    - ``queue_idx``: Queue index to validate against.
    - ``valid``: Pointer to an integer to store the validation result (1 for valid, 0 for invalid).
- **Logic and Control Flow**:
    - Initialize a union `efc` to store ethtool command data.
    - Set `efc.m.cmd` to `ETHTOOL_GRXCLSRLCNT` to get the count of currently defined rules.
    - Call [`run_ioctl`](<#run_ioctl>) to execute the ioctl command and check for errors.
    - If the command is not supported (`EOPNOTSUPP`), set `*valid` to 1 if `num_dports` is 0, otherwise set it to 0, and return 0.
    - If the rule count exceeds `MAX_NTUPLE_RULES`, return `EINVAL`.
    - If the rule count does not match `num_dports`, set `*valid` to 0 and return 0.
    - If there are no rules, set `*valid` to 1 and return 0.
    - Set `efc.m.cmd` to `ETHTOOL_GRXCLSRLALL` to get location indices of all rules and execute the command using `TRY_RUN_IOCTL`.
    - Loop over each rule, retrieve rule details using `ETHTOOL_GRXCLSRULE`, and validate the flow type, ring cookie, and masks against expected values.
    - For each valid rule, check if it matches any expected port in `dports`, mark matched ports as 0, and set `found` flag.
    - If no matching port is found for a rule, set `*valid` to 0 and return 0.
    - After validating all rules, check if any expected ports in `dports` are unmatched (non-zero), and set `*valid` to 0 if any are found.
    - Set `*valid` to 1 if all rules are valid and all expected ports are matched.
- **Output**: Returns 0 on success, with `*valid` set to 1 if all rules are valid and match expected ports, otherwise 0.
- **Functions Called**:
    - [`run_ioctl`](<#run_ioctl>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)