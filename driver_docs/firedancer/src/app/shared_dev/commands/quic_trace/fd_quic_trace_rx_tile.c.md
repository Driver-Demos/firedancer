<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Passive decryption of incoming QUIC packets with a mock setup and run loop for fd_quic_tile.

# Purpose
The `fd_quic_trace_rx_tile.c` file is responsible for the passive decryption and processing of incoming QUIC packets. It simulates the setup and execution loop of a real `fd_quic_tile`, which is a component in a QUIC protocol stack. The file includes several functions that handle different stages of QUIC packet processing, such as [`fd_quic_trace_initial`](<#fd_quic_trace_initial>), [`fd_quic_trace_handshake`](<#fd_quic_trace_handshake>), and [`fd_quic_trace_1rtt`](<#fd_quic_trace_1rtt>), which are used to process initial, handshake, and 1-RTT packets, respectively. These functions perform tasks like decoding packet headers, decrypting packet contents, and handling connection state.

The file also defines callback functions such as [`before_frag`](<#before_frag>), [`during_frag`](<#during_frag>), and [`after_frag`](<#after_frag>), which are used in the context of packet fragmentation and reassembly. These functions determine whether a packet should be processed, copy packet data into buffers, and invoke the appropriate packet processing functions. The [`fd_quic_trace_rx_tile`](<#fd_quic_trace_rx_tile>) function sets up the environment for processing packets by initializing necessary data structures and invoking the `stem_run1` function to start the packet processing loop. The file is part of a larger system that traces and analyzes QUIC traffic, providing insights into packet flows and connection states.
# Imports and Dependencies

---
- `fd_quic_trace.h`
- `../../../../waltz/quic/fd_quic_private.h`
- `../../../../waltz/quic/templ/fd_quic_parse_util.h`
- `../../../../waltz/quic/fd_quic_proto.c`
- `../../../../util/net/fd_eth.h`
- `../../../../util/net/fd_ip4.h`
- `../../../../util/net/fd_udp.h`
- `../../../../disco/stem/fd_stem.c`


# Functions

---
### before\_frag<!-- {{#callable:before_frag}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L15>)

Determines whether to process a packet based on its protocol and the context's trace send flag.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_quic_trace_ctx_t` structure that contains the context for tracing QUIC packets.
    - ``in_idx``: An unused parameter of type `ulong`.
    - ``seq``: An unused parameter of type `ulong`.
    - ``sig``: A `ulong` value representing the signal from which the protocol is derived.
- **Logic and Control Flow**:
    - Retrieve the protocol from the signal using `fd_disco_netmux_sig_proto(sig)` and store it in `proto`.
    - Retrieve the trace send flag from the context using `ctx->trace_send` and store it in `send`.
    - Use a switch statement to determine the action based on the `proto` value:
    - If `proto` is `DST_PROTO_OUTGOING`, return 0 to skip processing.
    - If `proto` is `DST_PROTO_TPU_QUIC`, return the value of `send`.
    - If `proto` is `DST_PROTO_SEND`, return the negation of `send`.
    - For any other `proto` value, return 1 to indicate processing should occur.
- **Output**: Returns an `int` indicating whether to process the packet (1) or not (0), based on the protocol and context's trace send flag.


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L38>)

Copies data from a source to a buffer based on the protocol type extracted from a signal.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_quic_trace_ctx_t` structure, which contains context information including a buffer for data storage.
    - ``in_idx``: An unused parameter of type `ulong`.
    - ``seq``: An unused parameter of type `ulong`.
    - ``sig``: A `ulong` representing a signal from which the protocol type is extracted.
    - ``chunk``: A `ulong` representing the chunk of data to be processed.
    - ``sz``: A `ulong` representing the size of the data to be copied.
    - ``ctl``: A `ulong` representing control information used in data translation.
- **Logic and Control Flow**:
    - Extracts the protocol type from `sig` using `fd_disco_netmux_sig_proto` function.
    - Checks if the protocol is `DST_PROTO_TPU_QUIC` or `DST_PROTO_SEND`.
    - If true, translates the fragment using `fd_net_rx_translate_frag` and copies it to `ctx->buffer` using `fd_memcpy`.
    - If the protocol is `DST_PROTO_OUTGOING`, calculates the address using `ctx->net_out_base` and `chunk`, then copies the data to `ctx->buffer` using `fd_memcpy`.
- **Output**: No return value; the function operates by modifying the `ctx->buffer` directly.


---
### bounds\_check\_conn<!-- {{#callable:bounds_check_conn}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L55>)

Checks if a given connection is within the valid bounds of a QUIC instance's connection layout.
- **Inputs**:
    - ``quic``: A pointer to a `fd_quic_t` structure representing the QUIC instance.
    - ``conn``: A pointer to a `fd_quic_conn_t` structure representing the connection to check.
- **Logic and Control Flow**:
    - Calculate the offset of the connection from the start of the QUIC instance by subtracting the base address of `quic` from the address of `conn`.
    - Check if the calculated offset is greater than or equal to `quic->layout.conns_off` and less than `quic->layout.conn_map_off`.
    - Return the result of the bounds check as a boolean integer.
- **Output**: Returns an integer indicating whether the connection is within the valid bounds (1 for true, 0 for false).


---
### fd\_quic\_trace\_initial<!-- {{#callable:fd_quic_trace_initial}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L62>)

Processes and decrypts QUIC initial packets, handling connection mapping and key derivation.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_trace_ctx_t` context, which contains QUIC tracing information.
    - ``data``: A pointer to the data buffer containing the QUIC packet to process.
    - ``data_sz``: The size of the data buffer in bytes.
    - ``ip4_saddr``: The source IPv4 address of the packet.
    - ``udp_sport``: The source UDP port of the packet.
    - ``ip4_daddr``: The destination IPv4 address of the packet.
    - ``udp_dport``: The destination UDP port of the packet.
    - ``key_idx``: An index indicating whether the packet is ingress (0) or egress (1).
- **Logic and Control Flow**:
    - Retrieve the QUIC state and connection map from the context.
    - Check if the packet size is less than the shortest allowed QUIC packet size; if so, return `FD_QUIC_PARSE_FAIL`.
    - Decode the initial packet and check for parsing errors; if any, return `FD_QUIC_PARSE_FAIL`.
    - Validate the packet length and destination connection ID length; log and return `FD_QUIC_PARSE_FAIL` if invalid.
    - Determine the connection index and keys based on the destination connection ID length and key index.
    - If no valid keys are found, generate initial secrets and derive decryption keys.
    - Decrypt the packet header and check for errors; if any, return `FD_QUIC_PARSE_FAIL`.
    - Calculate packet number size and total size, and check if it exceeds the data size; if so, return `FD_QUIC_PARSE_FAIL`.
    - Decrypt the packet body and check for errors; if any, return `FD_QUIC_PARSE_FAIL`.
    - If the context's `dump` flag is set, pretty print the QUIC packet; otherwise, trace the frames in the packet.
    - Return the total size of the processed packet.
- **Output**: Returns the total size of the processed packet or `FD_QUIC_PARSE_FAIL` on failure.
- **Functions Called**:
    - [`bounds_check_conn`](<#bounds_check_conn>)
    - [`fd_quic_trace_frames`](<fd_quic_trace_frame.c.md#fd_quic_trace_frames>)


---
### fd\_quic\_trace\_handshake<!-- {{#callable:fd_quic_trace_handshake}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L202>)

Processes QUIC handshake packets by decoding, decrypting, and optionally printing or tracing frames.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_trace_ctx_t` context structure, which contains the QUIC state and configuration.
    - ``data``: A pointer to the data buffer containing the QUIC packet to process.
    - ``data_sz``: The size of the data buffer in bytes.
    - ``ip4_saddr``: The source IPv4 address of the packet.
    - ``udp_sport``: The source UDP port of the packet.
    - ``ip4_daddr``: The destination IPv4 address of the packet.
    - ``udp_dport``: The destination UDP port of the packet.
    - ``key_idx``: An index indicating whether the packet is ingress (0) or egress (1).
- **Logic and Control Flow**:
    - Retrieve the QUIC state and connection map from the context.
    - Check if the packet size is less than the minimum QUIC packet size; if so, return `FD_QUIC_PARSE_FAIL`.
    - Decode the handshake packet using `fd_quic_decode_handshake`; if decoding fails, log a debug message and return `FD_QUIC_PARSE_FAIL`.
    - Calculate the total length of the packet and verify it does not exceed the data size; if it does, log a debug message and return `FD_QUIC_PARSE_FAIL`.
    - Initialize `conn_idx` to an invalid value and attempt to retrieve the connection keys based on the destination connection ID length.
    - If the connection ID is valid, query the connection map for the connection entry and verify its bounds; if valid, retrieve the encryption keys and connection index.
    - If no valid keys are found or the keys are empty, return `FD_QUIC_PARSE_FAIL`.
    - Decrypt the packet header using `fd_quic_crypto_decrypt_hdr`; if decryption fails, return `FD_QUIC_PARSE_FAIL`.
    - Calculate the packet number size and decode the packet number.
    - Calculate the total size of the packet body and verify it does not exceed the data size; if it does, return `FD_QUIC_PARSE_FAIL`.
    - Decrypt the packet body using `fd_quic_crypto_decrypt`; if decryption fails, return `FD_QUIC_PARSE_FAIL`.
    - Calculate the header size and wrap size, and verify the data size is sufficient; if not, return `FD_QUIC_PARSE_FAIL`.
    - If `ctx->dump` is true, pretty print the QUIC packet; otherwise, trace the frames using [`fd_quic_trace_frames`](<fd_quic_trace_frame.c.md#fd_quic_trace_frames>).
- **Output**: Always returns `FD_QUIC_PARSE_FAIL`.
- **Functions Called**:
    - [`bounds_check_conn`](<#bounds_check_conn>)
    - [`fd_quic_trace_frames`](<fd_quic_trace_frame.c.md#fd_quic_trace_frames>)


---
### fd\_quic\_trace\_1rtt<!-- {{#callable:fd_quic_trace_1rtt}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L302>)

Processes 1-RTT QUIC packets by decrypting headers and payloads, and optionally logs or traces the packet data.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_trace_ctx_t` context, which contains the QUIC state and configuration for tracing.
    - ``data``: A pointer to the data buffer containing the QUIC packet to process.
    - ``data_sz``: The size of the data buffer in bytes.
    - ``ip4_saddr``: The source IPv4 address of the packet.
    - ``udp_sport``: The source UDP port of the packet.
    - ``ip4_daddr``: The destination IPv4 address of the packet.
    - ``udp_dport``: The destination UDP port of the packet.
    - ``key_idx``: An index indicating whether the packet is ingress (0) or egress (1).
- **Logic and Control Flow**:
    - Retrieve the QUIC state and connection map from the context.
    - Check if the packet size is less than the shortest QUIC packet size; if so, return immediately.
    - Determine the connection based on `key_idx`: for ingress, use the destination connection ID; for egress, use the peer connection ID.
    - If the connection is not found or invalid, log an error and return.
    - Retrieve the cryptographic keys for the connection and decrypt the packet header.
    - Decode the packet number and decrypt the packet payload.
    - Check if the decrypted data size is valid; if not, return.
    - If `ctx->dump` is true, pretty print the packet data; otherwise, trace the frames if the packet is ingress.
- **Output**: No explicit output; the function may log or trace packet data based on the context configuration.
- **Functions Called**:
    - [`bounds_check_conn`](<#bounds_check_conn>)
    - [`fd_quic_trace_conn_at_idx`](<fd_quic_trace.h.md#fd_quic_trace_conn_at_idx>)
    - [`fd_quic_trace_frames`](<fd_quic_trace_frame.c.md#fd_quic_trace_frames>)


---
### is\_valid\_quic\_long\_hdr<!-- {{#callable:is_valid_quic_long_hdr}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L416>)

Checks if a QUIC packet has a valid long header by verifying the header form and version.
- **Inputs**:
    - `data`: A pointer to an array of unsigned characters representing the QUIC packet data.
- **Logic and Control Flow**:
    - Shift the first byte of `data` right by 6 bits and check if the result is equal to `0x3` to verify the header form.
    - If the header form is not valid, return `0`.
    - Load a 4-byte unsigned integer from `data + 1`, byte-swap it using `fd_uint_bswap`, and store it in `version`.
    - Check if `version` is equal to `1`.
    - If the version is not `1`, return `0`.
    - If both checks pass, return `1`.
- **Output**: Returns `1` if the QUIC packet has a valid long header, otherwise returns `0`.


---
### fd\_quic\_trace\_pkt<!-- {{#callable:fd_quic_trace_pkt}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L425>)

Processes QUIC packets by determining their type and handling them accordingly, including logging and tracing operations.
- **Inputs**:
    - `ctx`: A pointer to `fd_quic_trace_ctx_t`, which contains the context for tracing QUIC packets.
    - `data`: A pointer to the data buffer containing the QUIC packet to be processed.
    - `data_sz`: The size of the data buffer in bytes.
    - `ip4_saddr`: The source IPv4 address of the packet.
    - `udp_sport`: The source UDP port of the packet.
    - `ip4_daddr`: The destination IPv4 address of the packet.
    - `udp_dport`: The destination UDP port of the packet.
    - `key_idx`: An index indicating whether the packet is ingress (0) or egress (1).
- **Logic and Control Flow**:
    - Initialize pointers `cur_ptr` and `end_ptr` to iterate over the data buffer.
    - Enter a loop that continues until `cur_ptr` reaches `end_ptr`.
    - Determine if the packet is a long header packet using `fd_quic_h0_hdr_form`.
    - If the packet is a long header, check its validity with [`is_valid_quic_long_hdr`](<#is_valid_quic_long_hdr>).
    - Depending on the packet type, call the appropriate function ([`fd_quic_trace_initial`](<#fd_quic_trace_initial>), [`fd_quic_trace_handshake`](<#fd_quic_trace_handshake>)) to process the packet and update `sz`.
    - Log a notice and return if the packet type is `FD_QUIC_PKT_TYPE_RETRY` or unknown.
    - If the packet is not a long header, process it as a 1-RTT packet using [`fd_quic_trace_1rtt`](<#fd_quic_trace_1rtt>) and break the loop.
    - Break the loop if `sz` is 0 or `FD_QUIC_PARSE_FAIL`.
    - Increment `cur_ptr` by `sz` to process the next packet.
- **Output**: No explicit return value; the function performs operations such as logging and tracing based on the packet type.
- **Functions Called**:
    - [`is_valid_quic_long_hdr`](<#is_valid_quic_long_hdr>)
    - [`fd_quic_trace_initial`](<#fd_quic_trace_initial>)
    - [`fd_quic_trace_handshake`](<#fd_quic_trace_handshake>)
    - [`fd_quic_trace_1rtt`](<#fd_quic_trace_1rtt>)


---
### after\_frag<!-- {{#callable:after_frag}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L476>)

Processes a network fragment to extract and trace QUIC packet information if it meets certain criteria.
- **Inputs**:
    - `ctx`: A pointer to `fd_quic_trace_ctx_t`, which holds the context for QUIC packet tracing.
    - `in_idx`: An unused parameter of type `ulong`.
    - `seq`: An unused parameter of type `ulong`.
    - `sig`: A `ulong` representing the signal, used to determine the protocol type.
    - `sz`: A `ulong` representing the size of the fragment.
    - `tsorig`: An unused parameter of type `ulong`.
    - `tspub`: An unused parameter of type `ulong`.
    - `stem`: An unused pointer to `fd_stem_context_t`.
- **Logic and Control Flow**:
    - Determine the protocol type from `sig` using `fd_disco_netmux_sig_proto` and set `key_idx` based on whether the protocol is outgoing.
    - Check if `sz` is less than `FD_QUIC_SHORTEST_PKT` or greater than the size of `ctx->buffer`; if so, return immediately.
    - Set `cur` to the start of `ctx->buffer` and `end` to `cur + sz`.
    - Extract and validate the Ethernet header; if invalid, return.
    - Extract and validate the IPv4 header; if invalid, return.
    - Extract and validate the UDP header; if invalid, return.
    - Load source and destination IP addresses and ports from the headers.
    - Call [`fd_quic_trace_pkt`](<#fd_quic_trace_pkt>) to process the remaining data in the buffer.
- **Output**: No return value; the function operates by side effects, specifically by calling [`fd_quic_trace_pkt`](<#fd_quic_trace_pkt>) to process and trace the packet data.
- **Functions Called**:
    - [`fd_quic_trace_pkt`](<#fd_quic_trace_pkt>)


---
### fd\_quic\_trace\_rx\_tile<!-- {{#callable:fd_quic_trace_rx_tile}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/quic_trace/fd_quic_trace_rx_tile.c#L529>)

Processes incoming and outgoing QUIC packet metadata for tracing purposes.
- **Inputs**:
    - ``trace_ctx``: A pointer to `fd_quic_trace_ctx_t`, which holds the context for QUIC packet tracing.
    - ``rx_mcache``: A pointer to `fd_frag_meta_t`, representing the metadata cache for received packets.
    - ``tx_mcache``: A pointer to `fd_frag_meta_t`, representing the metadata cache for transmitted packets.
- **Logic and Control Flow**:
    - Initialize a memory buffer `fseq_mem` for sequence number tracking and align it according to `FD_FSEQ_ALIGN`.
    - Create and join two sequence number tables `fseq_tbl` using `fd_fseq_new` and `fd_fseq_join`.
    - Initialize a random number generator `rng` using `fd_rng_new` and `fd_rng_join`.
    - Prepare a scratch buffer for internal processing, aligned according to `FD_STEM_SCRATCH_ALIGN`.
    - Set up an array `in_mcache_tbl` with the input metadata caches `rx_mcache` and `tx_mcache`.
    - Call `stem_run1` to process the input metadata caches with the sequence tables, random number generator, and scratch buffer.
    - After processing, leave and delete the sequence tables using `fd_fseq_leave` and `fd_fseq_delete`.
- **Output**: No direct output; the function modifies the state of `trace_ctx` and processes packet metadata for tracing.



---
Made with ❤️ by [Driver](https://www.driver.ai/)