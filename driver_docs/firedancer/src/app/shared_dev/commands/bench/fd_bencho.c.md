<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a benchmarking tool for RPC client interactions, including block hash and transaction count services.

# Purpose
The code is a C source file that implements a component for interacting with a remote procedure call (RPC) server to perform specific tasks related to blockchain operations. It defines a context structure `fd_bencho_ctx_t` that holds state information and resources needed for the operations, such as deadlines, request states, and memory management. The code includes functions to handle RPC requests for the latest block hash and transaction count, managing the state transitions and handling responses from the RPC server. The functions [`service_block_hash`](<#service_block_hash>) and [`service_txn_count`](<#service_txn_count>) are responsible for sending requests, checking the status of these requests, and processing the responses.

The file also includes initialization and service functions that integrate with a larger system, as indicated by the inclusion of headers from other directories and the use of external functions like `fd_rpc_client_service` and `fd_stem_publish`. The [`unprivileged_init`](<#unprivileged_init>) function sets up the context and prepares it for operation by connecting to the RPC server and initializing state variables. The code is structured to be part of a larger application, likely a networked system that requires periodic updates from a blockchain network, as suggested by the use of transaction count and block hash operations. The file defines a `fd_topo_run_tile_t` structure, `fd_tile_bencho`, which encapsulates the functionality provided by this module, including initialization and execution routines.
# Imports and Dependencies

---
- `../../rpc_client/fd_rpc_client.h`
- `../../rpc_client/fd_rpc_client_private.h`
- `../../../../disco/topo/fd_topo.h`
- `../../../../util/net/fd_ip4.h`
- `linux/unistd.h`
- `../../../../disco/stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_bencho
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a `fd_topo_run_tile_t` structure named `fd_tile_bencho`. This structure is initialized with specific function pointers and parameters for managing a tile in a topology.
- **Use**: Used to configure and manage the execution of a tile named 'bencho' in a topology, including its initialization and runtime behavior.


# Data Structures

---
### fd\_bencho\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - `rpc_ready_deadline`: Stores the deadline for the RPC to be ready.
    - `blockhash_request`: Holds the request ID for the block hash.
    - `blockhash_state`: Indicates the current state of the block hash request.
    - `blockhash_deadline`: Stores the deadline for the block hash request.
    - `txncount_measured1`: Indicates if the transaction count has been measured.
    - `txncount_request`: Holds the request ID for the transaction count.
    - `txncount_state`: Indicates the current state of the transaction count request.
    - `txncount_nextprint`: Stores the time for the next transaction count print.
    - `txncount_deadline`: Stores the deadline for the transaction count request.
    - `txncount_prev`: Stores the previous transaction count.
    - `rpc`: Array of RPC client structures.
    - `mem`: Pointer to a workspace memory structure.
    - `out_chunk0`: Stores the initial output chunk.
    - `out_wmark`: Stores the watermark for output chunks.
    - `out_chunk`: Stores the current output chunk.
- **Description**: `fd_bencho_ctx_t` is a structure that manages the context for benchmarking operations, including handling RPC requests for block hashes and transaction counts. It maintains state information, deadlines, and request identifiers for these operations. The structure also includes memory management fields for output data chunks and an array for RPC client handling.


# Functions

---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_bencho.c#L39>)

Returns the alignment requirement of the `fd_bencho_ctx_t` structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `alignof` to determine the alignment requirement of the `fd_bencho_ctx_t` structure.
    - Returns the alignment value obtained from `alignof`.
- **Output**: The alignment requirement of the `fd_bencho_ctx_t` structure as an `ulong`.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_bencho.c#L44>)

Calculates the memory footprint required for a scratch space aligned to the size of `fd_bencho_ctx_t`.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure, which is not used in the function.
- **Logic and Control Flow**:
    - Initialize a variable `l` with `FD_LAYOUT_INIT`.
    - Append the alignment and size of `fd_bencho_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Finalize the layout with `FD_LAYOUT_FINI`, using the alignment from `scratch_align()`, and return the result.
- **Output**: Returns an `ulong` representing the calculated memory footprint for the scratch space.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### service\_block\_hash<!-- {{#callable:service_block_hash}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_bencho.c#L52>)

Handles the process of requesting and receiving the latest block hash from an RPC server, updating the context state accordingly.
- **Inputs**:
    - `ctx`: A pointer to `fd_bencho_ctx_t`, which holds the context for the block hash service, including state and deadlines.
    - `stem`: A pointer to `fd_stem_context_t`, used for publishing the block hash.
- **Logic and Control Flow**:
    - Initialize `did_work` to 0 to track if any work was done.
    - Check if `ctx->blockhash_state` is `FD_BENCHO_STATE_WAIT` and if the current time is past `ctx->blockhash_deadline`, then set `ctx->blockhash_state` to `FD_BENCHO_STATE_READY`.
    - If `ctx->blockhash_state` is `FD_BENCHO_STATE_READY`, send an RPC request for the latest block hash, update the state to `FD_BENCHO_STATE_SENT`, set a new deadline, and set `did_work` to 1.
    - If `ctx->blockhash_state` is `FD_BENCHO_STATE_SENT`, check the status of the RPC response.
    - If the response is pending and the deadline has passed, log a warning and return `did_work`.
    - If the response indicates a network error and the current time is before `ctx->rpc_ready_deadline`, reset the state to `FD_BENCHO_STATE_WAIT`, set a new deadline, close the RPC request, and return `did_work`.
    - If the response is not successful, log an error and terminate.
    - If the response is successful, copy the block hash to the output chunk, publish it, update the output chunk, close the RPC request, and set `did_work` to 1.
    - Return `did_work` to indicate if any work was done.
- **Output**: Returns an integer `did_work`, which is 1 if any work was done during the function execution, otherwise 0.


---
### service\_txn\_count<!-- {{#callable:service_txn_count}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_bencho.c#L108>)

Manages the transaction count service by handling state transitions and RPC requests to obtain transaction counts.
- **Inputs**:
    - `ctx`: A pointer to a `fd_bencho_ctx_t` structure that holds the context and state information for the transaction count service.
- **Logic and Control Flow**:
    - Check if `ctx->txncount_nextprint` is zero; if so, return 0 immediately.
    - Initialize `did_work` to 0 to track if any work was done.
    - If `ctx->txncount_state` is `FD_BENCHO_STATE_WAIT`, check if the current time is past `ctx->txncount_deadline`; if so, set `ctx->txncount_state` to `FD_BENCHO_STATE_READY`.
    - If `ctx->txncount_state` is `FD_BENCHO_STATE_READY`, send an RPC request for the transaction count using `fd_rpc_client_request_transaction_count`; if the request fails, log an error and exit.
    - Set `ctx->txncount_state` to `FD_BENCHO_STATE_SENT` and update `ctx->txncount_deadline` to the current time plus `FD_BENCHO_RPC_RESPONSE_TIMEOUT`.
    - Set `did_work` to 1 to indicate work was done.
    - If `ctx->txncount_state` is `FD_BENCHO_STATE_SENT`, check the status of the RPC request using `fd_rpc_client_status`.
    - If the response status is `FD_RPC_CLIENT_PENDING` and the current time is past `ctx->txncount_deadline`, log a timeout error and return `did_work`.
    - If the response status is not `FD_RPC_CLIENT_SUCCESS`, log an error with the status code.
    - Calculate the transaction rate if `ctx->txncount_measured1` is true, log the transaction rate, and update `ctx->txncount_prev` with the current transaction count.
    - Set `ctx->txncount_measured1` to 1 and update `ctx->txncount_nextprint` to 1.2 seconds in the future.
    - Close the RPC request using `fd_rpc_client_close` and set `ctx->txncount_state` to `FD_BENCHO_STATE_WAIT`.
    - Update `ctx->txncount_deadline` to `ctx->txncount_nextprint`.
    - Return `did_work` to indicate if any work was done.
- **Output**: Returns an integer indicating whether any work was done (1 if work was done, 0 otherwise).


---
### after\_credit<!-- {{#callable:after_credit}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_bencho.c#L157>)

Determines if any work was done by checking RPC client service, block hash service, and transaction count service, and updates the `charge_busy` flag accordingly.
- **Inputs**:
    - `ctx`: A pointer to `fd_bencho_ctx_t` structure, which contains context information for the benchmark operation.
    - `stem`: A pointer to `fd_stem_context_t` structure, which is used in the block hash service.
    - `opt_poll_in`: An optional pointer to an integer, which is not used in this function.
    - `charge_busy`: A pointer to an integer that will be set to indicate if any work was done.
- **Logic and Control Flow**:
    - Call `fd_rpc_client_service` with `ctx->rpc` and store the result in `did_work_rpc`.
    - Call [`service_block_hash`](<#service_block_hash>) with `ctx` and `stem`, and store the result in `did_work_service_block_hash`.
    - Call [`service_txn_count`](<#service_txn_count>) with `ctx`, and store the result in `did_work_service_txn_count`.
    - Combine the results of the three service calls using bitwise OR and store the result in `*charge_busy`.
- **Output**: Sets the integer pointed to by `charge_busy` to indicate if any of the service functions performed work.
- **Functions Called**:
    - [`service_block_hash`](<#service_block_hash>)
    - [`service_txn_count`](<#service_txn_count>)


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_bencho.c#L171>)

Initializes the unprivileged context for a tile in the topology, setting up memory and RPC client connections.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology configuration.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the specific tile to initialize.
- **Logic and Control Flow**:
    - Allocate scratch memory for the tile using `fd_topo_obj_laddr` to get the local address of the tile object.
    - Initialize the scratch allocator with `FD_SCRATCH_ALLOC_INIT`.
    - Allocate a `fd_bencho_ctx_t` context structure in the scratch memory using `FD_SCRATCH_ALLOC_APPEND`.
    - Set up the context's memory workspace, output chunk, watermark, and initial chunk using the topology's workspace and link information.
    - Initialize RPC-related fields in the context, including setting the `rpc_ready_deadline` and states for blockhash and transaction count.
    - Log a notice about connecting to the RPC server using the tile's RPC IP address and port.
    - Create and join an RPC client using `fd_rpc_client_new` and `fd_rpc_client_join`.
    - Finalize the scratch allocation with `FD_SCRATCH_ALLOC_FINI` and check for scratch overflow, logging an error if it occurs.
- **Output**: No return value; the function initializes the context and sets up the RPC client for the tile.
- **Functions Called**:
    - [`scratch_footprint`](<#scratch_footprint>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)