<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a benchmarking tool for transaction generation with different modes and configurations.

# Purpose
The code defines a module for benchmarking transaction processing in a distributed system. It includes several components and structures that facilitate the creation and management of different types of transactions, such as small no-operation transactions (`small_noop_t`), large no-operation transactions (`large_noop_t`), and transfer transactions (`transfer_t`). The module uses a context structure, `fd_benchg_ctx_t`, to maintain state information such as random number generators, cryptographic hashes, account keys, and transaction parameters. The code also defines constants for different transaction modes and includes functions to calculate memory alignment and footprint for the context structure.

The module is designed to be integrated into a larger system, as indicated by the inclusion of external headers and the use of a `fd_topo_run_tile_t` structure to define a tile named `benchg`. This tile is part of a larger topology and is responsible for initializing the benchmarking context and running the transaction processing logic. The code includes callback functions, [`after_credit`](<#after_credit>) and [`during_frag`](<#during_frag>), which handle transaction creation and blockhash management. The module is intended to be used in a distributed environment where it can simulate different transaction scenarios and measure performance metrics.
# Imports and Dependencies

---
- `../../../../disco/topo/fd_topo.h`
- `../../../../flamenco/types/fd_types_custom.h`
- `../../../../flamenco/runtime/fd_system_ids_pp.h`
- `linux/unistd.h`
- `../../../../disco/stem/fd_stem.c`


# Global Variables

---
### HARDCODED\_PUBKEY
- **Type**: ``static const uchar[32]``
- **Description**: A 32-byte array of unsigned characters that represents a hardcoded public key.
- **Use**: Used in cryptographic operations where a fixed public key is required, such as in the `large_noop_t` structure for transaction processing.


---
### HARDCODED\_SIG
- **Type**: ``static const uchar[64]``
- **Description**: A static constant array of unsigned characters with 64 elements, representing a hardcoded signature.
- **Use**: Used to store a predefined signature for cryptographic operations or verification processes.


---
### fd\_tile\_benchg
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a global variable of type `fd_topo_run_tile_t` named `fd_tile_benchg`. This variable is initialized with specific function pointers and parameters, such as `scratch_align`, `scratch_footprint`, `unprivileged_init`, and `stem_run`, which are used to configure and manage a tile in a topology.
- **Use**: Used to represent and configure a tile named 'benchg' in a topology, providing necessary alignment, footprint, initialization, and execution functions.


# Data Structures

---
### fd\_benchg\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``rng``: An array of one `fd_rng_t` object for random number generation.
    - ``sha``: An array of one `fd_sha512_t` object for SHA-512 hashing.
    - ``sender_idx``: An unsigned long integer representing the index of the sender.
    - ``lamport_idx``: An unsigned long integer representing the Lamport index.
    - ``changed_blockhash``: An integer indicating if the blockhash has changed.
    - ``has_recent_blockhash``: An integer indicating if there is a recent blockhash.
    - ``recent_blockhash``: An array of 32 unsigned characters storing the recent blockhash.
    - ``staged_blockhash``: An array of 32 unsigned characters storing the staged blockhash.
    - ``transaction_mode``: An integer representing the transaction mode.
    - ``contending_fraction``: A float representing the fraction of contending transactions.
    - ``cu_price_spread``: A float representing the price spread for compute units.
    - ``acct_cnt``: An unsigned long integer representing the account count.
    - ``acct_public_keys``: A pointer to an array of `fd_pubkey_t` objects for account public keys.
    - ``acct_private_keys``: A pointer to an array of `fd_pubkey_t` objects for account private keys.
    - ``benchg_cnt``: An unsigned long integer representing the count of benchmark generators.
    - ``benchg_idx``: An unsigned long integer representing the index of the benchmark generator.
    - ``mem``: A pointer to an `fd_wksp_t` object representing the memory workspace.
    - ``out_chunk0``: An unsigned long integer representing the initial output chunk.
    - ``out_wmark``: An unsigned long integer representing the watermark for output.
    - ``out_chunk``: An unsigned long integer representing the current output chunk.
- **Description**: `fd_benchg_ctx_t` is a `struct` that encapsulates the context for a benchmarking generator, including random number generation, hashing, transaction management, and memory workspace handling. It maintains state information such as sender and Lamport indices, blockhash status, transaction mode, and account keys. The structure is designed to facilitate the generation and management of transactions in a benchmarking environment, with fields for tracking output chunks and memory usage.


---
### single\_signer\_hdr\_t
- **Type**: ``struct``
- **Members**:
    - ``sig_cnt``: Stores the count of signatures, set to 1.
    - ``signature``: Holds a 64-byte signature.
    - ``_sig_cnt``: Duplicate of `sig_cnt`, also set to 1.
    - ``ro_signed_cnt``: Stores the count of read-only signed accounts.
    - ``ro_unsigned_cnt``: Stores the count of read-only unsigned accounts.
    - ``acct_addr_cnt``: Stores the count of account addresses.
    - ``fee_payer``: Holds a 32-byte fee payer address.
- **Description**: Defines a packed structure for a single signer header, which includes fields for signature count, a signature, and various account-related counts and addresses. The structure is used to manage transaction details for a single signer, with specific fields for signature and account information.


---
### small\_noop\_t
- **Type**: ``struct``
- **Members**:
    - `sig_cnt`: Holds the count of signatures, set to 1.
    - `signature`: Stores a 64-byte signature.
    - `_sig_cnt`: Duplicate of `sig_cnt`, also set to 1.
    - `ro_signed_cnt`: Holds the count of read-only signed accounts, set to 0.
    - `ro_unsigned_cnt`: Holds the count of read-only unsigned accounts, set to 1 for the Compute Budget Program.
    - `acct_addr_cnt`: Holds the count of account addresses, set to 2.
    - `fee_payer`: Stores a 32-byte fee payer address.
    - `compute_budget_program`: Stores a 32-byte identifier for the Compute Budget Program.
    - `recent_blockhash`: Stores a 32-byte recent blockhash.
    - `instr_cnt`: Holds the count of instructions, set to 2.
    - `_1`: First instruction structure with program ID, account count, data size, CU price setting, and micro lamports per CU.
    - `_2`: Second instruction structure with program ID, account count, data size, CU limit setting, and CU count.
- **Description**: Represents a packed structure for a small no-operation transaction with specific fields for signature, account counts, fee payer, compute budget program, and two instructions. The first instruction sets the compute unit price, while the second sets the compute unit limit. This structure is used in transaction processing, particularly in scenarios involving compute budget management.


---
### large\_noop\_t
- **Type**: ``struct``
- **Members**:
    - `sig_cnt`: Stores the signature count, initialized to 1.
    - `signature`: Holds a 64-byte signature.
    - `_sig_cnt`: Stores a duplicate signature count, also initialized to 1.
    - `ro_signed_cnt`: Stores the read-only signed count, initialized to 0.
    - `ro_unsigned_cnt`: Stores the read-only unsigned count, initialized to 2.
    - `acct_addr_cnt`: Stores the account address count, initialized to 3.
    - `fee_payer`: Holds a 32-byte fee payer address.
    - `compute_budget_program`: Holds a 32-byte compute budget program identifier.
    - `ed25519_sv_program`: Holds a 32-byte Ed25519 signature verification program identifier.
    - `recent_blockhash`: Holds a 32-byte recent blockhash.
    - `instr_cnt`: Stores the instruction count, initialized to 2.
    - `_1`: Represents the first instruction with program ID, account count, data size, CU price, and micro lamports per CU.
    - `_2`: Represents the second instruction with program ID, account count, data sizes, signature count, offsets, and hardcoded values.
- **Description**: `large_noop_t` is a packed structure that represents a large no-operation transaction with multiple fields for signature, account, and instruction details. It includes two instructions, each with specific program IDs and data configurations, and uses hardcoded values for public keys and signatures. The structure is designed to handle transaction details in a compact form, with specific fields for managing compute budget and Ed25519 signature verification.


---
### transfer\_t
- **Type**: ``struct``
- **Members**:
    - `sig_cnt`: Number of signatures, set to 1.
    - `signature`: Array of 64 unsigned characters representing the signature.
    - `_sig_cnt`: Duplicate of `sig_cnt`, also set to 1.
    - `ro_signed_cnt`: Number of read-only signed accounts, set to 0.
    - `ro_unsigned_cnt`: Number of read-only unsigned accounts, set to 1 for the system program.
    - `acct_addr_cnt`: Number of account addresses, set to 3.
    - `fee_payer`: Array of 32 unsigned characters representing the fee payer's public key.
    - `transfer_dest`: Array of 32 unsigned characters representing the transfer destination's public key.
    - `system_program`: Array of 32 unsigned characters representing the system program, initialized to zeros.
    - `recent_blockhash`: Array of 32 unsigned characters representing the recent blockhash.
    - `instr_cnt`: Number of instructions, set to 1.
    - `_1`: Nested struct representing the instruction details.
- **Description**: `transfer_t` is a packed structure that represents a transaction for transferring lamports in a system program. It includes fields for signature count, signature data, account details, and a nested structure for instruction specifics such as program ID, account count, and lamport transfer amount. The structure is designed to facilitate the execution of a single transfer instruction within a transaction.


# Functions

---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchg.c#L40>)

Returns the alignment requirement of the `fd_benchg_ctx_t` structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the `alignof` operator on the `fd_benchg_ctx_t` structure to determine its alignment requirement.
    - Returns the result of the `alignof` operator.
- **Output**: The alignment requirement of the `fd_benchg_ctx_t` structure as an `ulong`.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchg.c#L45>)

Calculates the memory footprint required for a scratch space based on the alignment and size of specific data structures and the number of accounts in a tile.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure that contains information about the number of accounts (`accounts_cnt`) in the `benchg` field.
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT` to start the layout calculation.
    - Append the size and alignment of `fd_benchg_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the size and alignment of `fd_pubkey_t` for each account twice to `l` using `FD_LAYOUT_APPEND`, based on `tile->benchg.accounts_cnt`.
    - Finalize the layout with `FD_LAYOUT_FINI`, using the alignment from `scratch_align()`, and return the result.
- **Output**: Returns an `ulong` representing the total memory footprint required for the scratch space.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### after\_credit<!-- {{#callable:after_credit}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchg.c#L173>)

Processes a transaction based on the current context and transaction mode, updating the context and publishing the transaction.
- **Inputs**:
    - `ctx`: A pointer to `fd_benchg_ctx_t`, which contains the context for the transaction including random number generator, transaction mode, and account information.
    - `stem`: A pointer to `fd_stem_context_t`, which is used for publishing the transaction.
    - `opt_poll_in`: An optional integer pointer, not used in this function.
    - `charge_busy`: A pointer to an integer that will be set to 1 if the function processes a transaction.
- **Logic and Control Flow**:
    - If `ctx->has_recent_blockhash` is false, return immediately without processing.
    - Set `*charge_busy` to 1 to indicate the function is processing a transaction.
    - Determine if the transaction is contending using a random float and `ctx->contending_fraction`.
    - Calculate `cu_price_spread` based on a normal random float and `ctx->cu_price_spread`.
    - Convert the output chunk to a local address for transaction processing.
    - Based on `ctx->transaction_mode`, process the transaction as small, large, or transfer, setting up the transaction structure accordingly.
    - Copy the fee payer and recent blockhash into the transaction header.
    - Sign the transaction using `fd_ed25519_sign` with the sender's public and private keys.
    - Publish the transaction using `fd_stem_publish`.
    - Update `ctx->out_chunk` using `fd_dcache_compact_next`.
    - Increment `ctx->sender_idx` and handle wrap-around, updating `ctx->lamport_idx` and `ctx->recent_blockhash` if necessary.
- **Output**: No return value; the function modifies the context and publishes a transaction.


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchg.c#L333>)

Updates the blockhash in the context if it has changed or is not set.
- **Inputs**:
    - `ctx`: A pointer to `fd_benchg_ctx_t` structure that holds the context, including blockhash information.
    - `in_idx`: An unused parameter.
    - `seq`: An unused parameter.
    - `sig`: An unused parameter.
    - `chunk`: An unsigned long integer representing the chunk from which to retrieve the blockhash.
    - `sz`: An unused parameter.
    - `ctl`: An unused parameter.
- **Logic and Control Flow**:
    - Check if `ctx->has_recent_blockhash` is false.
    - If false, copy the blockhash from the memory location derived from `chunk` into `ctx->recent_blockhash`, set `ctx->has_recent_blockhash` to true, and `ctx->changed_blockhash` to false.
    - If true, compare the current `ctx->recent_blockhash` with the blockhash from the memory location derived from `chunk`.
    - If they are different, copy the new blockhash into `ctx->staged_blockhash` and set `ctx->changed_blockhash` to true.
- **Output**: No return value; modifies the `ctx` structure in place.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchg.c#L353>)

Initializes the unprivileged context for a tile in the topology, setting up memory allocations and cryptographic contexts.
- **Inputs**:
    - `topo`: A pointer to the `fd_topo_t` structure representing the topology.
    - `tile`: A pointer to the `fd_topo_tile_t` structure representing the tile to initialize.
- **Logic and Control Flow**:
    - Allocate scratch memory for the tile using `fd_topo_obj_laddr` to get the local address of the tile object.
    - Initialize the scratch allocator with `FD_SCRATCH_ALLOC_INIT`.
    - Allocate memory for `fd_benchg_ctx_t` and public/private key arrays using `FD_SCRATCH_ALLOC_APPEND`.
    - Initialize random number generator and SHA-512 context with `fd_rng_join` and `fd_sha512_join`.
    - Set various context fields such as account count, transaction mode, contending fraction, and price spread from the tile's `benchg` configuration.
    - Initialize account private keys to zero and derive public keys using `fd_ed25519_public_from_private`.
    - Set initial values for context fields like `has_recent_blockhash`, `sender_idx`, `lamport_idx`, and `changed_blockhash`.
    - Determine the number of `benchg` tiles and set the index for the current tile.
    - Set memory workspace and calculate initial chunk and watermark for output data cache.
    - Finalize scratch allocation with `FD_SCRATCH_ALLOC_FINI` and check for overflow using `FD_LOG_ERR`.
- **Output**: No return value; the function initializes the context in place.
- **Functions Called**:
    - [`scratch_footprint`](<#scratch_footprint>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)