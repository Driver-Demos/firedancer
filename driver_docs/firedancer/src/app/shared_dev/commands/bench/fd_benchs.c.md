<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Benchmarks QUIC and UDP performance using asynchronous I/O and socket operations.

# Purpose
The code is a C source file that implements a benchmarking context for testing QUIC (Quick UDP Internet Connections) protocol operations. It includes functions for initializing and managing QUIC connections, handling asynchronous input/output (AIO) operations, and processing network packets. The file defines a structure `fd_benchs_ctx_t` that holds the state and configuration for the benchmarking, including connection details, packet buffers, and QUIC-specific parameters. The code uses the GNU extensions for socket operations, such as `recvmmsg` and `sendmmsg`, to handle multiple message transmissions efficiently.

The file includes several functions that manage the lifecycle of QUIC connections, such as [`quic_conn_new`](<#quic_conn_new>), [`handshake_complete`](<#handshake_complete>), and [`conn_final`](<#conn_final>), which are callbacks for connection events. The [`service_quic`](<#service_quic>) function processes incoming packets and passes them to the QUIC engine, while [`quic_tx_aio_send`](<#quic_tx_aio_send>) handles the transmission of packets. The code also includes initialization functions [`privileged_init`](<#privileged_init>) and [`unprivileged_init`](<#unprivileged_init>) to set up the benchmarking context and configure the QUIC engine. The file is part of a larger system, as indicated by the inclusion of headers from other directories, and it is designed to be integrated into a broader testing framework, as suggested by the inclusion of `fd_stem.c` for running the benchmark.
# Imports and Dependencies

---
- `../../../../disco/topo/fd_topo.h`
- `../../../../waltz/quic/fd_quic.h`
- `../../../../waltz/quic/tests/fd_quic_test_helpers.h`
- `../../../../waltz/tls/test_tls_helper.h`
- `errno.h`
- `linux/unistd.h`
- `sys/types.h`
- `sys/socket.h`
- `netinet/in.h`
- `string.h`
- `unistd.h`
- `poll.h`
- `stdio.h`
- `stdlib.h`
- `time.h`
- `../../../../disco/stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_benchs
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Represents a configuration for running a tile in a topology, specifically for benchmarking purposes. It includes initialization functions, alignment and footprint specifications, and a run function.
- **Use**: Used to define and configure the execution of a benchmarking tile in a distributed system.


# Data Structures

---
### fd\_benchs\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``round_robin_cnt``: Stores the count for round-robin operations.
    - ``round_robin_id``: Stores the identifier for round-robin operations.
    - ``packet_cnt``: Counts the number of packets processed.
    - ``conn_cnt``: Stores the number of connections.
    - ``conn_fd``: Array of file descriptors for connections.
    - ``poll_fd``: Array of `pollfd` structures for polling connections.
    - ``test_signer``: Holds the test signer context for TLS operations.
    - ``no_quic``: Indicates if QUIC is not used.
    - ``quic``: Pointer to a QUIC context.
    - ``quic_port``: Stores the port number for QUIC connections.
    - ``quic_conn``: Pointer to a QUIC connection.
    - ``no_stream``: Counts the number of streams not available.
    - ``service_ratio_idx``: Index for service ratio operations.
    - ``tx_aio``: Holds the asynchronous I/O context for transmission.
    - ``now``: Stores the current time in nanoseconds.
    - ``clock``: Array holding the clock context.
    - ``recal_next``: Stores the next recalibration time in nanoseconds.
    - ``rx_msgs``: Array of message headers for receiving data.
    - ``tx_msgs``: Array of message headers for transmitting data.
    - ``rx_iovecs``: Array of I/O vectors for receiving data.
    - ``tx_iovecs``: Array of I/O vectors for transmitting data.
    - ``rx_bufs``: Buffers for receiving data.
    - ``tx_bufs``: Buffers for transmitting data.
    - ``tx_idx``: Index for tracking transmission operations.
    - ``mem``: Pointer to workspace memory.
    - ``clock_mem``: Memory aligned for clock operations.
- **Description**: `fd_benchs_ctx_t` is a structure that manages the context for benchmarking operations, including connection handling, packet processing, and QUIC protocol management. It contains fields for round-robin operations, connection file descriptors, polling structures, TLS and QUIC contexts, and buffers for data transmission and reception. The structure also includes timing and clock management fields to support precise operation timing and recalibration.


# Functions

---
### service\_quic<!-- {{#callable:service_quic}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L71>)

Handles incoming QUIC packets by polling sockets, receiving messages, and processing them with the QUIC engine.
- **Inputs**:
    - ``ctx``: A pointer to `fd_benchs_ctx_t` structure containing context information for QUIC processing.
    - ``now``: A long integer representing the current time in nanoseconds.
- **Logic and Control Flow**:
    - Check if QUIC is enabled by verifying `ctx->no_quic` is false.
    - Poll the file descriptors in `ctx->poll_fd` for incoming data with a timeout of 0 milliseconds.
    - If `poll` returns 0, exit the function as there is no data to process.
    - If `poll` returns -1 and `errno` is `EINTR`, exit the function to try again later.
    - Log an error if `poll` returns -1 for other reasons.
    - Iterate over each connection in `ctx->poll_fd` to check for events.
    - If `POLLIN` event is detected, receive messages using `recvmmsg` into `ctx->rx_msgs`.
    - Log an error if `recvmmsg` fails.
    - For each received message, calculate the payload, UDP, and IP lengths, and set the appropriate fields in the buffer.
    - Call `fd_quic_process_packet` to process the packet with the QUIC engine.
    - If `POLLERR` event is detected, retrieve and log the socket error using `getsockopt`.
- **Output**: No return value; the function processes incoming QUIC packets and logs errors if they occur.


---
### quic\_conn\_new<!-- {{#callable:quic_conn_new}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L138>)

Handles the initialization of a new QUIC connection.
- **Inputs**:
    - ``conn``: A pointer to an `fd_quic_conn_t` structure representing the new QUIC connection.
    - ``_ctx``: A pointer to a context object, typically used to pass additional data or state information.
- **Logic and Control Flow**:
    - The function takes two parameters, `conn` and `_ctx`, but does not use them in its body.
    - Both parameters are explicitly cast to void to indicate they are unused, which prevents compiler warnings about unused parameters.
- **Output**: No output is produced as the function body is empty.


---
### handshake\_complete<!-- {{#callable:handshake_complete}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L146>)

Logs a notice indicating that the client handshake is complete.
- **Inputs**:
    - ``conn``: A pointer to an `fd_quic_conn_t` structure representing the QUIC connection.
    - ``_ctx``: A pointer to a context object, which is not used in this function.
- **Logic and Control Flow**:
    - The function takes two parameters, `conn` and `_ctx`, but does not use them.
    - It logs a notice message 'client handshake complete' using the `FD_LOG_NOTICE` macro.
- **Output**: No output is returned from this function.


---
### conn\_final<!-- {{#callable:conn_final}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L154>)

Sets the `quic_conn` field of the `fd_benchs_ctx_t` context to `NULL` if the context is not `NULL`.
- **Inputs**:
    - ``conn``: A pointer to an `fd_quic_conn_t` structure, which is not used in this function.
    - ``_ctx``: A pointer to a context of type `fd_benchs_ctx_t`.
- **Logic and Control Flow**:
    - Casts the `_ctx` pointer to a `fd_benchs_ctx_t` pointer and assigns it to `ctx`.
    - Checks if `ctx` is not `NULL`.
    - If `ctx` is not `NULL`, sets `ctx->quic_conn` to `NULL`.
- **Output**: No return value, as the function's return type is `void`.


---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L166>)

Calculates the maximum alignment requirement between QUIC and benchmark context structures.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `fd_quic_align()` to get the alignment requirement for QUIC.
    - Calls `alignof(fd_benchs_ctx_t)` to get the alignment requirement for the benchmark context structure.
    - Uses `fd_ulong_max()` to return the maximum of the two alignment values.
- **Output**: Returns the maximum alignment requirement as an unsigned long integer.


---
### populate\_quic\_limits<!-- {{#callable:populate_quic_limits}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L171>)

Initializes the fields of a `fd_quic_limits_t` structure with predefined values for QUIC connection limits.
- **Inputs**:
    - `limits`: A pointer to a `fd_quic_limits_t` structure that will be populated with QUIC connection limit values.
- **Logic and Control Flow**:
    - Set `limits->conn_cnt` to 2.
    - Set `limits->handshake_cnt` to the value of `limits->conn_cnt`.
    - Set `limits->conn_id_cnt` to 16.
    - Set `limits->inflight_frame_cnt` to 1500.
    - Set `limits->tx_buf_sz` to 2048 (1 shifted left by 11).
    - Set `limits->stream_pool_cnt` to 65536 (1 shifted left by 16).
    - Set `limits->stream_id_cnt` to 65536 (1 shifted left by 16).
- **Output**: No return value; the function modifies the `limits` structure in place.


---
### populate\_quic\_config<!-- {{#callable:populate_quic_config}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L182>)

Initializes a `fd_quic_config_t` structure with default client role settings for QUIC.
- **Inputs**:
    - `config`: A pointer to a `fd_quic_config_t` structure that will be populated with default values.
- **Logic and Control Flow**:
    - Set the `role` field of `config` to `FD_QUIC_ROLE_CLIENT` to specify the client role.
    - Set the `retry` field of `config` to 0, indicating no retry is expected.
    - Set the `initial_rx_max_stream_data` field of `config` to 0, as the client does not expect the server to initiate streams.
    - Set the `net.dscp` field of `config` to 0, which is the default DSCP value.
- **Output**: The function does not return a value; it modifies the `config` structure in place.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L190>)

Calculates the memory footprint required for a scratch space based on the configuration of a given tile, including optional QUIC components.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure that contains configuration details for the tile, including whether QUIC is used.
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT` to start the layout calculation.
    - Append the alignment and size of `fd_benchs_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Check if the `no_quic` flag in `tile->benchs` is false, indicating that QUIC is used.
    - If QUIC is used, initialize `fd_quic_limits_t` and populate it with [`populate_quic_limits`](<#populate_quic_limits>).
    - Calculate the QUIC footprint using `fd_quic_footprint` and append it to `l` with its alignment using `FD_LAYOUT_APPEND`.
    - Finalize the layout calculation with `FD_LAYOUT_FINI`, using [`scratch_align`](<#scratch_align>) for alignment, and return the result.
- **Output**: Returns an `ulong` representing the total memory footprint required for the scratch space.
- **Functions Called**:
    - [`populate_quic_limits`](<#populate_quic_limits>)
    - [`scratch_align`](<#scratch_align>)


---
### before\_frag<!-- {{#callable:before_frag}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L203>)

Determines if a given sequence number should be processed based on round-robin logic and updates the current time in the context.
- **Inputs**:
    - `ctx`: A pointer to `fd_benchs_ctx_t` structure, which holds the context for the operation including round-robin parameters and clock information.
    - `in_idx`: An unused `ulong` parameter, presumably intended for input index.
    - `seq`: A `ulong` representing the sequence number to be checked against the round-robin logic.
    - `sig`: An unused `ulong` parameter, presumably intended for a signature or signal.
- **Logic and Control Flow**:
    - Ignore `in_idx` and `sig` parameters as they are not used in the function.
    - Update the `now` field in the `ctx` structure with the current time obtained from `fd_clock_now` using the `ctx->clock`.
    - Calculate the modulus of `seq` with `ctx->round_robin_cnt` and compare it to `ctx->round_robin_id`.
    - Return 1 if the result of the modulus operation is not equal to `ctx->round_robin_id`, otherwise return 0.
- **Output**: Returns an `int` indicating whether the sequence number should be processed (0) or not (1) based on the round-robin logic.


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L216>)

Handles packet transmission over either a direct connection or a QUIC connection based on the context configuration.
- **Inputs**:
    - `ctx`: A pointer to the `fd_benchs_ctx_t` structure containing the context for the operation.
    - `in_idx`: An unused parameter, marked with `FD_PARAM_UNUSED`.
    - `seq`: An unused parameter, marked with `FD_PARAM_UNUSED`.
    - `sig`: An unused parameter, marked with `FD_PARAM_UNUSED`.
    - `chunk`: The memory chunk to send.
    - `sz`: The size of the data to send.
    - `ctl`: An unused parameter, marked with `FD_PARAM_UNUSED`.
- **Logic and Control Flow**:
    - Checks if `ctx->no_quic` is true to determine if QUIC is not used.
    - If QUIC is not used, sends the data using the `send` function and increments `ctx->packet_cnt`.
    - If QUIC is used, checks if `ctx->service_ratio_idx` has reached 8, then resets it and calls [`service_quic`](<#service_quic>) and `fd_quic_service`.
    - Attempts to establish a QUIC connection if `ctx->quic_conn` is NULL, logging the connection creation and setting the context.
    - If a new stream cannot be created, increments `ctx->no_stream` and calls [`service_quic`](<#service_quic>) and `fd_quic_service`.
    - If a stream is created, sends the data using `fd_quic_stream_send` and increments `ctx->packet_cnt`, logging an error if the send fails.
- **Output**: No return value; the function operates by side effects on the `ctx` structure.
- **Functions Called**:
    - [`service_quic`](<#service_quic>)


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L295>)

Initializes network connections and context for a tile in a topology, setting up sockets and configuring QUIC if needed.
- **Inputs**:
    - `topo`: A pointer to an `fd_topo_t` structure representing the topology.
    - `tile`: A pointer to an `fd_topo_tile_t` structure representing the tile to initialize.
- **Logic and Control Flow**:
    - Retrieve the local address of the tile object using `fd_topo_obj_laddr` and store it in `scratch`.
    - Call `fd_log_wallclock` to ensure the VDSO is loaded by glibc, which requires calling `mmap` while privileged.
    - Initialize a scratch allocator with `FD_SCRATCH_ALLOC_INIT` using `scratch`.
    - Allocate and zero-initialize a `fd_benchs_ctx_t` context structure using `FD_SCRATCH_ALLOC_APPEND` and `fd_memset`.
    - Set `no_quic` in the context based on `tile->benchs.no_quic` and initialize `port` to 12000.
    - Set `ctx->conn_cnt` to `tile->benchs.conn_cnt`, or 1 if QUIC is not used, and verify it does not exceed the maximum allowed connections.
    - Set `ctx->quic_port` to `tile->benchs.send_to_port`.
    - For each connection, create a UDP socket and configure its receive and send buffer sizes using `setsockopt`.
    - Attempt to bind the socket to a port, incrementing the port number if the address is in use, and log an error if binding fails.
    - Connect the socket to the destination address specified in `tile->benchs.send_to_ip_addr` and `tile->benchs.send_to_port`.
    - Store the socket file descriptor in `ctx->conn_fd` and configure polling if QUIC is not disabled.
- **Output**: No return value; the function initializes the network context and connections for the specified tile.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L363>)

Initializes the unprivileged context for a tile in a topology, setting up QUIC and other resources if needed.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the tile to initialize.
- **Logic and Control Flow**:
    - Allocate scratch memory for the tile using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_INIT`.
    - Allocate and initialize a `fd_benchs_ctx_t` context structure in the scratch memory.
    - Set initial values for `packet_cnt`, `round_robin_id`, and `round_robin_cnt` in the context.
    - Assign the appropriate workspace memory to `ctx->mem` based on the topology and tile configuration.
    - If QUIC is enabled (`!ctx->no_quic`), initialize QUIC parameters and memory, and join the QUIC context.
    - Configure QUIC settings, including role, idle timeout, and callbacks for connection events.
    - Set up asynchronous I/O for QUIC transmission using `fd_aio_join` and `fd_aio_new`.
    - Initialize receive buffers and message headers for QUIC if enabled.
    - Finalize scratch memory allocation with `FD_SCRATCH_ALLOC_FINI` and check for overflow.
    - Initialize the clock and set recalibration and current time values in the context.
- **Output**: No direct output; modifies the `fd_benchs_ctx_t` context and associated resources for the tile.
- **Functions Called**:
    - [`populate_quic_limits`](<#populate_quic_limits>)
    - [`populate_quic_config`](<#populate_quic_config>)
    - [`scratch_footprint`](<#scratch_footprint>)


---
### quic\_tx\_aio\_send\_flush<!-- {{#callable:quic_tx_aio_send_flush}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L441>)

Flushes pending messages in the transmission buffer by sending them over a network connection.
- **Inputs**:
    - `ctx`: A pointer to a `fd_benchs_ctx_t` structure that contains the context for the transmission, including the connection file descriptor and message buffers.
- **Logic and Control Flow**:
    - Check if `ctx->tx_idx` is non-zero, indicating there are messages to send.
    - If there are messages, call `sendmmsg` to send the messages in `ctx->tx_msgs` using the first connection file descriptor in `ctx->conn_fd`.
    - If `sendmmsg` returns a negative value, log an error message with the error number and description.
    - Reset `ctx->tx_idx` to zero after attempting to send the messages.
- **Output**: No return value; the function operates by side effects on the `ctx` structure.


---
### quic\_tx\_aio\_send<!-- {{#callable:quic_tx_aio_send}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L454>)

Processes a batch of packets by stripping headers and preparing them for transmission, flushing if necessary.
- **Inputs**:
    - `_ctx`: A pointer to the context (`fd_benchs_ctx_t`) which holds transmission buffers and state.
    - `batch`: A pointer to an array of `fd_aio_pkt_info_t` structures representing the packets to be processed.
    - `batch_cnt`: The number of packets in the `batch` array.
    - `opt_batch_idx`: An optional pointer to a `ulong` where the function writes the number of packets processed.
    - `flush`: An integer flag indicating whether to force a flush of the transmission buffers.
- **Logic and Control Flow**:
    - Calculate the header size to strip from each packet.
    - Check if there are packets to process (`batch_cnt` is non-zero).
    - Determine the remaining space in the transmission buffer (`remain`).
    - If the remaining space is less than the batch count, flush the current transmission buffer.
    - Calculate the number of packets to process (`cnt`) as the minimum of `remain` and `batch_cnt`.
    - Iterate over the packets to process, stripping headers and copying data to the transmission buffer.
    - Update the transmission index (`tx_idx`) after processing packets.
    - Flush the transmission buffer if it is full or if `flush` is set.
    - If `opt_batch_idx` is provided, set it to `batch_cnt`.
- **Output**: Returns 0 to indicate successful processing.
- **Functions Called**:
    - [`quic_tx_aio_send_flush`](<#quic_tx_aio_send_flush>)


---
### during\_housekeeping<!-- {{#callable:during_housekeeping}} -->
[View Source →](<../../../../../../../src/app/shared_dev/commands/bench/fd_benchs.c#L516>)

Checks if recalibration is needed and updates the next recalibration time if necessary.
- **Inputs**:
    - `ctx`: A pointer to a `fd_benchs_ctx_t` structure that contains the context for the function, including timing and clock information.
- **Logic and Control Flow**:
    - Checks if `ctx->recal_next` is less than or equal to `ctx->now` using the `FD_UNLIKELY` macro to optimize for the unlikely case.
    - If the condition is true, calls `fd_clock_default_recal` with `ctx->clock` to get the next recalibration time and assigns it to `ctx->recal_next`.
- **Output**: No return value; the function updates the `ctx->recal_next` field in the provided context structure.



---
Made with ❤️ by [Driver](https://www.driver.ai/)