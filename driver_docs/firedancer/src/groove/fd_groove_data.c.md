<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Lock-free atomic operations for managing superblocks in a memory allocation system, including functions for setting active superblocks, pushing and popping inactive superblocks, and verifying superblock integrity.

# Purpose
The code is a C source file that provides functions for managing memory allocation and deallocation using a lock-free, atomic approach. It is part of a memory management system that operates on the concept of superblocks, which are blocks of memory that can be subdivided into smaller objects for allocation. The file includes functions to displace active superblocks, push and pop inactive superblocks, and allocate and free objects within these superblocks. The functions use atomic operations to ensure thread safety without the need for locks, making them suitable for concurrent environments.

The file defines several key functions, such as [`fd_groove_data_private_active_displace`](<#fd_groove_data_private_active_displace>), [`fd_groove_data_private_inactive_push`](<#fd_groove_data_private_inactive_push>), and [`fd_groove_data_private_inactive_pop`](<#fd_groove_data_private_inactive_pop>), which manage the state of superblocks in a lock-free manner. It also includes functions like [`fd_groove_data_new`](<#fd_groove_data_new>), [`fd_groove_data_join`](<#fd_groove_data_join>), [`fd_groove_data_leave`](<#fd_groove_data_leave>), and [`fd_groove_data_delete`](<#fd_groove_data_delete>) to handle the lifecycle of the memory management system. The code uses compiler fences (`FD_COMPILER_MFENCE`) to ensure memory ordering and atomic operations (`FD_ATOMIC_XCHG`, `FD_ATOMIC_CAS`) to manipulate shared data safely. Additionally, the file contains verification functions to ensure the integrity of the memory structures, such as [`fd_groove_data_verify`](<#fd_groove_data_verify>) and [`fd_groove_data_volume_verify`](<#fd_groove_data_volume_verify>).
# Imports and Dependencies

---
- `fd_groove_data.h`


# Functions

---
### fd\_groove\_data\_private\_active\_displace<!-- {{#callable:fd_groove_data_private_active_displace}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L31>)

Atomically sets the active superblock offset and returns the previous offset.
- **Inputs**:
    - `_active_slot`: A pointer to a volatile unsigned long representing the active superblock offset.
    - `volume0`: A pointer to `fd_groove_volume_t`, which is not used in the function.
    - `superblock_off`: An unsigned long representing the new superblock offset to set.
- **Logic and Control Flow**:
    - Ignore `volume0` as it is not used in the function.
    - Execute a memory fence using `FD_COMPILER_MFENCE()` to ensure memory ordering before the atomic operation.
    - If `FD_HAS_ATOMIC` is defined, use `FD_ATOMIC_XCHG` to atomically exchange the value of `_active_slot` with `superblock_off`.
    - If `FD_HAS_ATOMIC` is not defined, manually swap the value of `_active_slot` with `superblock_off` using a temporary variable `old`.
    - Execute another memory fence using `FD_COMPILER_MFENCE()` to ensure memory ordering after the atomic operation.
    - Return the previous value of `_active_slot`, which is now stored in `superblock_off`.
- **Output**: Returns the previous offset of the active superblock as an unsigned long.


---
### fd\_groove\_data\_private\_inactive\_push<!-- {{#callable:fd_groove_data_private_inactive_push}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L56>)

Performs a lock-free atomic push of a superblock onto an inactive stack.
- **Inputs**:
    - `_inactive_stack`: A pointer to a volatile unsigned long representing the inactive stack.
    - `volume0`: A pointer to the base of the volume, used to calculate the address of the superblock.
    - `superblock_off`: An unsigned long representing the offset of the superblock from the base of the volume.
- **Logic and Control Flow**:
    - Executes a memory fence to ensure memory ordering before proceeding.
    - Calculates the address of the superblock using the base volume pointer and the superblock offset.
    - Enters an infinite loop to attempt the atomic push operation.
    - Reads the current value of the inactive stack to determine the version and next offset.
    - Updates the `info` field of the superblock with the next offset.
    - Calculates the next version number by incrementing the current version and wrapping it within the footprint limit.
    - Attempts an atomic compare-and-swap (CAS) operation to update the inactive stack with the new version and superblock offset.
    - If the CAS operation is successful, breaks out of the loop; otherwise, pauses briefly and retries.
    - Executes another memory fence to ensure memory ordering after the operation.
- **Output**: None (void function).


---
### fd\_groove\_data\_private\_inactive\_pop<!-- {{#callable:fd_groove_data_private_inactive_pop}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L96>)

Performs a lock-free atomic pop operation on an inactive stack to retrieve a superblock offset.
- **Inputs**:
    - `_inactive_stack`: A pointer to a volatile unsigned long representing the inactive stack.
    - `volume0`: A pointer to the base of the volume from which offsets are calculated.
- **Logic and Control Flow**:
    - Initialize `off` to store the offset of the superblock.
    - Use `FD_COMPILER_MFENCE` to ensure memory ordering before entering the loop.
    - Enter an infinite loop to attempt to pop the stack.
    - Read the current version and offset from `_inactive_stack`.
    - Extract the version and offset from `ver_off`.
    - If `off` is zero, break the loop as the stack is empty.
    - Calculate the address of the superblock using `volume0` and `off`.
    - Compute the next version and next offset from the superblock's `info`.
    - Use atomic compare-and-swap (`FD_ATOMIC_CAS`) to update `_inactive_stack` with the new version and offset, or use a conditional assignment if atomic operations are not available.
    - If the compare-and-swap was successful, break the loop.
    - Use `FD_SPIN_PAUSE` to yield the processor if the compare-and-swap failed.
    - Use `FD_COMPILER_MFENCE` to ensure memory ordering after the loop.
    - Return the offset `off`.
- **Output**: Returns the offset of the superblock relative to `volume0`, or 0 if the stack was empty.


---
### fd\_groove\_data\_new<!-- {{#callable:fd_groove_data_new}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L134>)

Initializes a shared memory region for groove data, ensuring alignment and configuration validity, and sets up a volume pool.
- **Inputs**:
    - `shmem`: A pointer to the shared memory region to initialize.
- **Logic and Control Flow**:
    - Cast `shmem` to a `fd_groove_data_shmem_t` pointer `shdata`.
    - Check if `shdata` is NULL; if so, log a warning and return NULL.
    - Check if `shdata` is aligned according to `fd_groove_data_align()`; if not, log a warning and return NULL.
    - Retrieve the footprint size using `fd_groove_data_footprint()` and check if it is zero; if so, log a warning and return NULL.
    - Clear the memory region pointed to by `shdata` using `memset` with the footprint size.
    - Initialize the volume pool in `shdata->volume_pool` using `fd_groove_volume_pool_new()`; if it fails, return NULL.
    - Use `FD_COMPILER_MFENCE()` to ensure memory ordering, then set `shdata->magic` to `FD_GROOVE_DATA_MAGIC`.
    - Return the original `shmem` pointer.
- **Output**: Returns the initialized shared memory pointer if successful, or NULL if any checks fail.
- **Functions Called**:
    - [`fd_groove_data_align`](<fd_groove_data.h.md#fd_groove_data_align>)
    - [`fd_groove_data_footprint`](<fd_groove_data.h.md#fd_groove_data_footprint>)


---
### fd\_groove\_data\_join<!-- {{#callable:fd_groove_data_join}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L166>)

Joins a local groove data structure with shared memory data, initializing volume pools and setting configuration hints.
- **Inputs**:
    - `ljoin`: Pointer to the local groove data structure to join.
    - `shdata`: Pointer to the shared memory groove data structure.
    - `volume0`: Pointer to the initial volume for the volume pool.
    - `volume_max`: Maximum volume size for the volume pool.
    - `cgroup_hint`: Concurrency group hint for the groove data.
- **Logic and Control Flow**:
    - Set `volume_max` to the provided value or the maximum possible if zero.
    - Cast `ljoin` and `shdata` to `fd_groove_data_t` and `fd_groove_data_shmem_t` respectively.
    - Check if `join` is NULL or misaligned, log a warning, and return NULL if true.
    - Check if `data` is NULL or misaligned, log a warning, and return NULL if true.
    - Verify `data->magic` matches `FD_GROOVE_DATA_MAGIC`, log a warning, and return NULL if not.
    - Check if `volume0` is NULL or misaligned, log a warning, and return NULL if true.
    - Attempt to join the volume pool using `fd_groove_volume_pool_join`, return NULL if it fails.
    - Copy `active_slot`, `inactive_stack`, and `cgroup_hint` from `data` to `join`.
- **Output**: Returns a pointer to the joined `fd_groove_data_t` structure or NULL if any checks fail.
- **Functions Called**:
    - [`fd_groove_data_align`](<fd_groove_data.h.md#fd_groove_data_align>)


---
### fd\_groove\_data\_leave<!-- {{#callable:fd_groove_data_leave}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L222>)

Validates and leaves a `fd_groove_data_t` join structure, ensuring proper cleanup of resources.
- **Inputs**:
    - `join`: A pointer to a `fd_groove_data_t` structure that represents the join to be left.
- **Logic and Control Flow**:
    - Checks if the `join` pointer is NULL and logs a warning if it is, then returns NULL.
    - Attempts to leave the volume pool associated with the `join` using `fd_groove_volume_pool_leave`.
    - Logs a warning and returns NULL if leaving the volume pool fails, although this is currently not possible.
    - Returns the `join` pointer if all operations succeed.
- **Output**: Returns the `join` pointer if successful, or NULL if an error occurs.


---
### fd\_groove\_data\_delete<!-- {{#callable:fd_groove_data_delete}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L237>)

Validates and deletes a shared memory data structure if it meets specific alignment and magic number criteria.
- **Inputs**:
    - ``shdata``: A pointer to the shared memory data structure to be deleted.
- **Logic and Control Flow**:
    - Cast `shdata` to a `fd_groove_data_shmem_t` pointer named `data`.
    - Check if `data` is NULL; if so, log a warning and return NULL.
    - Check if `data` is aligned according to `fd_groove_data_align()`; if not, log a warning and return NULL.
    - Check if `data->magic` equals `FD_GROOVE_DATA_MAGIC`; if not, log a warning and return NULL.
    - Use `FD_COMPILER_MFENCE()` to ensure memory operations are completed before and after setting `data->magic` to 0.
    - Return the original `shdata` pointer.
- **Output**: Returns the original `shdata` pointer if the deletion is successful, otherwise returns NULL.
- **Functions Called**:
    - [`fd_groove_data_align`](<fd_groove_data.h.md#fd_groove_data_align>)


---
### fd\_groove\_data\_private\_alloc\_obj<!-- {{#callable:fd_groove_data_private_alloc_obj}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L268>)

Allocates an object from a specified size class superblock, handling concurrency and memory management.
- **Inputs**:
    - ``data``: A pointer to `fd_groove_data_t`, which contains the data structure for groove data management.
    - ``obj_szc``: An unsigned long representing the size class of the object to allocate.
    - ``_obj_off``: A pointer to an unsigned long where the function will store the offset of the allocated object.
    - ``_obj_idx``: A pointer to an unsigned long where the function will store the index of the allocated object.
- **Logic and Control Flow**:
    - Retrieve the volume pointer `_volume0` from the data structure.
    - Determine the object count, footprint, concurrency group mask, and parent size class from the configuration for the given size class `obj_szc`.
    - Calculate the concurrency group using the `cgroup_hint` and `cgroup_mask`.
    - Attempt to access the active superblock for the concurrency group and size class, using a test-and-test-and-set approach to avoid unnecessary atomic operations.
    - If no active superblock is available, attempt to pop an inactive superblock from the stack.
    - If no inactive superblock is available, create a new superblock by acquiring a volume or a parent size class object, depending on the configuration.
    - Initialize the superblock header and mark all objects in the superblock as free.
    - Allocate a free object from the superblock, updating the free object bit field atomically.
    - If the superblock still has free objects, return it to circulation as the active superblock; otherwise, it will be returned to circulation when a block is freed.
    - Calculate the object index and store the offset and index in the provided pointers.
    - Return success status.
- **Output**: Returns an integer status code, `FD_GROOVE_SUCCESS` on success, or an error code if an error occurs during allocation.
- **Functions Called**:
    - [`fd_groove_data_volume0`](<fd_groove_data.h.md#fd_groove_data_volume0>)
    - [`fd_groove_data_volume1`](<fd_groove_data.h.md#fd_groove_data_volume1>)
    - [`fd_groove_data_private_active_displace`](<#fd_groove_data_private_active_displace>)
    - [`fd_groove_data_private_inactive_pop`](<#fd_groove_data_private_inactive_pop>)
    - [`fd_groove_data_hdr_t::fd_groove_data_hdr`](<fd_groove_data.h.md#fd_groove_data_hdr_tfd_groove_data_hdr>)
    - [`fd_groove_data_hdr_type`](<fd_groove_data.h.md#fd_groove_data_hdr_type>)
    - [`fd_groove_data_hdr_szc`](<fd_groove_data.h.md#fd_groove_data_hdr_szc>)
    - [`fd_groove_data_private_inactive_push`](<#fd_groove_data_private_inactive_push>)


---
### fd\_groove\_data\_alloc<!-- {{#callable:fd_groove_data_alloc}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L461>)

Allocates memory from a specified data structure with alignment and size constraints, returning a pointer to the allocated memory or NULL on error.
- **Inputs**:
    - ``data``: A pointer to an `fd_groove_data_t` structure from which memory is allocated.
    - ``align``: The desired alignment for the allocated memory, defaulting to `FD_GROOVE_DATA_ALLOC_ALIGN_DEFAULT` if zero.
    - ``sz``: The size of the memory to allocate.
    - ``tag``: A tag value associated with the allocation.
    - ``_err``: A pointer to an integer where the function stores the error code, or uses a local variable if NULL.
- **Logic and Control Flow**:
    - Initialize a local error variable if `_err` is NULL.
    - Check if `data` is NULL; if so, log a warning, set the error code to `FD_GROOVE_ERR_INVAL`, and return NULL.
    - Set `align` to `FD_GROOVE_DATA_ALLOC_ALIGN_DEFAULT` if it is zero, and validate that it is a power of two and within the maximum allowed alignment.
    - Calculate `off_obj` and `footprint` based on alignment and size, and validate that `footprint` is within the maximum allowed footprint.
    - Determine the size class `obj_szc` for the allocation footprint.
    - Attempt to allocate an object from the data structure using [`fd_groove_data_private_alloc_obj`](<#fd_groove_data_private_alloc_obj>); if it fails, set the error code and return NULL.
    - Calculate the header address for the allocated object and initialize it with allocation details.
    - Set the error code to `FD_GROOVE_SUCCESS` and return a pointer to the allocated memory.
- **Output**: Returns a pointer to the allocated memory if successful, or NULL if an error occurs.
- **Functions Called**:
    - [`fd_groove_data_szc`](<fd_groove_data.h.md#fd_groove_data_szc>)
    - [`fd_groove_data_private_alloc_obj`](<#fd_groove_data_private_alloc_obj>)
    - [`fd_groove_data_hdr_t::fd_groove_data_hdr`](<fd_groove_data.h.md#fd_groove_data_hdr_tfd_groove_data_hdr>)


---
### fd\_groove\_data\_private\_free<!-- {{#callable:fd_groove_data_private_free}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L517>)

Frees a previously allocated object in the groove data structure, ensuring it is marked as invalid and potentially returning its superblock to circulation.
- **Inputs**:
    - `data`: A pointer to the `fd_groove_data_t` structure, representing the groove data context.
    - `_obj`: A pointer to the object to be freed.
    - `exp_type`: The expected type of the object, used for validation in paranoid mode.
- **Logic and Control Flow**:
    - Check if `data` or `_obj` is NULL and return `FD_GROOVE_ERR_INVAL` if true.
    - Retrieve the object header using `fd_groove_data_object_hdr` and the volume base using [`fd_groove_data_volume0`](<fd_groove_data.h.md#fd_groove_data_volume0>).
    - In paranoid mode, validate the object's address and alignment, and check if the object type and size class are as expected.
    - Determine the object's size class and count of objects in the size class.
    - In paranoid mode, validate the object's alignment, size, and footprint against the expected values.
    - Mark the object as invalid by setting its type to an invalid value and update the free objects bit field.
    - If the superblock was full before freeing, return it to circulation by updating the active slot or pushing it onto the inactive stack.
    - If the superblock becomes completely empty after freeing, attempt to free it or its parent volume, depending on its size class.
- **Output**: Returns `FD_GROOVE_SUCCESS` on successful free, or an error code such as `FD_GROOVE_ERR_INVAL` or `FD_GROOVE_ERR_CORRUPT` if validation fails.
- **Functions Called**:
    - [`fd_groove_data_volume0`](<fd_groove_data.h.md#fd_groove_data_volume0>)
    - [`fd_groove_data_volume1`](<fd_groove_data.h.md#fd_groove_data_volume1>)
    - [`fd_groove_data_hdr_type`](<fd_groove_data.h.md#fd_groove_data_hdr_type>)
    - [`fd_groove_data_hdr_idx`](<fd_groove_data.h.md#fd_groove_data_hdr_idx>)
    - [`fd_groove_data_hdr_szc`](<fd_groove_data.h.md#fd_groove_data_hdr_szc>)
    - [`fd_groove_data_hdr_align`](<fd_groove_data.h.md#fd_groove_data_hdr_align>)
    - [`fd_groove_data_hdr_sz`](<fd_groove_data.h.md#fd_groove_data_hdr_sz>)
    - [`fd_groove_data_cgroup_hint`](<fd_groove_data.h.md#fd_groove_data_cgroup_hint>)
    - [`fd_groove_data_private_active_displace`](<#fd_groove_data_private_active_displace>)
    - [`fd_groove_data_private_inactive_push`](<#fd_groove_data_private_inactive_push>)
    - [`fd_groove_data_private_inactive_pop`](<#fd_groove_data_private_inactive_pop>)
    - [`fd_groove_data_private_free`](<#fd_groove_data_private_free>)
    - [`fd_groove_strerror`](<fd_groove_base.c.md#fd_groove_strerror>)


---
### fd\_groove\_data\_private\_verify\_superblock<!-- {{#callable:fd_groove_data_private_verify_superblock}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L789>)

Verifies that a specified memory location contains a valid superblock with correct headers and object configurations.
- **Inputs**:
    - `superblock_off`: The offset of the superblock relative to `_volume0`.
    - `exp_szc`: The expected size class of the superblock.
    - `in_circulation`: A flag indicating if the superblock is in circulation, meaning it contains at least one free object.
    - `verify_descendents`: A flag indicating whether to verify the descendents of the superblock.
    - `_volume0`: A pointer to the start of the volume in memory.
    - `_volume1`: A pointer to the end of the volume in memory.
- **Logic and Control Flow**:
    - Calculate the address of the superblock header using `superblock_off` and `_volume0`.
    - Verify that the superblock header is within the bounds of `_volume0` and `_volume1` and is properly aligned.
    - Check that the superblock header type is `FD_GROOVE_DATA_HDR_TYPE_SUPERBLOCK` and its size class matches `exp_szc`.
    - Retrieve object count, footprint, and parent size class from the size class configuration.
    - Verify that the parent object index is within the valid range and that the header alignment and size are correct.
    - Check the validity of the free object bit field and ensure there is at least one free object if `in_circulation` is true.
    - Iterate over remaining objects, verifying each object's header type, index, size class, alignment, and footprint.
    - If `verify_descendents` is true and the object type is a superblock, recursively verify its descendents.
    - Return `FD_GROOVE_SUCCESS` if all checks pass.
- **Output**: Returns `FD_GROOVE_SUCCESS` if the superblock is valid, otherwise returns `FD_GROOVE_ERR_CORRUPT` if any verification fails.
- **Functions Called**:
    - [`fd_groove_data_hdr_type`](<fd_groove_data.h.md#fd_groove_data_hdr_type>)
    - [`fd_groove_data_hdr_szc`](<fd_groove_data.h.md#fd_groove_data_hdr_szc>)
    - [`fd_groove_data_hdr_idx`](<fd_groove_data.h.md#fd_groove_data_hdr_idx>)
    - [`fd_groove_data_hdr_align`](<fd_groove_data.h.md#fd_groove_data_hdr_align>)
    - [`fd_groove_data_hdr_sz`](<fd_groove_data.h.md#fd_groove_data_hdr_sz>)


---
### fd\_groove\_data\_verify<!-- {{#callable:fd_groove_data_verify}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L880>)

Verifies the integrity and alignment of `fd_groove_data_t` structure and its associated components.
- **Inputs**:
    - `data`: A pointer to a constant `fd_groove_data_t` structure to verify.
- **Logic and Control Flow**:
    - Check if `data` is non-null and properly aligned.
    - Retrieve and verify the `volume_pool`, `active_slot`, and `inactive_stack` from `data`.
    - Verify the `volume_pool` using `fd_groove_volume_pool_verify`.
    - Retrieve shared memory pool and volume information from `volume_pool`.
    - Check alignment and range of volumes in the pool.
    - Iterate over volumes to verify their magic number and index.
    - Verify shared memory data alignment and consistency with `data`.
    - Iterate over sizeclass configurations to verify object count, footprint, and alignment.
    - Verify all active superblocks for each sizeclass and concurrency group.
    - Verify all inactive superblocks for each sizeclass, ensuring no cycles.
- **Output**: Returns `FD_GROOVE_SUCCESS` if all verifications pass, otherwise returns `FD_GROOVE_ERR_CORRUPT` on failure.
- **Functions Called**:
    - [`fd_groove_data_shdata_const`](<fd_groove_data.h.md#fd_groove_data_shdata_const>)
    - [`fd_groove_data_align`](<fd_groove_data.h.md#fd_groove_data_align>)
    - [`fd_groove_data_private_verify_superblock`](<#fd_groove_data_private_verify_superblock>)
    - [`fd_groove_data_hdr_szc`](<fd_groove_data.h.md#fd_groove_data_hdr_szc>)
    - [`fd_groove_data_hdr_info`](<fd_groove_data.h.md#fd_groove_data_hdr_info>)


---
### fd\_groove\_data\_volume\_verify<!-- {{#callable:fd_groove_data_volume_verify}} -->
[View Source →](<../../../../src/groove/fd_groove_data.c#L982>)

Verifies the integrity and validity of a specified volume within a groove data structure.
- **Inputs**:
    - `data`: A pointer to a constant `fd_groove_data_t` structure representing the groove data.
    - `_volume`: A pointer to a constant `fd_groove_volume_t` structure representing the volume to verify.
- **Logic and Control Flow**:
    - Check if `data` is not NULL using the `TEST` macro.
    - Retrieve the base and end pointers of the volume range using [`fd_groove_data_volume0_const`](<fd_groove_data.h.md#fd_groove_data_volume0_const>) and [`fd_groove_data_volume1_const`](<fd_groove_data.h.md#fd_groove_data_volume1_const>).
    - Calculate the offset of `_volume` from `_volume0`.
    - Verify that `_volume` is within the valid range and aligned to `FD_GROOVE_VOLUME_FOOTPRINT`.
    - Check if the `magic` field of `_volume` is either `FD_GROOVE_VOLUME_MAGIC` or its bitwise complement.
    - Ensure the `idx` field of `_volume` corresponds to its offset.
    - Verify that `info_sz` does not exceed `FD_GROOVE_VOLUME_INFO_MAX`.
    - If `magic` equals `FD_GROOVE_VOLUME_MAGIC`, verify the superblock at the calculated offset using [`fd_groove_data_private_verify_superblock`](<#fd_groove_data_private_verify_superblock>).
- **Output**: Returns `FD_GROOVE_SUCCESS` if the volume is valid, otherwise returns `FD_GROOVE_ERR_CORRUPT` if any test fails.
- **Functions Called**:
    - [`fd_groove_data_volume0_const`](<fd_groove_data.h.md#fd_groove_data_volume0_const>)
    - [`fd_groove_data_volume1_const`](<fd_groove_data.h.md#fd_groove_data_volume1_const>)
    - [`fd_groove_data_private_verify_superblock`](<#fd_groove_data_private_verify_superblock>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)