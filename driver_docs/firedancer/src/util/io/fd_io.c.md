<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

POSIX-style file I/O operations, buffered I/O, memory-mapped I/O, and error/signal string conversion.

# Purpose
The code provides a set of functions for file descriptor-based input and output operations, primarily targeting POSIX-compliant systems. It includes functions for reading and writing data ([`fd_io_read`](<#fd_io_read>), [`fd_io_write`](<#fd_io_write>)), managing file sizes ([`fd_io_sz`](<#fd_io_sz>), [`fd_io_truncate`](<#fd_io_truncate>)), and handling file offsets ([`fd_io_seek`](<#fd_io_seek>)). The code also supports buffered operations for reading and writing ([`fd_io_buffered_read`](<#fd_io_buffered_read>), [`fd_io_buffered_write`](<#fd_io_buffered_write>)) and includes memory-mapped I/O initialization and finalization functions ([`fd_io_mmio_init`](<#fd_io_mmio_init>), [`fd_io_mmio_fini`](<#fd_io_mmio_fini>)). Additionally, it provides utility functions to convert error codes and signals to human-readable strings ([`fd_io_strerror`](<#fd_io_strerror>), [`fd_io_strsignal`](<#fd_io_strsignal>)).

The code is designed to be included in other C programs, as indicated by the inclusion of a header file (`fd_io.h`) and the use of conditional compilation to handle different I/O styles. It defines a public API for file descriptor operations, with error handling and optimization for both blocking and non-blocking I/O. The code also includes mechanisms to handle platform-specific differences, such as the need to define `FD_IO_STYLE` for non-hosted environments. The functions are designed to provide robust error handling and are optimized for performance, particularly in scenarios involving small or large data transfers.
# Imports and Dependencies

---
- `fd_io.h`
- `errno.h`
- `signal.h`
- `unistd.h`
- `sys/stat.h`
- `sys/mman.h`


# Functions

---
### fd\_io\_read<!-- {{#callable:fd_io_read}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L22>)

Reads data from a file descriptor into a buffer, ensuring a minimum number of bytes are read, and handles non-blocking and error conditions.
- **Inputs**:
    - `fd`: The file descriptor from which to read data.
    - `_dst`: A pointer to the destination buffer where the data will be stored.
    - `dst_min`: The minimum number of bytes to read before returning.
    - `dst_max`: The maximum number of bytes that can be read into the buffer.
    - `_dst_sz`: A pointer to a variable where the function will store the actual number of bytes read.
- **Logic and Control Flow**:
    - Check if `dst_max` is zero; if so, set `*_dst_sz` to zero and return 0.
    - Cast `_dst` to a `uchar` pointer `dst` and initialize `dst_sz` to zero.
    - Enter a loop to read data until `dst_sz` is at least `dst_min`.
    - Use `read` to attempt to read data from `fd` into `dst` with a size limited by `dst_max-dst_sz` and `LONG_MAX`.
    - If `read` returns a value not in the range [1, `dst_max-dst_sz`], handle special cases:
    - If `ssz` is zero, set `*_dst_sz` to `dst_sz` and return -1 for EOF.
    - If `ssz` is -1 and `errno` is `EAGAIN` or `EWOULDBLOCK`, and `dst_sz` is less than `dst_min`, continue the loop.
    - If `ssz` is -1 and `errno` is not set, set `errno` to `EPROTO` and return the error.
    - If `rsz` is valid, add it to `dst_sz`.
    - Continue the loop until `dst_sz` is at least `dst_min`.
    - Set `*_dst_sz` to `dst_sz` and return 0.
- **Output**: Returns 0 on success, -1 on EOF, or an error code if an error occurs. The actual number of bytes read is stored in `*_dst_sz`.


---
### fd\_io\_write<!-- {{#callable:fd_io_write}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L90>)

Writes data from a source buffer to a file descriptor, ensuring a minimum number of bytes are written.
- **Inputs**:
    - `fd`: The file descriptor to which data will be written.
    - `_src`: A pointer to the source buffer containing the data to write.
    - `src_min`: The minimum number of bytes that must be written.
    - `src_max`: The maximum number of bytes that can be written.
    - `_src_sz`: A pointer to a variable where the function will store the number of bytes actually written.
- **Logic and Control Flow**:
    - Check if `src_max` is zero; if so, set `*_src_sz` to zero and return 0.
    - Cast `_src` to a `uchar` pointer `src`.
    - Initialize `src_sz` to zero to track the number of bytes written.
    - Enter a loop that continues until `src_sz` is at least `src_min`.
    - In each iteration, call `write` to attempt writing data from `src + src_sz` to the file descriptor `fd`.
    - Calculate `wsz` as the number of bytes successfully written.
    - If `ssz` is not positive or `wsz` exceeds the remaining bytes to write, handle errors:
    - - If `errno` is `EWOULDBLOCK`, treat it as `EAGAIN`.
    - - If fewer than `src_min` bytes have been written and `errno` is `EAGAIN`, continue the loop.
    - - If no error is set, set `err` to `EPROTO`.
    - Set `*_src_sz` to zero and return the error code.
    - If the write is successful, add `wsz` to `src_sz`.
    - After the loop, set `*_src_sz` to `src_sz` and return 0.
- **Output**: Returns 0 on success, or an error code if the write operation fails. The number of bytes written is stored in `*_src_sz`.


---
### fd\_io\_sz<!-- {{#callable:fd_io_sz}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L150>)

Retrieves the size of a file associated with a given file descriptor and stores it in a provided variable.
- **Inputs**:
    - `fd`: An integer representing the file descriptor of the file whose size is to be determined.
    - `_sz`: A pointer to an unsigned long where the function will store the size of the file.
- **Logic and Control Flow**:
    - Calls `fstat` to get the file status information for the file descriptor `fd` and stores it in a `stat` structure.
    - Retrieves the file size from `stat->st_size` and checks if the `fstat` call was successful and if the size is within valid bounds (0 to `LONG_MAX`).
    - If the conditions are not met, sets `*_sz` to 0, retrieves the error number from `errno`, defaults to `EPROTO` if `errno` is not set, and returns the error number.
    - If the conditions are met, casts the file size to `ulong`, stores it in `*_sz`, and returns 0.
- **Output**: Returns 0 on success, or an error code if the file size could not be determined or is out of bounds.


---
### fd\_io\_truncate<!-- {{#callable:fd_io_truncate}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L168>)

Truncates a file to a specified size using a file descriptor.
- **Inputs**:
    - `fd`: An integer representing the file descriptor of the file to truncate.
    - `sz`: An unsigned long integer representing the new size to truncate the file to.
- **Logic and Control Flow**:
    - Check if `sz` is greater than `LONG_MAX` or if `sz` cannot be safely cast to `off_t`; if so, return `EINVAL`.
    - Attempt to truncate the file using `ftruncate` with the file descriptor `fd` and size `sz` cast to `off_t`.
    - If `ftruncate` fails, retrieve the error code from `errno`; if `errno` is not set, use `EPROTO` as the error code.
    - Return the error code if `ftruncate` fails, otherwise return 0 indicating success.
- **Output**: Returns 0 on success, or an error code if the operation fails.


---
### fd\_io\_seek<!-- {{#callable:fd_io_seek}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L180>)

Adjusts the file offset for a given file descriptor based on a relative offset and a specified seek type.
- **Inputs**:
    - `fd`: The file descriptor for which the file offset is to be adjusted.
    - `rel_off`: The relative offset to apply to the file position.
    - `type`: The type of seek operation, which determines the reference point for the offset (0 for SEEK_SET, 1 for SEEK_CUR, 2 for SEEK_END).
    - `_idx`: A pointer to an unsigned long where the resulting file offset will be stored.
- **Logic and Control Flow**:
    - Define a static array `whence` with values corresponding to `SEEK_SET`, `SEEK_CUR`, and `SEEK_END`.
    - Check if `type` is within the valid range [0, 3] and if `rel_off` can be safely cast to `off_t`. If not, set `*_idx` to 0 and return `EINVAL`.
    - Use `lseek` to adjust the file offset based on `fd`, `rel_off`, and the appropriate `whence` value.
    - Check if the resulting offset `idx` is valid (non-negative and within the range of `ulong`).
    - If `idx` is invalid, set `*_idx` to 0, determine the error code (default to `EPROTO` if `errno` is not set), and return the error code.
    - If `idx` is valid, set `*_idx` to the new offset and return 0.
- **Output**: Returns 0 on success, or an error code if the operation fails. The resulting file offset is stored in the location pointed to by `_idx`.


---
### fd\_io\_buffered\_read<!-- {{#callable:fd_io_buffered_read}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L205>)

Reads data from a file descriptor into a destination buffer, using an intermediate buffer to optimize for small reads.
- **Inputs**:
    - `fd`: The file descriptor from which to read data.
    - `_dst`: A pointer to the destination buffer where the read data will be stored.
    - `dst_sz`: The size of the destination buffer.
    - `_rbuf`: A pointer to the read buffer used for intermediate storage.
    - `rbuf_sz`: The size of the read buffer.
    - `_rbuf_lo`: A pointer to the current offset in the read buffer.
    - `_rbuf_ready`: A pointer to the number of bytes currently available in the read buffer.
- **Logic and Control Flow**:
    - If `dst_sz` is zero, return immediately as there is nothing to read.
    - Convert `_dst` and `_rbuf` to `uchar` pointers and dereference `_rbuf_lo` and `_rbuf_ready` to local variables `rbuf_lo` and `rbuf_ready`.
    - If `rbuf_ready` is non-zero, copy the minimum of `dst_sz` and `rbuf_ready` bytes from `rbuf` to `dst`, update pointers and sizes, and return if the read is complete.
    - If `dst_sz` is greater than or equal to `rbuf_sz`, read directly into `dst` in multiples of `rbuf_sz`, update pointers and sizes, and return if the read is complete.
    - Otherwise, read data into `rbuf` and copy the required bytes to `dst`, updating `rbuf_lo` and `rbuf_ready`.
- **Output**: Returns 0 on success or an error code if the read operation fails.
- **Functions Called**:
    - [`fd_io_read`](<#fd_io_read>)


---
### fd\_io\_buffered\_skip<!-- {{#callable:fd_io_buffered_skip}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L305>)

Skips a specified number of bytes in a file descriptor, using buffered data if available, and falls back to seeking or reading if necessary.
- **Inputs**:
    - `fd`: The file descriptor to operate on.
    - `skip_sz`: The number of bytes to skip.
    - `rbuf`: A buffer used for reading data.
    - `rbuf_sz`: The size of the buffer `rbuf`.
    - `_rbuf_lo`: A pointer to the current position in the buffer `rbuf`.
    - `_rbuf_ready`: A pointer to the number of bytes available in the buffer `rbuf`.
- **Logic and Control Flow**:
    - Check if `skip_sz` is greater than the available buffered bytes (`rbuf_ready`).
    - If `skip_sz` is greater, reduce `skip_sz` by `rbuf_ready` and attempt to seek the file descriptor using `lseek`.
    - If `lseek` fails with `ESPIPE`, indicating the stream is not seekable, perform actual reads to skip the bytes.
    - If `lseek` or reads are successful, reset `_rbuf_lo` and `_rbuf_ready` to 0 and return 0.
    - If `skip_sz` is less than or equal to `rbuf_ready`, adjust `_rbuf_lo` and `_rbuf_ready` to reflect the skipped bytes and return 0.
- **Output**: Returns 0 on success or an error code if an error occurs during seeking or reading.
- **Functions Called**:
    - [`fd_io_read`](<#fd_io_read>)


---
### fd\_io\_buffered\_write<!-- {{#callable:fd_io_buffered_write}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L378>)

Writes data to a file descriptor using a buffer to optimize for small writes.
- **Inputs**:
    - `fd`: The file descriptor to which data is written.
    - `_src`: A pointer to the source data to write.
    - `src_sz`: The size of the source data in bytes.
    - `_wbuf`: A pointer to the buffer used for writing.
    - `wbuf_sz`: The size of the buffer in bytes.
    - `_wbuf_used`: A pointer to the number of bytes currently used in the buffer.
- **Logic and Control Flow**:
    - If `src_sz` is zero, return 0 as there is nothing to write.
    - Cast `_src` to `uchar const *` and `_wbuf` to `uchar *`.
    - Initialize `wbuf_used` with the value pointed by `_wbuf_used`.
    - If `wbuf_used` is non-zero, calculate `cpy_sz` as the minimum of available buffer space and `src_sz`.
    - Copy `cpy_sz` bytes from `src` to `wbuf` and update `src`, `src_sz`, and `wbuf_used`.
    - If `wbuf_used` equals or exceeds `wbuf_sz`, flush the buffer by writing it to `fd` and reset `wbuf_used`.
    - If `src_sz` is zero after copying, update `_wbuf_used` and return 0.
    - If `src_sz` is greater than or equal to `wbuf_sz`, write the largest multiple of `wbuf_sz` directly from `src` to `fd`.
    - If `src_sz` is zero after the direct write, update `_wbuf_used` and return 0.
    - Copy remaining `src_sz` bytes to `wbuf`, update `_wbuf_used`, and return 0.
- **Output**: Returns 0 on success or an error code if a write operation fails.
- **Functions Called**:
    - [`fd_io_write`](<#fd_io_write>)


---
### fd\_io\_mmio\_init<!-- {{#callable:fd_io_mmio_init}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L481>)

Maps a file into memory for I/O operations based on the specified mode.
- **Inputs**:
    - `fd`: The file descriptor of the file to map.
    - `mode`: The mode for memory mapping, either `FD_IO_MMIO_MODE_READ_ONLY` or `FD_IO_MMIO_MODE_READ_WRITE`.
    - `_mmio`: A pointer to store the address of the mapped memory.
    - `_mmio_sz`: A pointer to store the size of the mapped memory.
- **Logic and Control Flow**:
    - Check if `mode` is valid (either `FD_IO_MMIO_MODE_READ_ONLY` or `FD_IO_MMIO_MODE_READ_WRITE`).
    - If `mode` is invalid, set `_mmio` to `NULL`, `_mmio_sz` to `0UL`, and return `EINVAL`.
    - Determine the file size using [`fd_io_sz`](<#fd_io_sz>).
    - If the file size is zero or an error occurs, set `_mmio` to `NULL`, `_mmio_sz` to `0UL`, and return the error code.
    - Map the file into memory using `mmap` with the appropriate protection based on `mode`.
    - If `mmap` fails, set `_mmio` to `NULL`, `_mmio_sz` to `0UL`, and return the error code.
    - If successful, set `_mmio` to the mapped memory address and `_mmio_sz` to the file size.
- **Output**: Returns `0` on success, or an error code if an error occurs during the process.
- **Functions Called**:
    - [`fd_io_sz`](<#fd_io_sz>)


---
### fd\_io\_mmio\_fini<!-- {{#callable:fd_io_mmio_fini}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L545>)

Unmaps a memory-mapped file from the process's address space if it is non-zero in size.
- **Inputs**:
    - ``mmio``: A pointer to the memory-mapped file region to unmap.
    - ``mmio_sz``: The size of the memory-mapped file region to unmap.
- **Logic and Control Flow**:
    - Checks if `mmio` is NULL or `mmio_sz` is zero; if either is true, the function returns immediately without doing anything.
    - If both `mmio` and `mmio_sz` are valid, calls `munmap` to unmap the memory region specified by `mmio` and `mmio_sz`.
- **Output**: No output is returned as the function is of type `void`.


---
### fd\_io\_strerror<!-- {{#callable:fd_io_strerror}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L558>)

Maps an error code to its corresponding error message string.
- **Inputs**:
    - `err`: An integer representing the error code to be translated into a string message.
- **Logic and Control Flow**:
    - If `err` is less than 0, return "end-of-file".
    - If `err` is `EWOULDBLOCK`, set `err` to `EAGAIN`.
    - If `err` is `EOPNOTSUPP`, set `err` to `ENOTSUP`.
    - Use a `switch` statement to match `err` against known error codes and return the corresponding error message string.
    - If `err` does not match any known error code, return "unknown".
- **Output**: A constant character pointer to the error message string corresponding to the given error code.


---
### fd\_io\_strsignal<!-- {{#callable:fd_io_strsignal}} -->
[View Source →](<../../../../../src/util/io/fd_io.c#L652>)

Maps a signal number to its corresponding string description.
- **Inputs**:
    - `sig`: An integer representing the signal number to be converted to a string description.
- **Logic and Control Flow**:
    - Uses a `switch` statement to match the input signal number `sig` with predefined signal constants.
    - Returns a string description for the matched signal number, such as "SIGHUP-Hangup" for `SIGHUP`.
    - Handles platform-specific signals like `SIGSTKFLT`, `SIGEMT`, `SIGWINCH`, `SIGPOLL`, and `SIGPWR` using conditional compilation directives.
    - Returns "unknown" if the signal number does not match any predefined signal constants.
- **Output**: A constant character pointer to the string description of the signal.



---
Made with ❤️ by [Driver](https://www.driver.ai/)