<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for generating random floating-point numbers with various distributions, including robust, exponential, and normal, using the ziggurat algorithm.

# Purpose
The code provides a set of functions for generating random floating-point numbers with specific statistical distributions. It includes functions to generate random numbers following uniform, exponential, and normal distributions. The functions [`fd_rng_float_robust`](<#fd_rng_float_robust>), [`fd_rng_float_exp`](<#fd_rng_float_exp>), and [`fd_rng_float_norm`](<#fd_rng_float_norm>) are designed to work with single-precision floating-point numbers, while their double-precision counterparts are provided for systems that support double precision, as indicated by the `FD_HAS_DOUBLE` preprocessor directive.

The code uses a technique known as the Ziggurat algorithm to efficiently generate normally distributed random numbers. This method involves precomputed tables (`zig_x` and `zig_y`) that define the levels of the Ziggurat, allowing for quick acceptance of random numbers in most cases. The functions rely on an external random number generator, represented by the `fd_rng_t` type, to produce the base random values. The code also includes comments and preprocessor directives to handle platform-specific considerations and potential optimizations, such as reducing dependencies on the math library for cross-platform consistency.
# Imports and Dependencies

---
- `fd_rng.h`
- `math.h`


# Functions

---
### fd\_rng\_float\_robust<!-- {{#callable:fd_rng_float_robust}} -->
[View Source →](<../../../../../src/util/rng/fd_rng.c#L4>)

Generates a random float in the range [1,2] with rounding to the nearest even representable float, then applies an exponent to adjust the result.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is used to generate random numbers.
- **Logic and Control Flow**:
    - Call [`fd_rng_uint`](<fd_rng.h.md#fd_rng_uint>) to generate a 32-bit uniform random number and store it in `u`.
    - Calculate `m` as a trapezoidal random number in the range [0, 2^23] using bitwise operations on `u`.
    - Compute `f` as 1 plus `m` multiplied by `FLT_EPSILON`, ensuring it is an exact float in the range [1,2].
    - Call [`fd_rng_coin_tosses`](<fd_rng.h.md#fd_rng_coin_tosses>) to determine the exponent adjustment and apply it using `ldexpf` to compute the final float value.
    - Return the adjusted float value.
- **Output**: A float value in the range [1,2] with applied exponent adjustment.
- **Functions Called**:
    - [`fd_rng_uint`](<fd_rng.h.md#fd_rng_uint>)
    - [`fd_rng_coin_tosses`](<fd_rng.h.md#fd_rng_coin_tosses>)


---
### fd\_rng\_float\_exp<!-- {{#callable:fd_rng_float_exp}} -->
[View Source →](<../../../../../src/util/rng/fd_rng.c#L70>)

Generates a random float with an exponential distribution using the ziggurat algorithm.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is the random number generator state.
- **Logic and Control Flow**:
    - Enter an infinite loop to repeatedly attempt to generate a valid random number.
    - Generate a 7-bit ziggurat level and a 24-bit trapezoidal random number using [`fd_rng_uint`](<fd_rng.h.md#fd_rng_uint>).
    - Calculate a uniform random number `x` within the current ziggurat level using the trapezoidal random number.
    - Check if `x` is less than or equal to the level above; if true, accept `x` and break the loop.
    - If not, check if the level is less than the maximum ziggurat level; if true, generate a random `y` and check if it is less than `expf(-x)`; if true, accept `x` and break the loop.
    - If the level is the maximum, calculate `x` for the exponential tail using `logf` and break the loop.
- **Output**: Returns a float representing a random number with an exponential distribution.
- **Functions Called**:
    - [`fd_rng_uint`](<fd_rng.h.md#fd_rng_uint>)
    - [`fd_rng_float_c0`](<fd_rng.h.md#fd_rng_float_c0>)


---
### fd\_rng\_float\_norm<!-- {{#callable:fd_rng_float_norm}} -->
[View Source →](<../../../../../src/util/rng/fd_rng.c#L128>)

Generates a normally distributed random float using the ziggurat algorithm.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is the random number generator state.
- **Logic and Control Flow**:
    - Initialize static arrays `zig_x` and `zig_y` with precomputed values for the ziggurat algorithm.
    - Set constants `zig_level_cnt`, `zig_r`, `zig_rcp_r`, `zig_half_r`, and `zig_tail` for the ziggurat algorithm.
    - Enter an infinite loop to generate a random float.
    - Generate a 32-bit random number `u` using [`fd_rng_uint`](<fd_rng.h.md#fd_rng_uint>) and derive `s`, `l`, and `m` from `u`.
    - Calculate `x` as a uniform random number within the current ziggurat level using `zig_x` and `m`.
    - If `x` is less than or equal to `zig_x[l]`, accept `x` and break the loop.
    - If not, generate a random float `y` using [`fd_rng_float_c`](<fd_rng.h.md#fd_rng_float_c>).
    - If `l` is less than `zig_level_cnt - 1`, calculate `y` as a linear interpolation between `zig_y[l]` and `zig_y[l+1]`.
    - If `l` is equal to `zig_level_cnt - 1`, calculate `x` and `y` for the exponential tail using `zig_tail`, `zig_rcp_r`, and `zig_r`.
    - If `y` is less than `expf(-0.5f * x * x)`, accept `x` and break the loop.
    - If not, repeat the loop to try again.
    - Return `x` with a random sign determined by `s` using `fd_float_if`.
- **Output**: A normally distributed random float value.
- **Functions Called**:
    - [`fd_rng_uint`](<fd_rng.h.md#fd_rng_uint>)
    - [`fd_rng_float_c`](<fd_rng.h.md#fd_rng_float_c>)


---
### fd\_rng\_double\_robust<!-- {{#callable:fd_rng_double_robust}} -->
[View Source →](<../../../../../src/util/rng/fd_rng.c#L293>)

Generates a double-precision floating-point number in the range [1, 2) with a robust random distribution.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which represents the random number generator state.
- **Logic and Control Flow**:
    - Call [`fd_rng_ulong`](<fd_rng.h.md#fd_rng_ulong>) with `rng` to generate a 64-bit unsigned random number `u`.
    - Calculate `m` as the sum of the right-shifted `u` by 12 bits and the least significant bit of `u`.
    - Compute `d` as 1 plus `m` multiplied by `DBL_EPSILON`, which is the smallest difference between two representable double-precision numbers.
    - Call [`fd_rng_coin_tosses`](<fd_rng.h.md#fd_rng_coin_tosses>) with `rng` to determine the number of times to shift `d` right, effectively scaling it down.
    - Return the result of `ldexp` applied to `d` and the negated result of [`fd_rng_coin_tosses`](<fd_rng.h.md#fd_rng_coin_tosses>), which scales `d` by a power of two.
- **Output**: A double-precision floating-point number in the range [1, 2) with a robust random distribution.
- **Functions Called**:
    - [`fd_rng_ulong`](<fd_rng.h.md#fd_rng_ulong>)
    - [`fd_rng_coin_tosses`](<fd_rng.h.md#fd_rng_coin_tosses>)


---
### fd\_rng\_double\_exp<!-- {{#callable:fd_rng_double_exp}} -->
[View Source →](<../../../../../src/util/rng/fd_rng.c#L301>)

Generates a double-precision floating-point number from an exponential distribution using a random number generator.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which represents the random number generator state.
- **Logic and Control Flow**:
    - Call [`fd_rng_ulong`](<fd_rng.h.md#fd_rng_ulong>) with `rng` to generate a 64-bit unsigned random number.
    - Shift the random number right by 1 bit and add 1 to ensure it is in the range (0, 2^63].
    - Convert the resulting unsigned long to a double and scale it by dividing by 2^63 to get a value in the range (0, 1].
    - Compute the negative natural logarithm of the scaled double to transform it into an exponentially distributed random number.
    - Return the computed double value.
- **Output**: A double-precision floating-point number representing an exponentially distributed random value.
- **Functions Called**:
    - [`fd_rng_ulong`](<fd_rng.h.md#fd_rng_ulong>)


---
### fd\_rng\_double\_norm<!-- {{#callable:fd_rng_double_norm}} -->
[View Source →](<../../../../../src/util/rng/fd_rng.c#L308>)

Generates a normally distributed double-precision floating-point number using the ziggurat algorithm.
- **Inputs**:
    - `rng`: A pointer to an `fd_rng_t` structure, which is used as the source of randomness.
- **Logic and Control Flow**:
    - Initialize variables `s` and `x` for sign and value computation.
    - Enter an infinite loop to generate a random number using the ziggurat method.
    - Generate a 64-bit random number `u` using [`fd_rng_ulong`](<fd_rng.h.md#fd_rng_ulong>) and derive `s`, `l`, and `m` from `u`.
    - Calculate `x` using the `zig_x` array and `m`.
    - If `x` is less than or equal to `zig_x[l]`, break the loop and accept `x`.
    - Generate a random double `y` using [`fd_rng_double_c`](<fd_rng.h.md#fd_rng_double_c>).
    - If `l` is less than `zig_level_cnt-1`, compute `y` using `zig_y` values; otherwise, adjust `x` and `y` for the tail of the distribution.
    - If `y` is less than the exponential of `-0.5 * x * x`, break the loop and accept `x`.
    - Return the value of `x` with a sign determined by `s` using `fd_double_if`.
- **Output**: A double-precision floating-point number that follows a normal distribution.
- **Functions Called**:
    - [`fd_rng_ulong`](<fd_rng.h.md#fd_rng_ulong>)
    - [`fd_rng_double_c`](<fd_rng.h.md#fd_rng_double_c>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)