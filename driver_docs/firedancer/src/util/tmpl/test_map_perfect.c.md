<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for perfect hash maps with various key types and values, including AVX512 optimizations.

# Purpose
The code defines a series of perfect hash maps and tests their functionality. It includes several structures and macros to create hash maps for different data types and purposes. The `wrapped_ul_t` structure is used to wrap an unsigned long key, while `prime_to_primitive_root_t` associates a prime number with its primitive root. The code uses macros to define the properties of each hash map, such as the name, table size, data type, hash constant, and key type. These hash maps are then included from the `fd_map_perfect.c` file, which likely contains the implementation of the perfect hash map logic.

The code also includes several test functions to verify the correctness of the hash maps. The [`test_primes`](<#test_primes>) function checks if the sum of squares of prime numbers is correct. The [`test_primitive_root`](<#test_primitive_root>) function verifies the properties of primitive roots for prime numbers. The [`test_is_permutation`](<#test_is_permutation>) and [`test_permutation_idx`](<#test_permutation_idx>) functions test the handling of permutations with complex keys. Additionally, the code includes functions [`find32`](<#find32>) and [`find16`](<#find16>) that use AVX-512 instructions to find constants for a set of values, demonstrating the use of SIMD operations for performance optimization. The `main` function initializes the environment, runs the tests, and logs the results.
# Imports and Dependencies

---
- `../fd_util.h`
- `fd_map_perfect.c`
- `../simd/fd_avx512.h`


# Data Structures

---
### wrapped\_ul
- **Type**: ``struct``
- **Members**:
    - ``key``: Stores an unsigned long integer value.
- **Description**: Encapsulates a single unsigned long integer (`ulong`) in a structure, providing a type definition `wrapped_ul_t` for ease of use in other parts of the code.


---
### wrapped\_ul\_t
- **Type**: ``struct``
- **Members**:
    - `key`: Stores an unsigned long integer value.
- **Description**: Defines a structure named `wrapped_ul` that contains a single member `key`, which is of type `ulong`. This structure is used to encapsulate an unsigned long integer, providing a way to handle it as a single entity in various operations, such as in perfect hash maps defined in the code.


---
### prime\_to\_primitive\_root\_t
- **Type**: ``struct``
- **Members**:
    - `prime`: Stores a prime number.
    - `primitive_root`: Stores the primitive root corresponding to the prime number.
- **Description**: Maps a prime number to its corresponding primitive root, which is useful in number theory and cryptographic applications.


---
### b3\_t
- **Type**: ``union``
- **Members**:
    - ``key``: An array of three unsigned characters.
    - ``_ukey``: An unsigned integer representation of the `key` array.
- **Description**: Provides a way to store a 3-byte key as either an array of three unsigned characters or as a single unsigned integer, allowing for flexible access and manipulation of the key data.


---
### b3\_idx\_t
- **Type**: ``struct``
- **Members**:
    - ``key``: An array of three `uchar` elements used as a key.
    - ``index``: An `ulong` value representing an index.
    - ``dummy``: An `int` used as a placeholder or for padding.
- **Description**: Defines a structure with a 3-byte key, an index, and a dummy integer, possibly used for mapping or indexing operations.


# Functions

---
### test\_primes<!-- {{#callable:test_primes}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L44>)

Calculates the sum of squares of prime numbers less than 100 and verifies the result.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize `ssq` to 0.
    - Iterate over numbers from 0 to 99.
    - Check if the current number is a prime using `prime100_contains`.
    - If the number is prime, add its square to `ssq`.
    - After the loop, verify that `ssq` equals 65796 using `FD_TEST`.
- **Output**: No output is returned; the function performs a test and asserts a condition.


---
### test\_primitive\_root<!-- {{#callable:test_primitive_root}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L96>)

Validates that each primitive root for primes between 3 and 99 satisfies the condition x^((p-1)/2) == -1 (mod p).
- **Inputs**: None
- **Logic and Control Flow**:
    - Iterates over integers `j` from 3 to 99.
    - Queries `prim_root100` to get the primitive root and prime for `j`.
    - Checks if the query result is not null using `FD_UNLIKELY`.
    - Initializes `prod` to 1.
    - Iterates `k` from 0 to (j-1)/2, updating `prod` by multiplying it with the primitive root and taking modulo with the prime.
    - Uses `FD_TEST` to assert that `prod` equals `prime-1`.
- **Output**: No output is returned; the function performs assertions to validate conditions.


---
### test\_is\_permutation<!-- {{#callable:test_is_permutation}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L135>)

Tests if a given 3-element array is a permutation of the set {0, 1, 2} and verifies the result against expected conditions.
- **Inputs**: None
- **Logic and Control Flow**:
    - Declare a 4-element `uchar` array `query` with alignment of 4 bytes.
    - Iterate over all possible values of `a`, `b`, and `c` from 0 to 3.
    - Assign `a`, `b`, and `c` to the first three elements of `query`, and set the fourth element to 0.
    - Call `permq_contains` with `query` to check if it is a permutation of {0, 1, 2}.
    - Calculate `should_contain` as true if `a`, `b`, and `c` are all different and the maximum of `a`, `b`, and `c` is less than 3.
    - Use `FD_TEST` to assert that `contained` equals `should_contain`.
- **Output**: No output is returned; the function uses assertions to validate conditions.


---
### test\_permutation\_idx<!-- {{#callable:test_permutation_idx}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L180>)

Validates the permutation index mapping by iterating through possible indices and checking their hash values against expected permutations.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize a counter `cnt` to zero.
    - Iterate over all possible values of `i` from 0 to 0xFFFFFF.
    - For each `i`, call `permq2_hash_or_default(i)` and use a switch statement to check the returned value against predefined hash values for specific permutations.
    - If a match is found, update `cnt` by adding a power of two corresponding to the matched case.
    - If `permq2_hash_or_default(i)` returns `UINT_MAX`, do nothing and continue.
    - If the returned value does not match any case, log an error message indicating a bad value was returned.
    - After the loop, assert that `cnt` equals 0x3FUL using `FD_TEST`.
- **Output**: No direct output, but the function asserts that the counter `cnt` equals 0x3FUL, indicating all expected permutations were correctly hashed.


---
### test\_zero<!-- {{#callable:test_zero}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L225>)

Validates the presence or absence of specific keys in two hash tables and checks the existence of keys in a table.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `FD_TEST` to check if `table_with_0_contains(0)` returns true, indicating that the key 0 is present in the `table_with_0` hash table.
    - Calls `FD_TEST` to check if `table_with_0_contains(1)` returns false, indicating that the key 1 is not present in the `table_with_0` hash table.
    - Calls `FD_TEST` to check if `table_without_0_contains(0)` returns false, indicating that the key 0 is not present in the `table_without_0` hash table.
    - Calls `FD_TEST` to check if `table_without_0_contains(1)` returns true, indicating that the key 1 is present in the `table_without_0` hash table.
    - Calls `FD_TEST` to verify that `table_without_0_tbl[0].key` is non-zero, ensuring the first element in `table_without_0_tbl` has a valid key.
    - Calls `FD_TEST` to verify that `table_without_0_tbl[1].key` is non-zero, ensuring the second element in `table_without_0_tbl` has a valid key.
- **Output**: No output is returned; the function performs assertions to validate conditions.


---
### find32<!-- {{#callable:find32}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L237>)

Finds the smallest positive integer `c` such that a bitwise OR of shifted and multiplied values from the input array results in a bit vector with a population count equal to `cnt`.
- **Inputs**:
    - `vals`: An array of 32 unsigned integers, where the first `cnt` elements are the values to process.
    - `cnt`: The number of valid elements in `vals` to consider, which must be less than or equal to 32.
- **Logic and Control Flow**:
    - Fill the `vals` array from index `cnt` to 31 with the value at index `cnt-1` to ensure all 32 elements are initialized.
    - Load the first 16 elements of `vals` into `w0` and the next 16 elements into `w1` using `wwu_ld`.
    - Broadcast the value 1 into `one` using `wwu_bcast`.
    - Iterate over `c` from 1 to `UINT_MAX`, broadcasting `c` into `_c` using `wwu_bcast`.
    - Multiply `_c` with `w0` and `w1`, shift the results right by 27 bits, and store in `p0` and `p1` respectively.
    - Create bit masks `mask0` and `mask1` by left-shifting `one` by `p0` and `p1` respectively, then combine them using bitwise OR into `combined`.
    - Reduce `combined` using `_mm512_reduce_or_epi32` to get `ored_all`.
    - Check if the population count of `ored_all` equals `cnt` using `fd_uint_popcnt`; if true, return `c`.
    - If no such `c` is found, return 0.
- **Output**: Returns the smallest positive integer `c` that satisfies the condition, or 0 if no such `c` is found.


---
### find16<!-- {{#callable:find16}} -->
[View Source →](<../../../../../src/util/tmpl/test_map_perfect.c#L271>)

Finds the smallest positive integer `c` such that a bitwise OR of shifted and multiplied values from the input array results in a bit vector with a population count equal to `cnt`.
- **Inputs**:
    - `vals`: An array of 16 unsigned integers, which must be filled with at least `cnt` valid values.
    - `cnt`: The number of valid entries in the `vals` array, which must be less than or equal to 16.
- **Logic and Control Flow**:
    - Fill the `vals` array from index `cnt` to 15 with the value at index `cnt-1` to ensure all 16 entries are populated.
    - Load the first 16 values from `vals` into a SIMD register `w0`.
    - Broadcast the value 1 into a SIMD register `one`.
    - Iterate over `c` from 1 to `UINT_MAX`, performing the following steps:
    - Broadcast the current value of `c` into a SIMD register `_c`.
    - Multiply `_c` with `w0`, shift the result right by 28 bits, and store it in `p0`.
    - Create a bitmask `mask0` by left-shifting `one` by the values in `p0`.
    - Reduce `mask0` using a bitwise OR operation across all elements to produce `ored_all`.
    - Check if the population count of `ored_all` equals `cnt`; if true, return `c`.
    - If no such `c` is found, return 0.
- **Output**: Returns the smallest positive integer `c` that satisfies the condition, or 0 if no such `c` is found.



---
Made with ❤️ by [Driver](https://www.driver.ai/)