<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for fast manipulation of interprocess shared index sets with a large runtime-bounded number of elements.

# Purpose
The code provides a template for creating and manipulating dynamic index sets in C. These sets can contain a large number of elements and are designed to be shared between processes. The implementation is optimized for dense sets with a large maximum number of elements. The code is intended to be included in other C files, as indicated by the use of the `#include` directive with a template file path. The template requires the definition of `SET_NAME` to generate a specific set of functions for managing the index set, such as creating, joining, and deleting sets, as well as performing operations like insertion, removal, and iteration over set elements.

The code defines a variety of functions for managing the lifecycle and operations of the index sets. These include functions for creating and destroying sets in shared memory, checking the validity of sets and indices, and performing set operations such as union, intersection, and difference. The code also provides both destructive and non-destructive iterators for traversing the elements of a set. Additionally, it includes range-based operations for efficiently manipulating contiguous ranges of elements within a set. The implementation uses bit manipulation to efficiently manage the elements within the set, and it provides both private and public APIs to facilitate these operations.
# Imports and Dependencies

---
- `../bits/fd_bits.h`
- `stddef.h`
- `../log/fd_log.h`


# Global Variables

---
### FD\_STATIC\_ASSERT
- **Type**: `macro`
- **Description**: `FD_STATIC_ASSERT` is a macro used to perform compile-time assertions. It checks that the size of the type `SET_(t)` is equal to 8 bytes, and if not, it triggers a compilation error with the message `unexpected_set_word_type`. This ensures that the type `SET_(t)` is of the expected size for the implementation.
- **Use**: Used to validate the size of `SET_(t)` at compile time to prevent unexpected behavior due to incorrect type size.


---
### SET\_
- **Type**: ``SET_(t)``
- **Description**: Represents a type alias for `ulong`, used as an element type in a set data structure. This type is part of a template-based implementation for managing sets of indices.
- **Use**: Used to define elements within a set data structure, allowing operations on sets of indices.


# Functions

---
### SET\_<!-- {{#callable:SET_}} -->
[View Source →](<../../../../../src/util/tmpl/fd_set_dynamic.c#L682>)

Counts the number of set bits in a specified range of a bitset.
- **Inputs**:
    - `set`: A pointer to a constant `SET_(t)` bitset.
    - `l`: The lower bound of the range (inclusive).
    - `h`: The upper bound of the range (exclusive).
- **Logic and Control Flow**:
    - If `FD_TMPL_USE_HANDHOLDING` is defined, check if the range [l, h) is valid and log a critical error if not.
    - Initialize `cnt` to 0 to store the count of set bits.
    - Calculate `word_idx` as the index of the word containing the lower bound `l`.
    - Calculate `zcnt` as the offset of `l` within its word and count set bits in the mixed leading word if `zcnt` is non-zero.
    - Iterate over complete words between `l` and `h`, adding the count of set bits in each word to `cnt`.
    - Calculate `ocnt` as the offset of `h` within its word and count set bits in the mixed trailing word if `ocnt` is non-zero.
    - Return the total count of set bits in the specified range.
- **Output**: The function returns an `ulong` representing the number of set bits in the specified range [l, h) of the bitset.
- **Functions Called**:
    - [`SET_`](<#set_>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)