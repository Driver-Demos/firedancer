<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

A template for generating single-threaded and parallel sorting functions for POD types, with customizable sorting criteria and performance optimizations.

# Purpose
The code is a C template for generating a family of sorting functions optimized for single-threaded and optionally multi-threaded environments. It is designed to sort Plain Old Data (POD) types efficiently in high-performance contexts. The template allows users to define the sorting function's name, the data type to sort, and the comparison logic by setting preprocessor macros such as `SORT_NAME`, `SORT_KEY_T`, and `SORT_BEFORE`. The code provides various sorting functions, including insertion sort, merge sort, and quicksort, with different performance characteristics and use cases.

The template supports both stable and unstable sorting methods and includes functions for checking the validity of input sizes, calculating required scratch space, and performing binary searches on sorted data. It also offers parallelized versions of the sorting functions if the `SORT_PARALLEL` macro is defined, utilizing a thread pool for concurrent execution. The code is structured to be included multiple times in a compilation unit, allowing for the creation of different sorting functions by redefining the macros before each inclusion. The implementation is modular, with private helper functions for merge and quicksort operations, and it provides options to tune the sorting methods for specific performance needs.
# Imports and Dependencies

---
- `../tpool/fd_tpool.h`
- `../bits/fd_bits.h`


# Global Variables

---
### tmp
- **Type**: `SORT_KEY_T*`
- **Description**: `tmp` is a pointer to a `SORT_KEY_T` type, which is defined by the user of the sorting template. It is initialized with the value from the third element of the `arg` array, which is cast to a `SORT_KEY_T*`. This suggests that `tmp` is used as a temporary storage or buffer during sorting operations.
- **Use**: Used as a temporary storage buffer during sorting operations.


---
### \_in\_l
- **Type**: `SORT_KEY_T **`
- **Description**: `_in_l` is a pointer to a pointer of type `SORT_KEY_T`, which is a placeholder for the data type used in sorting operations. It is initialized with the first element of the `arg` array, cast to `SORT_KEY_T **`. This variable is used in the context of a parallel merge operation.
- **Use**: Used to store the address of the left input array for a merge operation in a parallel sorting algorithm.


---
### in\_l
- **Type**: `SORT_KEY_T *`
- **Description**: `in_l` is a pointer to a `SORT_KEY_T` type, which is defined by the user of the sorting template. It is initialized to point to the first element of a left subarray in a merge operation.
- **Use**: Used to reference the left subarray during a merge operation in the sorting algorithm.


---
### cnt\_l
- **Type**: `long`
- **Description**: `cnt_l` is a long integer variable that calculates the difference between `block_is` and `block_i0`. It represents the count of elements in the left partition of a merge operation.
- **Use**: Used to determine the number of elements in the left partition during a merge operation in sorting.


---
### \_in\_r
- **Type**: `SORT_KEY_T **`
- **Description**: `_in_r` is a pointer to a pointer of type `SORT_KEY_T`, which is a placeholder for the data type used in sorting operations. It is initialized by casting `_r1` to `SORT_KEY_T **`. This variable is used in the context of a parallel merge operation.
- **Use**: Used to access the right half of a data block during a merge operation in a parallel sorting algorithm.


---
### in\_r
- **Type**: `SORT_KEY_T *`
- **Description**: `in_r` is a pointer to a `SORT_KEY_T` type, which is defined by the user of the sorting template. It is initialized to point to the first element of the array pointed to by `_in_r`, which is a double pointer to `SORT_KEY_T`. This setup is part of a merge operation in a sorting algorithm.
- **Use**: Used to access and manipulate the right half of a data array during a merge operation in a sorting algorithm.


---
### cnt\_r
- **Type**: `long`
- **Description**: `cnt_r` is a long integer variable that represents the count of elements in the right partition of a merge operation.
- **Use**: Used to calculate the number of elements in the right partition by subtracting `block_is` from `block_i1`.


---
### out
- **Type**: `SORT_KEY_T *`
- **Description**: The `out` variable is a pointer to a `SORT_KEY_T` type, which is determined by the macro `SORT_KEY_T` defined elsewhere in the code. It is used to store the result of a merge operation in a sorting algorithm.
- **Use**: Used to store the result of merging two sorted halves of an array during a merge sort operation.


---
### FD\_FOR\_ALL\_BEGIN
- **Type**: `macro`
- **Description**: Defines the beginning of a loop or block that iterates over all elements in a collection or performs a specific operation on each element.
- **Use**: Used to initiate a loop or block for processing elements in a collection.


# Functions

---
### SORT\_<!-- {{#callable:SORT_}} -->
[View Source →](<../../../../../src/util/tmpl/fd_sort.c#L1142>)

Performs a parallelized sorting of an array of keys using a sample sort approach with optional stability.
- **Inputs**:
    - `tpool`: A pointer to a thread pool (`fd_tpool_t`) used for parallel execution.
    - `t0`: The starting index of the thread pool range.
    - `t1`: The ending index of the thread pool range.
    - `key`: A pointer to the array of keys (`SORT_KEY_T`) to be sorted.
    - `cnt`: The number of elements in the `key` array to sort.
    - `scratch`: A pointer to a scratch space used during sorting.
    - `seed`: A seed value for random operations, affecting the sort order if `stable` is zero.
    - `stable`: An integer flag indicating whether to perform a stable sort (non-zero) or an unstable sort (zero).
- **Logic and Control Flow**:
    - Check if `cnt` is less than 2; if so, return `key` as no sorting is needed.
    - Calculate the optimal number of threads (`t_cnt`) based on the size of the data and available threads.
    - If `t_cnt` is less than 2, perform a stable or inplace sort based on the `stable` flag and return the result.
    - Sample the keys to estimate their distribution, sort the samples, and downsample them into pivots for partitioning.
    - Allocate memory for `pivot` and `part` arrays to assist in partitioning and scattering keys.
    - Use `FD_FOR_ALL` to count and copy keys into temporary storage (`tmp`) based on their assigned partitions.
    - Convert the counts into a partitioning scheme and scatter the keys back into the `key` array in subsorted order.
    - Perform parallel subsorts on the partitioned keys to achieve the final sorted order.
    - Return the sorted `key` array.
- **Output**: Returns a pointer to the sorted array of keys (`SORT_KEY_T *`).


---
### FD\_FOR\_ALL\_BEGIN<!-- {{#callable:FD_FOR_ALL_BEGIN}} -->
[View Source →](<../../../../../src/util/tmpl/fd_sort.c#L1030>)

Distributes keys among threads for parallel sorting and prepares them for scattering.
- **Inputs**:
    - `tpool_base`: The base index of the thread pool.
    - `t_cnt`: The number of threads in the thread pool.
    - `_key_cnt`: A pointer to an array where the count of keys assigned to each thread will be stored.
    - `key`: A pointer to the array of keys to be sorted.
    - `tmp`: A pointer to a temporary array where keys will be copied.
    - `pivot`: A pointer to an array of pivot values used to determine key distribution among threads.
- **Logic and Control Flow**:
    - Allocate local scratch space for counting to avoid false sharing.
    - Initialize the local scratch space to zero.
    - Iterate over the block of keys assigned to the current thread.
    - For each key, determine which thread is responsible for sorting it using a binary search on the pivot array.
    - Increment the count for the responsible thread and copy the key to the temporary array.
    - Copy the local counts to the global count array for partitioning.
- **Output**: No direct output; modifies `_key_cnt` and `tmp` to reflect key distribution and preparation for scattering.



---
Made with ❤️ by [Driver](https://www.driver.ai/)