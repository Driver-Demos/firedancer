<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for sandboxing features such as environment clearing, file descriptor checks, and namespace restrictions.

# Purpose
The code is a C test suite designed to verify various sandboxing and security features in a Linux environment. It includes tests for environment variable management, file descriptor checks, namespace restrictions, user and group ID switching, root filesystem pivoting, capability dropping, resource limit settings, and Landlock security module functionality. The code uses a series of macros and functions to fork processes and test the behavior of these security features under different conditions. It also includes tests for seccomp (secure computing mode) and checks for the undumpable state of processes.

The test suite is structured to run multiple tests, each focusing on a specific aspect of system security and sandboxing. It uses external functions, such as `fd_sandbox_private_check_exact_file_descriptors` and `fd_sandbox_private_deny_namespaces`, to perform operations related to sandboxing. The code is intended to be executed as a standalone program, as indicated by the presence of a [`main`](<#main>) function, which orchestrates the execution of the various tests. The tests are designed to be run with root privileges to fully exercise the security features being tested, and the code includes checks to skip certain tests if the necessary permissions are not available.
# Imports and Dependencies

---
- `fd_sandbox.h`
- `fd_sandbox_private.h`
- `../fd_util.h`
- `generated/test_sandbox_seccomp.h`
- `sys/file.h`
- `stdlib.h`
- `fcntl.h`
- `errno.h`
- `unistd.h`
- `sched.h`
- `dirent.h`
- `net/if.h`
- `sys/wait.h`
- `sys/stat.h`
- `sys/mman.h`
- `sys/prctl.h`
- `sys/syscall.h`
- `sys/resource.h`
- `linux/securebits.h`
- `linux/capability.h`


# Global Variables

---
### environ
- **Type**: ``char **``
- **Description**: A pointer to an array of strings, where each string represents an environment variable in the format 'KEY=VALUE'. This variable is used to access and manipulate the environment variables of the current process.
- **Use**: Used to access and modify the environment variables of the process.


# Data Structures

---
### rlimit\_setting
- **Type**: ``struct``
- **Members**:
    - ``resource``: Specifies the resource type for which the limit is set, using `__rlimit_resource_t` for glibc or `int` for non-glibc systems.
    - ``limit``: Defines the maximum allowable value for the specified resource.
- **Description**: Defines resource limits for a process, with `resource` indicating the type of resource and `limit` specifying the maximum value allowed for that resource. The structure adapts to different system libraries by using conditional compilation to select the appropriate type for `resource`.


---
### landlock\_ruleset\_attr
- **Type**: ``struct``
- **Members**:
    - ``handled_access_fs``: Specifies the file system access rights that the ruleset can handle.
- **Description**: Defines attributes for a Landlock ruleset, which is used to specify the file system access rights that the ruleset can manage. This structure is part of the Landlock security module, which provides a way to restrict the actions that processes can perform on the file system.


# Functions

---
### test\_clear\_environment<!-- {{#callable:test_clear_environment}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L61>)

Tests the clearing and resetting of environment variables and verifies memory zeroing.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `clearenv()` to clear the environment and checks if `environ` is null.
    - Sets three environment variables using `setenv()` and verifies their values in `environ`.
    - Calls `fd_sandbox_private_explicit_clear_environment_variables()` to clear environment variables again and checks if `environ` is null.
    - Iterates over the memory of the previously set environment variables to ensure it is zeroed.
- **Output**: No return value; the function performs tests and assertions.


---
### test\_check\_file\_descriptors\_inner<!-- {{#callable:test_check_file_descriptors_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L85>)

Tests the behavior of file descriptor checks using various allowed file descriptor arrays and expected exit codes.
- **Inputs**: None
- **Logic and Control Flow**:
    - Defines an array `allow_fds` with file descriptors {0, 1, 2, 3} and checks if [`fd_sandbox_private_check_exact_file_descriptors`](<fd_sandbox.c.md#fd_sandbox_private_check_exact_file_descriptors>) with 4 file descriptors exits with code 0, and with 3 and 0 file descriptors exits with code 1.
    - Defines another array `allow_fds2` with file descriptors {0, 1, 2, 3, 4} and checks if [`fd_sandbox_private_check_exact_file_descriptors`](<fd_sandbox.c.md#fd_sandbox_private_check_exact_file_descriptors>) with 5 file descriptors exits with code 1.
    - Defines additional arrays `allow_fds3`, `allow_fds4`, `allow_fds5`, and `allow_fds6` with various file descriptors and checks the exit codes for each using [`fd_sandbox_private_check_exact_file_descriptors`](<fd_sandbox.c.md#fd_sandbox_private_check_exact_file_descriptors>).
    - Uses `dup2` to duplicate file descriptor 3 to 4 and checks the exit codes for [`fd_sandbox_private_check_exact_file_descriptors`](<fd_sandbox.c.md#fd_sandbox_private_check_exact_file_descriptors>) with 4 and 5 file descriptors using `allow_fds` and `allow_fds2`.
    - Creates an array `too_many_fds` with 257 file descriptors, duplicates file descriptor 3 to a range of file descriptors, and checks the exit codes for [`fd_sandbox_private_check_exact_file_descriptors`](<fd_sandbox.c.md#fd_sandbox_private_check_exact_file_descriptors>) with 256 and 257 file descriptors.
- **Output**: No output is returned as the function is void and primarily performs tests with assertions.
- **Functions Called**:
    - [`fd_sandbox_private_check_exact_file_descriptors`](<fd_sandbox.c.md#fd_sandbox_private_check_exact_file_descriptors>)


---
### test\_check\_file\_descriptors<!-- {{#callable:test_check_file_descriptors}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L119>)

Executes the [`test_check_file_descriptors_inner`](<#test_check_file_descriptors_inner>) function in a forked process and verifies it exits with code 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_check_file_descriptors_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks the process and runs `test_check_file_descriptors_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code 0.
- **Output**: No direct output; it verifies the child process exits with code 0.
- **Functions Called**:
    - [`test_check_file_descriptors_inner`](<#test_check_file_descriptors_inner>)


---
### test\_deny\_namespaces\_inner<!-- {{#callable:test_deny_namespaces_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L124>)

Tests the ability to deny the creation of new namespaces and verifies the system's namespace limits.
- **Inputs**: None
- **Logic and Control Flow**:
    - Retrieve the current user ID (`uid`) and group ID (`gid`).
    - Attempt to unshare the user namespace with `unshare(CLONE_NEWUSER)` and verify success.
    - Write the user and group ID maps using [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>).
    - Define an array `SYSCTLS` containing paths to various namespace limit files in `/proc/sys/user/`.
    - Iterate over each path in `SYSCTLS`, open the file, read its content, and verify that the value is greater than 1.
    - Call [`fd_sandbox_private_deny_namespaces`](<fd_sandbox.c.md#fd_sandbox_private_deny_namespaces>) to deny the creation of new namespaces.
    - Iterate over each path in `SYSCTLS` again, open the file, read its content, and verify specific values for each namespace type.
    - Use `TEST_FORK_EXIT_CODE` to test that unsharing various namespaces (network, cgroup, IPC, PID, UTS) fails, while unsharing the mount namespace succeeds.
    - Test that attempting to unshare the user namespace again fails.
- **Output**: No return value; the function performs tests and assertions to verify namespace restrictions.
- **Functions Called**:
    - [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>)
    - [`fd_sandbox_private_deny_namespaces`](<fd_sandbox.c.md#fd_sandbox_private_deny_namespaces>)


---
### test\_deny\_namespaces<!-- {{#callable:test_deny_namespaces}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L189>)

Executes the [`test_deny_namespaces_inner`](<#test_deny_namespaces_inner>) function in a forked process and checks for a successful exit code of 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_deny_namespaces_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks the process and runs `test_deny_namespaces_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code of 0.
- **Output**: No direct output; it verifies that [`test_deny_namespaces_inner`](<#test_deny_namespaces_inner>) completes successfully with an exit code of 0.
- **Functions Called**:
    - [`test_deny_namespaces_inner`](<#test_deny_namespaces_inner>)


---
### test\_switch\_uid\_gid1<!-- {{#callable:test_switch_uid_gid1}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L194>)

Verifies that the user and group IDs are correctly switched and checks the dumpable status of the process.
- **Inputs**:
    - `check_uid`: The user ID to switch to and verify.
    - `check_gid`: The group ID to switch to and verify.
- **Logic and Control Flow**:
    - Calls [`fd_sandbox_private_switch_uid_gid`](<fd_sandbox.c.md#fd_sandbox_private_switch_uid_gid>) to switch the user and group IDs to `check_uid` and `check_gid` respectively.
    - Retrieves the real, effective, and saved user IDs using `getresuid` and verifies they match `check_uid`.
    - Retrieves the real, effective, and saved group IDs using `getresgid` and verifies they match `check_gid`.
    - Checks that the process is in a dumpable state using `prctl` with `PR_GET_DUMPABLE`.
- **Output**: No return value; the function performs assertions to verify correct behavior.
- **Functions Called**:
    - [`fd_sandbox_private_switch_uid_gid`](<fd_sandbox.c.md#fd_sandbox_private_switch_uid_gid>)


---
### test\_switch\_uid\_gid<!-- {{#callable:test_switch_uid_gid}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L207>)

Tests the switching of user and group IDs by forking processes and verifying the changes.
- **Inputs**: None
- **Logic and Control Flow**:
    - Retrieve the current user ID (`uid`) and group ID (`gid`) using `getuid()` and `getgid()` functions.
    - Call `TEST_FORK_EXIT_CODE` macro multiple times with [`test_switch_uid_gid1`](<#test_switch_uid_gid1>) function and different user and group ID pairs to test the switching functionality.
    - Each call to `TEST_FORK_EXIT_CODE` forks a new process, executes [`test_switch_uid_gid1`](<#test_switch_uid_gid1>) with the specified IDs, and checks if the process exits with code 0.
    - The last call to `TEST_FORK_EXIT_CODE` uses the original `uid` and `gid` to ensure the process can switch back to the original IDs.
- **Output**: No direct output; the function performs tests and logs errors if any test fails.
- **Functions Called**:
    - [`test_switch_uid_gid1`](<#test_switch_uid_gid1>)


---
### test\_pivot\_root\_inner<!-- {{#callable:test_pivot_root_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L225>)

Tests the behavior of the system after performing a pivot root operation in a new user namespace.
- **Inputs**: None
- **Logic and Control Flow**:
    - Retrieve the current user ID and group ID using `getuid()` and `getgid()`.
    - Unshare the user namespace using `unshare(CLONE_NEWUSER)` and verify success with `FD_TEST`.
    - Map the current user and group IDs to the new namespace using [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>).
    - Open the `/mnt` and `/proc` directories to ensure they are accessible, then close them.
    - Perform a pivot root operation using [`fd_sandbox_private_pivot_root`](<fd_sandbox.c.md#fd_sandbox_private_pivot_root>).
    - Attempt to reopen `/mnt` and `/proc` to verify they are no longer accessible, expecting `ENOENT` errors.
    - Open the root directory `/` and iterate over its entries using `syscall(SYS_getdents64)` to ensure only `.` and `..` are present.
    - Close the root directory file descriptor.
    - Verify the current working directory is `/` using `getcwd`.
    - Attempt to change the directory to `..` and verify the working directory remains `/`.
- **Output**: No return value; the function uses `FD_TEST` to assert conditions and will terminate the program if any test fails.
- **Functions Called**:
    - [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>)
    - [`fd_sandbox_private_pivot_root`](<fd_sandbox.c.md#fd_sandbox_private_pivot_root>)


---
### test\_pivot\_root<!-- {{#callable:test_pivot_root}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L276>)

Executes the [`test_pivot_root_inner`](<#test_pivot_root_inner>) function in a child process and verifies it exits with code 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_pivot_root_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks a new process and runs `test_pivot_root_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code 0.
- **Output**: No direct output; verifies the child process exits with code 0.
- **Functions Called**:
    - [`test_pivot_root_inner`](<#test_pivot_root_inner>)


---
### test\_drop\_caps\_inner<!-- {{#callable:test_drop_caps_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L281>)

Tests the dropping of capabilities in a sandboxed environment by manipulating user and group IDs, secure bits, and capability sets.
- **Inputs**: None
- **Logic and Control Flow**:
    - Retrieve the current user ID (`uid`) and group ID (`gid`).
    - Unshare the user namespace using `unshare(CLONE_NEWUSER)` and map the user and group IDs using [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>).
    - Get the current secure bits using `prctl(PR_GET_SECUREBITS)` and verify they are not set.
    - Iterate over capabilities from 0 to 40, checking if they are set in the bounding set and ambient set using `prctl`.
    - Initialize capability header and data structures, retrieve current capabilities using `syscall(SYS_capget)`, and verify the effective, permitted, and inheritable capabilities.
    - Set the inheritable capabilities and update them using `syscall(SYS_capset)`, then verify the changes.
    - Call [`fd_sandbox_private_drop_caps`](<fd_sandbox.c.md#fd_sandbox_private_drop_caps>) to drop capabilities.
    - Verify the secure bits are set to specific locked values and check that capabilities are no longer set in the bounding and ambient sets.
    - Retrieve and verify that all capabilities are now zero using `syscall(SYS_capget)`.
- **Output**: No output is returned; the function uses assertions (`FD_TEST`) to verify conditions.
- **Functions Called**:
    - [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>)
    - [`fd_sandbox_private_drop_caps`](<fd_sandbox.c.md#fd_sandbox_private_drop_caps>)


---
### test\_drop\_caps<!-- {{#callable:test_drop_caps}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L341>)

Executes the [`test_drop_caps_inner`](<#test_drop_caps_inner>) function in a forked process and checks for a successful exit code of 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_drop_caps_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks the current process.
    - In the child process, it executes `test_drop_caps_inner()` and exits with `EXIT_SUCCESS`.
    - In the parent process, it waits for the child process to terminate and checks if it exited successfully with the expected exit code 0.
- **Output**: No direct output; it verifies that [`test_drop_caps_inner`](<#test_drop_caps_inner>) completes successfully with an exit code of 0.
- **Functions Called**:
    - [`test_drop_caps_inner`](<#test_drop_caps_inner>)


---
### test\_resource\_limits\_inner<!-- {{#callable:test_resource_limits_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L356>)

Tests resource limits by setting various limits to zero and verifying the system's behavior under these constraints.
- **Inputs**: None
- **Logic and Control Flow**:
    - Retrieve the current user ID (`uid`) and group ID (`gid`).
    - Unshare the user namespace using `unshare(CLONE_NEWUSER)` and map the current user and group IDs using [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>).
    - Define an array `rlimits` with various resource limits set to zero.
    - Open the root directory (`/`) and verify the file descriptor is valid, then close it.
    - Allocate memory using `mmap` and verify the allocation and deallocation using `munmap`.
    - Allocate another memory block, lock it with `mlock`, and then unlock it with `munlock`.
    - Fork a process and verify the exit code using `TEST_FORK_EXIT_CODE`.
    - Set resource limits using [`fd_sandbox_private_set_rlimits`](<fd_sandbox.c.md#fd_sandbox_private_set_rlimits>).
    - Iterate over the `rlimits` array, retrieve each limit using `getrlimit`, and verify that both current and maximum limits are set to zero.
    - Attempt to open the root directory again and verify that it fails with `EMFILE` error due to file descriptor limit.
    - Attempt to allocate memory again and verify that it fails with `ENOMEM` error due to memory limit.
    - Attempt to lock memory again and verify that it fails with `EPERM` error due to memory lock limit.
    - If the user ID is not zero, attempt to fork a process and verify that it fails with `EAGAIN` error due to process limit.
- **Output**: No output is returned; the function performs tests and assertions to verify system behavior under resource constraints.
- **Functions Called**:
    - [`fd_sandbox_private_write_userns_uid_gid_maps`](<fd_sandbox.c.md#fd_sandbox_private_write_userns_uid_gid_maps>)
    - [`fd_sandbox_private_set_rlimits`](<fd_sandbox.c.md#fd_sandbox_private_set_rlimits>)


---
### test\_resource\_limits<!-- {{#callable:test_resource_limits}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L414>)

Executes the [`test_resource_limits_inner`](<#test_resource_limits_inner>) function in a forked process and checks for a successful exit code.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_resource_limits_inner()` as the child process and `0` as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks a new process and executes `test_resource_limits_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited successfully with the expected exit code `0`.
- **Output**: No direct output; the function verifies that [`test_resource_limits_inner`](<#test_resource_limits_inner>) completes successfully with an exit code of `0`.
- **Functions Called**:
    - [`test_resource_limits_inner`](<#test_resource_limits_inner>)


---
### test\_landlock\_inner<!-- {{#callable:test_landlock_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L427>)

Tests the Landlock security feature by creating a ruleset, restricting access, and verifying access denial.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize a `landlock_ruleset_attr` structure with `handled_access_fs` set to 0, indicating no access permissions.
    - Call the `syscall` function with `SYS_landlock_create_ruleset` to create a Landlock ruleset and store the file descriptor in `landlock_fd`.
    - Check if `landlock_fd` is -1 and `errno` is `ENOSYS`, log a warning, and return if Landlock is not supported.
    - Verify that `landlock_fd` is valid and close it.
    - Open the root directory with read-only access, verify the file descriptor is valid, and close it.
    - Call [`fd_sandbox_private_landlock_restrict_self`](<fd_sandbox.c.md#fd_sandbox_private_landlock_restrict_self>) to apply the Landlock restrictions.
    - Attempt to open the root directory again with read-only access, log the result, and verify that access is denied with `errno` set to `EPERM`.
- **Output**: No return value; performs tests and logs results.
- **Functions Called**:
    - [`fd_sandbox_private_landlock_restrict_self`](<fd_sandbox.c.md#fd_sandbox_private_landlock_restrict_self>)


---
### test\_landlock<!-- {{#callable:test_landlock}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L452>)

Executes the [`test_landlock_inner`](<#test_landlock_inner>) function in a forked process and checks for a successful exit code of 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_landlock_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks a new process and runs `test_landlock_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code 0.
- **Output**: No direct output; the function verifies that [`test_landlock_inner`](<#test_landlock_inner>) completes successfully with an exit code of 0.
- **Functions Called**:
    - [`test_landlock_inner`](<#test_landlock_inner>)


---
### test\_read\_last\_cap<!-- {{#callable:test_read_last_cap}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L457>)

Verifies that the function [`fd_sandbox_private_read_cap_last_cap`](<fd_sandbox.c.md#fd_sandbox_private_read_cap_last_cap>) returns the value `40UL`.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the function [`fd_sandbox_private_read_cap_last_cap`](<fd_sandbox.c.md#fd_sandbox_private_read_cap_last_cap>) to retrieve the last capability value.
    - Uses the macro `FD_TEST` to assert that the returned value is `40UL`.
- **Output**: No output is returned as the function is a void type and only performs an assertion.
- **Functions Called**:
    - [`fd_sandbox_private_read_cap_last_cap`](<fd_sandbox.c.md#fd_sandbox_private_read_cap_last_cap>)


---
### test\_seccomp<!-- {{#callable:test_seccomp}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L462>)

Tests the application of a seccomp filter to restrict system calls and verify the behavior of child processes under this filter.
- **Inputs**:
    - `void`: No input parameters.
- **Logic and Control Flow**:
    - Defines a `sock_filter` array `seccomp_filter` with 128 elements.
    - Calls [`populate_sock_filter_policy_test_sandbox`](<generated/test_sandbox_seccomp.h.md#populate_sock_filter_policy_test_sandbox>) to initialize the `seccomp_filter`.
    - Defines macros `TEST_FORK_SECCOMP_SIGNAL` and `TEST_FORK_SECCOMP_EXIT_CODE` to test child processes with seccomp filters, checking for specific signals or exit codes.
    - Uses `prctl` to set `PR_SET_NO_NEW_PRIVS` to 1, ensuring no new privileges are granted to child processes.
    - Applies the seccomp filter using `fd_sandbox_private_set_seccomp_filter`.
    - Executes several test cases using the defined macros to verify the behavior of system calls under the seccomp filter, expecting either normal exit or termination by `SIGSYS`.
- **Output**: No return value; the function performs tests and logs results.
- **Functions Called**:
    - [`populate_sock_filter_policy_test_sandbox`](<generated/test_sandbox_seccomp.h.md#populate_sock_filter_policy_test_sandbox>)


---
### test\_undumpable\_inner<!-- {{#callable:test_undumpable_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L491>)

Tests the undumpable state and user/group IDs in a sandboxed environment.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initializes an array `allow_fds` with file descriptors 0, 1, 2, and 3.
    - Calls [`fd_sandbox_private_enter_no_seccomp`](<fd_sandbox.c.md#fd_sandbox_private_enter_no_seccomp>) with the current user and group IDs and the `allow_fds` array to enter a sandboxed environment without seccomp.
    - Checks that the process is not dumpable using `prctl` with `PR_GET_DUMPABLE`.
    - Checks that the process does not retain capabilities using `prctl` with `PR_GET_KEEPCAPS`.
    - Retrieves the real, effective, and saved user IDs using `getresuid` and verifies they are all set to 1.
    - Retrieves the real, effective, and saved group IDs using `getresgid` and verifies they are all set to 1.
- **Output**: No output is returned; the function performs tests and assertions.
- **Functions Called**:
    - [`fd_sandbox_private_enter_no_seccomp`](<fd_sandbox.c.md#fd_sandbox_private_enter_no_seccomp>)


---
### test\_undumpable<!-- {{#callable:test_undumpable}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L507>)

Executes the [`test_undumpable_inner`](<#test_undumpable_inner>) function in a forked process and checks for a successful exit code of 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_undumpable_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks the process and runs `test_undumpable_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code of 0.
- **Output**: No direct output; it verifies that [`test_undumpable_inner`](<#test_undumpable_inner>) completes successfully with an exit code of 0.
- **Functions Called**:
    - [`test_undumpable_inner`](<#test_undumpable_inner>)


---
### test\_controlling\_terminal\_inner<!-- {{#callable:test_controlling_terminal_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L512>)

Tests if the session ID changes after entering a sandbox environment without seccomp restrictions.
- **Inputs**:
    - `void`: No input parameters.
- **Logic and Control Flow**:
    - Retrieve the session ID of the current process using `getsid(0)` and store it in `sid1`.
    - Verify that `sid1` is not equal to -1 using `FD_TEST`.
    - Define an array `allow_fds` with file descriptors 0, 1, 2, and 3.
    - Call [`fd_sandbox_private_enter_no_seccomp`](<fd_sandbox.c.md#fd_sandbox_private_enter_no_seccomp>) with the current user ID, group ID, and `allow_fds` to enter a sandbox environment without seccomp restrictions.
    - Retrieve the session ID of the current process using `getsid(1)` and store it in `sid2`.
    - Verify that `sid2` is not equal to -1 using `FD_TEST`.
    - Check that `sid1` is not equal to `sid2` using `FD_TEST`.
- **Output**: No return value.
- **Functions Called**:
    - [`fd_sandbox_private_enter_no_seccomp`](<fd_sandbox.c.md#fd_sandbox_private_enter_no_seccomp>)


---
### test\_controlling\_terminal<!-- {{#callable:test_controlling_terminal}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L523>)

Executes [`test_controlling_terminal_inner`](<#test_controlling_terminal_inner>) in a child process and checks for a successful exit with code 0.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_controlling_terminal_inner()` as the child process and 0 as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks a new process and runs `test_controlling_terminal_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code 0.
- **Output**: No direct output; the function verifies the behavior of [`test_controlling_terminal_inner`](<#test_controlling_terminal_inner>) through the exit code.
- **Functions Called**:
    - [`test_controlling_terminal_inner`](<#test_controlling_terminal_inner>)


---
### test\_netns\_inner<!-- {{#callable:test_netns_inner}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L528>)

Tests network namespace functionality by checking interface names before and after entering a sandbox environment.
- **Inputs**: None
- **Logic and Control Flow**:
    - Call `if_nameindex()` to get a list of network interfaces and store it in `ifs`.
    - Use `FD_TEST` to assert that the second interface name (`ifs[1].if_name`) is not `NULL`.
    - Define an array `allow_fds` with file descriptors 0, 1, 2, and 3.
    - Call `fd_sandbox_private_enter_no_seccomp()` with the current user ID, group ID, and `allow_fds` to enter a sandbox environment without seccomp restrictions.
    - Call `if_nameindex()` again to get the list of network interfaces after entering the sandbox.
    - Use `FD_TEST` to assert that `ifs` is `NULL`, indicating no network interfaces are available.
- **Output**: No return value; uses assertions to validate conditions.
- **Functions Called**:
    - [`fd_sandbox_private_enter_no_seccomp`](<fd_sandbox.c.md#fd_sandbox_private_enter_no_seccomp>)


---
### test\_netns<!-- {{#callable:test_netns}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L540>)

Executes the [`test_netns_inner`](<#test_netns_inner>) function in a forked process and checks for a successful exit code.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the macro `TEST_FORK_EXIT_CODE` with `test_netns_inner()` as the child process and `0` as the expected exit code.
    - The macro `TEST_FORK_EXIT_CODE` forks the process and runs `test_netns_inner()` in the child process.
    - The parent process waits for the child process to exit and checks if it exited normally with the expected exit code `0`.
- **Output**: No direct output; it verifies that [`test_netns_inner`](<#test_netns_inner>) completes successfully with an exit code of `0`.
- **Functions Called**:
    - [`test_netns_inner`](<#test_netns_inner>)


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/util/sandbox/test_sandbox.c#L545>)

Executes a series of security and environment tests, logging the results, and halts the program.
- **Inputs**:
    - `argc`: The number of command-line arguments.
    - `argv`: An array of strings representing the command-line arguments.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with `argc` and `argv`.
    - Logs the start of each test using `FD_LOG_NOTICE`.
    - Calls [`test_clear_environment`](<#test_clear_environment>) to test environment clearing functionality.
    - Calls [`test_check_file_descriptors`](<#test_check_file_descriptors>) to test file descriptor checks.
    - Checks if the effective user ID is root; if so, calls [`test_switch_uid_gid`](<#test_switch_uid_gid>), otherwise logs a warning.
    - Calls [`test_deny_namespaces`](<#test_deny_namespaces>) to test namespace denial.
    - Calls [`test_pivot_root`](<#test_pivot_root>) to test root pivoting.
    - Calls [`test_drop_caps`](<#test_drop_caps>) to test capability dropping.
    - Calls [`test_resource_limits`](<#test_resource_limits>) to test resource limits.
    - Calls [`test_landlock`](<#test_landlock>) to test landlock functionality.
    - Calls [`test_read_last_cap`](<#test_read_last_cap>) to test reading the last capability.
    - Calls [`test_seccomp`](<#test_seccomp>) to test seccomp functionality.
    - Checks if the effective user ID is root; if so, calls [`test_undumpable`](<#test_undumpable>), otherwise logs a warning.
    - Checks if the effective user ID is root; if so, calls [`test_netns`](<#test_netns>), otherwise logs a warning.
    - Logs a pass message using `FD_LOG_NOTICE`.
    - Calls `fd_halt` to halt the program.
    - Returns 0 to indicate successful execution.
- **Output**: Returns 0 to indicate successful execution.
- **Functions Called**:
    - [`test_clear_environment`](<#test_clear_environment>)
    - [`test_check_file_descriptors`](<#test_check_file_descriptors>)
    - [`test_switch_uid_gid`](<#test_switch_uid_gid>)
    - [`test_deny_namespaces`](<#test_deny_namespaces>)
    - [`test_pivot_root`](<#test_pivot_root>)
    - [`test_drop_caps`](<#test_drop_caps>)
    - [`test_resource_limits`](<#test_resource_limits>)
    - [`test_landlock`](<#test_landlock>)
    - [`test_read_last_cap`](<#test_read_last_cap>)
    - [`test_seccomp`](<#test_seccomp>)
    - [`test_undumpable`](<#test_undumpable>)
    - [`test_netns`](<#test_netns>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)