<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for saturation arithmetic operations on various integer types, including 128-bit integers if supported.

# Purpose
The code is a C program designed to test the functionality of saturated arithmetic operations for various integer types, including `ulong`, `long`, `uint`, and `uint128`, if the platform supports 128-bit integers (`FD_HAS_INT128`). The program defines several static inline functions that perform saturated addition, subtraction, and multiplication for these types. Saturated arithmetic ensures that operations do not overflow; instead, they clamp the result to the maximum or minimum value representable by the type. The program includes functions like [`fd_ulong_sat_add_ref`](<#fd_ulong_sat_add_ref>), [`fd_long_sat_sub_ref`](<#fd_long_sat_sub_ref>), and [`fd_uint128_sat_mul_ref`](<#fd_uint128_sat_mul_ref>) to perform these operations and check against reference implementations.

The [`main`](<#main>) function serves as a test suite that validates the correctness of these saturated arithmetic functions. It uses a series of macros to automate the testing process for each operation and type, comparing the results of the reference functions with the actual implementations. The program generates random test cases using helper functions like [`make_test_rand_ulong`](<#make_test_rand_ulong>) and [`make_test_rand_uint128`](<#make_test_rand_uint128>) to create challenging scenarios with random bit patterns. If the results do not match, the program logs an error message. The test suite runs a large number of iterations to ensure robustness and logs progress at regular intervals. If the platform does not support 128-bit integers, the program logs a warning and exits.
# Imports and Dependencies

---
- `../fd_util.h`
- `math.h`


# Functions

---
### make\_test\_rand\_ulong<!-- {{#callable:make_test_rand_ulong}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L10>)

Generates a modified 64-bit unsigned long integer by applying bitwise operations based on control bits.
- **Inputs**:
    - `x`: A 64-bit unsigned long integer to be modified.
    - `_ctl`: A pointer to a 32-bit unsigned integer containing control bits for the operation.
- **Logic and Control Flow**:
    - Retrieve the control bits from the location pointed to by `_ctl` and store them in `ctl`.
    - Extract the shift amount `s` from the least significant 6 bits of `ctl` and shift `ctl` right by 6 bits.
    - Extract the direction `d` from the least significant bit of `ctl` and shift `ctl` right by 1 bit.
    - Extract the invert flag `i` from the least significant bit of `ctl` and shift `ctl` right by 1 bit.
    - Update the value pointed to by `_ctl` with the modified `ctl`.
    - Shift `x` left by `s` bits if `d` is 1, otherwise shift `x` right by `s` bits.
    - Invert all bits of `x` if `i` is 1, otherwise leave `x` unchanged.
    - Return the modified `x`.
- **Output**: A 64-bit unsigned long integer that has been shifted and possibly inverted based on the control bits.


---
### make\_test\_rand\_uint<!-- {{#callable:make_test_rand_uint}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L22>)

Generates a modified 32-bit unsigned integer by applying bitwise operations based on control bits.
- **Inputs**:
    - `x`: A random 32-bit unsigned integer to be modified.
    - `_ctl`: A pointer to a 32-bit unsigned integer containing control bits that determine the operations to apply on `x`.
- **Logic and Control Flow**:
    - Extracts the least significant 8 bits from `*_ctl` and assigns them to `ctl`.
    - Extracts a shift value `s` from the least significant 5 bits of `ctl`, then shifts `ctl` right by 6 bits.
    - Extracts a direction bit `d` from the least significant bit of `ctl`, then shifts `ctl` right by 1 bit.
    - Extracts an invert bit `i` from the least significant bit of `ctl`, then shifts `ctl` right by 1 bit.
    - Updates `*_ctl` with the modified `ctl`.
    - Shifts `x` left by `s` if `d` is 1, otherwise shifts `x` right by `s`.
    - Inverts `x` if `i` is 1, otherwise leaves `x` unchanged.
- **Output**: Returns the modified 32-bit unsigned integer `x` after applying the specified bitwise operations.


---
### make\_test\_rand\_uint128<!-- {{#callable:make_test_rand_uint128}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L36>)

Generates a 128-bit unsigned integer with random bit patterns by shifting and optionally inverting the input based on control bits.
- **Inputs**:
    - `x`: A 128-bit unsigned integer that serves as the base for generating the random pattern.
    - `_ctl`: A pointer to a 32-bit unsigned integer that provides control bits for the operation and is updated during the process.
- **Logic and Control Flow**:
    - Extracts the least significant 8 bits from the control integer `*_ctl` and assigns it to `ctl`.
    - Calculates the shift amount `s` by masking `ctl` with `31U` and then shifts `ctl` right by 6 bits.
    - Determines the shift direction `d` by masking `ctl` with `1U` and then shifts `ctl` right by 1 bit.
    - Determines whether to invert the result `i` by masking `ctl` with `1U` and then shifts `ctl` right by 1 bit.
    - Updates the original control integer `*_ctl` with the modified `ctl`.
    - Shifts `x` left by `s` bits if `d` is true, otherwise shifts `x` right by `s` bits.
    - Inverts `x` if `i` is true, otherwise returns `x` as is.
- **Output**: Returns a 128-bit unsigned integer that has been shifted and possibly inverted based on the control bits.


---
### fd\_ulong\_sat\_add\_ref<!-- {{#callable:fd_ulong_sat_add_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L50>)

Performs saturated addition of two unsigned long integers, returning the maximum value if overflow occurs.
- **Inputs**:
    - `x`: The first unsigned long integer to add.
    - `y`: The second unsigned long integer to add.
- **Logic and Control Flow**:
    - Initialize a `uint128` variable `ref` with the value of `x`.
    - Add `y` to `ref`.
    - Check if `ref` exceeds `ULONG_MAX`.
    - If `ref` exceeds `ULONG_MAX`, return `ULONG_MAX`.
    - Otherwise, return `ref` cast to `ulong`.
- **Output**: Returns the result of the addition as an unsigned long integer, or `ULONG_MAX` if overflow occurs.


---
### fd\_ulong\_sat\_sub\_ref<!-- {{#callable:fd_ulong_sat_sub_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L63>)

Performs saturated subtraction of two unsigned long integers, returning zero if the result would be negative.
- **Inputs**:
    - `x`: The minuend, an unsigned long integer.
    - `y`: The subtrahend, an unsigned long integer.
- **Logic and Control Flow**:
    - Initialize a `uint128` variable `ref` with the value of `x`.
    - Subtract `y` from `ref`.
    - Check if `y` is greater than `x`.
    - If `y` is greater than `x`, return 0.
    - Otherwise, cast `ref` to `ulong` and return it.
- **Output**: Returns the result of `x - y` as an unsigned long integer, or 0 if `y` is greater than `x`.


---
### fd\_ulong\_sat\_mul\_ref<!-- {{#callable:fd_ulong_sat_mul_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L76>)

Performs multiplication of two unsigned long integers with saturation to handle overflow.
- **Inputs**:
    - `x`: The first unsigned long integer to multiply.
    - `y`: The second unsigned long integer to multiply.
- **Logic and Control Flow**:
    - Initialize a `uint128` variable `ref` with the value of `x` and multiply it by `y`.
    - Check if either `x` or `y` is zero; if true, return 0 as the result.
    - Check for overflow conditions: if `ref` is less than `x` or `y`, or if dividing `ref` by `x` does not yield `y`, or if `ref` exceeds `ULONG_MAX`, return `ULONG_MAX`.
    - If no overflow conditions are met, cast `ref` to `ulong` and return it.
- **Output**: Returns the product of `x` and `y` as an unsigned long integer, saturated to `ULONG_MAX` in case of overflow.


---
### fd\_long\_sat\_add\_ref<!-- {{#callable:fd_long_sat_add_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L93>)

Performs saturated addition of two long integers, returning the maximum or minimum long value if overflow or underflow occurs.
- **Inputs**:
    - `x`: The first long integer to add.
    - `y`: The second long integer to add.
- **Logic and Control Flow**:
    - Convert `x` to an `int128` type and store it in `ref`.
    - Add `y` to `ref`.
    - Check if `ref` exceeds `LONG_MAX`; if true, return `LONG_MAX`.
    - Check if `ref` is less than `LONG_MIN`; if true, return `LONG_MIN`.
    - If neither condition is met, cast `ref` to a `long` and return it.
- **Output**: Returns the result of the saturated addition as a `long` integer.


---
### fd\_long\_sat\_sub\_ref<!-- {{#callable:fd_long_sat_sub_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L108>)

Performs saturated subtraction of two `long` integers, ensuring the result does not exceed the limits of a `long` type.
- **Inputs**:
    - `x`: The minuend, a `long` integer.
    - `y`: The subtrahend, a `long` integer.
- **Logic and Control Flow**:
    - Convert `x` to an `int128` type and store it in `ref`.
    - Subtract `y` from `ref`.
    - Check if `ref` is greater than `LONG_MAX`; if true, return `LONG_MAX`.
    - Check if `ref` is less than `LONG_MIN`; if true, return `LONG_MIN`.
    - If neither condition is met, cast `ref` to `long` and return it.
- **Output**: A `long` integer representing the saturated subtraction result of `x` and `y`.


---
### fd\_uint\_sat\_add\_ref<!-- {{#callable:fd_uint_sat_add_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L123>)

Performs saturated addition of two unsigned integers, returning the maximum unsigned integer value if overflow occurs.
- **Inputs**:
    - `x`: The first unsigned integer to add.
    - `y`: The second unsigned integer to add.
- **Logic and Control Flow**:
    - Convert `x` to a `uint128` type and store it in `ref`.
    - Add `y` to `ref`.
    - Check if `ref` exceeds `UINT_MAX`.
    - If `ref` exceeds `UINT_MAX`, return `UINT_MAX`.
    - Otherwise, return `ref` cast to `uint`.
- **Output**: Returns the result of the addition as an unsigned integer, or `UINT_MAX` if overflow occurs.


---
### fd\_uint\_sat\_sub\_ref<!-- {{#callable:fd_uint_sat_sub_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L136>)

Performs a subtraction of two unsigned integers with saturation at zero.
- **Inputs**:
    - `x`: The minuend, an unsigned integer.
    - `y`: The subtrahend, an unsigned integer.
- **Logic and Control Flow**:
    - Initialize a `uint128` variable `ref` with the value of `x`.
    - Subtract `y` from `ref`.
    - Check if `y` is greater than `x`.
    - If `y` is greater than `x`, return 0.
    - Otherwise, cast `ref` to `uint` and return it.
- **Output**: Returns the result of `x - y` as an unsigned integer, or 0 if the result would be negative.


---
### fd\_uint\_sat\_mul\_ref<!-- {{#callable:fd_uint_sat_mul_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L149>)

Performs saturated multiplication of two unsigned integers, returning the maximum unsigned integer value if overflow occurs.
- **Inputs**:
    - `x`: An unsigned integer to multiply.
    - `y`: Another unsigned integer to multiply.
- **Logic and Control Flow**:
    - Initialize a variable `ref` with the value of `x` and multiply it by `y`.
    - Check if either `x` or `y` is zero; if true, return 0.
    - Check for overflow conditions: if `ref` is less than `x` or `y`, or if dividing `ref` by `x` does not yield `y`, or if `ref` exceeds `UINT_MAX`, return `UINT_MAX`.
    - If no overflow conditions are met, return `ref` cast to an unsigned integer.
- **Output**: Returns the product of `x` and `y` as an unsigned integer, or `UINT_MAX` if overflow occurs.


---
### fd\_uint128\_sat\_add\_ref<!-- {{#callable:fd_uint128_sat_add_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L168>)

Performs saturated addition of two 128-bit unsigned integers.
- **Inputs**:
    - `x`: The first 128-bit unsigned integer operand.
    - `y`: The second 128-bit unsigned integer operand.
- **Logic and Control Flow**:
    - Calculate the sum of `x` and `y` and store it in `res`.
    - Check if `res` is less than `x`, indicating an overflow.
    - If overflow occurs, return `UINT128_MAX`; otherwise, return `res`.
- **Output**: Returns the result of the saturated addition, which is either the sum of `x` and `y` or `UINT128_MAX` if overflow occurs.


---
### fd\_uint128\_sat\_mul\_ref<!-- {{#callable:fd_uint128_sat_mul_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L174>)

Performs a saturated multiplication of two 128-bit unsigned integers and returns the result, capping at `UINT128_MAX` if overflow occurs.
- **Inputs**:
    - `x`: The first 128-bit unsigned integer operand.
    - `y`: The second 128-bit unsigned integer operand.
- **Logic and Control Flow**:
    - Calculate the product of `x` and `y` and store it in `res`.
    - Determine if an overflow occurred by checking if both `x` and `y` are non-zero and if `res` is less than either `x` or `y`, or if `res` divided by `x` does not equal `y`.
    - Use the `fd_uint128_if` function to return `UINT128_MAX` if overflow is true, otherwise return `res`.
- **Output**: Returns the product of `x` and `y` as a 128-bit unsigned integer, or `UINT128_MAX` if overflow occurs.


---
### fd\_uint128\_sat\_sub\_ref<!-- {{#callable:fd_uint128_sat_sub_ref}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L181>)

Performs a subtraction of two 128-bit unsigned integers with saturation, returning zero if the result would be negative.
- **Inputs**:
    - `x`: The minuend, a 128-bit unsigned integer.
    - `y`: The subtrahend, a 128-bit unsigned integer.
- **Logic and Control Flow**:
    - Calculate the result of subtracting `y` from `x` and store it in `res`.
    - Check if `res` is greater than `x`, which indicates an underflow (i.e., `y` was greater than `x`).
    - If underflow is detected, return 0; otherwise, return `res`.
- **Output**: Returns the result of the subtraction if no underflow occurs; otherwise, returns 0.


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/util/bits/test_sat.c#L383>)

Initializes the environment, checks for `FD_HAS_INT128` capability, and logs a warning if the capability is not present before halting.
- **Inputs**:
    - `argc`: The count of command-line arguments.
    - `argv`: The array of command-line arguments.
- **Logic and Control Flow**:
    - Call `fd_boot` to initialize the environment with `argc` and `argv`.
    - Log a warning message indicating that the unit test requires `FD_HAS_INT128` capability.
    - Call `fd_halt` to terminate the program.
- **Output**: Returns 0, indicating successful execution.



---
Made with ❤️ by [Driver](https://www.driver.ai/)