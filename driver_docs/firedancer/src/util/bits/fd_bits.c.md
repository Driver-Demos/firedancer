<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for calculating approximate, floor, ceiling, and rounded square and cube roots of unsigned long integers.

# Purpose
The code provides a set of functions to compute the square root and cube root of an unsigned long integer (`ulong`) with different rounding methods. The functions include [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>), [`fd_ulong_round_sqrt`](<#fd_ulong_round_sqrt>), [`fd_ulong_floor_sqrt`](<#fd_ulong_floor_sqrt>), and [`fd_ulong_ceil_sqrt`](<#fd_ulong_ceil_sqrt>) for square roots, and [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>), [`fd_ulong_round_cbrt`](<#fd_ulong_round_cbrt>), [`fd_ulong_floor_cbrt`](<#fd_ulong_floor_cbrt>), and [`fd_ulong_ceil_cbrt`](<#fd_ulong_ceil_cbrt>) for cube roots. Each function uses a combination of bit manipulation and Newton-Raphson iteration to approximate the root value. The functions handle edge cases, such as when the input is zero, and use precomputed tables for efficient computation.

The code is organized into individual functions that each perform a specific type of root calculation. The functions use a common approach of breaking down the input number into components that allow for efficient computation of the root using integer arithmetic. The functions [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>) and [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>) provide initial approximations, which are then refined by the other functions to achieve the desired rounding behavior (round, floor, or ceil). The code is intended to be part of a larger library, as indicated by the inclusion of the header file `fd_bits.h`, and does not define a main function, suggesting it is not an executable but rather a utility for other programs to use.
# Imports and Dependencies

---
- `fd_bits.h`


# Functions

---
### fd\_ulong\_approx\_sqrt<!-- {{#callable:fd_ulong_approx_sqrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L3>)

Approximates the square root of an unsigned long integer using bit manipulation and precomputed tables.
- **Inputs**:
    - `x`: An unsigned long integer for which the approximate square root is to be calculated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Find the most significant bit position `e` of `x` using [`fd_ulong_find_msb`](<fd_bits_find_msb.h.md#fd_ulong_find_msb>).
    - Calculate `m` by left-shifting `x` by `(63-e)`.
    - Determine `q` as `e` divided by 2 and `r` as `e` modulo 2.
    - Calculate the table index `i` using `4*r + (m >> 61) & 3UL`.
    - Extract `h` as the upper 32 bits of `m` shifted right by 29.
    - Use precomputed tables `a` and `b` to calculate the approximate square root.
    - Return the result of the expression `(a[i] + b[i]*h + (1UL<<(61-q))) >> (62-q)`.
- **Output**: Returns an unsigned long integer representing the approximate square root of `x`.
- **Functions Called**:
    - [`fd_ulong_find_msb`](<fd_bits_find_msb.h.md#fd_ulong_find_msb>)


---
### fd\_ulong\_round\_sqrt<!-- {{#callable:fd_ulong_round_sqrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L72>)

Calculates the integer closest to the square root of a given unsigned long integer, rounding ties towards zero.
- **Inputs**:
    - `x`: An unsigned long integer for which the function calculates the rounded square root.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Initialize `y` with an approximate square root of `x` using [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>).
    - Enter a loop to refine `y` using a modified Newton-Raphson iteration until convergence.
    - In each iteration, calculate `den` as `2*y` and `num` as `x - y*y + y - 1`.
    - Check if `num` is between 0 and `den`; if true, break the loop.
    - If not, adjust `y` by adding the result of the integer division of `num` by `den`, adjusted for negative `num` using `fd_long_if`.
    - Return the final value of `y`.
- **Output**: The function returns an unsigned long integer representing the rounded square root of `x`.
- **Functions Called**:
    - [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>)


---
### fd\_ulong\_floor\_sqrt<!-- {{#callable:fd_ulong_floor_sqrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L162>)

Calculates the largest integer less than or equal to the square root of a given unsigned long integer.
- **Inputs**:
    - `x`: The unsigned long integer for which the floor of the square root is to be calculated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Initialize `y` with an approximate square root of `x` using [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>).
    - Enter a loop to refine `y` using a modified Newton-Raphson iteration until convergence.
    - Calculate `den` as `2*y + 1` and `num` as `x - y*y`.
    - Check if `num` is between 0 and `den`; if true, break the loop.
    - Adjust `y` by adding the result of the division of `num` by `den`, ensuring floor division is used.
- **Output**: Returns the largest integer `y` such that `y^2` is less than or equal to `x`.
- **Functions Called**:
    - [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>)


---
### fd\_ulong\_ceil\_sqrt<!-- {{#callable:fd_ulong_ceil_sqrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L211>)

Calculates the smallest integer greater than or equal to the square root of a given unsigned long integer.
- **Inputs**:
    - `x`: An unsigned long integer for which the ceiling of the square root is to be calculated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Initialize `y` with an approximate square root of `x` using [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>).
    - Enter a loop to refine `y` using a modified Newton-Raphson iteration until convergence.
    - Calculate `tmp` as `y` shifted left by 1.
    - Calculate `den` as `tmp` minus 1.
    - Calculate `num` as `x` minus `y` squared plus `tmp` minus 2.
    - Check if `num` is non-negative and less than `den`; if true, break the loop.
    - Adjust `y` by adding the result of the division of `num` adjusted for floor division by `den`.
- **Output**: Returns the smallest integer `y` such that `y` squared is greater than or equal to `x`.
- **Functions Called**:
    - [`fd_ulong_approx_sqrt`](<#fd_ulong_approx_sqrt>)


---
### fd\_ulong\_approx\_cbrt<!-- {{#callable:fd_ulong_approx_cbrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L264>)

Approximates the cube root of an unsigned long integer using bit manipulation and precomputed constants.
- **Inputs**:
    - `x`: The unsigned long integer for which to approximate the cube root.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Find the most significant bit position `e` of `x` using [`fd_ulong_find_msb`](<fd_bits_find_msb.h.md#fd_ulong_find_msb>).
    - Shift `x` left by `(63-e)` to compute `m`, ensuring `m` is in the range [2^63, 2^64).
    - Calculate `q` as the integer division of `e` by 3, which determines the power of 2 scaling factor.
    - Calculate `r` as the remainder of `e` divided by 3, which helps determine the index for the precomputed tables.
    - Compute `i` as `2*r + (m >> 62) & 1UL`, which is used to index into the precomputed tables `a` and `b`.
    - Shift `m` right by 30 bits to compute `h`, which is used in the linear approximation.
    - Use the precomputed tables `a` and `b` to calculate the approximate cube root using the formula `(a[i] + b[i]*h + (1UL<<(61-q))) >> (62-q)`.
- **Output**: Returns an unsigned long integer that approximates the cube root of `x`.
- **Functions Called**:
    - [`fd_ulong_find_msb`](<fd_bits_find_msb.h.md#fd_ulong_find_msb>)


---
### fd\_ulong\_round\_cbrt<!-- {{#callable:fd_ulong_round_cbrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L287>)

Calculates the integer cube root of a given unsigned long integer, rounding to the nearest integer.
- **Inputs**:
    - `x`: An unsigned long integer for which the cube root is to be calculated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Initialize `y` with an approximate cube root of `x` using [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>).
    - Enter a loop to refine `y` using a Newton-Raphson-like method adapted for integer arithmetic.
    - Calculate `ysq` as the square of `y`.
    - Compute `num` as `4 * (x - y * ysq) + 6 * ysq - 3 * y`.
    - Compute `den` as `12 * ysq + 1`.
    - Check if `num` is between 0 and `den`; if true, break the loop.
    - Adjust `y` by adding the result of `(num - fd_long_if(num >= 0, 0, den - 1)) / den` to it.
    - Return the refined value of `y`.
- **Output**: The function returns the cube root of `x`, rounded to the nearest integer, as an unsigned long integer.
- **Functions Called**:
    - [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>)


---
### fd\_ulong\_floor\_cbrt<!-- {{#callable:fd_ulong_floor_cbrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L313>)

Calculates the largest integer cube root of a given unsigned long integer.
- **Inputs**:
    - `x`: The unsigned long integer for which the cube root is to be calculated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Initialize `y` with an approximate cube root of `x` using [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>).
    - Enter a loop to refine `y` using Newton-Raphson method generalized for integer arithmetic.
    - Calculate `ysq` as `y*y`.
    - Calculate `num` as `x - y*ysq`.
    - Calculate `den` as `3*(ysq+y) + 1`.
    - Check if `num` is in the range [0, `den`); if true, break the loop.
    - Update `y` by adding the result of the integer division of `num` adjusted for floor division by `den`.
    - Return the refined value of `y`.
- **Output**: The largest integer `y` such that `y^3` is less than or equal to `x`.
- **Functions Called**:
    - [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>)


---
### fd\_ulong\_ceil\_cbrt<!-- {{#callable:fd_ulong_ceil_cbrt}} -->
[View Source →](<../../../../../src/util/bits/fd_bits.c#L339>)

Calculates the smallest integer cube root of a given unsigned long integer that is greater than or equal to the actual cube root.
- **Inputs**:
    - `x`: An unsigned long integer for which the ceiling of the cube root is to be calculated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if so, return 0.
    - Initialize `y` with an approximate cube root of `x` using [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>).
    - Enter a loop to refine `y` using a Newton-Raphson-like method adapted for integer arithmetic.
    - Calculate `ysq` as the square of `y` and `tmp` as `3 * (ysq - y)`.
    - Compute `num` as `x - y * ysq + tmp` and `den` as `tmp + 1`.
    - Check if `num` is between 0 and `den`; if true, break the loop.
    - Adjust `y` by adding the result of the integer division of `num` by `den`, adjusted for negative numerators.
    - Return the refined value of `y`.
- **Output**: The smallest integer `y` such that `y^3` is greater than or equal to `x`.
- **Functions Called**:
    - [`fd_ulong_approx_cbrt`](<#fd_ulong_approx_cbrt>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)