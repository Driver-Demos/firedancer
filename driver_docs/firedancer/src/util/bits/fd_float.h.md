<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for manipulating and classifying IEEE-754 floating-point bit patterns in C.

# Purpose
The code in this file provides utility functions for handling IEEE-754 floating-point representations in C. It includes functions for both single precision (`float`) and, conditionally, double precision (`double`) floating-point numbers. The primary purpose is to manipulate and classify the bit patterns of these floating-point numbers without relying on standard library functions, which may behave differently depending on compiler optimizations and hardware. The file defines functions to convert between floating-point numbers and their bit representations, extract components such as the sign, exponent, and mantissa, and classify numbers as zero, denormalized, infinity, NaN, or normal.

The file is structured as a C header file, which suggests it is intended to be included in other C source files. It defines a set of inline functions that perform operations on the bit-level representation of floating-point numbers. These functions are designed to be efficient and provide consistent results across different platforms and compiler settings. The file also includes conditional compilation for double precision operations, which are only included if the `FD_HAS_DOUBLE` macro is defined. This modular approach allows for flexibility in usage depending on the precision requirements of the application.
# Imports and Dependencies

---
- `fd_bits.h`


# Functions

---
### fd\_fltbits<!-- {{#callable:fd_fltbits}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L38>)

Converts a float to its equivalent 32-bit unsigned integer representation.
- **Inputs**:
    - `f`: A floating-point number to convert to a 32-bit unsigned integer representation.
- **Logic and Control Flow**:
    - Declare a union `tmp` with a 32-bit unsigned integer array `u` and a float array `f`.
    - Assign the input float `f` to the first element of the float array `tmp.f`.
    - Return the first element of the unsigned integer array `tmp.u` cast to an `ulong`.
- **Output**: A 32-bit unsigned integer (`ulong`) representing the bit pattern of the input float.


---
### fd\_fltbits\_sign<!-- {{#callable:fd_fltbits_sign}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L86>)

Extracts the sign bit from a 32-bit unsigned integer representing a floating-point number.
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing a floating-point number.
- **Logic and Control Flow**:
    - Right shifts the input `u` by 31 bits to isolate the sign bit.
- **Output**: Returns the sign bit as a 1-bit unsigned long integer.


---
### fd\_fltbits\_bexp<!-- {{#callable:fd_fltbits_bexp}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L87>)

Extracts the 8-bit biased exponent from a 32-bit floating-point representation.
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing a floating-point number.
- **Logic and Control Flow**:
    - Right shifts the input `u` by 23 bits to align the biased exponent to the least significant bits.
    - Applies a bitwise AND operation with `255UL` to isolate the 8-bit biased exponent.
- **Output**: Returns the 8-bit biased exponent as an unsigned long integer.


---
### fd\_fltbits\_mant<!-- {{#callable:fd_fltbits_mant}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L88>)

Extracts the 23-bit mantissa from a 32-bit unsigned integer representing a floating-point number.
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing a floating-point number.
- **Logic and Control Flow**:
    - Performs a bitwise AND operation between the input `u` and the constant `8388607UL` to isolate the mantissa bits.
- **Output**: Returns the 23-bit mantissa as an unsigned long integer.


---
### fd\_fltbits\_unbias<!-- {{#callable:fd_fltbits_unbias}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L90>)

Calculates the unbiased exponent from a biased exponent for single-precision floating-point numbers.
- **Inputs**:
    - `b`: An 8-bit unsigned long integer representing the biased exponent.
- **Logic and Control Flow**:
    - Convert the 8-bit biased exponent `b` to a long integer.
    - Subtract 127 from the converted long integer to obtain the unbiased exponent.
- **Output**: A long integer in the range [-127, 128] representing the unbiased exponent.


---
### fd\_fltbits\_bias<!-- {{#callable:fd_fltbits_bias}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L91>)

Calculates the biased exponent for a given exponent in the range [-127, 128].
- **Inputs**:
    - `e`: A long integer representing the exponent, which must be in the range [-127, 128].
- **Logic and Control Flow**:
    - Adds 127 to the input exponent `e`.
    - Casts the result to an unsigned long integer.
- **Output**: Returns the biased exponent as an unsigned long integer.


---
### fd\_fltbits\_pack<!-- {{#callable:fd_fltbits_pack}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L93>)

Packs a sign bit, biased exponent, and mantissa into a 32-bit floating-point representation.
- **Inputs**:
    - `s`: A 1-bit unsigned long representing the sign bit.
    - `b`: An 8-bit unsigned long representing the biased exponent.
    - `m`: A 23-bit unsigned long representing the mantissa.
- **Logic and Control Flow**:
    - Shift the sign bit `s` 31 positions to the left.
    - Shift the biased exponent `b` 23 positions to the left.
    - Combine the shifted sign, biased exponent, and mantissa using bitwise OR operations.
- **Output**: Returns a 32-bit unsigned long representing the packed floating-point number.


---
### fd\_float<!-- {{#callable:fd_float}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L100>)

Converts a 32-bit unsigned integer to a floating-point number by reinterpreting its bit pattern.
- **Inputs**:
    - `u`: A 32-bit unsigned integer to be reinterpreted as a float.
- **Logic and Control Flow**:
    - Declare a union `tmp` with a 32-bit unsigned integer array and a float array.
    - Assign the input `u` to the first element of the unsigned integer array in `tmp`.
    - Return the first element of the float array in `tmp`, which now contains the float representation of `u`.
- **Output**: A floating-point number that shares the same bit pattern as the input unsigned integer.


---
### fd\_fltbits\_is\_zero<!-- {{#callable:fd_fltbits_is_zero}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L107>)

Checks if the given floating-point bit representation corresponds to a signed zero.
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing the bit pattern of a floating-point number.
- **Logic and Control Flow**:
    - Extracts the biased exponent from the input `u` using [`fd_fltbits_bexp`](<#fd_fltbits_bexp>) and checks if it is zero.
    - Extracts the mantissa from the input `u` using [`fd_fltbits_mant`](<#fd_fltbits_mant>) and checks if it is zero.
    - Returns 1 if both the biased exponent and mantissa are zero, indicating a signed zero; otherwise, returns 0.
- **Output**: Returns 1 if the input represents a signed zero, otherwise returns 0.
- **Functions Called**:
    - [`fd_fltbits_bexp`](<#fd_fltbits_bexp>)
    - [`fd_fltbits_mant`](<#fd_fltbits_mant>)


---
### fd\_fltbits\_is\_denorm<!-- {{#callable:fd_fltbits_is_denorm}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L113>)

Checks if a given 32-bit floating-point bit pattern represents a denormalized number.
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing the bit pattern of a floating-point number.
- **Logic and Control Flow**:
    - Extracts the biased exponent from the input `u` using `fd_fltbits_bexp(u)` and checks if it is equal to 0.
    - Extracts the mantissa from the input `u` using `fd_fltbits_mant(u)` and checks if it is not equal to 0.
    - Returns the result of a bitwise AND operation between the two conditions above.
- **Output**: Returns 1 if the input represents a denormalized number, otherwise returns 0.
- **Functions Called**:
    - [`fd_fltbits_bexp`](<#fd_fltbits_bexp>)
    - [`fd_fltbits_mant`](<#fd_fltbits_mant>)


---
### fd\_fltbits\_is\_inf<!-- {{#callable:fd_fltbits_is_inf}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L119>)

Checks if a 32-bit floating-point bit pattern represents positive or negative infinity.
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing the bit pattern of a floating-point number.
- **Logic and Control Flow**:
    - Extracts the biased exponent from `u` using [`fd_fltbits_bexp`](<#fd_fltbits_bexp>) and checks if it equals 255.
    - Extracts the mantissa from `u` using [`fd_fltbits_mant`](<#fd_fltbits_mant>) and checks if it equals 0.
    - Returns 1 if both conditions are true, indicating infinity; otherwise, returns 0.
- **Output**: Returns 1 if the bit pattern represents infinity, otherwise returns 0.
- **Functions Called**:
    - [`fd_fltbits_bexp`](<#fd_fltbits_bexp>)
    - [`fd_fltbits_mant`](<#fd_fltbits_mant>)


---
### fd\_fltbits\_is\_nan<!-- {{#callable:fd_fltbits_is_nan}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L125>)

Determines if a 32-bit floating-point bit pattern represents a NaN (Not a Number).
- **Inputs**:
    - `u`: A 32-bit unsigned integer representing the bit pattern of a floating-point number.
- **Logic and Control Flow**:
    - Extracts the biased exponent from the input `u` using `fd_fltbits_bexp(u)` and checks if it equals 255, indicating a special floating-point value (infinity or NaN).
    - Extracts the mantissa from the input `u` using `fd_fltbits_mant(u)` and checks if it is not equal to 0, which differentiates NaN from infinity.
    - Returns 1 if both conditions are true, indicating the input represents a NaN; otherwise, returns 0.
- **Output**: Returns 1 if the input represents a NaN, otherwise returns 0.
- **Functions Called**:
    - [`fd_fltbits_bexp`](<#fd_fltbits_bexp>)
    - [`fd_fltbits_mant`](<#fd_fltbits_mant>)


---
### fd\_fltbits\_is\_normal<!-- {{#callable:fd_fltbits_is_normal}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L131>)

Determines if a floating-point bit pattern represents a normal number in IEEE-754 format.
- **Inputs**:
    - `u`: An unsigned long integer representing the bit pattern of a floating-point number.
- **Logic and Control Flow**:
    - Checks if `u` is not zero using [`fd_fltbits_is_zero`](<#fd_fltbits_is_zero>) function.
    - Checks if `u` is not a denormalized number using [`fd_fltbits_is_denorm`](<#fd_fltbits_is_denorm>) function.
    - Checks if `u` is not infinity using [`fd_fltbits_is_inf`](<#fd_fltbits_is_inf>) function.
    - Checks if `u` is not NaN using [`fd_fltbits_is_nan`](<#fd_fltbits_is_nan>) function.
    - Returns 1 if all checks are true, indicating `u` is a normal number; otherwise, returns 0.
- **Output**: Returns 1 if the bit pattern represents a normal number; otherwise, returns 0.
- **Functions Called**:
    - [`fd_fltbits_is_zero`](<#fd_fltbits_is_zero>)
    - [`fd_fltbits_is_denorm`](<#fd_fltbits_is_denorm>)
    - [`fd_fltbits_is_inf`](<#fd_fltbits_is_inf>)
    - [`fd_fltbits_is_nan`](<#fd_fltbits_is_nan>)


---
### fd\_dblbits<!-- {{#callable:fd_dblbits}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L141>)

Converts a double-precision floating-point number to its 64-bit unsigned integer representation.
- **Inputs**:
    - `f`: A double-precision floating-point number to convert.
- **Logic and Control Flow**:
    - Declare a union `tmp` with a 64-bit unsigned integer array and a double array.
    - Assign the input double `f` to the first element of the double array in the union.
    - Return the first element of the unsigned integer array from the union, which now contains the bit representation of the double.
- **Output**: A 64-bit unsigned integer representing the bit pattern of the input double.


---
### fd\_dblbits\_sign<!-- {{#callable:fd_dblbits_sign}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L148>)

Extracts the sign bit from a 64-bit unsigned integer representing a double-precision floating-point number.
- **Inputs**:
    - `u`: A 64-bit unsigned integer representing a double-precision floating-point number.
- **Logic and Control Flow**:
    - Right shifts the input `u` by 63 bits to isolate the sign bit.
- **Output**: Returns the sign bit as a 1-bit unsigned long integer.


---
### fd\_dblbits\_bexp<!-- {{#callable:fd_dblbits_bexp}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L149>)

Extracts the 11-bit biased exponent from a 64-bit double-precision floating-point representation.
- **Inputs**:
    - `u`: A 64-bit unsigned long integer representing a double-precision floating-point number.
- **Logic and Control Flow**:
    - Right shifts the input `u` by 52 bits to align the exponent bits to the least significant position.
    - Applies a bitwise AND operation with `2047UL` to isolate the 11-bit biased exponent.
- **Output**: Returns the 11-bit biased exponent as an unsigned long integer.


---
### fd\_dblbits\_mant<!-- {{#callable:fd_dblbits_mant}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L150>)

Extracts the 52-bit mantissa from a 64-bit unsigned integer representing a double-precision floating-point number.
- **Inputs**:
    - `u`: A 64-bit unsigned integer representing a double-precision floating-point number.
- **Logic and Control Flow**:
    - Performs a bitwise AND operation between the input `u` and the constant `4503599627370495UL` to isolate the 52-bit mantissa.
- **Output**: A 52-bit unsigned long integer representing the mantissa of the double-precision floating-point number.


---
### fd\_dblbits\_unbias<!-- {{#callable:fd_dblbits_unbias}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L152>)

Converts a biased exponent from a double-precision floating-point representation to its unbiased form.
- **Inputs**:
    - `b`: An 11-bit unsigned long integer representing the biased exponent of a double-precision floating-point number.
- **Logic and Control Flow**:
    - Subtracts 1023 from the input `b` to convert the biased exponent to an unbiased exponent.
- **Output**: Returns a long integer representing the unbiased exponent, which ranges from -1023 to 1024.


---
### fd\_dblbits\_bias<!-- {{#callable:fd_dblbits_bias}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L153>)

Calculates the biased exponent for a given exponent in double precision floating-point representation.
- **Inputs**:
    - `e`: A long integer representing the exponent in the range [-1023, 1024].
- **Logic and Control Flow**:
    - Adds 1023 to the input exponent `e`.
    - Casts the result to an unsigned long integer.
- **Output**: An unsigned long integer representing the biased exponent.


---
### fd\_dblbits\_pack<!-- {{#callable:fd_dblbits_pack}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L155>)

Packs a sign bit, an 11-bit biased exponent, and a 52-bit mantissa into a 64-bit unsigned long integer representing a double-precision floating-point number.
- **Inputs**:
    - `s`: A 1-bit unsigned long integer representing the sign of the double-precision floating-point number.
    - `b`: An 11-bit unsigned long integer representing the biased exponent of the double-precision floating-point number.
    - `m`: A 52-bit unsigned long integer representing the mantissa of the double-precision floating-point number.
- **Logic and Control Flow**:
    - Shift the sign bit `s` left by 63 positions.
    - Shift the biased exponent `b` left by 52 positions.
    - Combine the shifted sign, shifted exponent, and mantissa `m` using bitwise OR operations to form the final 64-bit result.
- **Output**: A 64-bit unsigned long integer representing the packed double-precision floating-point number.


---
### fd\_double<!-- {{#callable:fd_double}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L162>)

Converts a 64-bit unsigned integer to a double-precision floating-point number by reinterpreting the bit pattern.
- **Inputs**:
    - `u`: A 64-bit unsigned integer representing the bit pattern of a double-precision floating-point number.
- **Logic and Control Flow**:
    - Declare a union `tmp` with a 64-bit unsigned integer array and a double array.
    - Assign the input `u` to the first element of the unsigned integer array in `tmp`.
    - Return the first element of the double array in `tmp`, which now contains the double-precision floating-point number corresponding to the bit pattern of `u`.
- **Output**: A double-precision floating-point number that shares the same bit pattern as the input 64-bit unsigned integer.


---
### fd\_dblbits\_is\_zero<!-- {{#callable:fd_dblbits_is_zero}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L169>)

Checks if a double-precision floating-point number, represented by its bit pattern, is zero.
- **Inputs**:
    - `u`: An unsigned long integer representing the bit pattern of a double-precision floating-point number.
- **Logic and Control Flow**:
    - Extracts the biased exponent from the bit pattern using `fd_dblbits_bexp(u)` and checks if it is zero.
    - Extracts the mantissa from the bit pattern using `fd_dblbits_mant(u)` and checks if it is zero.
    - Returns the result of a bitwise AND operation between the two checks, indicating if both the biased exponent and mantissa are zero.
- **Output**: Returns 1 if the input represents a zero value in double-precision floating-point format, otherwise returns 0.
- **Functions Called**:
    - [`fd_dblbits_bexp`](<#fd_dblbits_bexp>)
    - [`fd_dblbits_mant`](<#fd_dblbits_mant>)


---
### fd\_dblbits\_is\_denorm<!-- {{#callable:fd_dblbits_is_denorm}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L175>)

Checks if a given 64-bit unsigned integer represents a denormalized double-precision floating-point number.
- **Inputs**:
    - `u`: A 64-bit unsigned integer representing the bit pattern of a double-precision floating-point number.
- **Logic and Control Flow**:
    - Calls `fd_dblbits_bexp(u)` to extract the biased exponent from the input `u`.
    - Checks if the biased exponent is zero, indicating a potential denormalized number.
    - Calls `fd_dblbits_mant(u)` to extract the mantissa from the input `u`.
    - Checks if the mantissa is non-zero, confirming the number is denormalized.
    - Returns the result of a bitwise AND operation between the two conditions.
- **Output**: Returns 1 if the input represents a denormalized double-precision floating-point number, otherwise returns 0.
- **Functions Called**:
    - [`fd_dblbits_bexp`](<#fd_dblbits_bexp>)
    - [`fd_dblbits_mant`](<#fd_dblbits_mant>)


---
### fd\_dblbits\_is\_inf<!-- {{#callable:fd_dblbits_is_inf}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L181>)

Checks if a 64-bit unsigned integer represents positive or negative infinity in IEEE-754 double precision format.
- **Inputs**:
    - `u`: A 64-bit unsigned integer representing a double precision floating-point number.
- **Logic and Control Flow**:
    - Calls `fd_dblbits_bexp(u)` to extract the biased exponent from `u` and checks if it equals 2047, which indicates infinity in double precision.
    - Calls `fd_dblbits_mant(u)` to extract the mantissa from `u` and checks if it equals 0, which is required for the number to be infinity.
    - Returns the result of a bitwise AND operation between the two checks, which will be 1 if both conditions are true, indicating that `u` represents infinity.
- **Output**: Returns 1 if `u` represents positive or negative infinity, otherwise returns 0.
- **Functions Called**:
    - [`fd_dblbits_bexp`](<#fd_dblbits_bexp>)
    - [`fd_dblbits_mant`](<#fd_dblbits_mant>)


---
### fd\_dblbits\_is\_nan<!-- {{#callable:fd_dblbits_is_nan}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L187>)

Determines if a 64-bit unsigned integer represents a NaN (Not a Number) in IEEE-754 double precision format.
- **Inputs**:
    - `u`: A 64-bit unsigned integer representing the bit pattern of a double precision floating-point number.
- **Logic and Control Flow**:
    - Calls `fd_dblbits_bexp(u)` to extract the biased exponent from the input `u`.
    - Checks if the biased exponent equals 2047, which indicates a special value (infinity or NaN) in IEEE-754 double precision format.
    - Calls `fd_dblbits_mant(u)` to extract the mantissa from the input `u`.
    - Checks if the mantissa is not equal to 0, which differentiates NaN from infinity.
    - Returns the result of a bitwise AND operation between the two conditions: biased exponent equals 2047 and mantissa is not zero.
- **Output**: Returns 1 if the input represents a NaN, otherwise returns 0.
- **Functions Called**:
    - [`fd_dblbits_bexp`](<#fd_dblbits_bexp>)
    - [`fd_dblbits_mant`](<#fd_dblbits_mant>)


---
### fd\_dblbits\_is\_normal<!-- {{#callable:fd_dblbits_is_normal}} -->
[View Source →](<../../../../../src/util/bits/fd_float.h#L193>)

Determines if a double-precision floating-point number is a normal number by checking its bit representation.
- **Inputs**:
    - `u`: An unsigned long integer representing the bit pattern of a double-precision floating-point number.
- **Logic and Control Flow**:
    - Call [`fd_dblbits_is_zero`](<#fd_dblbits_is_zero>) with `u` to check if the number is zero.
    - Call [`fd_dblbits_is_denorm`](<#fd_dblbits_is_denorm>) with `u` to check if the number is denormalized.
    - Call [`fd_dblbits_is_inf`](<#fd_dblbits_is_inf>) with `u` to check if the number is infinite.
    - Call [`fd_dblbits_is_nan`](<#fd_dblbits_is_nan>) with `u` to check if the number is NaN.
    - Return 1 if none of the above checks are true, indicating the number is normal; otherwise, return 0.
- **Output**: Returns 1 if the number is normal, otherwise returns 0.
- **Functions Called**:
    - [`fd_dblbits_is_zero`](<#fd_dblbits_is_zero>)
    - [`fd_dblbits_is_denorm`](<#fd_dblbits_is_denorm>)
    - [`fd_dblbits_is_inf`](<#fd_dblbits_is_inf>)
    - [`fd_dblbits_is_nan`](<#fd_dblbits_is_nan>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)