<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements clock synchronization and recalibration functions using linear approximations and error handling.

# Purpose
The code is a C module that manages the synchronization and calibration of two clocks, referred to as the x-clock and y-clock. It provides functions to align, initialize, join, leave, delete, and recalibrate these clocks. The module uses a shared memory structure, `fd_clock_shmem_t`, to store clock data and parameters, and it implements a mechanism to estimate the relationship between the two clocks using a linear approximation. The recalibration process involves calculating an observed tick rate and adjusting the estimated rate to minimize clock drift while maintaining monotonicity.

Key functions include [`fd_clock_new`](<#fd_clock_new>), which initializes a new clock instance in shared memory, and [`fd_clock_recal`](<#fd_clock_recal>), which recalibrates the clock based on new observations. The module also provides utility functions such as [`fd_clock_now`](<#fd_clock_now>) to get the current time from the y-clock, and [`fd_clock_joint_read`](<#fd_clock_joint_read>) to read both clocks simultaneously. Error handling is implemented through functions like [`fd_clock_strerror`](<#fd_clock_strerror>), which returns error messages based on error codes. The module ensures that the clocks remain synchronized and that any drift is corrected over time, using a decaying average filter to adjust the tick rate estimates.
# Imports and Dependencies

---
- `fd_clock.h`


# Functions

---
### fd\_clock\_align<!-- {{#callable:fd_clock_align}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L133>)

Returns the alignment requirement of the `fd_clock_shmem_t` type.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the `alignof` operator on the `fd_clock_shmem_t` type to determine its alignment requirement.
    - Returns the result of the `alignof` operation.
- **Output**: An `unsigned long` representing the alignment requirement of the `fd_clock_shmem_t` type.


---
### fd\_clock\_footprint<!-- {{#callable:fd_clock_footprint}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L138>)

Calculates the memory footprint of the `fd_clock_shmem_t` structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the size of the `fd_clock_shmem_t` structure using the `sizeof` operator.
- **Output**: Returns an unsigned long integer representing the size of the `fd_clock_shmem_t` structure.


---
### fd\_clock\_new<!-- {{#callable:fd_clock_new}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L143>)

Initializes a shared memory clock structure with specified recalibration parameters and initial values.
- **Inputs**:
    - `shmem`: Pointer to shared memory where the clock structure will be initialized.
    - `recal_avg`: Average recalibration interval in ticks.
    - `recal_jit`: Jitter in recalibration interval; if zero, it defaults to a calculated value based on `recal_avg`.
    - `recal_hist`: History factor for recalibration; if zero, it defaults to 3.
    - `recal_frac`: Fraction of drift to absorb in recalibration; if zero, it defaults to 1.
    - `init_x0`: Initial x-clock observation.
    - `init_y0`: Initial y-clock observation.
    - `init_w`: Initial x-tick per y-tick rate; must be positive.
- **Logic and Control Flow**:
    - Cast `shmem` to `fd_clock_shmem_t` pointer `shclock`.
    - Set default values for `recal_jit`, `recal_hist`, and `recal_frac` if they are zero.
    - Check if `shclock` is NULL or misaligned, and return NULL with a warning if so.
    - Validate recalibration parameters (`recal_jit`, `recal_avg`, `recal_hist`, `recal_frac`) and return NULL with a warning if invalid.
    - Calculate `init_m` as the inverse of `init_w` and validate `init_w` and `init_m` are positive.
    - Get the footprint size using `fd_clock_footprint()` and return NULL with a warning if zero.
    - Clear the memory for `shclock` using `memset`.
    - Calculate effective jitter `recal_jit_eff`, minimum recalibration interval `recal_min`, and mask `recal_mask`.
    - Initialize `shclock` fields with recalibration parameters, initial values, and calculated values.
    - Initialize each epoch in `shclock->epoch` with initial values and calculated `init_m`.
    - Set `shclock->magic` to `FD_CLOCK_MAGIC` to mark the structure as initialized.
    - Return the initialized `shclock` pointer.
- **Output**: Pointer to the initialized `fd_clock_shmem_t` structure, or NULL if initialization fails.
- **Functions Called**:
    - [`fd_clock_align`](<#fd_clock_align>)
    - [`fd_clock_footprint`](<#fd_clock_footprint>)


---
### fd\_clock\_join<!-- {{#callable:fd_clock_join}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L238>)

Initializes a `fd_clock_t` structure by validating and linking it to a shared memory clock and a clock function.
- **Inputs**:
    - `_lmem`: A pointer to local memory where the `fd_clock_t` structure will be initialized.
    - `_shclock`: A pointer to shared memory representing the clock state.
    - `clock_x`: A function pointer to a clock function that provides time observations.
    - `args_x`: A pointer to arguments for the clock function `clock_x`.
- **Logic and Control Flow**:
    - Cast `_lmem` to a `fd_clock_t` pointer and `_shclock` to a `fd_clock_shmem_t` pointer.
    - Check if `clock` is NULL; if so, log a warning and return NULL.
    - Check if `clock` is misaligned; if so, log a warning and return NULL.
    - Check if `shclock` is NULL; if so, log a warning and return NULL.
    - Check if `shclock` is misaligned; if so, log a warning and return NULL.
    - Verify that `shclock->magic` matches `FD_CLOCK_MAGIC`; if not, log a warning and return NULL.
    - Check if `clock_x` is NULL; if so, log a warning and return NULL.
    - Assign `shclock`, `clock_x`, and `args_x` to the `clock` structure.
    - Return the initialized `clock` structure.
- **Output**: A pointer to the initialized `fd_clock_t` structure, or NULL if any validation fails.
- **Functions Called**:
    - [`fd_clock_align`](<#fd_clock_align>)


---
### fd\_clock\_leave<!-- {{#callable:fd_clock_leave}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L283>)

Returns the input `fd_clock_t` pointer if it is not NULL, otherwise logs a warning and returns NULL.
- **Inputs**:
    - `clock`: A pointer to an `fd_clock_t` structure that represents the clock to leave.
- **Logic and Control Flow**:
    - Check if the `clock` pointer is NULL using `FD_UNLIKELY`.
    - If `clock` is NULL, log a warning message 'NULL clock' and return NULL.
    - If `clock` is not NULL, return the `clock` pointer.
- **Output**: Returns the `fd_clock_t` pointer if it is not NULL, otherwise returns NULL.


---
### fd\_clock\_delete<!-- {{#callable:fd_clock_delete}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L294>)

Deletes a shared memory clock object by validating its alignment and magic number, then resetting its magic number to zero.
- **Inputs**:
    - `_shclock`: A pointer to the shared memory clock object (`fd_clock_shmem_t`) to be deleted.
- **Logic and Control Flow**:
    - Cast `_shclock` to a `fd_clock_shmem_t` pointer named `shclock`.
    - Check if `shclock` is NULL; if true, log a warning and return NULL.
    - Check if `shclock` is aligned according to `fd_clock_align()`; if not, log a warning and return NULL.
    - Check if `shclock->magic` equals `FD_CLOCK_MAGIC`; if not, log a warning and return NULL.
    - Use `FD_COMPILER_MFENCE()` to ensure memory operations are completed before and after setting `shclock->magic` to 0.
    - Return the `shclock` pointer.
- **Output**: Returns the pointer to the shared memory clock object if successful, or NULL if any validation fails.
- **Functions Called**:
    - [`fd_clock_align`](<#fd_clock_align>)


---
### fd\_clock\_now<!-- {{#callable:fd_clock_now}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L320>)

Retrieves the current time from a shared memory clock, ensuring consistency by checking sequence numbers.
- **Inputs**:
    - `_clock`: A pointer to a `fd_clock_t` structure, which contains the shared memory clock and function pointers for clock operations.
- **Logic and Control Flow**:
    - Cast `_clock` to a `fd_clock_t` pointer and extract `shclock`, `clock_x`, and `args_x` from it.
    - Enter an infinite loop to ensure consistent reading of the clock data.
    - Read the sequence number `seq0` from `shclock` and store it.
    - Read the epoch data from `shclock` using `seq0`.
    - Call the function `clock_x` with `args_x` to get the observed x-clock time `x_obs`.
    - Read the sequence number `seq1` from `shclock`.
    - Check if `seq0`, `seq1`, and the epoch's sequence numbers are consistent; if so, break the loop.
    - If not consistent, pause and retry the loop.
    - Return the y-clock time calculated from the epoch data and `x_obs` using [`fd_clock_epoch_y`](<fd_clock.h.md#fd_clock_epoch_y>).
- **Output**: Returns a `long` integer representing the current y-clock time.
- **Functions Called**:
    - [`fd_clock_seq`](<fd_clock.h.md#fd_clock_seq>)
    - [`fd_clock_epoch_read`](<fd_clock.h.md#fd_clock_epoch_read>)
    - [`fd_clock_epoch_y`](<fd_clock.h.md#fd_clock_epoch_y>)


---
### fd\_clock\_joint\_read<!-- {{#callable:fd_clock_joint_read}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L340>)

Reads clock values from two clock functions, calculates the best index based on the smallest difference in x-clock values, and optionally stores the results.
- **Inputs**:
    - `clock_x`: A function pointer to the x-clock function.
    - `args_x`: A pointer to the arguments for the x-clock function.
    - `clock_y`: A function pointer to the y-clock function.
    - `args_y`: A pointer to the arguments for the y-clock function.
    - `opt_x`: An optional pointer to store the calculated x-clock value.
    - `opt_y`: An optional pointer to store the calculated y-clock value.
    - `opt_dx`: An optional pointer to store the calculated difference in x-clock values.
- **Logic and Control Flow**:
    - Initialize arrays `x` and `y` to store clock readings.
    - Loop `FD_CLOCK_JOINT_READ_CNT` times to fill `x` and `y` with clock readings from `clock_x` and `clock_y`.
    - Take an additional reading for `x` to complete the array.
    - Initialize `best_idx` to 0 and calculate `best_dx` as the difference between the first two x-clock readings.
    - Check if `best_dx` is negative; if so, return `FD_CLOCK_ERR_X`.
    - Loop through the remaining indices to calculate differences `dy` and `dx` for y-clock and x-clock readings, respectively.
    - Check if `dy` or `dx` is negative; if so, return `FD_CLOCK_ERR_Y` or `FD_CLOCK_ERR_X` accordingly.
    - Update `best_idx` and `best_dx` based on the smallest `dx` value found.
    - Calculate `best_dx` as the ceiling of half the difference between the best consecutive x-clock readings.
    - Optionally store the calculated values in `opt_x`, `opt_y`, and `opt_dx`.
- **Output**: Returns `FD_CLOCK_SUCCESS` on successful execution, or an error code if the x-clock or y-clock is not well-behaved.


---
### fd\_clock\_next<!-- {{#callable:fd_clock_next}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L376>)

Updates the shared memory clock state with new epoch data and calculates the next recalibration time.
- **Inputs**:
    - `shclock`: Pointer to the shared memory clock structure `fd_clock_shmem_t`.
    - `x0`: The initial x-clock observation for the epoch.
    - `y0`: The initial y-clock observation for the epoch.
    - `w`: The observed x-tick per y-tick rate for the epoch.
    - `y0_eff`: The effective y-clock observation for the epoch.
    - `m`: The conversion rate from x-ticks to y-ticks for the epoch.
    - `err`: An integer indicating if there was an error in the epoch (non-zero if error).
- **Logic and Control Flow**:
    - Increment the sequence number `seq` from the shared memory clock `shclock` by 1.
    - Calculate `recal_next` as the sum of `y0_eff`, `shclock->recal_min`, and a hashed value based on `x0` and `shclock->recal_mask`.
    - Increment the error count `err_cnt` in `shclock` if `err` is non-zero.
    - Determine the current epoch in the shared memory clock using the updated sequence number `seq`.
    - Use memory fences (`FD_COMPILER_MFENCE`) to ensure memory ordering when updating the epoch data.
    - Mark the epoch entry as unsafe to read by setting `epoch->seq1` to `seq`.
    - Update the epoch data with `x0`, `y0`, `w`, `y0_eff`, and `m`.
    - Mark the epoch entry as safe to read by setting `epoch->seq0` to `seq`.
    - Update the shared memory clock's sequence number, recalibration time, and error count with the new values.
    - Return the calculated `recal_next` value.
- **Output**: Returns the calculated next recalibration time `recal_next` as a long integer.


---
### fd\_clock\_recal<!-- {{#callable:fd_clock_recal}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L410>)

Recalibrates the clock by updating the epoch with new observations and estimates, ensuring monotonicity and handling potential errors.
- **Inputs**:
    - ``clock``: A pointer to an `fd_clock_t` structure representing the clock to recalibrate.
    - ``x1``: The new x-clock observation value.
    - ``y1``: The new y-clock observation value.
- **Logic and Control Flow**:
    - Retrieve the shared memory clock structure `shclock` from the `clock` parameter.
    - Access the current epoch using the sequence number from `shclock`.
    - Extract the previous epoch's x-clock (`x0`), y-clock (`y0`), tick rate (`w0`), effective y-clock (`y0_eff`), and conversion rate (`m0`).
    - Calculate the differences `dx` and `dy` between the new and previous x-clock and y-clock values, respectively.
    - Compute the observed tick rate `w_obs` as the ratio of `dx` to `dy`.
    - Check if the observed tick rate is within a plausible range compared to the previous tick rate `w0`.
    - If the observed tick rate is not plausible, set the new epoch's tick rate to `w0`, effective y-clock to `y1`, conversion rate to `1/w0`, and log an error.
    - If the observed tick rate is plausible, calculate the new tick rate `w1` as a weighted average of `w0` and `w_obs`.
    - Determine the effective y-clock `y1_eff` for the new epoch, ensuring monotonicity by taking the maximum of `y1` and the estimated y-clock based on `x1`.
    - Calculate the new conversion rate `m1` based on `w1` and the difference between `y1_eff` and `y1`.
    - Call [`fd_clock_next`](<#fd_clock_next>) to update the epoch with the new values and return the result.
- **Output**: Returns the recalculated next epoch value as a long integer.
- **Functions Called**:
    - [`fd_clock_next`](<#fd_clock_next>)


---
### fd\_clock\_step<!-- {{#callable:fd_clock_step}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L493>)

Calls [`fd_clock_next`](<#fd_clock_next>) to update the clock state with new x and y observations and a given rate.
- **Inputs**:
    - ``clock``: A pointer to an `fd_clock_t` structure representing the clock to update.
    - ``x0``: The current x-clock observation.
    - ``y0``: The current y-clock observation.
    - ``w``: The rate of x-ticks per y-tick for the current epoch.
- **Logic and Control Flow**:
    - Calls the [`fd_clock_next`](<#fd_clock_next>) function with the parameters `clock->shclock`, `x0`, `y0`, `w`, `y0`, `1./w`, and `0`.
    - The function [`fd_clock_next`](<#fd_clock_next>) updates the clock's shared memory state with these parameters.
- **Output**: Returns the result of the [`fd_clock_next`](<#fd_clock_next>) function, which is the recalculated next epoch's recalibration time.
- **Functions Called**:
    - [`fd_clock_next`](<#fd_clock_next>)


---
### fd\_clock\_strerror<!-- {{#callable:fd_clock_strerror}} -->
[View Source →](<../../../../../src/util/clock/fd_clock.c#L501>)

Maps error codes to their corresponding error messages for clock operations.
- **Inputs**:
    - ``err``: An integer representing the error code to be translated into a human-readable message.
- **Logic and Control Flow**:
    - Use a `switch` statement to check the value of `err`.
    - If `err` is `FD_CLOCK_SUCCESS`, return the string "success".
    - If `err` is `FD_CLOCK_ERR_X`, return the string "x-clock not well-behaved".
    - If `err` is `FD_CLOCK_ERR_Y`, return the string "y-clock not well-behaved".
    - For any other value of `err`, return the string "unknown".
- **Output**: A constant character pointer to a string describing the error.



---
Made with ❤️ by [Driver](https://www.driver.ai/)