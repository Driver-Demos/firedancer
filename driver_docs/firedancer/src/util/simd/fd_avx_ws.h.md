<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines macros and functions for AVX vector operations on 16-bit signed integers, including arithmetic, memory, and logical operations.

# Purpose
The code defines a set of macros and inline functions for handling 256-bit vector operations using AVX (Advanced Vector Extensions) instructions in C. It focuses on operations with vectors of 16 signed 16-bit integers, referred to as `ws_t`. The code provides a variety of operations, including constructors for creating vectors, memory operations for loading and storing vectors, element operations for extracting and inserting values, arithmetic operations such as addition and multiplication, binary operations like bitwise shifts and logical operations, and logical comparisons.

The code is intended to be included indirectly through a header file, as indicated by the preprocessor directive `#error "Do not include this directly; use fd_avx.h"`. This suggests that the file is part of a larger library or framework that provides SIMD (Single Instruction, Multiple Data) operations. The macros and functions are designed to facilitate efficient vector processing by leveraging AVX instructions, which are useful for applications requiring high-performance computations, such as multimedia processing or scientific computing. The use of macros and inline functions aims to optimize performance by minimizing function call overhead and allowing the compiler to generate efficient machine code.
# Functions

---
### ws\_ld<!-- {{#callable:ws_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L44>)

Loads a 256-bit vector of 16 signed 16-bit integers from a 32-byte aligned memory location.
- **Inputs**:
    - `p`: A pointer to a 32-byte aligned memory location containing 16 signed 16-bit integers.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_load_si256` intrinsic to load a 256-bit vector from the memory location pointed to by the casted pointer.
- **Output**: Returns a `ws_t` type, which is a 256-bit vector containing 16 signed 16-bit integers loaded from the specified memory location.


---
### ws\_st<!-- {{#callable:ws_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L45>)

Stores a 256-bit vector of 16 signed 16-bit integers into a 32-byte aligned memory location.
- **Inputs**:
    - `p`: A pointer to a 32-byte aligned memory location where the vector will be stored.
    - `i`: A 256-bit vector of type `ws_t` containing 16 signed 16-bit integers to store.
- **Logic and Control Flow**:
    - Uses the `_mm256_store_si256` intrinsic to store the vector `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### ws\_ldu<!-- {{#callable:ws_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L47>)

Loads a 256-bit vector of 16 signed 16-bit integers from an unaligned memory address.
- **Inputs**:
    - `p`: A pointer to the memory location from which to load the vector. The pointer does not need to be aligned.
- **Logic and Control Flow**:
    - Uses the `_mm256_loadu_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p`.
    - Casts the pointer `p` to a pointer of type `__m256i const *` before loading.
- **Output**: Returns a `ws_t` type, which is a 256-bit vector containing 16 signed 16-bit integers loaded from the specified memory location.


---
### ws\_stu<!-- {{#callable:ws_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L48>)

Stores a 256-bit vector of 16-bit integers to a memory location without alignment requirements.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector will be stored. The location does not need to be aligned.
    - ``i``: A 256-bit vector of 16-bit integers (`ws_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the vector `i` at the memory location `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### ws\_extract\_variable<!-- {{#callable:ws_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L64>)

Extracts a 16-bit signed integer from a specified lane of a 256-bit vector.
- **Inputs**:
    - ``a``: A 256-bit vector of type `ws_t` containing 16 lanes, each holding a 16-bit signed integer.
    - ``n``: An integer specifying the lane index (0 to 15) from which to extract the short value.
- **Logic and Control Flow**:
    - Declare a union `t` with a 256-bit vector `m` and an array `h` of 16 shorts.
    - Store the vector `a` into the union's 256-bit vector `m` using `_mm256_store_si256`.
    - Return the short value from the `n`-th position of the array `h`.
- **Output**: A 16-bit signed integer extracted from the specified lane `n` of the vector `a`.


---
### ws\_insert\_variable<!-- {{#callable:ws_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L71>)

Inserts a short integer into a specified lane of a 256-bit vector of shorts.
- **Inputs**:
    - `a`: A 256-bit vector of shorts (`ws_t`) where the insertion will occur.
    - `n`: An integer representing the lane index (0 to 15) where the short integer will be inserted.
    - `v`: A short integer value to insert into the specified lane of the vector.
- **Logic and Control Flow**:
    - Store the 256-bit vector `a` into a temporary union `t` that allows access to individual short elements.
    - Assign the short value `v` to the `n`-th element of the short array `t->h`.
    - Load the modified 256-bit vector from the union `t` and return it.
- **Output**: Returns a new 256-bit vector of shorts with the specified lane replaced by the given short value.


---
### ws\_rol<!-- {{#callable:ws_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L121>)

Performs a bitwise left rotation on each 16-bit lane of a vector of 16-bit integers.
- **Inputs**:
    - ``a``: A vector of 16-bit integers (`ws_t`) to rotate.
    - ``imm``: An integer specifying the number of positions to rotate left, masked to 4 bits (0-15).
- **Logic and Control Flow**:
    - Compute the left shift of `a` by `imm & 15` bits using `ws_shl`.
    - Compute the right shift of `a` by `(-imm) & 15` bits using `ws_shru`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `ws_or`.
- **Output**: Returns a vector of 16-bit integers (`ws_t`) with each lane rotated left by the specified number of positions.


---
### ws\_ror<!-- {{#callable:ws_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L122>)

Performs a bitwise right rotation on each 16-bit lane of a vector of signed 16-bit integers.
- **Inputs**:
    - ``a``: A vector of signed 16-bit integers (`ws_t`) to rotate.
    - ``imm``: An integer specifying the number of positions to rotate right, masked to 4 bits (0-15).
- **Logic and Control Flow**:
    - Mask `imm` with 15 to ensure it is within the range 0-15.
    - Perform an unsigned right shift on `a` by `imm` bits using `ws_shru`.
    - Perform a left shift on `a` by `(-imm) & 15` bits using `ws_shl`.
    - Combine the results of the two shifts using a bitwise OR operation with `ws_or`.
- **Output**: Returns a vector (`ws_t`) where each 16-bit lane is the result of the right rotation of the corresponding lane in `a` by `imm` positions.


---
### ws\_rol\_variable<!-- {{#callable:ws_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L124>)

Performs a variable bitwise left rotation on each 16-bit lane of a vector of signed 16-bit integers.
- **Inputs**:
    - ``a``: A vector of signed 16-bit integers (`ws_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate each lane to the left.
- **Logic and Control Flow**:
    - Compute `n & 15` to ensure the rotation count is within the range of 0 to 15 bits.
    - Perform a left shift on vector `a` by `n & 15` bits using `ws_shl_variable`.
    - Perform a logical right shift on vector `a` by `(-n) & 15` bits using `ws_shru_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `ws_or`.
- **Output**: Returns a vector of signed 16-bit integers (`ws_t`) where each lane has been rotated left by `n` bits.


---
### ws\_ror\_variable<!-- {{#callable:ws_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_ws.h#L125>)

Performs a variable bitwise right rotation on each 16-bit lane of a vector of signed 16-bit integers.
- **Inputs**:
    - ``a``: A vector of signed 16-bit integers (`ws_t`) to rotate.
    - ``n``: An integer specifying the number of positions to rotate each lane to the right.
- **Logic and Control Flow**:
    - Compute `n & 15` to ensure the rotation count is within the range of 0 to 15 bits.
    - Perform an unsigned right shift on `a` by `n & 15` bits using `ws_shru_variable`.
    - Perform a left shift on `a` by `(-n) & 15` bits using `ws_shl_variable`.
    - Combine the results of the two shifts using a bitwise OR operation with `ws_or`.
- **Output**: Returns a vector (`ws_t`) where each lane is the result of rotating the corresponding lane in `a` to the right by `n` positions.



---
Made with ❤️ by [Driver](https://www.driver.ai/)