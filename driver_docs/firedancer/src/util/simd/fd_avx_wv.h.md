<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Header file for AVX vector operations on unsigned 64-bit integers, including constructors, arithmetic, and logical operations.

# Purpose
The code defines a set of macros and inline functions for operations on 256-bit vectors using AVX (Advanced Vector Extensions) intrinsics in C. It is designed to handle vectors of unsigned 64-bit integers, referred to as `wv_t`. The code provides a comprehensive API for constructing, manipulating, and performing arithmetic, logical, and memory operations on these vectors. It includes constructors for creating vectors with specific patterns, memory operations for loading and storing vectors, and a variety of arithmetic and logical operations such as addition, subtraction, bitwise operations, and comparisons.

The code is structured to support both compile-time and runtime flexibility, with certain operations optimized for specific compilers like Clang. It also includes conditional operations and conversion functions to transform vectors into different data types. The use of macros and inline functions aims to optimize performance by reducing function call overhead and allowing the compiler to better optimize the code. The file is intended to be included indirectly through a header file `fd_avx.h`, as indicated by the initial preprocessor directive, ensuring that it is part of a larger library or application that utilizes AVX for vector processing.
# Functions

---
### wv\_bcast\_pair<!-- {{#callable:wv_bcast_pair}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L25>)

Creates a vector with the pattern `[v0 v1 v0 v1]` using two unsigned long inputs.
- **Inputs**:
    - `v0`: An unsigned long integer to be broadcasted to the first and third positions in the vector.
    - `v1`: An unsigned long integer to be broadcasted to the second and fourth positions in the vector.
- **Logic and Control Flow**:
    - Converts `v0` and `v1` to long integers.
    - Uses `_mm256_setr_epi64x` to create a 256-bit vector with the pattern `[v0 v1 v0 v1]`.
- **Output**: A 256-bit vector of type `wv_t` containing the pattern `[v0 v1 v0 v1]`.


---
### wv\_bcast\_wide<!-- {{#callable:wv_bcast_wide}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L30>)

Creates a vector with two pairs of repeated 64-bit unsigned integers.
- **Inputs**:
    - `v0`: The first 64-bit unsigned integer to repeat in the vector.
    - `v1`: The second 64-bit unsigned integer to repeat in the vector.
- **Logic and Control Flow**:
    - Casts `v0` and `v1` to 64-bit signed integers.
    - Uses `_mm256_setr_epi64x` to create a vector with the pattern `[v0, v0, v1, v1]`.
- **Output**: A `wv_t` vector containing the values `[v0, v0, v1, v1]`.


---
### wv\_permute<!-- {{#callable:wv_permute}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L40>)

Reorders the elements of a 256-bit vector of unsigned 64-bit integers based on specified indices.
- **Inputs**:
    - ``x``: A 256-bit vector of unsigned 64-bit integers (`wv_t`).
    - ``imm_i0``: An integer index (0-3) specifying the position of the first element in the output vector.
    - ``imm_i1``: An integer index (0-3) specifying the position of the second element in the output vector.
    - ``imm_i2``: An integer index (0-3) specifying the position of the third element in the output vector.
    - ``imm_i3``: An integer index (0-3) specifying the position of the fourth element in the output vector.
- **Logic and Control Flow**:
    - Store the input vector `x` into a temporary union `t` that can be accessed as an array of unsigned long integers.
    - Assign elements from `t.u` to another union `u.u` based on the indices `imm_i0`, `imm_i1`, `imm_i2`, and `imm_i3`.
    - Load the reordered elements from `u.v` and return them as a new 256-bit vector.
- **Output**: A 256-bit vector of unsigned 64-bit integers with elements reordered according to the specified indices.


---
### wv\_ld<!-- {{#callable:wv_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L73>)

Loads a 256-bit vector of four unsigned 64-bit integers from a 32-byte aligned memory location.
- **Inputs**:
    - `p`: A pointer to a 32-byte aligned memory location containing four unsigned 64-bit integers.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_load_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p`.
- **Output**: A `wv_t` type, which is a 256-bit vector containing four unsigned 64-bit integers loaded from the specified memory location.


---
### wv\_st<!-- {{#callable:wv_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L74>)

Stores a vector of four unsigned 64-bit integers into a 32-byte aligned memory location.
- **Inputs**:
    - ``p``: A pointer to a 32-byte aligned memory location where the vector will be stored.
    - ``i``: A vector of four unsigned 64-bit integers (`wv_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_store_si256` intrinsic to store the vector `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wv\_ldu<!-- {{#callable:wv_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L76>)

Loads a 256-bit vector of unsigned 64-bit integers from an unaligned memory address.
- **Inputs**:
    - `p`: A pointer to the memory location from which to load the vector.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_loadu_si256` intrinsic to load a 256-bit vector from the unaligned memory location pointed to by `p`.
- **Output**: Returns a `wv_t` type, which is a 256-bit vector containing four unsigned 64-bit integers loaded from the specified memory location.


---
### wv\_stu<!-- {{#callable:wv_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L77>)

Stores a vector of unsigned 64-bit integers to a memory location without alignment requirements.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector will be stored. The location does not need to be aligned.
    - ``i``: A vector of unsigned 64-bit integers (`wv_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the vector `i` at the memory location `p`.
- **Output**: No output is returned as the function is of type `void`.


---
### wv\_extract\_variable<!-- {{#callable:wv_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L103>)

Extracts an unsigned long integer from a specified lane of a vector of unsigned long integers.
- **Inputs**:
    - ``a``: A vector of unsigned long integers (`wv_t`) from which to extract a value.
    - ``n``: An integer specifying the lane (0 to 3) from which to extract the unsigned long integer.
- **Logic and Control Flow**:
    - Declare a union `t` that can store a vector of type `__m256i` and an array of four unsigned long integers.
    - Store the vector `a` into the `m` member of the union `t` using `_mm256_store_si256`.
    - Return the `n`-th element from the `u` member of the union `t`.
- **Output**: An unsigned long integer extracted from the specified lane of the input vector.


---
### wv\_insert\_variable<!-- {{#callable:wv_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L110>)

Replaces the `n`-th element of a vector `wv_t` with a given `ulong` value and returns the modified vector.
- **Inputs**:
    - `a`: A vector of type `wv_t` containing four unsigned 64-bit integers.
    - `n`: An integer index (0 to 3) indicating which element of the vector to replace.
    - `v`: An unsigned long integer value to insert into the vector at the specified index.
- **Logic and Control Flow**:
    - Store the vector `a` into a temporary union `t` that can be accessed as both a vector and an array of `ulong` values.
    - Replace the `n`-th element of the array `t->u` with the value `v`.
    - Load the modified vector from the union `t` and return it.
- **Output**: Returns a vector of type `wv_t` with the `n`-th element replaced by `v`.


---
### wv\_rol<!-- {{#callable:wv_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L169>)

Performs a bitwise left rotation on each 64-bit lane of a vector `wv_t` by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of type `wv_t` containing four 64-bit unsigned integers.
    - ``imm``: An integer specifying the number of bits to rotate each 64-bit lane to the left.
- **Logic and Control Flow**:
    - Compute the left shift of vector `a` by `imm & 63` bits using `wv_shl` function.
    - Compute the right shift of vector `a` by `(-imm) & 63` bits using `wv_shr` function.
    - Combine the results of the left and right shifts using the bitwise OR operation with `wv_or` function.
- **Output**: Returns a vector `wv_t` where each 64-bit lane is the result of rotating the corresponding lane in `a` to the left by `imm` bits.


---
### wv\_ror<!-- {{#callable:wv_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L170>)

Performs a bitwise right rotation on each 64-bit lane of a 256-bit vector by a specified number of bits.
- **Inputs**:
    - ``a``: A 256-bit vector of type `wv_t` containing four 64-bit unsigned integers.
    - ``imm``: An integer specifying the number of bits to rotate right, masked to the range 0-63.
- **Logic and Control Flow**:
    - Mask `imm` with 63 to ensure it is within the range 0-63.
    - Perform a logical right shift on `a` by `imm` bits using `wv_shr`.
    - Perform a logical left shift on `a` by `(-imm) & 63` bits using `wv_shl`.
    - Combine the results of the two shifts using a bitwise OR operation with `wv_or`.
- **Output**: A 256-bit vector of type `wv_t` with each 64-bit lane rotated right by `imm` bits.


---
### wv\_rol\_variable<!-- {{#callable:wv_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L173>)

Performs a variable left rotation on a vector of unsigned 64-bit integers.
- **Inputs**:
    - ``a``: A vector of unsigned 64-bit integers (`wv_t`) to rotate.
    - ``n``: An integer specifying the number of positions to rotate the vector `a` to the left.
- **Logic and Control Flow**:
    - Compute `n & 63` to ensure the rotation amount is within the range of 0 to 63 bits.
    - Perform a left shift on vector `a` by `n & 63` bits using `wv_shl_variable`.
    - Perform a right shift on vector `a` by `(-n) & 63` bits using `wv_shr_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wv_or`.
- **Output**: Returns a vector of unsigned 64-bit integers (`wv_t`) that is the result of rotating the input vector `a` to the left by `n` positions.


---
### wv\_ror\_variable<!-- {{#callable:wv_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L174>)

Performs a variable bitwise right rotation on a vector of unsigned 64-bit integers.
- **Inputs**:
    - ``a``: A vector of unsigned 64-bit integers (`wv_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate right.
- **Logic and Control Flow**:
    - Compute `n & 63` to ensure the shift amount is within the range of 0 to 63 bits.
    - Perform a right shift on `a` by `n & 63` bits using `wv_shr_variable`.
    - Compute `(-n) & 63` to determine the equivalent left shift amount.
    - Perform a left shift on `a` by `(-n) & 63` bits using `wv_shl_variable`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `wv_or`.
- **Output**: Returns a vector of unsigned 64-bit integers (`wv_t`) that is the result of the right rotation.


---
### wv\_rol\_vector<!-- {{#callable:wv_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L176>)

Performs a bitwise left rotation on each 64-bit element of a vector `wv_t` by a specified number of bits given in another vector `wl_t`.
- **Inputs**:
    - ``a``: A vector of type `wv_t` containing 64-bit unsigned integers to rotate.
    - ``b``: A vector of type `wl_t` specifying the number of bits to rotate each corresponding element in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `63L` to all elements of a vector `wl_t` and assigns it to `m`.
    - Performs a bitwise AND operation between `b` and `m` to ensure the shift amount is within the range of 0 to 63 bits.
    - Shifts each element of `a` to the left by the number of bits specified in the result of the AND operation, using `wv_shl_vector`.
    - Negates `b`, performs a bitwise AND with `m`, and shifts each element of `a` to the right by the resulting number of bits, using `wv_shr_vector`.
    - Combines the results of the left and right shifts using a bitwise OR operation, using `wv_or`.
- **Output**: A vector of type `wv_t` containing the rotated 64-bit unsigned integers.


---
### wv\_ror\_vector<!-- {{#callable:wv_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L181>)

Performs a bitwise right rotation on each 64-bit integer in a vector by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of 64-bit unsigned integers (`wv_t`).
    - ``b``: A vector of 64-bit integers (`wl_t`) specifying the number of bits to rotate each corresponding element in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `63L` to all elements of a vector `m` using `wl_bcast` to ensure shifts are within 0 to 63 bits.
    - Performs a bitwise AND operation between `b` and `m` to limit the shift amount to 63 bits.
    - Calculates the right-shifted vector by calling `wv_shr_vector` with `a` and the masked `b`.
    - Calculates the left-shifted vector by calling `wv_shl_vector` with `a` and the negated and masked `b`.
    - Combines the right-shifted and left-shifted vectors using a bitwise OR operation with `wv_or` to complete the rotation.
- **Output**: A vector of 64-bit unsigned integers (`wv_t`) where each element is the result of rotating the corresponding element in `a` to the right by the number of bits specified in `b`.


---
### wv\_min<!-- {{#callable:wv_min}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L219>)

Determines the minimum of two vector unsigned long integers.
- **Inputs**:
    - ``a``: A vector of unsigned long integers (`wv_t`).
    - ``b``: A vector of unsigned long integers (`wv_t`).
- **Logic and Control Flow**:
    - Calls `wv_lt` to compare vectors `a` and `b` element-wise to determine which elements of `a` are less than those in `b`.
    - Uses `wv_if` to select elements from `a` where `a` is less than `b`, otherwise selects elements from `b`.
- **Output**: Returns a vector (`wv_t`) containing the minimum values from the corresponding elements of vectors `a` and `b`.


---
### wv\_max<!-- {{#callable:wv_max}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L220>)

Determines the maximum value between two vector unsigned long integers.
- **Inputs**:
    - ``a``: A vector of unsigned long integers (`wv_t`).
    - ``b``: Another vector of unsigned long integers (`wv_t`).
- **Logic and Control Flow**:
    - Calls `wv_gt(a, b)` to compare vectors `a` and `b` element-wise, resulting in a vector of comparison results.
    - Uses `wv_if` to select elements from `a` or `b` based on the comparison results, returning the maximum value for each element position.
- **Output**: A vector of unsigned long integers (`wv_t`) containing the maximum values from the corresponding elements of `a` and `b`.


---
### wv\_to\_wf<!-- {{#callable:wv_to_wf}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L250>)

Converts a vector of unsigned 64-bit integers to a vector of floats and inserts it into a specified position in another vector of floats.
- **Inputs**:
    - `v`: A vector of type `wv_t` containing four unsigned 64-bit integers.
    - `f`: A vector of type `wf_t` where the converted floats will be inserted.
    - `imm_hi`: An integer that determines the position in `f` where the converted floats will be inserted; 0 for the lower half and 1 for the upper half.
- **Logic and Control Flow**:
    - Stores the vector `v` into a temporary union `t` to access its unsigned long elements.
    - Converts each of the four unsigned long elements in `t` to floats and stores them in another union `u`.
    - Loads the floats from `u` into a 128-bit vector `w`.
    - Inserts the 128-bit vector `w` into the 256-bit vector `f` at the position specified by `imm_hi` (0 for lower half, 1 for upper half).
- **Output**: A vector of type `wf_t` with the converted floats inserted at the specified position.


---
### wv\_to\_wi<!-- {{#callable:wv_to_wi}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L262>)

Converts a vector of unsigned 64-bit integers to a vector of signed 32-bit integers, inserting the result into a specified position of another vector.
- **Inputs**:
    - ``v``: A `wv_t` vector containing unsigned 64-bit integers.
    - ``i``: A `wi_t` vector where the result will be inserted.
    - ``imm_hi``: An integer that determines the position (0 or 1) in the `wi_t` vector where the result will be inserted.
- **Logic and Control Flow**:
    - Extracts the lower 128 bits from the `wv_t` vector `v` and casts them to a `__m128` type, storing the result in `v01`.
    - Extracts the upper 128 bits from the `wv_t` vector `v` and casts them to a `__m128` type, storing the result in `v23`.
    - Shuffles the elements of `v01` and `v23` to create a new `__m128i` vector `w` containing the lower 32 bits of each element.
    - Inserts the `__m128i` vector `w` into the `wi_t` vector `i` at the position specified by `imm_hi` (0 for lower, 1 for upper 128 bits).
- **Output**: Returns a `wv_t` vector with the converted and inserted values.


---
### wv\_to\_wu<!-- {{#callable:wv_to_wu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L269>)

Converts a vector of unsigned 64-bit integers to another vector with optional insertion at a specified position.
- **Inputs**:
    - ``v``: A vector of unsigned 64-bit integers (`wv_t`).
    - ``u``: A vector of unsigned 64-bit integers (`wu_t`) where the result will be inserted.
    - ``imm_hi``: An integer flag to determine the insertion position (0 or 1).
- **Logic and Control Flow**:
    - Extracts the lower 128 bits from the vector `v` and casts them to a 128-bit floating-point vector `v01`.
    - Extracts the upper 128 bits from the vector `v` and casts them to a 128-bit floating-point vector `v23`.
    - Shuffles the elements of `v01` and `v23` to create a new 128-bit integer vector `w`.
    - Checks the `imm_hi` flag to determine the insertion position.
    - Inserts the 128-bit vector `w` into the vector `u` at the position specified by `imm_hi` (0 for lower, 1 for upper).
- **Output**: Returns a vector of unsigned 64-bit integers (`wu_t`) with the inserted 128-bit vector `w`.


---
### wv\_to\_wd<!-- {{#callable:wv_to_wd}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L277>)

Converts a vector of unsigned 64-bit integers to a vector of double-precision floating-point numbers.
- **Inputs**:
    - ``v``: A vector of type `wv_t` containing four unsigned 64-bit integers.
- **Logic and Control Flow**:
    - Store the input vector `v` into a union `t` that can hold either an array of four unsigned long integers or a single `__m256i` vector.
    - Convert each of the four unsigned long integers in `t` to double-precision floating-point numbers and store them in a union `u` that can hold either an array of four doubles or a single `__m256d` vector.
    - Load the double-precision floating-point numbers from `u` and return them as a `__m256d` vector.
- **Output**: A `wd_t` vector containing four double-precision floating-point numbers converted from the input vector's unsigned 64-bit integers.


---
### wv\_sum\_all<!-- {{#callable:wv_sum_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L299>)

Computes the sum of all elements in a vector of unsigned 64-bit integers and broadcasts the result across all lanes of the vector.
- **Inputs**:
    - `x`: A vector of unsigned 64-bit integers (`wv_t`) containing the elements to sum.
- **Logic and Control Flow**:
    - Add the vector `x` to itself after permuting its 128-bit lanes, effectively summing the first two and last two elements.
    - Permute the 64-bit lanes of the resulting vector and add it to itself, completing the sum of all elements.
    - Return the vector with the sum broadcasted to all lanes.
- **Output**: A vector (`wv_t`) where each lane contains the sum of all elements in the input vector `x`.


---
### wv\_min\_all<!-- {{#callable:wv_min_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L305>)

Computes the minimum value across all lanes of a vector and broadcasts it to all lanes.
- **Inputs**:
    - ``x``: A vector of type `wv_t` containing four 64-bit unsigned integers.
- **Logic and Control Flow**:
    - Use `_mm256_permute2f128_si256` to permute the vector `x` and combine it with itself, reducing the vector to two 64-bit integers with the minimum values from each half.
    - Apply [`wv_min`](<#wv_min>) to find the minimum value between the two 64-bit integers.
    - Use `_mm256_permute_pd` and `_mm256_castsi256_pd` to further reduce the vector to a single 64-bit integer with the minimum value.
    - Broadcast the minimum value to all lanes of the vector using `wv_bcast`.
- **Output**: A vector of type `wv_t` where all lanes contain the minimum value found in the input vector `x`.
- **Functions Called**:
    - [`wv_min`](<#wv_min>)


---
### wv\_max\_all<!-- {{#callable:wv_max_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L311>)

Computes the maximum value across all lanes of a vector and broadcasts it to all lanes.
- **Inputs**:
    - ``x``: A vector of type `wv_t` containing four 64-bit unsigned integers.
- **Logic and Control Flow**:
    - Permutes the input vector `x` to swap its two 128-bit halves using `_mm256_permute2f128_si256` and computes the maximum of the original and permuted vectors using [`wv_max`](<#wv_max>).
    - Permutes the resulting vector by swapping adjacent pairs of 64-bit lanes using `_mm256_permute_pd` and computes the maximum of the original and permuted vectors again using [`wv_max`](<#wv_max>).
- **Output**: A vector of type `wv_t` where all lanes contain the maximum value found in the input vector `x`.
- **Functions Called**:
    - [`wv_max`](<#wv_max>)


---
### wv\_gather<!-- {{#callable:wv_gather}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wv.h#L327>)

Gathers 64-bit integers from a base address using indices from a vector, with a compile-time branch based on a flag.
- **Inputs**:
    - `b`: A pointer to a constant array of unsigned long integers, serving as the base address for gathering.
    - `i`: A vector of indices (`wi_t` type) used to gather elements from the base address.
    - `imm_hi`: An integer flag that determines which half of the index vector to use for gathering.
- **Logic and Control Flow**:
    - Check if `imm_hi` is non-zero.
    - If `imm_hi` is non-zero, use the second half of the index vector `i` to gather elements from `b`.
    - If `imm_hi` is zero, use the first half of the index vector `i` to gather elements from `b`.
- **Output**: Returns a vector (`wv_t` type) containing the gathered 64-bit integers.



---
Made with ❤️ by [Driver](https://www.driver.ai/)