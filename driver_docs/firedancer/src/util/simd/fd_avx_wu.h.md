<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines macros and functions for AVX-based operations on vectors of unsigned 32-bit integers.

# Purpose
The code defines a set of macros and inline functions for handling 256-bit wide vectors of unsigned 32-bit integers using AVX (Advanced Vector Extensions) intrinsics. The primary data type used is `wu_t`, which represents a vector of eight unsigned 32-bit integers. The code provides a variety of operations on these vectors, including constructors, arithmetic operations, logical operations, and memory operations. It also includes functions for element extraction and insertion, vector permutation, and conversion between different data types.

The code is structured to provide efficient vector operations by leveraging AVX intrinsics, which are designed to perform operations on multiple data points simultaneously. This is useful in applications that require high-performance computing, such as graphics processing, scientific simulations, and data analysis. The use of macros and inline functions helps to ensure that the operations are performed with minimal overhead, and the code includes specific handling for alignment and type conversion to maintain compatibility with the AVX instruction set. The file is intended to be included indirectly through `fd_avx.h`, as indicated by the initial preprocessor directive, which prevents direct inclusion.
# Functions

---
### wu\_bcast\_pair<!-- {{#callable:wu_bcast_pair}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L26>)

Creates a vector with alternating repetitions of two unsigned integers.
- **Inputs**:
    - `u0`: The first unsigned integer to broadcast.
    - `u1`: The second unsigned integer to broadcast.
- **Logic and Control Flow**:
    - Convert `u0` and `u1` to signed integers `i0` and `i1` respectively.
    - Use `_mm256_setr_epi32` to create a vector with the pattern `[i0, i1, i0, i1, i0, i1, i0, i1]`.
- **Output**: A `wu_t` vector with the pattern `[u0, u1, u0, u1, u0, u1, u0, u1]`.


---
### wu\_bcast\_lohi<!-- {{#callable:wu_bcast_lohi}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L32>)

Creates a vector with the first four lanes set to `u0` and the last four lanes set to `u1`.
- **Inputs**:
    - `u0`: An unsigned 32-bit integer to broadcast to the first four lanes of the vector.
    - `u1`: An unsigned 32-bit integer to broadcast to the last four lanes of the vector.
- **Logic and Control Flow**:
    - Convert `u0` and `u1` to signed integers `i0` and `i1` respectively.
    - Use `_mm256_setr_epi32` to create a vector with the first four lanes set to `i0` and the last four lanes set to `i1`.
- **Output**: A `wu_t` vector with the first four lanes containing `u0` and the last four lanes containing `u1`.


---
### wu\_bcast\_quad<!-- {{#callable:wu_bcast_quad}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L38>)

Creates a 256-bit vector with two sets of four 32-bit unsigned integers.
- **Inputs**:
    - ``u0``: The first unsigned 32-bit integer.
    - ``u1``: The second unsigned 32-bit integer.
    - ``u2``: The third unsigned 32-bit integer.
    - ``u3``: The fourth unsigned 32-bit integer.
- **Logic and Control Flow**:
    - Convert each input `uint` to an `int` and store them in `i0`, `i1`, `i2`, and `i3`.
    - Use `_mm256_setr_epi32` to create a 256-bit vector with the pattern `[i0, i1, i2, i3, i0, i1, i2, i3]`.
- **Output**: A 256-bit vector (`wu_t`) containing two sets of the four input integers.


---
### wu\_bcast\_wide<!-- {{#callable:wu_bcast_wide}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L44>)

Creates a 256-bit vector with each input value duplicated in adjacent lanes.
- **Inputs**:
    - `u0`: The first unsigned 32-bit integer to broadcast.
    - `u1`: The second unsigned 32-bit integer to broadcast.
    - `u2`: The third unsigned 32-bit integer to broadcast.
    - `u3`: The fourth unsigned 32-bit integer to broadcast.
- **Logic and Control Flow**:
    - Convert each input `uint` to an `int` and store them in `i0`, `i1`, `i2`, and `i3`.
    - Use `_mm256_setr_epi32` to create a 256-bit vector with the pattern `[i0, i0, i1, i1, i2, i2, i3, i3]`.
- **Output**: A 256-bit vector (`wu_t`) with the pattern `[u0, u0, u1, u1, u2, u2, u3, u3]`.


---
### wu\_exch\_adj\_quad<!-- {{#callable:wu_exch_adj_quad}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L66>)

Reorders the elements of a 256-bit vector of unsigned 32-bit integers by swapping the first and second 128-bit lanes.
- **Inputs**:
    - `x`: A 256-bit vector of unsigned 32-bit integers (`wu_t`).
- **Logic and Control Flow**:
    - Uses the `_mm256_permute2f128_si256` intrinsic to swap the 128-bit lanes of the input vector `x`.
- **Output**: A 256-bit vector of unsigned 32-bit integers with the first and second 128-bit lanes exchanged.


---
### wu\_ld<!-- {{#callable:wu_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L87>)

Loads 8 unsigned 32-bit integers from a 32-byte aligned memory location into a vector.
- **Inputs**:
    - `p`: A pointer to a 32-byte aligned memory location containing 8 unsigned 32-bit integers.
- **Logic and Control Flow**:
    - Uses the `_mm256_load_si256` intrinsic to load data from the memory location pointed to by `p` into a `__m256i` vector.
- **Output**: A `wu_t` vector containing the loaded 8 unsigned 32-bit integers.


---
### wu\_st<!-- {{#callable:wu_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L88>)

Stores a vector of eight 32-bit unsigned integers to a 32-byte aligned memory location.
- **Inputs**:
    - ``p``: A pointer to a 32-byte aligned memory location where the vector will be stored.
    - ``i``: A vector of eight 32-bit unsigned integers (`wu_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Converts the pointer `p` to a pointer of type `__m256i` to match the type expected by the `_mm256_store_si256` intrinsic.
    - Uses the `_mm256_store_si256` intrinsic to store the vector `i` at the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wu\_ldu<!-- {{#callable:wu_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L90>)

Loads an unaligned 256-bit vector of unsigned 32-bit integers from memory.
- **Inputs**:
    - ``p``: A pointer to the memory location from which to load the vector.
- **Logic and Control Flow**:
    - Uses the `_mm256_loadu_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p` without requiring alignment.
- **Output**: Returns a `wu_t` type, which is a 256-bit vector containing eight unsigned 32-bit integers loaded from the specified memory location.


---
### wu\_stu<!-- {{#callable:wu_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L91>)

Stores a 256-bit vector of unsigned 32-bit integers to a memory location without alignment requirements.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector will be stored. The location does not need to be aligned.
    - ``i``: A 256-bit vector of unsigned 32-bit integers (`wu_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the vector `i` at the memory location `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wu\_extract\_variable<!-- {{#callable:wu_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L116>)

Extracts the unsigned integer from a specified lane of a vector of unsigned integers.
- **Inputs**:
    - ``a``: A vector of type `wu_t` containing 8 unsigned 32-bit integers.
    - ``n``: An integer specifying the lane index (0 to 7) from which to extract the unsigned integer.
- **Logic and Control Flow**:
    - Declare a union `t` with a `__m256i` array `m` and a `uint` array `u`, both of size 1.
    - Store the vector `a` into the `m` array of the union `t` using `_mm256_store_si256`.
    - Return the `n`-th element from the `u` array of the union `t`.
- **Output**: Returns the unsigned integer from the specified lane `n` of the vector `a`.


---
### wu\_insert\_variable<!-- {{#callable:wu_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L123>)

Replaces the value at a specified lane in a vector of unsigned 32-bit integers with a new value.
- **Inputs**:
    - ``a``: A vector of type `wu_t` containing eight unsigned 32-bit integers.
    - ``n``: An integer specifying the lane index (0 to 7) where the new value will be inserted.
    - ``v``: An unsigned integer value to insert into the specified lane of the vector.
- **Logic and Control Flow**:
    - Stores the vector `a` into a temporary union `t` that allows access to individual lanes as an array of unsigned integers.
    - Replaces the value at the `n`-th index of the array `t->u` with the new value `v`.
    - Loads the modified vector from the union `t` and returns it.
- **Output**: A vector of type `wu_t` with the value at the specified lane replaced by the new value.


---
### wu\_rol<!-- {{#callable:wu_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L175>)

Performs a bitwise left rotation on each 32-bit lane of a vector of unsigned integers by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`) to rotate.
    - ``imm``: An integer specifying the number of bits to rotate each lane to the left.
- **Logic and Control Flow**:
    - Compute the effective number of bits to rotate left by taking `imm & 31` to ensure it is within the range [0, 31].
    - Compute the effective number of bits to rotate right by taking `(-imm) & 31`.
    - Perform a left shift on `a` by the effective left rotation bits using `wu_shl`.
    - Perform a right shift on `a` by the effective right rotation bits using `wu_shr`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wu_or`.
- **Output**: A vector of unsigned 32-bit integers (`wu_t`) with each lane rotated left by the specified number of bits.


---
### wu\_ror<!-- {{#callable:wu_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L176>)

Performs a bitwise right rotation on each 32-bit lane of a vector of unsigned integers by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`) to rotate.
    - ``imm``: An integer specifying the number of bits to rotate right, masked to the range [0, 31].
- **Logic and Control Flow**:
    - Masks the `imm` value with 31 to ensure it is within the valid range for bit rotation.
    - Performs a right logical shift on `a` by `imm` bits using `wu_shr`.
    - Performs a left logical shift on `a` by `(-imm) & 31` bits using `wu_shl`.
    - Combines the results of the two shifts using a bitwise OR operation with `wu_or`.
- **Output**: A vector of unsigned 32-bit integers (`wu_t`) with each lane rotated right by the specified number of bits.


---
### wu\_rol\_variable<!-- {{#callable:wu_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L179>)

Performs a variable bitwise left rotation on each 32-bit lane of a vector of unsigned integers.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate left, where the effective rotation is `n & 31`.
- **Logic and Control Flow**:
    - Compute the effective number of bits to rotate left as `n & 31` and right as `(-n) & 31`.
    - Shift the vector `a` left by the effective number of bits using `wu_shl_variable`.
    - Shift the vector `a` right by the effective number of bits using `wu_shr_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wu_or`.
- **Output**: A vector of unsigned 32-bit integers (`wu_t`) with each lane rotated left by `n` bits.


---
### wu\_ror\_variable<!-- {{#callable:wu_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L180>)

Performs a variable right rotation on a vector of unsigned 32-bit integers.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`).
    - ``n``: An integer specifying the number of positions to rotate right.
- **Logic and Control Flow**:
    - Compute `n & 31` to ensure the shift amount is within the range [0, 31].
    - Perform a right shift on `a` by `n & 31` using `wu_shr_variable`.
    - Perform a left shift on `a` by `(-n) & 31` using `wu_shl_variable`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `wu_or`.
- **Output**: A vector of unsigned 32-bit integers (`wu_t`) that is the result of the right rotation.


---
### wu\_rol\_vector<!-- {{#callable:wu_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L182>)

Performs a bitwise left rotation on each element of a vector of unsigned 32-bit integers by a specified number of bits, using another vector to determine the rotation amount for each element.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`) to rotate.
    - ``b``: A vector of signed 32-bit integers (`wi_t`) specifying the number of bits to rotate each corresponding element in `a`.
- **Logic and Control Flow**:
    - Broadcasts the integer value 31 to all elements of a vector `m` using `wi_bcast` to create a mask for bitwise operations.
    - Performs a bitwise AND operation between each element of `b` and `m` to ensure the rotation amount is within the range [0, 31].
    - Shifts each element of `a` left by the corresponding masked value from `b` using `wu_shl_vector`.
    - Negates each element of `b`, masks it with `m`, and shifts each element of `a` right by the resulting value using `wu_shr_vector`.
    - Combines the results of the left and right shifts using a bitwise OR operation with `wu_or` to complete the rotation.
- **Output**: Returns a vector of unsigned 32-bit integers (`wu_t`) where each element is the result of the left rotation of the corresponding element in `a` by the number of bits specified in `b`.


---
### wu\_ror\_vector<!-- {{#callable:wu_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L187>)

Performs a bitwise right rotation on each 32-bit lane of a vector of unsigned integers by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`).
    - ``b``: A vector of signed 32-bit integers (`wi_t`) specifying the number of bits to rotate each corresponding lane in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `31` to all lanes of a vector `m`.
    - Performs a bitwise AND operation between `b` and `m`, and between the negation of `b` and `m`, to ensure the shift amounts are within the range [0, 31].
    - Shifts the vector `a` right by the result of the first AND operation and left by the result of the second AND operation.
    - Combines the results of the right and left shifts using a bitwise OR operation to complete the rotation.
- **Output**: A vector of unsigned 32-bit integers (`wu_t`) with each lane rotated right by the specified number of bits.


---
### wu\_to\_wd<!-- {{#callable:wu_to_wd}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L258>)

Converts a vector of unsigned 32-bit integers to a vector of double-precision floating-point numbers, handling values greater than 2^31 with two's complement and floating-point arithmetic.
- **Inputs**:
    - `u`: A vector of unsigned 32-bit integers (`wu_t`).
    - `imm_hi`: An integer that determines which half of the vector to process (0 for lower half, 1 for upper half).
- **Logic and Control Flow**:
    - Extracts a 128-bit integer from the input vector `u` based on `imm_hi` (0 for lower half, 1 for upper half).
    - Compares the extracted integer to zero to create a mask `c` that is 0 if the integer is less than 2^31, and -1 otherwise.
    - Converts the extracted integer to a double-precision floating-point vector `d`.
    - Adds 2^32 to `d` to create `ds`, which corrects the conversion for values greater than 2^31.
    - Converts the mask `c` to a 256-bit integer `cl`.
    - Blends `d` and `ds` using `cl` to produce the final result, effectively adding 2^32 to values that were originally greater than 2^31.
- **Output**: A vector of double-precision floating-point numbers (`__m256d`).


---
### wu\_to\_wf<!-- {{#callable:wu_to_wf}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L274>)

Converts a vector of unsigned 32-bit integers to a vector of single-precision floating-point numbers.
- **Inputs**:
    - ``a``: A vector of unsigned 32-bit integers (`wu_t`).
- **Logic and Control Flow**:
    - Converts the lower and upper halves of the input vector `a` to double-precision floating-point numbers using [`wu_to_wd`](<#wu_to_wd>) function.
    - Converts these double-precision numbers to single-precision floating-point numbers using `_mm256_cvtpd_ps`.
    - Concatenates the two halves of single-precision floating-point numbers to form the final result.
- **Output**: A vector of single-precision floating-point numbers (`wf_t`).
- **Functions Called**:
    - [`wu_to_wd`](<#wu_to_wd>)


---
### wu\_sum\_all<!-- {{#callable:wu_sum_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L301>)

Calculates the sum of all elements in a vector of unsigned 32-bit integers and broadcasts the result across all lanes of the vector.
- **Inputs**:
    - `x`: A vector of unsigned 32-bit integers (`wu_t`) containing the elements to sum.
- **Logic and Control Flow**:
    - Add the vector `x` to itself after permuting its 128-bit lanes, effectively summing pairs of elements across the lanes.
    - Perform a horizontal addition on the vector to sum adjacent pairs of elements, reducing the vector to half its size.
    - Perform another horizontal addition to sum the remaining elements, resulting in the total sum of the original vector elements.
    - Broadcast the total sum across all lanes of the vector and return it.
- **Output**: A vector (`wu_t`) where each lane contains the sum of all elements in the input vector `x`.


---
### wu\_min\_all<!-- {{#callable:wu_min_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L308>)

Finds the minimum value in a vector of unsigned 32-bit integers and broadcasts it across all lanes.
- **Inputs**:
    - `x`: A vector of type `wu_t` containing eight unsigned 32-bit integers.
- **Logic and Control Flow**:
    - Permute the input vector `x` to swap its two 128-bit lanes, storing the result in `y`.
    - Compute the element-wise minimum of `x` and `y`, updating `x`.
    - Shuffle `x` to rearrange its elements, storing the result in `y`.
    - Compute the element-wise minimum of `x` and `y`, updating `x`.
    - Shuffle `x` again to rearrange its elements, storing the result in `y`.
    - Compute the element-wise minimum of `x` and `y`, updating `x`.
- **Output**: A vector of type `wu_t` where all lanes contain the minimum value found in the input vector `x`.


---
### wu\_max\_all<!-- {{#callable:wu_max_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L319>)

Finds the maximum value in a vector of unsigned 32-bit integers and broadcasts it across all lanes.
- **Inputs**:
    - `x`: A vector of unsigned 32-bit integers (`wu_t`).
- **Logic and Control Flow**:
    - Permute the input vector `x` to swap its 128-bit lanes, storing the result in `y`.
    - Compute the element-wise maximum of `x` and `y`, updating `x`.
    - Shuffle `x` to rearrange its elements, storing the result in `y`.
    - Compute the element-wise maximum of `x` and `y`, updating `x`.
    - Shuffle `x` again to rearrange its elements, storing the result in `y`.
    - Compute the element-wise maximum of `x` and `y`, updating `x` to contain the maximum value across all lanes.
- **Output**: A vector (`wu_t`) where all lanes contain the maximum value found in the input vector `x`.


---
### wu\_gather<!-- {{#callable:wu_gather}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wu.h#L337>)

Gathers 32-bit integers from a base address using specified indices and returns them as a vector.
- **Inputs**:
    - `b`: A pointer to the base address of an array of unsigned 32-bit integers.
    - `i`: A vector of indices (`wi_t`) used to gather elements from the base address.
- **Logic and Control Flow**:
    - Uses the `_mm256_i32gather_epi32` intrinsic to gather 32-bit integers from the base address `b` using the indices specified in `i`.
    - The gathered integers are returned as a 256-bit vector of type `wu_t`.
- **Output**: A 256-bit vector (`wu_t`) containing the gathered 32-bit integers from the specified indices.



---
Made with ❤️ by [Driver](https://www.driver.ai/)