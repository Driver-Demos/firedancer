<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

AVX-based vector integer operations for 32-bit signed integers, including arithmetic, logical, and memory operations.

# Purpose
The code defines a set of macros and inline functions for handling 256-bit wide vector operations using AVX (Advanced Vector Extensions) in C. It focuses on operations for vectors of 32-bit signed integers, represented by the type `wi_t`, which is an alias for `__m256i`. The code provides a comprehensive API for constructing, manipulating, and performing arithmetic, logical, and memory operations on these vectors. It includes constructors for creating vectors with specific patterns, arithmetic operations like addition and multiplication, logical operations such as AND and OR, and memory operations for loading and storing vectors. Additionally, it provides conversion functions to transform vectors into different data types and reduction operations to compute sums, minimums, and maximums across vector elements.

The file is intended to be included indirectly through another header file, as indicated by the preprocessor directive at the beginning. This ensures that the macros and functions are used in the correct context. The code is designed to be used in performance-critical applications where SIMD (Single Instruction, Multiple Data) operations can provide significant speedups by processing multiple data elements in parallel. The use of macros and inline functions helps to minimize overhead and maximize the efficiency of these operations. The file does not define public APIs or external interfaces but provides a low-level utility for vector operations that can be used internally within a larger software system.
# Functions

---
### wi\_bcast\_pair<!-- {{#callable:wi_bcast_pair}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L26>)

Creates a vector of eight 32-bit integers with a repeating pattern of two input integers.
- **Inputs**:
    - `i0`: The first integer to be repeated in the vector.
    - `i1`: The second integer to be repeated in the vector.
- **Logic and Control Flow**:
    - Uses the `_mm256_setr_epi32` intrinsic to create a vector with the pattern `[i0, i1, i0, i1, i0, i1, i0, i1]`.
- **Output**: A `wi_t` vector containing the integers `[i0, i1, i0, i1, i0, i1, i0, i1]`.


---
### wi\_bcast\_lohi<!-- {{#callable:wi_bcast_lohi}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L31>)

Creates a vector with the first four lanes set to `i0` and the last four lanes set to `i1`.
- **Inputs**:
    - `i0`: The integer value to broadcast to the first four lanes of the vector.
    - `i1`: The integer value to broadcast to the last four lanes of the vector.
- **Logic and Control Flow**:
    - Calls `_mm256_setr_epi32` with `i0` repeated four times followed by `i1` repeated four times.
    - Returns the resulting `__m256i` vector.
- **Output**: A `__m256i` vector with the first four lanes set to `i0` and the last four lanes set to `i1`.


---
### wi\_bcast\_quad<!-- {{#callable:wi_bcast_quad}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L36>)

Creates a 256-bit integer vector with a specific pattern using four input integers.
- **Inputs**:
    - `i0`: The first integer to be used in the vector.
    - `i1`: The second integer to be used in the vector.
    - `i2`: The third integer to be used in the vector.
    - `i3`: The fourth integer to be used in the vector.
- **Logic and Control Flow**:
    - Uses the `_mm256_setr_epi32` intrinsic to create a 256-bit integer vector.
    - The vector is constructed with the pattern `[i0, i1, i2, i3, i0, i1, i2, i3]`.
- **Output**: A 256-bit integer vector (`wi_t`) with the specified pattern.


---
### wi\_bcast\_wide<!-- {{#callable:wi_bcast_wide}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L41>)

Creates a vector of 8 integers where each pair of integers is a duplicate of the input integers.
- **Inputs**:
    - `i0`: The first integer to duplicate in the vector.
    - `i1`: The second integer to duplicate in the vector.
    - `i2`: The third integer to duplicate in the vector.
    - `i3`: The fourth integer to duplicate in the vector.
- **Logic and Control Flow**:
    - Uses the `_mm256_setr_epi32` intrinsic to create a 256-bit vector.
    - Places `i0` in the first and second positions of the vector.
    - Places `i1` in the third and fourth positions of the vector.
    - Places `i2` in the fifth and sixth positions of the vector.
    - Places `i3` in the seventh and eighth positions of the vector.
- **Output**: A `wi_t` vector containing the integers `[i0, i0, i1, i1, i2, i2, i3, i3]`.


---
### wi\_exch\_adj\_quad<!-- {{#callable:wi_exch_adj_quad}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L62>)

Reorders the elements of a 256-bit integer vector by swapping the lower and upper 128-bit lanes.
- **Inputs**:
    - `x`: A 256-bit integer vector (`wi_t`) containing eight 32-bit signed integers.
- **Logic and Control Flow**:
    - Uses the `_mm256_permute2f128_si256` intrinsic to swap the lower and upper 128-bit lanes of the input vector `x`.
- **Output**: A 256-bit integer vector with the elements reordered as `[i4 i5 i6 i7 i0 i1 i2 i3]`.


---
### wi\_ld<!-- {{#callable:wi_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L83>)

Loads 8 integers from a 32-byte aligned memory location into a vector of 256-bit integers.
- **Inputs**:
    - `p`: A pointer to a constant integer array that is 32-byte aligned.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_load_si256` intrinsic to load 8 integers from the memory location pointed to by `p` into a 256-bit vector.
- **Output**: A 256-bit vector (`wi_t`) containing the 8 loaded integers.


---
### wi\_st<!-- {{#callable:wi_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L84>)

Stores a vector of eight 32-bit integers into a 32-byte aligned memory location.
- **Inputs**:
    - ``p``: A pointer to an integer array where the vector will be stored. The memory location must be 32-byte aligned.
    - ``i``: A vector of type `wi_t` containing eight 32-bit integers to store.
- **Logic and Control Flow**:
    - Uses the `_mm256_store_si256` intrinsic to store the vector `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wi\_ldu<!-- {{#callable:wi_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L86>)

Loads an unaligned 256-bit vector of integers from memory into a `wi_t` type.
- **Inputs**:
    - `p`: A pointer to a memory location from which to load the 256-bit vector of integers.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_loadu_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p`.
- **Output**: Returns a `wi_t` type, which is a 256-bit vector containing the loaded integers.


---
### wi\_stu<!-- {{#callable:wi_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L87>)

Stores a vector of 8 signed 32-bit integers to a memory location without alignment requirements.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector will be stored. The location does not need to be aligned.
    - ``i``: A vector of type `wi_t` containing 8 signed 32-bit integers to be stored.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the vector `i` at the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wi\_extract\_variable<!-- {{#callable:wi_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L112>)

Extracts an integer from a specified lane of a vector of 32-bit integers.
- **Inputs**:
    - ``a``: A vector of type `wi_t` containing eight 32-bit signed integers.
    - ``n``: An integer specifying the lane index (0 to 7) from which to extract the value.
- **Logic and Control Flow**:
    - Declare a union `t` with a `__m256i` array and an integer array, both of size 1.
    - Store the vector `a` into the `__m256i` member of the union `t`.
    - Return the integer at index `n` from the integer array member of the union `t`.
- **Output**: An integer extracted from the specified lane `n` of the vector `a`.


---
### wi\_insert\_variable<!-- {{#callable:wi_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L119>)

Replaces the integer at a specified index in a vector of integers with a new value.
- **Inputs**:
    - ``a``: A vector of integers (`wi_t`) where each lane holds a signed 32-bit integer.
    - ``n``: An integer index (0 to 7) indicating which lane in the vector to replace.
    - ``v``: The new integer value to insert into the vector at the specified index.
- **Logic and Control Flow**:
    - Stores the vector `a` into a temporary union `t` that allows access to individual integer lanes.
    - Replaces the integer at index `n` in the array `t->i` with the new value `v`.
    - Loads the modified vector from the union `t` and returns it.
- **Output**: A vector of integers (`wi_t`) with the specified lane replaced by the new value.


---
### wi\_rol<!-- {{#callable:wi_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L174>)

Performs a bitwise left rotation on each 32-bit lane of a vector of integers by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of integers (`wi_t`) on which to perform the left rotation.
    - ``imm``: An integer specifying the number of bits to rotate each lane of the vector `a` to the left.
- **Logic and Control Flow**:
    - Compute the left shift of vector `a` by `imm & 31` bits using `wi_shl` function.
    - Compute the right shift of vector `a` by `(-imm) & 31` bits using `wi_shru` function.
    - Combine the results of the left and right shifts using the bitwise OR operation with `wi_or` function.
- **Output**: Returns a vector of integers (`wi_t`) where each lane is the result of rotating the corresponding lane of `a` to the left by `imm` bits.


---
### wi\_ror<!-- {{#callable:wi_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L175>)

Performs a bitwise right rotation on each 32-bit lane of a vector integer by a specified number of bits.
- **Inputs**:
    - ``a``: A vector integer (`wi_t`) where each 32-bit lane holds a signed 32-bit integer.
    - ``imm``: An integer specifying the number of bits to rotate right, masked to the range [0, 31].
- **Logic and Control Flow**:
    - Masks `imm` with 31 to ensure it is within the range [0, 31].
    - Performs an unsigned right shift on `a` by `imm` bits using `wi_shru`.
    - Performs a left shift on `a` by `(-imm) & 31` bits using `wi_shl`.
    - Combines the results of the two shifts using a bitwise OR operation with `wi_or`.
- **Output**: Returns a vector integer (`wi_t`) with each lane rotated right by the specified number of bits.


---
### wi\_rol\_variable<!-- {{#callable:wi_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L178>)

Performs a variable bitwise left rotation on each 32-bit lane of a vector of integers.
- **Inputs**:
    - ``a``: A vector of 32-bit signed integers (`wi_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate each lane of the vector `a` to the left.
- **Logic and Control Flow**:
    - Compute `n & 31` to ensure the rotation count is within the range of 0 to 31 bits.
    - Perform a left shift on vector `a` by `n & 31` bits using `wi_shl_variable`.
    - Perform a right shift on vector `a` by `(-n) & 31` bits using `wi_shru_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wi_or`.
- **Output**: Returns a vector of 32-bit signed integers (`wi_t`) where each lane is the result of rotating the corresponding lane of `a` to the left by `n` bits.


---
### wi\_ror\_variable<!-- {{#callable:wi_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L179>)

Performs a variable bitwise right rotation on each 32-bit lane of a vector of integers.
- **Inputs**:
    - ``a``: A vector of 32-bit signed integers (`wi_t`) to rotate.
    - ``n``: An integer specifying the number of positions to rotate each element in the vector `a` to the right.
- **Logic and Control Flow**:
    - Compute the bitwise AND of `n` with 31 to ensure the rotation count is within the range [0, 31].
    - Perform an unsigned right shift on `a` by the computed value (`n & 31`) using `wi_shru_variable`.
    - Compute the bitwise AND of `-n` with 31 to determine the left shift amount.
    - Perform a left shift on `a` by the computed value (`(-n) & 31`) using `wi_shl_variable`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `wi_or`.
- **Output**: A vector of 32-bit signed integers (`wi_t`) where each element is the result of rotating the corresponding element in `a` to the right by `n` positions.


---
### wi\_rol\_vector<!-- {{#callable:wi_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L181>)

Performs a bitwise rotate left operation on each 32-bit lane of vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - ``a``: A vector of type `wi_t` where each lane contains a signed 32-bit integer to be rotated.
    - ``b``: A vector of type `wi_t` where each lane specifies the number of positions to rotate the corresponding lane in `a`.
- **Logic and Control Flow**:
    - Broadcasts the integer value 31 to all lanes of a vector `m` using `wi_bcast(31)` to create a mask for the rotation amount.
    - Performs a bitwise AND operation between vector `b` and the mask `m` to ensure the rotation amount is within the range [0, 31].
    - Calculates the left-shifted version of `a` using `wi_shl_vector(a, wi_and(b, m))`.
    - Calculates the right-shifted version of `a` using `wi_shru_vector(a, wi_and(wi_neg(b), m))`.
    - Combines the left-shifted and right-shifted results using a bitwise OR operation with `wi_or` to produce the final rotated vector.
- **Output**: A vector of type `wi_t` where each lane contains the result of rotating the corresponding lane in `a` left by the number of positions specified in `b`.


---
### wi\_ror\_vector<!-- {{#callable:wi_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L186>)

Performs a bitwise right rotation on each 32-bit lane of vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - `a`: A vector of type `wi_t` where each lane contains a signed 32-bit integer.
    - `b`: A vector of type `wi_t` where each lane specifies the number of positions to rotate the corresponding lane in `a` to the right.
- **Logic and Control Flow**:
    - Broadcasts the integer value 31 to all lanes of a vector `m` using `wi_bcast(31)`.
    - Performs a bitwise AND operation between `b` and `m` to ensure the shift amount is within the range [0, 31].
    - Calculates the right-shifted version of `a` using `wi_shru_vector(a, wi_and(b, m))`.
    - Calculates the left-shifted version of `a` using `wi_shl_vector(a, wi_and(wi_neg(b), m))`.
    - Combines the results of the right and left shifts using a bitwise OR operation with `wi_or`.
- **Output**: A vector of type `wi_t` where each lane contains the result of the right rotation of the corresponding lane in `a` by the amount specified in `b`.


---
### wi\_sum\_all<!-- {{#callable:wi_sum_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L259>)

Computes the sum of all elements in a vector of 32-bit integers and broadcasts the result across all lanes of the vector.
- **Inputs**:
    - `x`: A vector of type `wi_t` containing eight 32-bit signed integers.
- **Logic and Control Flow**:
    - Adds the vector `x` to itself after permuting its 128-bit lanes, effectively summing pairs of elements across the lanes.
    - Performs a horizontal addition on the vector to sum adjacent pairs of elements, reducing the vector to four sums.
    - Performs another horizontal addition to sum the remaining pairs, resulting in the total sum of all elements in the vector.
    - Broadcasts the total sum across all lanes of the vector.
- **Output**: A vector of type `wi_t` where each lane contains the sum of all elements in the input vector `x`.


---
### wi\_min\_all<!-- {{#callable:wi_min_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L266>)

Finds the minimum value in a vector of integers and broadcasts it across all lanes.
- **Inputs**:
    - ``x``: A vector of type `wi_t` containing eight 32-bit signed integers.
- **Logic and Control Flow**:
    - Permute the input vector `x` to swap its two 128-bit halves, storing the result in `y`.
    - Compute the element-wise minimum of `x` and `y`, updating `x`.
    - Shuffle `x` to rearrange its elements, storing the result in `y`.
    - Compute the element-wise minimum of `x` and `y`, updating `x`.
    - Shuffle `x` again to rearrange its elements, storing the result in `y`.
    - Compute the element-wise minimum of `x` and `y`, updating `x`.
- **Output**: A vector of type `wi_t` where all lanes contain the minimum value found in the input vector `x`.


---
### wi\_max\_all<!-- {{#callable:wi_max_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wi.h#L277>)

Finds the maximum value in a vector of integers and broadcasts it across all lanes of the vector.
- **Inputs**:
    - ``x``: A vector of 8 signed 32-bit integers (`wi_t`).
- **Logic and Control Flow**:
    - Permute the input vector `x` to swap its two 128-bit lanes, storing the result in `y`.
    - Compute the element-wise maximum of `x` and `y`, updating `x`.
    - Shuffle the elements of `x` to rearrange them, storing the result in `y`.
    - Compute the element-wise maximum of `x` and `y`, updating `x`.
    - Shuffle the elements of `x` again to rearrange them, storing the result in `y`.
    - Compute the element-wise maximum of `x` and `y`, updating `x`.
- **Output**: A vector where all lanes contain the maximum value found in the input vector `x`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)