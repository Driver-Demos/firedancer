<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines macros and functions for AVX-512 vector operations on 64-bit integers using `wwl_t` type.

# Purpose
The code defines a set of macros and inline functions for operations on 512-bit vectors using Intel's AVX-512 instruction set. It focuses on handling vectors of signed 64-bit integers, referred to as `wwl_t`, where each vector contains eight such integers. The code provides a comprehensive set of operations, including arithmetic, binary, comparison, and conditional operations, as well as memory and conversion functions. These operations are implemented using AVX-512 intrinsic functions, which allow for efficient parallel processing of data.

The code is structured to facilitate vector operations by defining macros for common tasks such as loading, storing, and manipulating vector data. It includes predefined constants, memory operations for aligned and unaligned data, and a variety of arithmetic and binary operations. Additionally, the code provides functions for vector permutation, selection, and conditional operations, as well as conversions between different data types. The use of macros and inline functions aims to optimize performance by leveraging the capabilities of the AVX-512 instruction set, making it suitable for high-performance computing tasks that require processing large datasets in parallel.
# Global Variables

---
### \_wwl\_transpose\_t0
- **Type**: ``wwl_t``
- **Description**: A vector type where each adjacent pair of 32-bit wide lanes holds a signed 64-bit two's-complement integer. The variable `_wwl_transpose_t0` is initialized using the `_mm512_shuffle_i64x2` intrinsic, which shuffles 64-bit integers from two source vectors, `_wwl_transpose_r0` and `_wwl_transpose_r2`, according to the control mask `0x88`. This operation is part of a larger process to transpose an 8x8 matrix of 64-bit integers.
- **Use**: Used in the `wwl_transpose_8x8` macro to perform an outer 4x4 transpose of 2x2 blocks in a matrix transposition operation.


---
### \_wwl\_transpose\_t1
- **Type**: ``wwl_t``
- **Description**: Holds the result of a shuffle operation on two `wwl_t` vectors, `_wwl_transpose_r1` and `_wwl_transpose_r3`, using the `_mm512_shuffle_i64x2` intrinsic with a control mask of `0x88`. This operation is part of a larger process to transpose an 8x8 matrix of 64-bit integers.
- **Use**: Used in the `wwl_transpose_8x8` macro to assist in transposing matrix rows into columns.


---
### \_wwl\_transpose\_t2
- **Type**: ``wwl_t``
- **Description**: The variable `_wwl_transpose_t2` is a vector of signed 64-bit integers, defined using the `__m512i` type. It is initialized by shuffling elements from two other vectors, `_wwl_transpose_r0` and `_wwl_transpose_r2`, using the `_mm512_shuffle_i64x2` intrinsic with a control mask of `0xdd`.
- **Use**: Used in the process of transposing an 8x8 matrix of 64-bit integers by rearranging elements from input vectors.


---
### \_wwl\_transpose\_t3
- **Type**: ``wwl_t``
- **Description**: A vector type where each adjacent pair of 32-bit wide lanes holds a signed 64-bit two's-complement integer. The variable `_wwl_transpose_t3` is initialized using the `_mm512_shuffle_i64x2` intrinsic, which shuffles 64-bit integers from two source vectors, `_wwl_transpose_r1` and `_wwl_transpose_r3`, according to the control mask `0xdd`. This operation is part of a larger 8x8 matrix transpose operation.
- **Use**: Used to store intermediate results during the outer 4x4 transpose of 2x2 blocks in the `wwl_transpose_8x8` macro.


---
### \_wwl\_transpose\_t4
- **Type**: ``wwl_t``
- **Description**: Holds the result of a shuffle operation on two `wwl_t` vectors, `_wwl_transpose_r4` and `_wwl_transpose_r6`, using the `_mm512_shuffle_i64x2` intrinsic with a control mask of `0x88`. This operation is part of a larger process to transpose an 8x8 matrix of 64-bit integers.
- **Use**: Used in the `wwl_transpose_8x8` macro to perform an outer 4x4 transpose of 2x2 blocks.


---
### \_wwl\_transpose\_t5
- **Type**: ``wwl_t``
- **Description**: The variable `_wwl_transpose_t5` is a vector of signed 64-bit integers, defined using the `__m512i` type. It is initialized by shuffling elements from two other vectors, `_wwl_transpose_r5` and `_wwl_transpose_r7`, using the `_mm512_shuffle_i64x2` intrinsic with a control mask of `0x88`.
- **Use**: Used in the process of transposing an 8x8 matrix of 64-bit integers by rearranging elements from two input vectors.


---
### \_wwl\_transpose\_t6
- **Type**: ``wwl_t``
- **Description**: A `wwl_t` is a vector type that holds eight signed 64-bit two's-complement integers, each represented by a pair of 32-bit lanes. The variable `_wwl_transpose_t6` is initialized using the `_mm512_shuffle_i64x2` intrinsic, which shuffles 64-bit integers from two source vectors, `_wwl_transpose_r4` and `_wwl_transpose_r6`, according to the control mask `0xdd`. This operation is part of a larger 8x8 matrix transpose operation.
- **Use**: Used to store intermediate results during the transpose of an 8x8 matrix of `wwl_t` vectors.


---
### \_wwl\_transpose\_t7
- **Type**: ``wwl_t``
- **Description**: Holds the result of a shuffle operation on two `wwl_t` vectors, `_wwl_transpose_r5` and `_wwl_transpose_r7`, using the `_mm512_shuffle_i64x2` intrinsic with a control mask of `0xdd`. This operation rearranges the 64-bit integer elements of the input vectors to form a new vector.
- **Use**: Used in the process of transposing an 8x8 matrix of 64-bit integers by rearranging elements of two input vectors.


# Functions

---
### wwl\_ld<!-- {{#callable:wwl_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L49>)

Loads a 512-bit vector of eight 64-bit integers from a 64-byte aligned memory address.
- **Inputs**:
    - `m`: A pointer to a constant long integer array, which must be 64-byte aligned, from which the function loads data.
- **Logic and Control Flow**:
    - Uses the `_mm512_load_epi64` intrinsic to load eight 64-bit integers from the memory location pointed to by `m`.
- **Output**: Returns a `wwl_t` type, which is a 512-bit vector containing the loaded eight 64-bit integers.


---
### wwl\_st<!-- {{#callable:wwl_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L50>)

Stores the elements of a `wwl_t` vector into a memory location.
- **Inputs**:
    - `m`: A pointer to a memory location where the elements of the vector will be stored. It must be 64-byte aligned.
    - `x`: A `wwl_t` vector containing eight 64-bit integers to be stored in memory.
- **Logic and Control Flow**:
    - Uses the `_mm512_store_epi64` intrinsic to store the elements of the `wwl_t` vector `x` into the memory location pointed to by `m`.
    - The operation stores each element of the vector `x` into consecutive memory locations starting from `m[0]` to `m[7]`.
- **Output**: No return value; the function performs a memory store operation.


---
### wwl\_ldu<!-- {{#callable:wwl_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L52>)

Loads a vector of eight 64-bit integers from memory with arbitrary alignment.
- **Inputs**:
    - `m`: A pointer to the memory location from which to load the vector of eight 64-bit integers.
- **Logic and Control Flow**:
    - Uses the `_mm512_loadu_epi64` intrinsic to load data from the memory location pointed to by `m`.
- **Output**: Returns a `wwl_t` type, which is a vector containing the loaded eight 64-bit integers.


---
### wwl\_stu<!-- {{#callable:wwl_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L53>)

Stores a vector of 64-bit integers into memory with arbitrary alignment.
- **Inputs**:
    - ``m``: A pointer to the memory location where the vector will be stored. The memory can have arbitrary alignment.
    - ``x``: A `wwl_t` type vector containing eight 64-bit integers to store.
- **Logic and Control Flow**:
    - Uses the `_mm512_storeu_epi64` intrinsic to store the vector `x` into the memory location pointed to by `m`.
- **Output**: No return value; the function performs a memory store operation.


---
### wwl\_rol\_variable<!-- {{#callable:wwl_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L97>)

Performs a variable left rotation on a vector of 64-bit integers.
- **Inputs**:
    - ``a``: A vector of 64-bit integers (`wwl_t`) to rotate.
    - ``n``: The number of positions to rotate each element in the vector to the left.
- **Logic and Control Flow**:
    - Compute `n & 63L` to ensure the rotation count is within the range of 0 to 63.
    - Perform a left shift on `a` by `n & 63L` positions using `wwl_shl`.
    - Perform a right logical shift on `a` by `(-n) & 63L` positions using `wwl_shru`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wwl_or`.
- **Output**: Returns a `wwl_t` vector where each 64-bit integer is left-rotated by `n` positions.


---
### wwl\_ror\_variable<!-- {{#callable:wwl_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L98>)

Performs a variable right rotation on a vector of 64-bit integers.
- **Inputs**:
    - ``a``: A `wwl_t` vector containing 64-bit integers to rotate.
    - ``n``: A `long` integer specifying the number of positions to rotate the elements in `a` to the right.
- **Logic and Control Flow**:
    - Calculates `n & 63L` to ensure the rotation amount is within the range of 0 to 63.
    - Performs an unsigned right shift on `a` by `n & 63L` using `wwl_shru`.
    - Calculates `(-n) & 63L` to determine the equivalent left shift amount.
    - Performs a left shift on `a` by `(-n) & 63L` using `wwl_shl`.
    - Combines the results of the right and left shifts using a bitwise OR operation with `wwl_or`.
- **Output**: Returns a `wwl_t` vector where each 64-bit integer in `a` is right-rotated by `n` positions.


---
### wwl\_rol\_vector<!-- {{#callable:wwl_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L100>)

Performs a vectorized left rotation on each 64-bit element of vector `a` by the corresponding element in vector `b`.
- **Inputs**:
    - `a`: A vector of type `wwl_t` containing 64-bit elements to rotate.
    - `b`: A vector of type `wwl_t` containing 64-bit elements that specify the number of positions to rotate the corresponding elements in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `63L` to all elements of a vector `m` using `wwl_bcast` to ensure shifts are within 0-63 range.
    - Performs a bitwise AND operation between each element of `b` and `m` to limit the shift amount to 0-63 using `wwl_and`.
    - Calculates the left-shifted version of `a` by the masked `b` using `wwl_shl_vector`.
    - Calculates the right-shifted version of `a` by the negated and masked `b` using `wwl_shru_vector`.
    - Combines the results of the left and right shifts using a bitwise OR operation with `wwl_or` to complete the rotation.
- **Output**: Returns a vector of type `wwl_t` where each element is the result of rotating the corresponding element in `a` left by the number of positions specified in `b`.


---
### wwl\_ror\_vector<!-- {{#callable:wwl_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwl.h#L105>)

Performs a bitwise right rotation on each 64-bit element of vector `a` by the corresponding element in vector `b`.
- **Inputs**:
    - `a`: A vector of type `wwl_t` containing 64-bit elements to be rotated.
    - `b`: A vector of type `wwl_t` containing 64-bit elements that specify the number of positions to rotate the corresponding elements in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value 63 into a vector `m` using `wwl_bcast` to ensure shifts are within 0-63 range.
    - Performs a bitwise AND operation between `b` and `m` to limit the shift amount to 0-63, then performs an unsigned right shift on `a` using `wwl_shru_vector`.
    - Negates `b` using `wwl_neg`, performs a bitwise AND with `m`, and then performs a left shift on `a` using `wwl_shl_vector`.
    - Combines the results of the right and left shifts using a bitwise OR operation with `wwl_or` to complete the rotation.
- **Output**: Returns a vector of type `wwl_t` where each element is the result of the right rotation of the corresponding element in `a` by the number of positions specified in `b`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)