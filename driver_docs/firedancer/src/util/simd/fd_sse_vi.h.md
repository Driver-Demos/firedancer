<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Header file for vector integer operations using SSE intrinsics, including arithmetic, logical, and memory operations.

# Purpose
The code defines a set of macros and inline functions for handling 128-bit SIMD (Single Instruction, Multiple Data) operations on vectors of 32-bit integers using the SSE (Streaming SIMD Extensions) instruction set. It provides a comprehensive API for vector integer operations, including construction, memory operations, arithmetic, binary, logical, conditional, conversion, reduction, and miscellaneous operations. The code is intended to be included indirectly through a header file `fd_sse.h`, as indicated by the preprocessor directive at the beginning.

The primary data type used is `vi_t`, which represents a vector of four 32-bit signed integers. The code includes macros for creating vectors, broadcasting values, and performing various arithmetic and logical operations. It also provides functions for loading and storing vectors from memory, extracting and inserting elements, and performing reductions like sum, minimum, and maximum. Additionally, the code includes operations for vector permutation, conditional selection, and type conversion between different vector types. The use of macros and inline functions aims to optimize performance by leveraging the compiler's ability to inline and optimize these operations.
# Functions

---
### vi\_bcast\_pair<!-- {{#callable:vi_bcast_pair}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L25>)

Creates a vector with the pattern [i0, i1, i0, i1] using two integer inputs.
- **Inputs**:
    - `i0`: The first integer to be used in the vector.
    - `i1`: The second integer to be used in the vector.
- **Logic and Control Flow**:
    - Calls the `_mm_setr_epi32` function with the arguments `i0`, `i1`, `i0`, and `i1`.
- **Output**: A `vi_t` vector with the pattern [i0, i1, i0, i1].


---
### vi\_bcast\_wide<!-- {{#callable:vi_bcast_wide}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L30>)

Creates a vector with two pairs of repeated integers.
- **Inputs**:
    - `i0`: The first integer to repeat in the vector.
    - `i1`: The second integer to repeat in the vector.
- **Logic and Control Flow**:
    - Uses the `_mm_setr_epi32` intrinsic to create a vector with the pattern `[i0, i0, i1, i1]`.
- **Output**: A `vi_t` vector containing the integers `[i0, i0, i1, i1]`.


---
### vi\_ld<!-- {{#callable:vi_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L56>)

Loads a 128-bit vector of four 32-bit integers from a 16-byte aligned memory location.
- **Inputs**:
    - `p`: A pointer to a 16-byte aligned memory location containing four 32-bit integers.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m128i const *`.
    - Uses the `_mm_load_si128` intrinsic to load a 128-bit vector from the memory location pointed to by the casted pointer.
- **Output**: Returns a `vi_t` type, which is a 128-bit vector containing four 32-bit integers loaded from the specified memory location.


---
### vi\_st<!-- {{#callable:vi_st}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L57>)

Stores a vector of four 32-bit integers into a 16-byte aligned memory location.
- **Inputs**:
    - ``p``: A pointer to an integer array where the vector will be stored. The memory location must be 16-byte aligned.
    - ``i``: A vector of type `vi_t` containing four 32-bit integers to be stored.
- **Logic and Control Flow**:
    - Uses the `_mm_store_si128` intrinsic to store the vector `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### vi\_ldu<!-- {{#callable:vi_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L59>)

Loads a 128-bit vector of integers from an unaligned memory address.
- **Inputs**:
    - `p`: A pointer to the memory location from which to load the vector of integers. The pointer does not need to be aligned.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m128i const *`.
    - Uses the `_mm_loadu_si128` intrinsic to load a 128-bit vector from the unaligned memory location pointed to by the casted pointer.
- **Output**: Returns a `vi_t` type, which is a 128-bit vector containing four 32-bit signed integers loaded from the specified memory location.


---
### vi\_stu<!-- {{#callable:vi_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L60>)

Stores a vector of four 32-bit integers into a memory location without requiring alignment.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector will be stored. The location does not need to be aligned.
    - ``i``: A vector of four 32-bit signed integers (`vi_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm_storeu_si128` intrinsic to store the vector `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### vi\_extract\_variable<!-- {{#callable:vi_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L85>)

Extracts an integer from a specified lane of a vector integer.
- **Inputs**:
    - ``a``: A vector integer of type `vi_t` from which to extract an integer.
    - ``n``: An integer specifying the lane (0 to 3) from which to extract the integer.
- **Logic and Control Flow**:
    - Declare a union `t` with a `__m128i` array and an integer array, both of size 1.
    - Store the vector integer `a` into the `__m128i` array of the union `t`.
    - Return the integer from the `n`-th position of the integer array of the union `t`.
- **Output**: Returns the integer from the specified lane `n` of the vector integer `a`.


---
### vi\_insert\_variable<!-- {{#callable:vi_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L92>)

Replaces the integer at a specified lane in a vector with a new integer value.
- **Inputs**:
    - ``a``: A vector of type `vi_t` containing four 32-bit integers.
    - ``n``: An integer specifying the lane index (0 to 3) in the vector where the replacement will occur.
    - ``v``: An integer value to insert into the specified lane of the vector.
- **Logic and Control Flow**:
    - Store the vector `a` into a temporary union `t` that can be accessed as an array of integers.
    - Replace the integer at index `n` in the array `t->i` with the new integer `v`.
    - Load the modified array back into a vector and return it.
- **Output**: A vector of type `vi_t` with the integer at lane `n` replaced by `v`.


---
### vi\_rol<!-- {{#callable:vi_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L146>)

Performs a bitwise left rotation on each 32-bit lane of a vector integer by a specified number of bits.
- **Inputs**:
    - ``a``: A vector integer (`vi_t`) where each 32-bit lane will be rotated.
    - ``imm``: An integer specifying the number of bits to rotate each lane to the left.
- **Logic and Control Flow**:
    - Compute the left shift of `a` by `imm & 31` bits using `vi_shl`.
    - Compute the right shift of `a` by `(-imm) & 31` bits using `vi_shru`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `vi_or`.
- **Output**: Returns a vector integer (`vi_t`) with each lane rotated left by the specified number of bits.


---
### vi\_ror<!-- {{#callable:vi_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L147>)

Performs a bitwise right rotation on each 32-bit integer in a vector by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of 32-bit signed integers (`vi_t`).
    - ``imm``: An integer specifying the number of bits to rotate right, masked to 0-31.
- **Logic and Control Flow**:
    - Masks the `imm` value with 31 to ensure it is within the range of 0 to 31.
    - Performs an unsigned right shift on the vector `a` by the masked `imm` value using `vi_shru`.
    - Performs a left shift on the vector `a` by the negated and masked `imm` value using `vi_shl`.
    - Combines the results of the two shifts using a bitwise OR operation with `vi_or`.
- **Output**: A vector of 32-bit signed integers (`vi_t`) with each element rotated right by the specified number of bits.


---
### vi\_rol\_variable<!-- {{#callable:vi_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L150>)

Performs a variable bitwise left rotation on a 128-bit vector of signed 32-bit integers.
- **Inputs**:
    - ``a``: A 128-bit vector of signed 32-bit integers (`vi_t`).
    - ``n``: An integer specifying the number of positions to rotate the bits to the left.
- **Logic and Control Flow**:
    - Compute `n & 31` to ensure the rotation count is within the range of 0 to 31 bits.
    - Perform a left shift on vector `a` by `n & 31` bits using `vi_shl_variable`.
    - Compute `(-n) & 31` to determine the equivalent right shift count.
    - Perform a right logical shift on vector `a` by `(-n) & 31` bits using `vi_shru_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `vi_or`.
- **Output**: Returns a 128-bit vector of signed 32-bit integers (`vi_t`) with the bits rotated to the left by `n` positions.


---
### vi\_ror\_variable<!-- {{#callable:vi_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L151>)

Performs a variable bitwise right rotation on a vector of 32-bit integers.
- **Inputs**:
    - ``a``: A vector of 32-bit signed integers (`vi_t`) to rotate.
    - ``n``: An integer specifying the number of positions to rotate the vector `a` to the right.
- **Logic and Control Flow**:
    - Compute `n & 31` to ensure the rotation count is within the range of 0 to 31 bits.
    - Perform an unsigned right shift on vector `a` by `n & 31` bits using `vi_shru_variable`.
    - Perform a left shift on vector `a` by `(-n) & 31` bits using `vi_shl_variable`.
    - Combine the results of the two shifts using a bitwise OR operation with `vi_or`.
- **Output**: Returns a vector of 32-bit signed integers (`vi_t`) that is the result of the right rotation of the input vector `a` by `n` positions.


---
### vi\_rol\_vector<!-- {{#callable:vi_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L153>)

Performs a bitwise left rotation on each 32-bit integer in vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - `a`: A vector of 32-bit signed integers to be rotated.
    - `b`: A vector of 32-bit signed integers specifying the number of positions to rotate each corresponding integer in `a`.
- **Logic and Control Flow**:
    - Broadcasts the integer 31 to all lanes of a vector `m` using `vi_bcast` to create a mask for bitwise operations.
    - Performs a bitwise AND operation between `b` and `m` to ensure the shift amount is within the range of 0 to 31.
    - Calculates the left-shifted version of `a` using `vi_shl_vector` with the masked `b` as the shift amount.
    - Calculates the right-shifted version of `a` using `vi_shru_vector` with the negated and masked `b` as the shift amount.
    - Combines the left-shifted and right-shifted results using a bitwise OR operation with `vi_or` to achieve the rotation effect.
- **Output**: A vector of 32-bit signed integers, each rotated left by the specified amount in `b`.


---
### vi\_ror\_vector<!-- {{#callable:vi_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L158>)

Performs a bitwise right rotation on each 32-bit lane of vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - `a`: A vector of type `vi_t` where each 32-bit lane holds a signed 32-bit integer.
    - `b`: A vector of type `vi_t` specifying the number of positions to rotate each corresponding lane of `a` to the right.
- **Logic and Control Flow**:
    - Broadcasts the integer value 31 to all lanes of a vector `m` using `vi_bcast(31)`.
    - Performs a bitwise AND operation between `b` and `m` to ensure the shift amount is within 0 to 31, then performs an unsigned right shift on `a` by this amount using `vi_shru_vector`.
    - Performs a bitwise AND operation between the negation of `b` and `m`, then performs a left shift on `a` by this amount using `vi_shl_vector`.
    - Combines the results of the right and left shifts using a bitwise OR operation with `vi_or`.
- **Output**: A vector of type `vi_t` containing the result of the right rotation for each lane.


---
### vi\_sum\_all<!-- {{#callable:vi_sum_all}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L223>)

Computes the sum of all elements in a vector of four 32-bit integers and broadcasts the result to all elements of the vector.
- **Inputs**:
    - `x`: A vector of four 32-bit signed integers (`vi_t`).
- **Logic and Control Flow**:
    - Performs a horizontal addition of the vector `x` with itself, resulting in a vector where the first two elements are the sums of the first two pairs of the original vector.
    - Performs another horizontal addition on the resulting vector, producing a vector where all elements are the sum of the original vector's elements.
- **Output**: A vector (`vi_t`) where all four elements are the sum of the input vector's elements.


---
### vi\_min\_all<!-- {{#callable:vi_min_all}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L229>)

Finds the minimum value in a vector of four 32-bit integers and broadcasts it across all lanes of the vector.
- **Inputs**:
    - `x`: A vector of four 32-bit signed integers (`vi_t`).
- **Logic and Control Flow**:
    - Shuffle the input vector `x` to rearrange its elements using `_mm_shuffle_epi32` with the shuffle mask `_MM_SHUFFLE(1, 0, 3, 2)`.
    - Compute the minimum of the original and shuffled vectors using `_mm_min_epi32`, storing the result back in `x`.
    - Shuffle the result again with the mask `_MM_SHUFFLE(2, 3, 0, 1)`.
    - Compute the minimum of the current `x` and the newly shuffled vector, storing the final result in `x`.
- **Output**: A vector where all four lanes contain the minimum value found in the input vector `x`.


---
### vi\_max\_all<!-- {{#callable:vi_max_all}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vi.h#L239>)

Finds the maximum value in a vector of four 32-bit integers and broadcasts it across all lanes of the vector.
- **Inputs**:
    - `x`: A vector of four 32-bit signed integers (`vi_t`).
- **Logic and Control Flow**:
    - Shuffle the input vector `x` to rearrange its elements using `_mm_shuffle_epi32` with the shuffle mask `_MM_SHUFFLE(1, 0, 3, 2)`.
    - Compute the element-wise maximum of the original and shuffled vectors using `_mm_max_epi32`.
    - Shuffle the resulting vector again with the shuffle mask `_MM_SHUFFLE(2, 3, 0, 1)`.
    - Compute the element-wise maximum of the vector from the previous step and the newly shuffled vector.
    - Return the vector where all lanes contain the maximum value found in the original vector.
- **Output**: A vector (`vi_t`) where all four lanes contain the maximum value from the input vector `x`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)