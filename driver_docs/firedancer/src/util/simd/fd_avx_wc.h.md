<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Vector conditional API for AVX SIMD operations, including constructors, memory, and logical operations.

# Purpose
The code defines a set of macros and inline functions for handling vector conditionals using AVX (Advanced Vector Extensions) in C. It is designed to work with 256-bit wide SIMD (Single Instruction, Multiple Data) lanes, specifically focusing on 32-bit integer operations. The primary data type used is `wc_t`, which represents a vector conditional where each 32-bit lane can be either 0 (indicating true) or -1 (indicating false). This allows for efficient bitwise operations on vectors, which can be used to mask other types of vectors.

The code provides a comprehensive API for constructing, manipulating, and operating on these vector conditionals. It includes constructors like `wc`, [`wc_bcast`](<#wc_bcast>), and [`wc_bcast_pair`](<#wc_bcast_pair>) for creating vector conditionals from logical values. It also includes memory operations such as [`wc_ld`](<#wc_ld>) and [`wc_st`](<#wc_st>) for loading and storing vector conditionals, as well as various binary and logical operations like `wc_and`, `wc_or`, and `wc_not`. Additionally, the code offers conversion functions to transform vector conditionals into other vector types, and reduction operations to evaluate conditions across all lanes. The code is intended to be included indirectly through `fd_avx.h`, as indicated by the initial preprocessor directive.
# Functions

---
### wc\_bcast<!-- {{#callable:wc_bcast}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L48>)

Broadcasts a single integer value across all lanes of a 256-bit AVX vector, converting it to a vector conditional format.
- **Inputs**:
    - `c0`: An integer value to broadcast across all lanes of the vector. It is treated as a C-style logical value, where zero is false and non-zero is true.
- **Logic and Control Flow**:
    - Convert `c0` to a C-style logical value by using `-!!c0`, which results in 0 for false and -1 for true.
    - Call `FD_COMPILER_FORGET(c0)` to prevent the compiler from optimizing away the conversion.
    - Use `_mm256_set1_epi32(c0)` to set all lanes of a 256-bit AVX vector to the value of `c0`.
- **Output**: Returns a 256-bit AVX vector (`__m256i`) with all lanes set to the logical value of `c0`.


---
### wc\_bcast\_pair<!-- {{#callable:wc_bcast_pair}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L55>)

Creates a vector conditional with alternating lanes set to the logical values of two input integers.
- **Inputs**:
    - `c0`: An integer representing a logical value; non-zero becomes -1 (true), zero becomes 0 (false).
    - `c1`: An integer representing a logical value; non-zero becomes -1 (true), zero becomes 0 (false).
- **Logic and Control Flow**:
    - Convert `c0` to -1 if non-zero, otherwise 0.
    - Convert `c1` to -1 if non-zero, otherwise 0.
    - Return a vector with the pattern [c0, c1, c0, c1, c0, c1, c0, c1].
- **Output**: A `wc_t` vector with alternating lanes set to the logical values of `c0` and `c1`.


---
### wc\_bcast\_lohi<!-- {{#callable:wc_bcast_lohi}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L61>)

Creates a vector conditional with the first four lanes set to the logical value of `c0` and the last four lanes set to the logical value of `c1`.
- **Inputs**:
    - `c0`: An integer representing a logical value for the first four lanes of the vector.
    - `c1`: An integer representing a logical value for the last four lanes of the vector.
- **Logic and Control Flow**:
    - Convert `c0` to a logical value where non-zero becomes -1 and zero becomes 0.
    - Convert `c1` to a logical value where non-zero becomes -1 and zero becomes 0.
    - Use `_mm256_setr_epi32` to create a vector with the first four lanes set to `c0` and the last four lanes set to `c1`.
- **Output**: A `wc_t` vector conditional with the first four lanes set to the logical value of `c0` and the last four lanes set to the logical value of `c1`.


---
### wc\_bcast\_quad<!-- {{#callable:wc_bcast_quad}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L67>)

Creates a vector conditional with four pairs of 32-bit lanes, each pair set to the logical negation of the input integers.
- **Inputs**:
    - `c0`: An integer representing a logical condition for the first and fifth lanes.
    - `c1`: An integer representing a logical condition for the second and sixth lanes.
    - `c2`: An integer representing a logical condition for the third and seventh lanes.
    - `c3`: An integer representing a logical condition for the fourth and eighth lanes.
- **Logic and Control Flow**:
    - Convert each input integer `c0`, `c1`, `c2`, and `c3` to a logical value where non-zero becomes -1 and zero becomes 0.
    - Use `_mm256_setr_epi32` to create a vector with the pattern `[c0, c1, c2, c3, c0, c1, c2, c3]`.
- **Output**: Returns a `wc_t` vector conditional with the specified pattern of logical values.


---
### wc\_bcast\_wide<!-- {{#callable:wc_bcast_wide}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L73>)

Creates a vector conditional with each pair of lanes set to the logical value of the corresponding input integer.
- **Inputs**:
    - `c0`: An integer representing a logical value for the first pair of lanes.
    - `c1`: An integer representing a logical value for the second pair of lanes.
    - `c2`: An integer representing a logical value for the third pair of lanes.
    - `c3`: An integer representing a logical value for the fourth pair of lanes.
- **Logic and Control Flow**:
    - Convert each input integer `c0`, `c1`, `c2`, and `c3` to -1 if non-zero or 0 if zero using the expression `-!!c`.
    - Use `_mm256_setr_epi32` to create a vector with the pattern `[c0, c0, c1, c1, c2, c2, c3, c3]`.
- **Output**: Returns a `wc_t` vector conditional with each pair of lanes set to the logical value of the corresponding input integer.


---
### wc\_exch\_adj\_quad<!-- {{#callable:wc_exch_adj_quad}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L95>)

Reorders the 128-bit lanes of a 256-bit vector by swapping the first and second 128-bit lanes.
- **Inputs**:
    - `c`: A 256-bit vector of type `wc_t` representing a vector conditional.
- **Logic and Control Flow**:
    - Uses the `_mm256_permute2f128_si256` intrinsic to reorder the 128-bit lanes of the input vector `c`.
    - The intrinsic swaps the first and second 128-bit lanes of the vector.
- **Output**: A 256-bit vector of type `wc_t` with the 128-bit lanes swapped.


---
### wc\_ld<!-- {{#callable:wc_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L119>)

Loads 8 integers from a 32-byte aligned memory location and returns a vector conditional where each lane is 0 if the integer is zero, or -1 otherwise.
- **Inputs**:
    - `p`: A pointer to a 32-byte aligned memory location containing 8 integers.
- **Logic and Control Flow**:
    - Load 8 integers from the memory location pointed to by `p` using `_mm256_load_si256`.
    - Compare each loaded integer to zero using `_mm256_cmpeq_epi32`, resulting in a vector where each lane is 0xFFFFFFFF if the integer is zero, or 0 otherwise.
    - Invert the comparison result using `_mm256_xor_si256` with a vector of all bits set to 1, resulting in a vector where each lane is 0 if the integer is zero, or -1 otherwise.
- **Output**: A `wc_t` vector conditional with each lane set to 0 if the corresponding integer is zero, or -1 otherwise.


---
### wc\_ld\_fast<!-- {{#callable:wc_ld_fast}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L124>)

Loads a 256-bit vector from a 32-byte aligned memory location.
- **Inputs**:
    - `p`: A pointer to a constant integer array, which must be 32-byte aligned.
- **Logic and Control Flow**:
    - Uses the `_mm256_load_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p`.
- **Output**: Returns a `wc_t` type, which is a 256-bit vector loaded from the specified memory location.


---
### wc\_st<!-- {{#callable:wc_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L125>)

Stores a vector conditional `c` into a 32-byte aligned memory location `p`.
- **Inputs**:
    - `p`: A pointer to an integer array where the vector conditional will be stored. It must be 32-byte aligned.
    - `c`: A vector conditional of type `wc_t` to be stored at the location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_store_si256` intrinsic to store the vector conditional `c` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wc\_ldu<!-- {{#callable:wc_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L127>)

Loads an unaligned 256-bit vector from memory and returns a vector conditional with lanes set to -1 if the loaded value is zero, otherwise 0.
- **Inputs**:
    - `p`: A pointer to the memory location from which to load the 256-bit vector.
- **Logic and Control Flow**:
    - Load a 256-bit vector from the memory location pointed to by `p` using `_mm256_loadu_si256`.
    - Compare the loaded vector with a zero vector using `_mm256_cmpeq_epi32`, resulting in a vector where each lane is set to -1 if the corresponding lane in the loaded vector is zero, otherwise 0.
    - Invert the comparison result using `_mm256_xor_si256` with a vector of all -1s, effectively flipping the bits, so that lanes that were zero become -1 and non-zero lanes become 0.
- **Output**: A `wc_t` vector conditional where each lane is -1 if the corresponding lane in the loaded vector was zero, otherwise 0.


---
### wc\_ldu\_fast<!-- {{#callable:wc_ldu_fast}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L132>)

Loads a 256-bit vector from an unaligned memory address.
- **Inputs**:
    - ``p``: A pointer to a memory location from which to load the 256-bit vector.
- **Logic and Control Flow**:
    - Use the `_mm256_loadu_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p`.
- **Output**: Returns a `wc_t` type, which is a 256-bit vector loaded from the specified memory location.


---
### wc\_stu<!-- {{#callable:wc_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L133>)

Stores a vector conditional `wc_t` to a memory location without alignment requirements.
- **Inputs**:
    - `p`: A pointer to the memory location where the vector conditional will be stored. The location does not need to be aligned.
    - `c`: The vector conditional of type `wc_t` to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the vector conditional `c` at the memory location `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wc\_narrow<!-- {{#callable:wc_narrow}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wc.h#L275>)

Combines two 256-bit vector conditionals into a single 256-bit vector by interleaving specific elements from each input.
- **Inputs**:
    - ``a``: A 256-bit vector conditional of type `wc_t`.
    - ``b``: A 256-bit vector conditional of type `wc_t`.
- **Logic and Control Flow**:
    - Extracts the lower 128 bits from vector `a` and casts them to a 128-bit floating-point vector `a01`.
    - Extracts the upper 128 bits from vector `a` and casts them to a 128-bit floating-point vector `a23`.
    - Extracts the lower 128 bits from vector `b` and casts them to a 128-bit floating-point vector `b01`.
    - Extracts the upper 128 bits from vector `b` and casts them to a 128-bit floating-point vector `b23`.
    - Shuffles the elements of `a01` and `a23` to interleave the lower elements, resulting in a 128-bit integer vector.
    - Shuffles the elements of `b01` and `b23` to interleave the lower elements, resulting in a 128-bit integer vector.
    - Combines the two 128-bit integer vectors into a single 256-bit vector.
- **Output**: A 256-bit vector conditional of type `wc_t` that contains interleaved elements from the input vectors `a` and `b`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)