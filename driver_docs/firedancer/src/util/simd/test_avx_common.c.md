<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for AVX SIMD operations on various data types, including extraction, insertion, and memory operations.

# Purpose
The code is a C source file that defines a series of test functions for various data types and operations, likely related to vectorized operations using SIMD (Single Instruction, Multiple Data) instructions. Each function tests a specific data type, such as `wc_t`, `wf_t`, `wi_t`, `wu_t`, `wd_t`, `wl_t`, `wv_t`, `ws_t`, `wh_t`, and `wb_t`, which appear to be custom types representing different kinds of vectors or packed data. The functions perform a series of operations to verify the correctness of data extraction, insertion, storage, and loading operations on these vector types.

The test functions follow a common pattern: they extract elements from a vector, perform variable extraction, store the vector in memory (both aligned and unaligned), load the vector back from memory, and compare the results to ensure data integrity. They also test the insertion of elements into vectors and verify the results. The functions return `1` if all tests pass and `0` if any test fails. This code is likely part of a test suite for a library that provides SIMD operations, ensuring that the operations behave as expected across different data types and memory alignments.
# Imports and Dependencies

---
- `../fd_util.h`
- `fd_avx.h`


# Functions

---
### wc\_test<!-- {{#callable:wc_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L4>)

Validates the operations on a `wc_t` type by testing packing, unpacking, extraction, insertion, and memory operations.
- **Inputs**:
    - `c`: A `wc_t` type representing a vector of 8 boolean values.
    - `c0`: An integer representing the first boolean value in the vector.
    - `c1`: An integer representing the second boolean value in the vector.
    - `c2`: An integer representing the third boolean value in the vector.
    - `c3`: An integer representing the fourth boolean value in the vector.
    - `c4`: An integer representing the fifth boolean value in the vector.
    - `c5`: An integer representing the sixth boolean value in the vector.
    - `c6`: An integer representing the seventh boolean value in the vector.
    - `c7`: An integer representing the eighth boolean value in the vector.
- **Logic and Control Flow**:
    - Convert each `c0` to `c7` to boolean values (0 or 1).
    - Initialize a volatile integer array `_` and an integer array `m` with 79 elements.
    - Set all elements of `m` to zero using `fd_memset`.
    - Pack the boolean values into an integer `b` and compare with the packed value of `c`.
    - Unpack `b` and compare with `c` using `wc_eq` and `wc_pack`.
    - Extract each boolean value from `c` and compare with `c0` to `c7`.
    - Use `wc_extract_variable` to extract values from `c` using indices stored in `_` and compare with `c0` to `c7`.
    - Store `c` into `m` using aligned and unaligned store functions [`wc_st`](<fd_avx_wc.h.md#wc_st>) and [`wc_stu`](<fd_avx_wc.h.md#wc_stu>).
    - Load values from `m` using [`wc_ld_fast`](<fd_avx_wc.h.md#wc_ld_fast>) and [`wc_ldu_fast`](<fd_avx_wc.h.md#wc_ldu_fast>) and compare with `c` using `wc_ne`.
    - Gather values from `m` using `wc_gather_fast` and compare with `c`.
    - Multiply each element of `m` by its index plus one.
    - Load values from `m` using [`wc_ld`](<fd_avx_wc.h.md#wc_ld>) and [`wc_ldu`](<fd_avx_wc.h.md#wc_ldu>) and compare with `c` using `wc_eq`.
    - Gather values from `m` using `wc_gather` and compare with `c`.
    - Insert boolean values into a new `wc_t` using `wc_insert` and compare with `c` using `wc_ne`.
    - Insert boolean values into a new `wc_t` using `wc_insert_variable` and compare with `c` using `wc_ne`.
    - Return 1 if all tests pass, otherwise return 0.
- **Output**: Returns 1 if all tests pass, otherwise returns 0.
- **Functions Called**:
    - [`wc_st`](<fd_avx_wc.h.md#wc_st>)
    - [`wc_stu`](<fd_avx_wc.h.md#wc_stu>)
    - [`wc_ld_fast`](<fd_avx_wc.h.md#wc_ld_fast>)
    - [`wc_ldu_fast`](<fd_avx_wc.h.md#wc_ldu_fast>)
    - [`wc_ld`](<fd_avx_wc.h.md#wc_ld>)
    - [`wc_ldu`](<fd_avx_wc.h.md#wc_ldu>)


---
### wf\_test<!-- {{#callable:wf_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L91>)

Validates a vector of floats by comparing extracted elements and performing various store and load operations.
- **Inputs**:
    - `f`: A vector of floats to test.
    - `f0`: The expected value of the first element in the vector.
    - `f1`: The expected value of the second element in the vector.
    - `f2`: The expected value of the third element in the vector.
    - `f3`: The expected value of the fourth element in the vector.
    - `f4`: The expected value of the fifth element in the vector.
    - `f5`: The expected value of the sixth element in the vector.
    - `f6`: The expected value of the seventh element in the vector.
    - `f7`: The expected value of the eighth element in the vector.
- **Logic and Control Flow**:
    - Initialize a volatile integer array and a float array with 79 elements.
    - Extract each element from the vector `f` and compare it with the corresponding input float `f0` to `f7`. If any comparison fails, return 0.
    - Use a volatile integer to extract elements from `f` using [`wf_extract_variable`](<fd_avx_wf.h.md#wf_extract_variable>) and compare them with `f0` to `f7`. If any comparison fails, return 0.
    - Store the vector `f` into the float array `m` using aligned and unaligned store operations.
    - Load the stored values back into a vector `g` and compare with `f` using `wf_eq` and `wc_pack`. If any comparison fails, return 0.
    - Gather elements from `m` using `wf_gather` and compare with `f`. If the comparison fails, return 0.
    - Insert each input float `f0` to `f7` into a zero-initialized vector and compare with `f` using `wf_ne`. If any comparison fails, return 0.
    - Use a volatile integer to insert each input float into a one-initialized vector using [`wf_insert_variable`](<fd_avx_wf.h.md#wf_insert_variable>) and compare with `f`. If any comparison fails, return 0.
    - Return 1 if all tests pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0.
- **Functions Called**:
    - [`wf_extract`](<fd_avx_wf.h.md#wf_extract>)
    - [`wf_extract_variable`](<fd_avx_wf.h.md#wf_extract_variable>)
    - [`wf_insert_variable`](<fd_avx_wf.h.md#wf_insert_variable>)


---
### wi\_test<!-- {{#callable:wi_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L157>)

Validates the extraction, storage, loading, and insertion operations on a vector `wi_t` using integer elements.
- **Inputs**:
    - `i`: A vector of type `wi_t` to test.
    - `i0`: The expected integer value at index 0 of the vector.
    - `i1`: The expected integer value at index 1 of the vector.
    - `i2`: The expected integer value at index 2 of the vector.
    - `i3`: The expected integer value at index 3 of the vector.
    - `i4`: The expected integer value at index 4 of the vector.
    - `i5`: The expected integer value at index 5 of the vector.
    - `i6`: The expected integer value at index 6 of the vector.
    - `i7`: The expected integer value at index 7 of the vector.
- **Logic and Control Flow**:
    - Initialize a volatile integer array `_` and an integer array `m` with 79 elements.
    - Extract each element from the vector `i` using `wi_extract` and compare it with the corresponding input integer `i0` to `i7`. If any comparison fails, return 0.
    - Use [`wi_extract_variable`](<fd_avx_wi.h.md#wi_extract_variable>) to extract elements from `i` using the volatile array `_` as the index and compare with `i0` to `i7`. If any comparison fails, return 0.
    - Store the vector `i` into the array `m` using [`wi_st`](<fd_avx_wi.h.md#wi_st>) and [`wi_stu`](<fd_avx_wi.h.md#wi_stu>) for aligned and unaligned storage.
    - Load the vector from `m` using [`wi_ld`](<fd_avx_wi.h.md#wi_ld>) and [`wi_ldu`](<fd_avx_wi.h.md#wi_ldu>), compare with `i` using `wi_eq`, and pack the result with `wc_pack`. If the packed result is not 255, return 0.
    - Gather elements from `m` using `wi_gather` and compare with `i` using `wi_eq`. If not all elements are equal, return 0.
    - Insert each input integer `i0` to `i7` into a zero-initialized vector using `wi_insert` and compare with `i` using `wi_ne`. If any element is not equal, return 0.
    - Use [`wi_insert_variable`](<fd_avx_wi.h.md#wi_insert_variable>) to insert each input integer `i0` to `i7` into a one-initialized vector using the volatile array `_` as the index and compare with `i` using `wi_ne`. If any element is not equal, return 0.
    - Return 1 if all tests pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0.
- **Functions Called**:
    - [`wi_extract_variable`](<fd_avx_wi.h.md#wi_extract_variable>)
    - [`wi_st`](<fd_avx_wi.h.md#wi_st>)
    - [`wi_stu`](<fd_avx_wi.h.md#wi_stu>)
    - [`wi_ld`](<fd_avx_wi.h.md#wi_ld>)
    - [`wi_ldu`](<fd_avx_wi.h.md#wi_ldu>)
    - [`wi_insert_variable`](<fd_avx_wi.h.md#wi_insert_variable>)


---
### wu\_test<!-- {{#callable:wu_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L223>)

Validates the extraction, storage, loading, and insertion operations on a `wu_t` vector against expected values.
- **Inputs**:
    - `u`: A `wu_t` vector to test.
    - `u0`: Expected value for the 0th element of the vector.
    - `u1`: Expected value for the 1st element of the vector.
    - `u2`: Expected value for the 2nd element of the vector.
    - `u3`: Expected value for the 3rd element of the vector.
    - `u4`: Expected value for the 4th element of the vector.
    - `u5`: Expected value for the 5th element of the vector.
    - `u6`: Expected value for the 6th element of the vector.
    - `u7`: Expected value for the 7th element of the vector.
- **Logic and Control Flow**:
    - Check if each element of `u` matches the corresponding expected value `u0` to `u7` using `wu_extract` and return 0 if any mismatch is found.
    - Use a volatile integer array `_` to extract elements from `u` using [`wu_extract_variable`](<fd_avx_wu.h.md#wu_extract_variable>) and return 0 if any mismatch is found.
    - Store `u` into an aligned and several unaligned positions in the array `m` using [`wu_st`](<fd_avx_wu.h.md#wu_st>) and [`wu_stu`](<fd_avx_wu.h.md#wu_stu>).
    - Load the stored values back into `v` using [`wu_ld`](<fd_avx_wu.h.md#wu_ld>) and [`wu_ldu`](<fd_avx_wu.h.md#wu_ldu>), and check if they match `u` using `wu_eq` and `wc_pack`, returning 0 if any mismatch is found.
    - Use [`wu_gather`](<fd_avx_wu.h.md#wu_gather>) to gather elements from `m` and check if they match `u`, returning 0 if not.
    - Insert each expected value `u0` to `u7` into a zero-initialized vector using `wu_insert` and check if it matches `u`, returning 0 if any mismatch is found.
    - Use [`wu_insert_variable`](<fd_avx_wu.h.md#wu_insert_variable>) to insert each expected value into a one-initialized vector and check if it matches `u`, returning 0 if any mismatch is found.
    - Return 1 if all checks pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0.
- **Functions Called**:
    - [`wu_extract_variable`](<fd_avx_wu.h.md#wu_extract_variable>)
    - [`wu_st`](<fd_avx_wu.h.md#wu_st>)
    - [`wu_stu`](<fd_avx_wu.h.md#wu_stu>)
    - [`wu_ld`](<fd_avx_wu.h.md#wu_ld>)
    - [`wu_ldu`](<fd_avx_wu.h.md#wu_ldu>)
    - [`wu_gather`](<fd_avx_wu.h.md#wu_gather>)
    - [`wu_insert_variable`](<fd_avx_wu.h.md#wu_insert_variable>)


---
### wd\_test<!-- {{#callable:wd_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L289>)

Validates the extraction, storage, loading, gathering, and insertion operations on a `wd_t` data type against expected double values.
- **Inputs**:
    - `d`: A `wd_t` data type to test.
    - `d0`: Expected double value for index 0.
    - `d1`: Expected double value for index 1.
    - `d2`: Expected double value for index 2.
    - `d3`: Expected double value for index 3.
- **Logic and Control Flow**:
    - Check if `d` extracts to `d0`, `d1`, `d2`, and `d3` at indices 0, 1, 2, and 3 respectively; return 0 if any check fails.
    - Use a volatile integer array `_` to perform variable index extraction checks for `d` against `d0`, `d1`, `d2`, and `d3`; return 0 if any check fails.
    - Store `d` into a double array `m` using aligned and unaligned store functions `wd_st` and `wd_stu`.
    - Load from `m` using aligned and unaligned load functions `wd_ld` and `wd_ldu`, and check equality with `d`; return 0 if any check fails.
    - Perform gather operations on `m` with specific indices and check if the result equals `d`; return 0 if any check fails.
    - Insert `d0`, `d1`, `d2`, and `d3` into a zero-initialized `wd_t` and check if it equals `d`; return 0 if any check fails.
    - Use variable index insertion to insert `d0`, `d1`, `d2`, and `d3` into a one-initialized `wd_t` and check if it equals `d`; return 0 if any check fails.
    - Return 1 if all checks pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0.
- **Functions Called**:
    - [`wd_extract`](<fd_avx_wd.h.md#wd_extract>)
    - [`wd_extract_variable`](<fd_avx_wd.h.md#wd_extract_variable>)
    - [`wd_insert`](<fd_avx_wd.h.md#wd_insert>)
    - [`wd_insert_variable`](<fd_avx_wd.h.md#wd_insert_variable>)


---
### wl\_test<!-- {{#callable:wl_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L332>)

Validates the extraction, storage, loading, gathering, and insertion operations on a `wl_t` vector with given long integer values.
- **Inputs**:
    - `l`: A `wl_t` vector to test.
    - `l0`: The expected long integer value at index 0.
    - `l1`: The expected long integer value at index 1.
    - `l2`: The expected long integer value at index 2.
    - `l3`: The expected long integer value at index 3.
- **Logic and Control Flow**:
    - Check if the extracted values from `l` at indices 0 to 3 match `l0` to `l3`; return 0 if any do not match.
    - Use a volatile integer array to extract values from `l` using [`wl_extract_variable`](<fd_avx_wl.h.md#wl_extract_variable>) and compare them to `l0` to `l3`; return 0 if any do not match.
    - Store `l` into a long array `m` using aligned and unaligned store functions ([`wl_st`](<fd_avx_wl.h.md#wl_st>) and [`wl_stu`](<fd_avx_wl.h.md#wl_stu>)).
    - Load values from `m` into `k` using aligned and unaligned load functions ([`wl_ld`](<fd_avx_wl.h.md#wl_ld>) and [`wl_ldu`](<fd_avx_wl.h.md#wl_ldu>)), and check if they are equal to `l` using `wl_eq` and `wc_pack`; return 0 if any are not equal.
    - Gather values from `m` using [`wl_gather`](<fd_avx_wl.h.md#wl_gather>) with specific indices and check if they are equal to `l` using `wl_eq` and `wc_all`; return 0 if any are not equal.
    - Insert `l0` to `l3` into a zero-initialized `wl_t` vector and check if it is equal to `l` using `wl_ne` and `wc_any`; return 0 if not equal.
    - Use a volatile integer array to insert `l0` to `l3` into a one-initialized `wl_t` vector using [`wl_insert_variable`](<fd_avx_wl.h.md#wl_insert_variable>) and check if it is equal to `l` using `wl_ne` and `wc_any`; return 0 if not equal.
    - Return 1 if all checks pass.
- **Output**: Returns 1 if all operations validate successfully, otherwise returns 0.
- **Functions Called**:
    - [`wl_extract_variable`](<fd_avx_wl.h.md#wl_extract_variable>)
    - [`wl_st`](<fd_avx_wl.h.md#wl_st>)
    - [`wl_stu`](<fd_avx_wl.h.md#wl_stu>)
    - [`wl_ld`](<fd_avx_wl.h.md#wl_ld>)
    - [`wl_ldu`](<fd_avx_wl.h.md#wl_ldu>)
    - [`wl_gather`](<fd_avx_wl.h.md#wl_gather>)
    - [`wl_insert_variable`](<fd_avx_wl.h.md#wl_insert_variable>)


---
### wv\_test<!-- {{#callable:wv_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L375>)

Validates a vector `wv_t` against four `ulong` values through extraction, storage, loading, and insertion operations.
- **Inputs**:
    - `v`: A vector of type `wv_t` to test.
    - `v0`: The first `ulong` value to compare against the vector.
    - `v1`: The second `ulong` value to compare against the vector.
    - `v2`: The third `ulong` value to compare against the vector.
    - `v3`: The fourth `ulong` value to compare against the vector.
- **Logic and Control Flow**:
    - Extracts elements from `v` and compares them to `v0`, `v1`, `v2`, and `v3`; returns 0 if any comparison fails.
    - Uses a volatile integer array `_` to extract elements from `v` using [`wv_extract_variable`](<fd_avx_wv.h.md#wv_extract_variable>) and compares them to `v0`, `v1`, `v2`, and `v3`; returns 0 if any comparison fails.
    - Stores `v` into an array `m` using aligned and unaligned store functions ([`wv_st`](<fd_avx_wv.h.md#wv_st>) and [`wv_stu`](<fd_avx_wv.h.md#wv_stu>)).
    - Loads vectors from `m` using aligned and unaligned load functions ([`wv_ld`](<fd_avx_wv.h.md#wv_ld>) and [`wv_ldu`](<fd_avx_wv.h.md#wv_ldu>)) and checks equality with `v`; returns 0 if any comparison fails.
    - Gathers elements from `m` using [`wv_gather`](<fd_avx_wv.h.md#wv_gather>) and checks equality with `v`; returns 0 if any comparison fails.
    - Inserts `v0`, `v1`, `v2`, and `v3` into a zeroed vector using `wv_insert` and checks if it matches `v`; returns 0 if any comparison fails.
    - Inserts `v0`, `v1`, `v2`, and `v3` into a vector initialized with ones using [`wv_insert_variable`](<fd_avx_wv.h.md#wv_insert_variable>) and checks if it matches `v`; returns 0 if any comparison fails.
    - Returns 1 if all tests pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0.
- **Functions Called**:
    - [`wv_extract_variable`](<fd_avx_wv.h.md#wv_extract_variable>)
    - [`wv_st`](<fd_avx_wv.h.md#wv_st>)
    - [`wv_stu`](<fd_avx_wv.h.md#wv_stu>)
    - [`wv_ld`](<fd_avx_wv.h.md#wv_ld>)
    - [`wv_ldu`](<fd_avx_wv.h.md#wv_ldu>)
    - [`wv_gather`](<fd_avx_wv.h.md#wv_gather>)
    - [`wv_insert_variable`](<fd_avx_wv.h.md#wv_insert_variable>)


---
### ws\_test<!-- {{#callable:ws_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L418>)

Validates the extraction, storage, and insertion operations on a `ws_t` vector against a reference array of shorts.
- **Inputs**:
    - `s`: A `ws_t` vector to test.
    - `si`: A pointer to a constant array of 16 shorts used as a reference for validation.
- **Logic and Control Flow**:
    - Check if each element extracted from `s` matches the corresponding element in `si` for indices 0 to 15; return 0 if any mismatch is found.
    - Use a loop to verify that variable extraction from `s` matches `si` for indices 0 to 15; return 0 if any mismatch is found.
    - Store `s` into an aligned array `m` and perform several unaligned stores at different offsets; these operations do not affect control flow directly.
    - Load from `m` and compare with `s` using `ws_eq`; return 0 if any comparison fails.
    - Insert elements from `si` into a zeroed vector `t` and compare with `s` using `ws_ne`; return 0 if any comparison indicates inequality.
    - Use a loop to insert elements from `si` into a zeroed vector `t` using variable insertion; compare with `s` using `ws_ne` and return 0 if any comparison indicates inequality.
    - Return 1 if all checks pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0 if any test fails.
- **Functions Called**:
    - [`ws_extract_variable`](<fd_avx_ws.h.md#ws_extract_variable>)
    - [`ws_st`](<fd_avx_ws.h.md#ws_st>)
    - [`ws_stu`](<fd_avx_ws.h.md#ws_stu>)
    - [`ws_ld`](<fd_avx_ws.h.md#ws_ld>)
    - [`ws_ldu`](<fd_avx_ws.h.md#ws_ldu>)
    - [`ws_insert_variable`](<fd_avx_ws.h.md#ws_insert_variable>)


---
### wh\_test<!-- {{#callable:wh_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L485>)

Validates the extraction, storage, and insertion operations on a `wh_t` type against a reference array of `ushort` values.
- **Inputs**:
    - `h`: A `wh_t` type representing the data to test.
    - `hj`: A pointer to an array of `ushort` values used as the reference for validation.
- **Logic and Control Flow**:
    - Declare a volatile integer array `_` and a `ushort` array `m` with 151 elements.
    - Declare a `wh_t` variable `l` for temporary storage.
    - Check if each element extracted from `h` matches the corresponding element in `hj` for indices 0 to 15; return 0 if any mismatch occurs.
    - Use a loop to perform variable extraction from `h` and compare with `hj`; return 0 if any mismatch occurs.
    - Store `h` into `m` using aligned and unaligned store functions [`wh_st`](<fd_avx_wh.h.md#wh_st>) and [`wh_stu`](<fd_avx_wh.h.md#wh_stu>).
    - Load from `m` into `l` using aligned and unaligned load functions [`wh_ld`](<fd_avx_wh.h.md#wh_ld>) and [`wh_ldu`](<fd_avx_wh.h.md#wh_ldu>), and check equality with `h`; return 0 if any mismatch occurs.
    - Insert elements from `hj` into a zero-initialized `wh_t` and compare with `h`; return 0 if any mismatch occurs.
    - Use a loop to insert elements from `hj` into a zero-initialized `wh_t` using variable insertion and compare with `h`; return 0 if any mismatch occurs.
    - Return 1 if all checks pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0 if any test fails.
- **Functions Called**:
    - [`wh_extract_variable`](<fd_avx_wh.h.md#wh_extract_variable>)
    - [`wh_st`](<fd_avx_wh.h.md#wh_st>)
    - [`wh_stu`](<fd_avx_wh.h.md#wh_stu>)
    - [`wh_ld`](<fd_avx_wh.h.md#wh_ld>)
    - [`wh_ldu`](<fd_avx_wh.h.md#wh_ldu>)
    - [`wh_insert_variable`](<fd_avx_wh.h.md#wh_insert_variable>)


---
### wb\_test<!-- {{#callable:wb_test}} -->
[View Source →](<../../../../../src/util/simd/test_avx_common.c#L552>)

Validates that a `wb_t` object matches a given array of `uchar` values through various extraction, storage, and insertion operations.
- **Inputs**:
    - `b`: A `wb_t` object to test against the `uchar` array.
    - `bi`: A constant pointer to an array of `uchar` values to compare with the `wb_t` object.
- **Logic and Control Flow**:
    - Initialize a volatile integer array `_` and a `uchar` array `m` with specific attributes.
    - Declare a `wb_t` variable `g` for temporary storage.
    - Iterate over indices 0 to 31, comparing each extracted value from `b` with the corresponding value in `bi` using `wb_extract`. Return 0 if any comparison fails.
    - Use a loop to perform variable extraction with [`wb_extract_variable`](<fd_avx_wb.h.md#wb_extract_variable>) and compare with `bi`. Return 0 if any comparison fails.
    - Store `b` into `m` using [`wb_st`](<fd_avx_wb.h.md#wb_st>) and [`wb_stu`](<fd_avx_wb.h.md#wb_stu>) at various offsets, ensuring both aligned and unaligned storage.
    - Load from `m` into `g` using [`wb_ld`](<fd_avx_wb.h.md#wb_ld>) and [`wb_ldu`](<fd_avx_wb.h.md#wb_ldu>), and compare with `b` using `wb_eq`. Return 0 if any comparison fails.
    - Initialize `g` to zero and insert values from `bi` into `g` using `wb_insert`. Compare `g` with `b` using `wb_ne`. Return 0 if any comparison fails.
    - Use a loop to insert values from `bi` into `g` using [`wb_insert_variable`](<fd_avx_wb.h.md#wb_insert_variable>). Compare `g` with `b` using `wb_ne`. Return 0 if any comparison fails.
    - Return 1 if all tests pass.
- **Output**: Returns 1 if all tests pass, otherwise returns 0 if any test fails.
- **Functions Called**:
    - [`wb_extract_variable`](<fd_avx_wb.h.md#wb_extract_variable>)
    - [`wb_st`](<fd_avx_wb.h.md#wb_st>)
    - [`wb_stu`](<fd_avx_wb.h.md#wb_stu>)
    - [`wb_ld`](<fd_avx_wb.h.md#wb_ld>)
    - [`wb_ldu`](<fd_avx_wb.h.md#wb_ldu>)
    - [`wb_insert_variable`](<fd_avx_wb.h.md#wb_insert_variable>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)