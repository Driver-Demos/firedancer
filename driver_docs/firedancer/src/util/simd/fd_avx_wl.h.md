<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

AVX-based vector long API for 64-bit integer operations, including constructors, arithmetic, and logical functions.

# Purpose
The code defines a set of macros and inline functions for handling vector operations on 256-bit wide vectors using AVX (Advanced Vector Extensions) intrinsics in C. The primary data type used is `wl_t`, which represents a vector of four 64-bit signed integers. The code provides a comprehensive API for constructing, manipulating, and performing arithmetic, logical, and memory operations on these vectors. It includes constructors for creating vectors with specific values, broadcasting values across all lanes, and permuting elements within vectors.

The code also defines operations for loading and storing vectors from memory, both aligned and unaligned, and provides conditional operations for selective loading and storing based on vector conditions. Arithmetic operations such as addition, subtraction, and negation are implemented, along with logical operations like AND, OR, XOR, and NOT. The code includes support for bitwise shifts and rotations, both with compile-time constants and variable amounts. Additionally, it provides conversion functions to transform vector data into different types, such as floating-point or integer vectors, and includes reduction operations to compute sums, minimums, and maximums across vector elements. The code is designed to be used as part of a larger system, as indicated by the inclusion guard and the error directive that prevents direct inclusion.
# Functions

---
### wl\_bcast\_pair<!-- {{#callable:wl_bcast_pair}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L25>)

Creates a vector of four 64-bit integers with a pattern of two input long integers repeated.
- **Inputs**:
    - `l0`: The first long integer to broadcast.
    - `l1`: The second long integer to broadcast.
- **Logic and Control Flow**:
    - Calls the `_mm256_setr_epi64x` intrinsic to create a vector of four 64-bit integers.
    - The vector is constructed with the pattern `[l0, l1, l0, l1]`.
- **Output**: A `wl_t` vector containing four 64-bit integers in the pattern `[l0, l1, l0, l1]`.


---
### wl\_bcast\_wide<!-- {{#callable:wl_bcast_wide}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L30>)

Creates a vector with two pairs of repeated long integers.
- **Inputs**:
    - `l0`: The first long integer to repeat in the vector.
    - `l1`: The second long integer to repeat in the vector.
- **Logic and Control Flow**:
    - Calls `_mm256_setr_epi64x` with `l0`, `l0`, `l1`, `l1` to create a vector of four 64-bit integers.
    - Returns the created vector.
- **Output**: A `wl_t` vector containing the values `[l0, l0, l1, l1]`.


---
### wl\_permute<!-- {{#callable:wl_permute}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L40>)

Reorders the elements of a 256-bit vector of four 64-bit integers based on specified indices.
- **Inputs**:
    - ``x``: A 256-bit vector of four 64-bit integers (`wl_t`).
    - ``imm_i0``: An integer index (0-3) specifying the position of the first element in the output vector.
    - ``imm_i1``: An integer index (0-3) specifying the position of the second element in the output vector.
    - ``imm_i2``: An integer index (0-3) specifying the position of the third element in the output vector.
    - ``imm_i3``: An integer index (0-3) specifying the position of the fourth element in the output vector.
- **Logic and Control Flow**:
    - Stores the input vector `x` into a union `t` that can be accessed as an array of four 64-bit integers.
    - Assigns elements from `t.l` to `u.l` based on the indices `imm_i0`, `imm_i1`, `imm_i2`, and `imm_i3`.
    - Loads the reordered elements from `u.l` back into a 256-bit vector and returns it.
- **Output**: A 256-bit vector of four 64-bit integers with elements reordered according to the specified indices.


---
### wl\_ld<!-- {{#callable:wl_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L73>)

Loads a 256-bit vector of four 64-bit integers from a 32-byte aligned memory location.
- **Inputs**:
    - `p`: A pointer to a constant long integer array, which must be 32-byte aligned.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_load_si256` intrinsic to load a 256-bit vector from the memory location pointed to by the casted pointer.
- **Output**: Returns a `wl_t` type, which is a 256-bit vector containing four 64-bit integers loaded from the specified memory location.


---
### wl\_st<!-- {{#callable:wl_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L74>)

Stores a vector of four 64-bit integers into a 32-byte aligned memory location.
- **Inputs**:
    - ``p``: A pointer to a 32-byte aligned memory location where the vector will be stored.
    - ``i``: A vector of four 64-bit integers (`wl_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_store_si256` intrinsic to store the vector `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wl\_ldu<!-- {{#callable:wl_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L76>)

Loads a 256-bit vector from an unaligned memory address into a `wl_t` type.
- **Inputs**:
    - `p`: A pointer to the memory location from which to load the vector.
- **Logic and Control Flow**:
    - Calls the `_mm256_loadu_si256` intrinsic to load a 256-bit vector from the memory location pointed to by `p`.
- **Output**: Returns a `wl_t` type, which is a 256-bit vector containing four 64-bit integers loaded from the specified memory location.


---
### wl\_stu<!-- {{#callable:wl_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L77>)

Stores a vector of 64-bit integers to a memory location without requiring alignment.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector will be stored. The location does not need to be aligned.
    - ``i``: A vector of 64-bit integers (`wl_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the vector `i` at the memory location `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### wl\_extract\_variable<!-- {{#callable:wl_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L103>)

Extracts a long integer from a specified lane of a vector long.
- **Inputs**:
    - ``a``: A vector long of type `wl_t` from which to extract a long integer.
    - ``n``: An integer specifying the lane (0 to 3) from which to extract the long integer.
- **Logic and Control Flow**:
    - Declare a union `t` with a `__m256i` array `m` and a `long` array `l` to facilitate type punning.
    - Store the vector long `a` into the `m` array of the union `t` using `_mm256_store_si256`.
    - Return the long integer from the `n`-th position of the `l` array of the union `t`.
- **Output**: A long integer extracted from the specified lane `n` of the vector long `a`.


---
### wl\_insert\_variable<!-- {{#callable:wl_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L110>)

Replaces a specified element in a vector of four 64-bit integers with a new value.
- **Inputs**:
    - ``a``: A vector of four 64-bit integers (`wl_t`).
    - ``n``: The index of the element to replace, ranging from 0 to 3.
    - ``v``: The new 64-bit integer value to insert at index `n`.
- **Logic and Control Flow**:
    - Store the vector `a` into a union `t` that can be accessed as an array of four 64-bit integers.
    - Replace the element at index `n` in the array `t->l` with the value `v`.
    - Load the modified array back into a vector and return it.
- **Output**: A new vector of four 64-bit integers with the element at index `n` replaced by `v`.


---
### wl\_rol<!-- {{#callable:wl_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L172>)

Performs a bitwise left rotation on each 64-bit lane of a vector long by a specified number of bits.
- **Inputs**:
    - ``a``: A vector long (`wl_t`) containing four 64-bit integers to rotate.
    - ``imm``: An integer specifying the number of bits to rotate each 64-bit lane to the left.
- **Logic and Control Flow**:
    - Compute the effective rotation amount by taking `imm & 63` to ensure it is within the range of 0 to 63 bits.
    - Perform a left shift on the vector `a` by the effective rotation amount using `wl_shl`.
    - Perform a right logical shift on the vector `a` by the complement of the effective rotation amount using `wl_shru`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wl_or`.
- **Output**: Returns a vector long (`wl_t`) with each 64-bit lane rotated left by the specified number of bits.


---
### wl\_ror<!-- {{#callable:wl_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L173>)

Performs a bitwise right rotation on each 64-bit element of a vector long by a specified number of bits.
- **Inputs**:
    - ``a``: A vector long (`wl_t`) containing four 64-bit integers to rotate.
    - ``imm``: An integer specifying the number of bits to rotate each element to the right.
- **Logic and Control Flow**:
    - Calculate the effective number of bits to rotate right by using `imm & 63` to ensure it is within the range of 0 to 63.
    - Perform an unsigned right shift on `a` by the calculated number of bits using `wl_shru`.
    - Calculate the effective number of bits to rotate left by using `(-imm) & 63`.
    - Perform a left shift on `a` by the calculated number of bits using `wl_shl`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `wl_or`.
- **Output**: A vector long (`wl_t`) with each 64-bit element rotated right by the specified number of bits.


---
### wl\_rol\_variable<!-- {{#callable:wl_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L176>)

Performs a variable bitwise left rotation on a vector of 64-bit integers.
- **Inputs**:
    - ``a``: A vector of 64-bit integers (`wl_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate left.
- **Logic and Control Flow**:
    - Compute `n & 63` to ensure the rotation count is within the range of 0 to 63 bits.
    - Perform a left shift on `a` by `n & 63` bits using `wl_shl_variable`.
    - Perform a right shift on `a` by `(-n) & 63` bits using `wl_shru_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `wl_or`.
- **Output**: Returns a vector of 64-bit integers (`wl_t`) that is the result of rotating `a` left by `n` bits.


---
### wl\_ror\_variable<!-- {{#callable:wl_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L177>)

Performs a variable bitwise right rotation on a vector of 64-bit integers.
- **Inputs**:
    - ``a``: A vector of 64-bit integers (`wl_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate right.
- **Logic and Control Flow**:
    - Compute `n & 63` to ensure the rotation amount is within the range of 0 to 63 bits.
    - Perform an unsigned right shift on `a` by `n & 63` bits using `wl_shru_variable`.
    - Compute `(-n) & 63` to determine the equivalent left shift amount.
    - Perform a left shift on `a` by `(-n) & 63` bits using `wl_shl_variable`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `wl_or`.
- **Output**: Returns a vector of 64-bit integers (`wl_t`) that has been right-rotated by `n` bits.


---
### wl\_rol\_vector<!-- {{#callable:wl_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L179>)

Performs a vectorized bitwise rotate left operation on each 64-bit integer in the vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - `a`: A vector of 64-bit integers (`wl_t`) to be rotated.
    - `b`: A vector of 64-bit integers (`wl_t`) specifying the number of positions to rotate each corresponding integer in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `63L` to all elements of a vector `m` using `wl_bcast` to ensure shifts are within 0 to 63 bits.
    - Performs a bitwise AND operation between `b` and `m` to limit the shift amount to 63 bits.
    - Calculates the left shift of `a` by the masked `b` using `wl_shl_vector`.
    - Calculates the right shift of `a` by the negated and masked `b` using `wl_shru_vector`.
    - Combines the results of the left and right shifts using a bitwise OR operation with `wl_or` to complete the rotate left operation.
- **Output**: Returns a vector of 64-bit integers (`wl_t`) where each integer is the result of rotating the corresponding integer in `a` left by the number of positions specified in `b`.


---
### wl\_ror\_vector<!-- {{#callable:wl_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L184>)

Performs a bitwise right rotation on each 64-bit element of vector `a` by the corresponding element in vector `b`.
- **Inputs**:
    - `a`: A vector of type `wl_t` containing 64-bit integers to be rotated.
    - `b`: A vector of type `wl_t` containing 64-bit integers that specify the number of positions to rotate each corresponding element in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `63L` to all elements of a vector `m` using `wl_bcast`.
    - Computes the bitwise AND of vector `b` and `m`, and then performs an unsigned right shift on vector `a` by the result using `wl_shru_vector`.
    - Computes the bitwise AND of the negation of vector `b` and `m`, and then performs a left shift on vector `a` by the result using `wl_shl_vector`.
    - Combines the results of the two shifts using a bitwise OR operation with `wl_or` and returns the result.
- **Output**: A vector of type `wl_t` containing the rotated 64-bit integers.


---
### wl\_abs<!-- {{#callable:wl_abs}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L214>)

Computes the absolute value of each element in a vector of signed 64-bit integers.
- **Inputs**:
    - ``a``: A vector of signed 64-bit integers (`wl_t`).
- **Logic and Control Flow**:
    - Checks if each element in vector `a` is less than zero using `wl_lt(a, wl_zero())`.
    - If an element is less than zero, it negates the element using `wl_neg(a)`.
    - If an element is not less than zero, it retains the element as is.
    - Uses `wl_if` to select between the negated and original values based on the condition.
- **Output**: A vector of signed 64-bit integers (`wl_t`) where each element is the absolute value of the corresponding element in the input vector `a`.


---
### wl\_min<!-- {{#callable:wl_min}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L215>)

Determines the minimum of two vector long values `a` and `b`.
- **Inputs**:
    - `a`: A vector long of type `wl_t`.
    - `b`: A vector long of type `wl_t`.
- **Logic and Control Flow**:
    - Compares `a` and `b` using `wl_lt` to determine which vector long is smaller.
    - Uses `wl_if` to select `a` if it is less than `b`, otherwise selects `b`.
- **Output**: Returns the vector long that contains the minimum values from `a` and `b`.


---
### wl\_max<!-- {{#callable:wl_max}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L216>)

Selects the maximum value between two vector long integers.
- **Inputs**:
    - ``a``: A vector long integer of type `wl_t`.
    - ``b``: Another vector long integer of type `wl_t`.
- **Logic and Control Flow**:
    - Compares the vector long integers `a` and `b` using the `wl_gt` function to determine which is greater.
    - Uses the `wl_if` function to select `a` if it is greater than `b`, otherwise selects `b`.
- **Output**: Returns a vector long integer of type `wl_t` that contains the maximum values from the corresponding lanes of `a` and `b`.


---
### wl\_shr<!-- {{#callable:wl_shr}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L219>)

Performs an arithmetic right shift on a vector of signed 64-bit integers, treating them as signed values.
- **Inputs**:
    - ``a``: A vector of signed 64-bit integers (`wl_t`) to be right-shifted.
    - ``imm``: An integer representing the number of bits to shift, which must be a compile-time constant between 0 and 63.
- **Logic and Control Flow**:
    - Compute a vector conditional `c` by comparing `a` with zero using `wl_lt`, which results in a vector where each element is -1 if the corresponding element in `a` is negative, and 0 otherwise.
    - Perform a bitwise XOR between `a` and `c`, effectively flipping the bits of negative numbers to prepare them for logical right shift.
    - Perform a logical right shift on the result of the XOR operation by `imm` bits using `_mm256_srli_epi64`.
    - Perform another XOR operation between the shifted result and `c` to restore the sign of the original numbers, completing the arithmetic right shift.
- **Output**: Returns a vector of signed 64-bit integers (`wl_t`) that have been right-shifted by `imm` bits, with sign extension for negative numbers.


---
### wl\_shr\_variable<!-- {{#callable:wl_shr_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L223>)

Performs an arithmetic right shift on a vector of signed 64-bit integers by a variable number of bits.
- **Inputs**:
    - ``a``: A vector of signed 64-bit integers (`wl_t`) to be shifted.
    - ``n``: An integer specifying the number of bits to shift each element in the vector `a`.
- **Logic and Control Flow**:
    - Determine if each element in `a` is negative by comparing it to zero using `wl_lt` and store the result in `c`.
    - Perform a bitwise XOR between `a` and `c` to prepare for the shift operation, effectively converting negative numbers to their two's complement representation.
    - Insert the shift amount `n` into a 128-bit zero vector at position 0 using `_mm_insert_epi64`.
    - Perform a logical right shift on the XOR result by `n` bits using `_mm256_srl_epi64`.
    - XOR the shifted result with `c` to restore the sign of the original numbers, completing the arithmetic right shift.
- **Output**: A vector of signed 64-bit integers (`wl_t`) where each element is the result of the arithmetic right shift of the corresponding element in `a` by `n` bits.


---
### wl\_shr\_vector<!-- {{#callable:wl_shr_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L227>)

Performs an arithmetic right shift on a vector of signed 64-bit integers, considering the sign bit.
- **Inputs**:
    - ``a``: A vector of signed 64-bit integers (`wl_t`) to be right-shifted.
    - ``n``: A vector of unsigned 64-bit integers (`wl_t`) representing the number of positions to shift each corresponding element in `a`.
- **Logic and Control Flow**:
    - Determine if each element in `a` is negative by comparing it to zero using `wl_lt`, resulting in a vector `c` where each element is either 0 or -1.
    - Perform a bitwise XOR between `a` and `c` to prepare for the shift operation, effectively flipping the bits of negative numbers to handle the sign bit correctly.
    - Right shift the result of the XOR operation by the corresponding elements in `n` using `_mm256_srlv_epi64`.
    - Perform another bitwise XOR with `c` to restore the sign of the original negative numbers, completing the arithmetic right shift.
- **Output**: A vector of signed 64-bit integers (`wl_t`) where each element is the result of the arithmetic right shift of the corresponding element in `a` by the number of positions specified in `n`.


---
### wl\_to\_wf<!-- {{#callable:wl_to_wf}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L259>)

Converts a vector of long integers to a vector of floats and inserts it into a specified position in another float vector.
- **Inputs**:
    - ``l``: A vector of long integers (`wl_t`) to convert to floats.
    - ``f``: A vector of floats (`wf_t`) where the converted values will be inserted.
    - ``imm_hi``: An integer that determines the position (0 or 1) in the float vector `f` where the converted values will be inserted.
- **Logic and Control Flow**:
    - Store the vector of long integers `l` into a temporary union `t`.
    - Convert each long integer in `t` to a float and store them in a union `u`.
    - Load the floats from `u` into a 128-bit vector `v`.
    - If `imm_hi` is true, insert `v` into the high 128 bits of `f`; otherwise, insert `v` into the low 128 bits of `f`.
- **Output**: A vector of floats (`wf_t`) with the converted long integers inserted at the specified position.


---
### wl\_to\_wi<!-- {{#callable:wl_to_wi}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L271>)

Converts a vector of 64-bit integers to a vector of 32-bit integers, inserting the result into a specified position of an existing vector.
- **Inputs**:
    - ``l``: A `wl_t` vector containing 64-bit integers to convert.
    - ``i``: A `wi_t` vector where the converted integers will be inserted.
    - ``imm_hi``: An integer flag that determines the position in `i` where the converted integers will be inserted (0 for low, 1 for high).
- **Logic and Control Flow**:
    - Extracts the lower 128 bits from `l` and casts them to a 128-bit float vector `v01`.
    - Extracts the upper 128 bits from `l` and casts them to a 128-bit float vector `v23`.
    - Shuffles `v01` and `v23` to interleave the lower 32 bits of each, resulting in a 128-bit integer vector `v`.
    - Inserts `v` into `i` at the position specified by `imm_hi` (0 for low, 1 for high).
- **Output**: Returns a `wi_t` vector with the converted 32-bit integers inserted at the specified position.


---
### wl\_to\_wu<!-- {{#callable:wl_to_wu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L278>)

Converts a vector of signed 64-bit integers to a vector of unsigned 32-bit integers, inserting the result into a specified position of an existing vector.
- **Inputs**:
    - `l`: A `wl_t` vector containing signed 64-bit integers to convert.
    - `u`: A `wu_t` vector where the converted values will be inserted.
    - `imm_hi`: An integer that determines the position (0 or 1) in the `u` vector where the converted values will be inserted.
- **Logic and Control Flow**:
    - Extracts the lower 128 bits from the `wl_t` vector `l` and casts them to a 128-bit floating-point vector `v01`.
    - Extracts the upper 128 bits from the `wl_t` vector `l` and casts them to a 128-bit floating-point vector `v23`.
    - Shuffles the elements of `v01` and `v23` to create a new 128-bit integer vector `v`.
    - Checks the value of `imm_hi` to determine the insertion position in the `wu_t` vector `u`.
    - Inserts the 128-bit integer vector `v` into the `wu_t` vector `u` at the position specified by `imm_hi`.
- **Output**: A `wu_t` vector with the converted values inserted at the specified position.


---
### wl\_to\_wd<!-- {{#callable:wl_to_wd}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L286>)

Converts a vector of four 64-bit integers to a vector of four 64-bit doubles.
- **Inputs**:
    - ``l``: A vector of four 64-bit integers (`wl_t`).
- **Logic and Control Flow**:
    - Store the input vector `l` into a union `t` that can hold either four 64-bit integers or a single `__m256i` vector.
    - Convert each of the four 64-bit integers in `t` to a double and store them in a union `u` that can hold either four doubles or a single `__m256d` vector.
    - Load the four doubles from `u` and return them as a `__m256d` vector.
- **Output**: A vector of four 64-bit doubles (`wd_t`).


---
### wl\_sum\_all<!-- {{#callable:wl_sum_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L308>)

Computes the sum of all elements in a vector of 64-bit integers and broadcasts the result across all lanes of the vector.
- **Inputs**:
    - `x`: A vector of 64-bit integers (`wl_t`) containing the elements to sum.
- **Logic and Control Flow**:
    - Add the vector `x` to itself after permuting its 128-bit lanes using `_mm256_permute2f128_si256` to sum the elements across the lanes.
    - Convert the result to a double-precision floating-point vector using `_mm256_castsi256_pd`, permute the elements using `_mm256_permute_pd`, and cast it back to an integer vector using `_mm256_castpd_si256`.
    - Add the permuted result to the original sum to complete the reduction across all elements.
- **Output**: A vector (`wl_t`) where each lane contains the sum of all elements in the input vector `x`.


---
### wl\_min\_all<!-- {{#callable:wl_min_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L314>)

Broadcasts the minimum value from a vector of signed 64-bit integers across all lanes.
- **Inputs**:
    - `x`: A vector of signed 64-bit integers (`wl_t`).
- **Logic and Control Flow**:
    - Use [`wl_min`](<#wl_min>) to find the minimum value between `x` and its permuted version using `_mm256_permute2f128_si256` with control parameter `1`.
    - Use [`wl_min`](<#wl_min>) again to find the minimum value between the result and its permuted version using `_mm256_permute_pd` with control parameter `5`.
    - Return the result, which is the minimum value broadcasted across all lanes.
- **Output**: A vector (`wl_t`) where all lanes contain the minimum value from the input vector `x`.
- **Functions Called**:
    - [`wl_min`](<#wl_min>)


---
### wl\_max\_all<!-- {{#callable:wl_max_all}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L320>)

Computes the maximum value across all lanes of a vector and broadcasts it to all lanes.
- **Inputs**:
    - `x`: A vector of type `wl_t` containing four signed 64-bit integers.
- **Logic and Control Flow**:
    - Use `_mm256_permute2f128_si256` to shuffle the vector `x` and combine it with itself to compare the first two and last two lanes.
    - Apply [`wl_max`](<#wl_max>) to find the maximum value between the original and shuffled vector.
    - Use `_mm256_castpd_si256` and `_mm256_permute_pd` to further shuffle the vector and find the maximum value between the result and the shuffled vector.
    - Return the result of [`wl_max`](<#wl_max>), which is the maximum value broadcasted to all lanes.
- **Output**: A vector of type `wl_t` where all lanes contain the maximum value found in the input vector `x`.
- **Functions Called**:
    - [`wl_max`](<#wl_max>)


---
### wl\_gather<!-- {{#callable:wl_gather}} -->
[View Source →](<../../../../../src/util/simd/fd_avx_wl.h#L336>)

Gathers 64-bit integers from a base array using indices from a vector, selecting either the lower or upper half of the vector based on a compile-time constant.
- **Inputs**:
    - `b`: A pointer to a constant array of long integers from which to gather values.
    - `i`: A vector of indices (`wi_t`) used to specify which elements to gather from the array `b`.
    - `imm_hi`: A compile-time constant integer that determines whether to use the lower or upper half of the index vector `i` for gathering.
- **Logic and Control Flow**:
    - Check if `imm_hi` is non-zero.
    - If `imm_hi` is non-zero, use the upper half of the index vector `i` to gather elements from `b`.
    - If `imm_hi` is zero, use the lower half of the index vector `i` to gather elements from `b`.
- **Output**: Returns a vector (`wl_t`) containing the gathered 64-bit integers from the array `b`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)