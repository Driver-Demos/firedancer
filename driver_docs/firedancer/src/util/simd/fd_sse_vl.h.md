<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines macros and functions for vector long operations using SSE intrinsics, including arithmetic, logical, and memory operations.

# Purpose
The code defines a set of macros and inline functions for operations on 128-bit SIMD (Single Instruction, Multiple Data) vectors using Intel's SSE (Streaming SIMD Extensions) intrinsics. The primary focus is on handling vectors of two 64-bit signed integers, referred to as `vl_t`. The code provides a comprehensive API for constructing, manipulating, and performing arithmetic, logical, and conversion operations on these vector types. It includes constructors for creating vectors, memory operations for loading and storing vectors, and a variety of arithmetic operations such as addition, subtraction, and multiplication. Logical operations like AND, OR, and XOR are also defined, along with conditional operations and conversions between different vector types.

The code is structured to ensure compatibility with different versions of Intel's instruction sets, such as AVX-512, by providing emulations for missing intrinsics when necessary. It also includes utility functions for vector reduction operations, such as summing or finding the minimum or maximum of vector elements, and for transposing 2x2 matrices of vectors. The use of macros and inline functions aims to optimize performance by reducing function call overhead and allowing the compiler to better optimize the generated machine code. The file is intended to be included indirectly through `fd_sse.h`, as indicated by the initial preprocessor directive, ensuring that it is part of a larger library or framework for SIMD operations.
# Functions

---
### vl\_ld<!-- {{#callable:vl_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L46>)

Loads two 64-bit integers from a 16-byte aligned memory location into a vector long.
- **Inputs**:
    - `p`: A pointer to a 16-byte aligned memory location containing two 64-bit integers.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m128i const *`.
    - Uses the `_mm_load_si128` intrinsic to load the data from the memory location into a `__m128i` vector.
- **Output**: A `vl_t` type, which is a `__m128i` vector containing the two loaded 64-bit integers.


---
### vl\_st<!-- {{#callable:vl_st}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L47>)

Stores a vector long (`vl_t`) into a 16-byte aligned memory location as two long integers.
- **Inputs**:
    - ``p``: A pointer to a 16-byte aligned memory location where the vector long will be stored.
    - ``i``: A vector long (`vl_t`) to be stored at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm_store_si128` intrinsic to store the vector long `i` into the memory location pointed to by `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### vl\_ldu<!-- {{#callable:vl_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L49>)

Loads a vector long from a memory location that does not need to be aligned.
- **Inputs**:
    - `p`: A pointer to a memory location from which to load the vector long; the pointer does not need to be aligned.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m128i const *`.
    - Uses the `_mm_loadu_si128` intrinsic to load a 128-bit value from the memory location pointed to by the casted pointer.
- **Output**: Returns a `vl_t` type, which is a 128-bit vector long loaded from the specified memory location.


---
### vl\_stu<!-- {{#callable:vl_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L50>)

Stores a vector long to a memory location without requiring alignment.
- **Inputs**:
    - ``p``: A pointer to the memory location where the vector long will be stored. The location does not need to be aligned.
    - ``i``: The vector long (`vl_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm_storeu_si128` intrinsic to store the vector long `i` at the memory location `p`.
- **Output**: No return value; the function performs a memory store operation.


---
### vl\_extract\_variable<!-- {{#callable:vl_extract_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L76>)

Extracts a 64-bit integer from a specified lane of a vector long.
- **Inputs**:
    - ``a``: A `vl_t` type representing a vector long containing two 64-bit integers.
    - ``n``: An integer specifying the lane index (0 or 1) from which to extract the 64-bit integer.
- **Logic and Control Flow**:
    - Declare a union `t` with a `__m128i` array and a `long` array, both of size 1.
    - Store the vector long `a` into the `__m128i` array of the union `t` using `_mm_store_si128`.
    - Return the `n`-th element from the `long` array of the union `t`.
- **Output**: Returns a 64-bit integer from the specified lane of the vector long `a`.


---
### vl\_insert\_variable<!-- {{#callable:vl_insert_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L83>)

Replaces a specified element in a vector long with a new value.
- **Inputs**:
    - ``a``: A vector long (`vl_t`) containing two 64-bit integers.
    - ``n``: An integer index (0 or 1) indicating which element in the vector to replace.
    - ``v``: A long integer value to insert into the vector at the specified index.
- **Logic and Control Flow**:
    - Store the vector `a` into a union `t` that can be accessed as either a vector or an array of two long integers.
    - Replace the element at index `n` in the array `t->l` with the value `v`.
    - Load the modified vector from `t->m` and return it.
- **Output**: A modified vector long (`vl_t`) with the specified element replaced by the new value.


---
### vl\_rol<!-- {{#callable:vl_rol}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L145>)

Performs a bitwise left rotation on a 128-bit vector of two 64-bit integers by a specified number of bits.
- **Inputs**:
    - ``a``: A 128-bit vector (`vl_t`) containing two 64-bit integers to rotate.
    - ``imm``: An integer specifying the number of bits to rotate the vector to the left.
- **Logic and Control Flow**:
    - Compute the left shift of `a` by `imm & 63` bits using `vl_shl`.
    - Compute the right shift of `a` by `(-imm) & 63` bits using `vl_shru`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `vl_or`.
- **Output**: Returns a 128-bit vector (`vl_t`) with each 64-bit integer rotated left by the specified number of bits.


---
### vl\_ror<!-- {{#callable:vl_ror}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L146>)

Performs a bitwise right rotation on a 128-bit vector of two 64-bit integers by a specified number of bits.
- **Inputs**:
    - ``a``: A 128-bit vector (`vl_t`) containing two 64-bit integers to rotate.
    - ``imm``: An integer specifying the number of bits to rotate the vector to the right.
- **Logic and Control Flow**:
    - Compute the bitwise AND of `imm` with 63 to ensure the shift amount is within the range of 0 to 63 bits.
    - Perform an unsigned right shift on `a` by the computed shift amount using `vl_shru`.
    - Compute the bitwise AND of the negation of `imm` with 63 to determine the complementary left shift amount.
    - Perform a left shift on `a` by the complementary shift amount using `vl_shl`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `vl_or` to achieve the rotation.
- **Output**: Returns a 128-bit vector (`vl_t`) with the two 64-bit integers rotated to the right by the specified number of bits.


---
### vl\_rol\_variable<!-- {{#callable:vl_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L149>)

Performs a variable left rotation on a vector long by a specified number of bits.
- **Inputs**:
    - ``a``: A vector long (`vl_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate `a` to the left.
- **Logic and Control Flow**:
    - Compute `n & 63` to ensure the rotation amount is within the range of 0 to 63 bits.
    - Perform a left shift on `a` by `n & 63` bits using `vl_shl_variable`.
    - Perform a right shift on `a` by `(-n) & 63` bits using `vl_shru_variable`.
    - Combine the results of the left and right shifts using a bitwise OR operation with `vl_or`.
- **Output**: Returns a vector long (`vl_t`) that is the result of rotating `a` to the left by `n` bits.


---
### vl\_ror\_variable<!-- {{#callable:vl_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L150>)

Performs a variable right rotation on a vector long by a specified number of bits.
- **Inputs**:
    - ``a``: A vector long (`vl_t`) to rotate.
    - ``n``: An integer specifying the number of bits to rotate `a` to the right.
- **Logic and Control Flow**:
    - Compute `n & 63` to ensure the shift amount is within the range of 0 to 63 bits.
    - Perform an unsigned right shift on `a` by `n & 63` bits using `vl_shru_variable`.
    - Compute `(-n) & 63` to determine the equivalent left shift amount.
    - Perform a left shift on `a` by `(-n) & 63` bits using `vl_shl_variable`.
    - Combine the results of the right and left shifts using a bitwise OR operation with `vl_or`.
- **Output**: Returns a vector long (`vl_t`) that is the result of rotating `a` to the right by `n` bits.


---
### vl\_rol\_vector<!-- {{#callable:vl_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L152>)

Performs a bitwise left rotation on each 64-bit element of vector `a` by the corresponding element in vector `b`.
- **Inputs**:
    - `a`: A vector of type `vl_t` containing 64-bit integers to rotate.
    - `b`: A vector of type `vl_t` containing 64-bit integers specifying the number of positions to rotate each corresponding element in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value `63L` into a vector `m` using `vl_bcast` to mask the rotation amount.
    - Computes the bitwise AND of vector `b` and `m` to ensure the rotation amount is within 0 to 63 bits.
    - Performs a left shift on vector `a` by the masked rotation amount using `vl_shl_vector`.
    - Computes the bitwise AND of the negated vector `b` and `m` to determine the complementary right shift amount.
    - Performs a logical right shift on vector `a` by the complementary amount using `vl_shru_vector`.
    - Combines the results of the left and right shifts using a bitwise OR operation with `vl_or` to complete the rotation.
- **Output**: Returns a vector of type `vl_t` with each element being the result of the left rotation of the corresponding element in `a` by the specified amount in `b`.


---
### vl\_ror\_vector<!-- {{#callable:vl_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L157>)

Performs a bitwise right rotation on each 64-bit integer in a vector by a specified number of bits.
- **Inputs**:
    - ``a``: A vector of 64-bit integers to rotate.
    - ``b``: A vector specifying the number of bits to rotate each corresponding integer in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant `63L` into a vector `m` to mask the rotation amount.
    - Computes the bitwise AND of `b` and `m` to ensure the rotation amount is within 0 to 63 bits.
    - Performs an unsigned right shift on `a` by the masked rotation amount.
    - Computes the bitwise AND of the negated `b` and `m` to determine the left shift amount.
    - Performs a left shift on `a` by the computed left shift amount.
    - Combines the results of the right and left shifts using a bitwise OR to complete the rotation.
- **Output**: A vector of 64-bit integers, each rotated right by the specified number of bits.


---
### vl\_abs<!-- {{#callable:vl_abs}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L186>)

Computes the absolute value of a vector long by conditionally negating negative elements.
- **Inputs**:
    - ``a``: A vector long (`vl_t`) containing two signed 64-bit integers.
- **Logic and Control Flow**:
    - Checks if each element in vector `a` is less than zero using `vl_lt(a, vl_zero())`.
    - If an element is less than zero, negates it using `vl_neg(a)`.
    - Uses `vl_if` to select the negated value or the original value based on the condition.
- **Output**: Returns a vector long (`vl_t`) with the absolute values of the input vector's elements.


---
### vl\_min<!-- {{#callable:vl_min}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L187>)

Selects the minimum value between two vector long (`vl_t`) inputs.
- **Inputs**:
    - `a`: A vector long (`vl_t`) input.
    - `b`: Another vector long (`vl_t`) input.
- **Logic and Control Flow**:
    - Compares the two vector long inputs `a` and `b` using `vl_lt` to determine which is smaller.
    - Uses `vl_if` to select `a` if it is less than `b`, otherwise selects `b`.
- **Output**: Returns the vector long (`vl_t`) that contains the minimum values from the inputs `a` and `b`.


---
### vl\_max<!-- {{#callable:vl_max}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L188>)

Selects the maximum value between two vector long (`vl_t`) inputs.
- **Inputs**:
    - `a`: A vector long (`vl_t`) input.
    - `b`: Another vector long (`vl_t`) input.
- **Logic and Control Flow**:
    - Compares the two vector long inputs `a` and `b` using the `vl_gt` function to determine which is greater.
    - Uses the `vl_if` function to select `a` if `a` is greater than `b`, otherwise selects `b`.
- **Output**: Returns a vector long (`vl_t`) that contains the maximum values from the corresponding lanes of `a` and `b`.


---
### vl\_shr<!-- {{#callable:vl_shr}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L191>)

Performs an arithmetic right shift on a vector of signed 64-bit integers, considering the sign bit for negative numbers.
- **Inputs**:
    - ``a``: A vector of signed 64-bit integers (`vl_t`) to be right-shifted.
    - ``imm``: An integer representing the number of bits to shift, which must be a compile-time constant between 0 and 63.
- **Logic and Control Flow**:
    - Determine if each element in vector `a` is negative by comparing it to zero using `vl_lt`, resulting in a vector `c` that is binary compatible with `vl_t`.
    - Perform a bitwise XOR between `a` and `c` to prepare for the arithmetic shift, effectively flipping the bits of negative numbers to handle the sign bit correctly.
    - Right shift the result of the XOR operation by `imm` bits using `_mm_srli_epi64`, which treats the numbers as unsigned during the shift.
    - Perform another XOR with `c` to restore the sign of the original negative numbers, completing the arithmetic right shift.
- **Output**: Returns a vector of signed 64-bit integers (`vl_t`) that have been right-shifted by `imm` bits, with the sign bit preserved for negative numbers.


---
### vl\_shr\_variable<!-- {{#callable:vl_shr_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L195>)

Performs an arithmetic right shift on a 128-bit vector of two 64-bit integers by a variable number of bits.
- **Inputs**:
    - ``a``: A 128-bit vector (`vl_t`) containing two 64-bit signed integers to be shifted.
    - ``n``: An integer specifying the number of bits to shift the vector `a` to the right.
- **Logic and Control Flow**:
    - Determine if the vector `a` is negative by comparing it to zero using `vl_lt`, resulting in a vector `c` that is binary compatible with `vl_t`.
    - Perform a bitwise XOR between `a` and `c` to prepare for the shift operation.
    - Insert the shift amount `n` into a zero-initialized 128-bit vector using `_mm_insert_epi64`.
    - Perform a logical right shift on the XOR result by `n` bits using `_mm_srl_epi64`.
    - XOR the shifted result with `c` to complete the arithmetic right shift, preserving the sign of the original vector `a`.
- **Output**: Returns a 128-bit vector (`vl_t`) with the result of the arithmetic right shift operation.


---
### vl\_shr\_vector<!-- {{#callable:vl_shr_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L199>)

Performs an arithmetic right shift on a vector of signed 64-bit integers, considering negative values.
- **Inputs**:
    - ``a``: A vector of signed 64-bit integers to be shifted.
    - ``n``: A vector specifying the number of bits to shift each corresponding element in `a`.
- **Logic and Control Flow**:
    - Check if each element in `a` is negative using `vl_lt` and store the result in `c`.
    - Perform a bitwise XOR between `a` and `c` to prepare for the shift operation.
    - Use `_mm_srlv_epi64` to perform a logical right shift on the XOR result by the number of bits specified in `n`.
    - Perform another bitwise XOR on the shifted result with `c` to complete the arithmetic right shift.
- **Output**: Returns a vector of signed 64-bit integers, each element of which is the result of an arithmetic right shift of the corresponding element in `a` by the number of bits specified in `n`.


---
### vl\_to\_vf<!-- {{#callable:vl_to_vf}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L231>)

Converts a vector of long integers to a vector of floats, inserting the converted values into specified positions of an existing float vector.
- **Inputs**:
    - ``l``: A vector of long integers (`vl_t`) from which to extract and convert two 64-bit integers to floats.
    - ``f``: A vector of floats (`vf_t`) into which the converted float values will be inserted.
    - ``imm_hi``: An integer flag that determines the positions in the float vector where the converted values will be inserted.
- **Logic and Control Flow**:
    - Extracts the first 64-bit integer from the vector `l` and converts it to a float, storing it in `f0`.
    - Extracts the second 64-bit integer from the vector `l` and converts it to a float, storing it in `f1`.
    - Checks the value of `imm_hi`.
    - If `imm_hi` is non-zero, inserts `f0` and `f1` into positions 2 and 3 of the float vector `f`.
    - If `imm_hi` is zero, inserts `f0` and `f1` into positions 0 and 1 of the float vector `f`.
- **Output**: Returns a float vector (`vf_t`) with the converted values inserted at the specified positions.


---
### vl\_to\_vi<!-- {{#callable:vl_to_vi}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L237>)

Converts a vector long to a vector integer with optional shuffling based on a flag.
- **Inputs**:
    - `l`: A vector long (`vl_t`) to convert.
    - `i`: A vector integer (`vi_t`) used for shuffling.
    - `imm_hi`: An integer flag to determine the shuffle pattern.
- **Logic and Control Flow**:
    - Cast the vector long `l` to a vector float `_l`.
    - Cast the vector integer `i` to a vector float `_i`.
    - If `imm_hi` is true, shuffle `_i` and `_l` using the pattern `_MM_SHUFFLE(2,0,1,0)`.
    - If `imm_hi` is false, shuffle `_l` and `_i` using the pattern `_MM_SHUFFLE(3,2,2,0)`.
    - Cast the resulting vector float back to a vector integer and return it.
- **Output**: A vector integer (`vl_t`) resulting from the conversion and optional shuffling.


---
### vl\_to\_vu<!-- {{#callable:vl_to_vu}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L245>)

Converts a vector long `vl_t` to a vector unsigned `vu_t` by shuffling elements based on the `imm_hi` flag.
- **Inputs**:
    - `l`: A vector long (`vl_t`) to be converted.
    - `u`: A vector unsigned (`vu_t`) used in the conversion process.
    - `imm_hi`: An integer flag that determines the shuffle pattern.
- **Logic and Control Flow**:
    - Casts the vector long `l` to a vector float `vf_t` and assigns it to `_l`.
    - Casts the vector unsigned `u` to a vector float `vf_t` and assigns it to `_u`.
    - Checks the `imm_hi` flag to determine the shuffle pattern.
    - If `imm_hi` is true, shuffles `_u` and `_l` using the pattern `_MM_SHUFFLE(2,0,1,0)`.
    - If `imm_hi` is false, shuffles `_l` and `_u` using the pattern `_MM_SHUFFLE(3,2,2,0)`.
    - Casts the shuffled vector float `_l` back to a vector long `vl_t` and returns it.
- **Output**: Returns a vector long (`vl_t`) that is the result of the shuffle operation.


---
### vl\_to\_vd<!-- {{#callable:vl_to_vd}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L253>)

Converts a vector long (`vl_t`) to a vector double (`vd_t`) by extracting and casting each 64-bit integer lane to a double.
- **Inputs**:
    - ``l``: A vector long (`vl_t`) containing two 64-bit signed integers.
- **Logic and Control Flow**:
    - Extracts the first 64-bit integer from `l` using `_mm_extract_epi64` and casts it to a double.
    - Extracts the second 64-bit integer from `l` using `_mm_extract_epi64` and casts it to a double.
    - Creates a vector double (`vd_t`) with the two double values using `_mm_setr_pd`.
- **Output**: A vector double (`vd_t`) containing the two double-precision floating-point values converted from the input vector long.


---
### vl\_sum\_all<!-- {{#callable:vl_sum_all}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L268>)

Computes the sum of two 64-bit integers in a vector and returns a vector with the sum broadcasted to both lanes.
- **Inputs**:
    - ``x``: A vector of type `vl_t` containing two 64-bit integers.
- **Logic and Control Flow**:
    - Permutes the input vector `x` to swap its two lanes using `vl_permute(x, 1, 0)`.
    - Adds the original vector `x` and the permuted vector using `vl_add` to compute the sum of the two integers.
    - Returns the result of the addition, which is a vector with the sum broadcasted to both lanes.
- **Output**: A vector of type `vl_t` with the sum of the two integers in `x` broadcasted to both lanes.


---
### vl\_min\_all<!-- {{#callable:vl_min_all}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L273>)

Computes the minimum value of a vector long and broadcasts it across all lanes.
- **Inputs**:
    - ``x``: A vector long (`vl_t`) containing two 64-bit signed integers.
- **Logic and Control Flow**:
    - Permutes the input vector `x` to swap its two lanes using `vl_permute(x, 1, 0)`.
    - Computes the element-wise minimum of the original vector `x` and the permuted vector using `vl_min(x, vl_permute(x, 1, 0))`.
- **Output**: A vector long (`vl_t`) where both lanes contain the minimum value of the input vector `x`.
- **Functions Called**:
    - [`vl_min`](<#vl_min>)


---
### vl\_max\_all<!-- {{#callable:vl_max_all}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L278>)

Computes the maximum value of a vector long and broadcasts it across all lanes.
- **Inputs**:
    - ``x``: A vector long (`vl_t`) containing two 64-bit signed integers.
- **Logic and Control Flow**:
    - Permutes the input vector `x` to swap its two lanes using `vl_permute(x, 1, 0)`.
    - Computes the maximum of the original vector `x` and the permuted vector using `vl_max(x, vl_permute(x, 1, 0))`.
    - Returns the result, which is a vector long with the maximum value broadcasted to both lanes.
- **Output**: A vector long (`vl_t`) with the maximum value of the input vector `x` broadcasted to both lanes.
- **Functions Called**:
    - [`vl_max`](<#vl_max>)


---
### \_vl\_gather<!-- {{#callable:_vl_gather}} -->
[View Source →](<../../../../../src/util/simd/fd_sse_vl.h#L294>)

Gathers 64-bit integers from a base array using 32-bit indices and returns them as a vector long.
- **Inputs**:
    - `b`: A pointer to a constant array of long integers from which to gather data.
    - `i`: A vector of 32-bit integer indices specifying which elements to gather from the array.
- **Logic and Control Flow**:
    - Uses the `_mm_i32gather_epi64` intrinsic to gather 64-bit integers from the array `b` at positions specified by the indices in `i`.
    - The gathered integers are returned as a vector long (`vl_t`).
- **Output**: A vector long (`vl_t`) containing the gathered 64-bit integers.



---
Made with ❤️ by [Driver](https://www.driver.ai/)