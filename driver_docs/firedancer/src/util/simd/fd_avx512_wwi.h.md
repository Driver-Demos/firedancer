<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Macros and inline functions for AVX-512 vector operations on 32-bit integers, including arithmetic, binary, and memory operations.

# Purpose
The code defines a set of macros and inline functions for operations on 512-bit wide vector integers using AVX-512 intrinsics. It is intended to be included indirectly through `fd_avx512.h`, as indicated by the preprocessor directive at the beginning. The primary data type used is `wwi_t`, which represents a vector of sixteen 32-bit signed integers. The code provides a comprehensive API for constructing, manipulating, and performing arithmetic, binary, and comparison operations on these vectors.

The API includes constructors for creating vectors with specific values or broadcasting a single value across all lanes. It also provides memory operations for loading and storing vectors with both aligned and unaligned memory addresses. Arithmetic operations such as addition, subtraction, multiplication, and various binary operations like shifts, rotates, and logical operations are defined. The code also includes comparison operations that return masks based on the comparison results. Additionally, there are conditional operations that blend vectors based on a mask and conversion functions to transform vectors into different formats. The code concludes with miscellaneous operations, including packing, sliding, unpacking, and transposing vectors, which are useful for matrix operations and data rearrangement.
# Global Variables

---
### \_wwi\_transpose\_t0
- **Type**: ``wwi_t``
- **Description**: Holds the result of a vector selection operation using the `wwi_select` macro. This operation selects elements from two vectors, `_wwi_transpose_r0` and `_wwi_transpose_r4`, based on a permutation vector `_wwi_transpose_p`. The result is a vector of 32-bit integers.
- **Use**: Used in the process of transposing a 16x16 matrix of integers by selecting and rearranging elements from input vectors.


---
### \_wwi\_transpose\_t1
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit lane holds a signed 32-bit integer. The variable `_wwi_transpose_t1` is initialized using the `wwi_select` macro, which selects and permutes elements from two `wwi_t` vectors based on a permutation vector `p`. This operation is part of a larger transpose operation for 2x8x8 matrices.
- **Use**: Used to store intermediate results during the transpose of 2x8x8 matrices.


---
### \_wwi\_transpose\_t2
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit wide lane holds a signed two's complement 32-bit integer. It is used to perform operations on vectors of integers using AVX-512 intrinsics.
- **Use**: Used to store the result of selecting and permuting elements from two `wwi_t` vectors using the `wwi_select` macro.


---
### \_wwi\_transpose\_t3
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit lane holds a signed 32-bit integer. The variable `_wwi_transpose_t3` is initialized using the `wwi_select` macro, which selects and permutes elements from two `wwi_t` vectors, `_wwi_transpose_r3` and `_wwi_transpose_r7`, based on the permutation vector `_wwi_transpose_p`. This operation is part of a larger transpose operation for 16x16 matrices.
- **Use**: Used to store intermediate results during the transpose of 16x16 matrices.


---
### \_wwi\_transpose\_t4
- **Type**: ``wwi_t``
- **Description**: Holds a vector of 32-bit signed integers, representing a part of the transposition process in a 2x8x8 matrix transpose operation. It is initialized using the `wwi_select` macro, which selects and permutes elements from two input vectors based on a permutation vector.
- **Use**: Used in the `wwi_transpose_2x8x8` macro to assist in transposing 8x8 matrices by selecting and rearranging elements from input vectors.


---
### \_wwi\_transpose\_t5
- **Type**: ``wwi_t``
- **Description**: Holds a vector of 16 signed 32-bit integers, representing a 512-bit wide SIMD register. It is initialized using the `wwi_select` macro, which selects elements from two vectors based on a permutation vector.
- **Use**: Used to store the result of a permutation operation on two vectors, `_wwi_transpose_r1` and `_wwi_transpose_r5`, using the permutation vector `_wwi_transpose_q`.


---
### \_wwi\_transpose\_t6
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit lane holds a signed 32-bit integer. The variable `_wwi_transpose_t6` is initialized using the `wwi_select` macro, which selects and arranges elements from two `wwi_t` vectors based on a permutation vector.
- **Use**: Used in the process of transposing 2x8x8 matrices by selecting and rearranging elements from two input vectors.


---
### \_wwi\_transpose\_t7
- **Type**: ``wwi_t``
- **Description**: Holds the result of a vector permutation operation using the `wwi_select` macro. This operation combines two vectors, `_wwi_transpose_r3` and `_wwi_transpose_r7`, using a permutation vector `_wwi_transpose_q`. The result is a new vector with elements selected from the two input vectors based on the permutation vector.
- **Use**: Used to store a specific permutation of elements from two input vectors as part of a matrix transpose operation.


---
### \_wwi\_transpose\_t8
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit lane holds a signed 32-bit integer. The variable `_wwi_transpose_t8` is initialized using the `_mm512_shuffle_i32x4` intrinsic, which shuffles 128-bit lanes of two input vectors, `_wwi_transpose_r8` and `_wwi_transpose_rc`, according to the control mask `0x88`. This operation is part of a larger transpose operation for 16x16 matrices.
- **Use**: Used to store the result of a shuffle operation on two vectors as part of a matrix transpose process.


---
### \_wwi\_transpose\_t9
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit lane holds a signed 32-bit integer. The variable `_wwi_transpose_t9` is initialized using the `_mm512_shuffle_i32x4` intrinsic, which shuffles 128-bit lanes of two input vectors, `_wwi_transpose_r9` and `_wwi_transpose_rd`, according to the control mask `0x88`. This operation is part of a larger matrix transpose operation.
- **Use**: Used in the process of transposing a 16x16 matrix by shuffling 128-bit lanes of input vectors.


---
### \_wwi\_transpose\_ta
- **Type**: ``wwi_t``
- **Description**: Holds a vector of 16 signed 32-bit integers. It is initialized using the `_mm512_shuffle_i32x4` intrinsic to shuffle elements from two other vectors, `_wwi_transpose_ra` and `_wwi_transpose_re`, with a control mask of `0x88`. This operation is part of a larger process to transpose a 16x16 matrix of integers.
- **Use**: Used in the `wwi_transpose_16x16` macro to assist in transposing a 16x16 matrix of integers.


---
### \_wwi\_transpose\_tb
- **Type**: ``wwi_t``
- **Description**: The variable `_wwi_transpose_tb` is a vector of 32-bit signed integers, defined using the `__m512i` type. It is initialized by shuffling 128-bit lanes from the vectors `_wwi_transpose_rb` and `_wwi_transpose_rf` using the `_mm512_shuffle_i32x4` intrinsic with a control mask of `0x88`. This operation selects the lower 128-bit lanes from both input vectors to form a new vector.
- **Use**: Used in the process of transposing a 16x16 matrix of integers by rearranging 128-bit lanes of input vectors.


---
### \_wwi\_transpose\_tc
- **Type**: ``wwi_t``
- **Description**: The variable `_wwi_transpose_tc` is a vector of 32-bit signed integers, defined using the `__m512i` type. It is initialized by shuffling the 32-bit integer elements of `_wwi_transpose_r8` and `_wwi_transpose_rc` using the `_mm512_shuffle_i32x4` intrinsic with a control mask of `0xdd`. This operation rearranges the elements of the input vectors to form a new vector.
- **Use**: Used to store a shuffled combination of two input vectors as part of a matrix transpose operation.


---
### \_wwi\_transpose\_td
- **Type**: ``wwi_t``
- **Description**: Holds a 512-bit vector where each 32-bit lane contains a signed 32-bit integer. It is initialized using the `_mm512_shuffle_i32x4` intrinsic to shuffle elements from two other `wwi_t` vectors, `_wwi_transpose_r9` and `_wwi_transpose_rd`, with a control mask of `0xdd`. This operation is part of a larger matrix transpose operation.
- **Use**: Used in the process of transposing a 16x16 matrix of integers by shuffling elements between vectors.


---
### \_wwi\_transpose\_te
- **Type**: ``wwi_t``
- **Description**: Holds a 512-bit vector of signed 32-bit integers. It is initialized using the `_mm512_shuffle_i32x4` intrinsic to shuffle elements from two other vectors, `_wwi_transpose_ra` and `_wwi_transpose_re`, with a control mask `0xdd`. This operation is part of a larger process to transpose a 16x16 matrix of integers.
- **Use**: Used in the `wwi_transpose_16x16` macro to assist in transposing a 16x16 matrix of integers.


---
### \_wwi\_transpose\_tf
- **Type**: ``wwi_t``
- **Description**: A global variable of type `wwi_t`, which is a vector where each 32-bit wide lane holds a signed two's complement 32-bit integer. It is initialized using the `_mm512_shuffle_i32x4` intrinsic to shuffle elements from two other vectors, `_wwi_transpose_rb` and `_wwi_transpose_rf`, with a control mask of `0xdd`.
- **Use**: Used to store a shuffled vector of 32-bit integers, likely for matrix transposition operations.


---
### \_wwi\_transpose\_p
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit wide lane holds a signed two's complement 32-bit integer. The variable `_wwi_transpose_p` is initialized using the `wwi` macro, which sets the vector lanes to specific integer values.
- **Use**: Used in the `wwi_transpose_2x8x8` macro to select and permute elements from two 8x8 matrices.


---
### \_wwi\_transpose\_q
- **Type**: ``wwi_t``
- **Description**: A vector type where each 32-bit lane holds a signed 32-bit integer. The variable `_wwi_transpose_q` is initialized with a vector of integers using the `wwi` macro, which sets the vector lanes to specific integer values.
- **Use**: Used to define a specific permutation pattern for vector operations, particularly in matrix transposition functions.


# Functions

---
### wwi\_ld<!-- {{#callable:wwi_ld}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L51>)

Loads a 512-bit vector of 16 32-bit integers from a 64-byte aligned memory address.
- **Inputs**:
    - `m`: A pointer to a constant integer array that must be 64-byte aligned.
- **Logic and Control Flow**:
    - Uses the `_mm512_load_epi32` intrinsic to load 16 32-bit integers from the memory location pointed to by `m`.
- **Output**: Returns a `wwi_t` type, which is a 512-bit vector containing the loaded integers.


---
### wwi\_st<!-- {{#callable:wwi_st}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L52>)

Stores a 512-bit vector of 32-bit integers into a memory location.
- **Inputs**:
    - ``m``: A pointer to an integer array where the vector will be stored. The array must be 64-byte aligned.
    - ``x``: A `wwi_t` type representing a 512-bit vector of 32-bit integers to store.
- **Logic and Control Flow**:
    - Uses the `_mm512_store_epi32` intrinsic to store the vector `x` into the memory location pointed to by `m`.
- **Output**: No return value; the function performs a memory store operation.


---
### wwi\_ldu<!-- {{#callable:wwi_ldu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L54>)

Loads a 512-bit vector of 16 32-bit integers from memory with arbitrary alignment.
- **Inputs**:
    - `m`: A pointer to the memory location from which to load the vector.
- **Logic and Control Flow**:
    - Uses the `_mm512_loadu_epi32` intrinsic to load a 512-bit vector from the memory location pointed to by `m`.
- **Output**: Returns a `wwi_t` type, which is a 512-bit vector containing 16 32-bit integers loaded from the specified memory location.


---
### wwi\_stu<!-- {{#callable:wwi_stu}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L55>)

Stores a 512-bit vector of 32-bit integers into memory with arbitrary alignment.
- **Inputs**:
    - ``m``: A pointer to the memory location where the vector will be stored. The memory can have arbitrary alignment.
    - ``x``: A `wwi_t` type, which is a 512-bit vector containing 16 signed 32-bit integers.
- **Logic and Control Flow**:
    - Uses the `_mm512_storeu_epi32` intrinsic to store the vector `x` into the memory location pointed to by `m`.
- **Output**: No return value; the function performs a memory store operation.


---
### wwi\_rol\_variable<!-- {{#callable:wwi_rol_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L98>)

Performs a variable left bitwise rotation on a 512-bit vector of 32-bit integers.
- **Inputs**:
    - `a`: A `wwi_t` type representing a 512-bit vector of 32-bit integers to rotate.
    - `n`: An integer representing the number of positions to rotate the bits to the left.
- **Logic and Control Flow**:
    - Calculates `n & 31` to ensure the shift amount is within the range of 0 to 31.
    - Performs a left shift on `a` by `n & 31` positions using `wwi_shl`.
    - Calculates `(-n) & 31` to determine the equivalent right shift amount.
    - Performs an unsigned right shift on `a` by `(-n) & 31` positions using `wwi_shru`.
    - Combines the results of the left and right shifts using a bitwise OR operation with `wwi_or`.
- **Output**: Returns a `wwi_t` type representing the result of the left bitwise rotation of the input vector `a` by `n` positions.


---
### wwi\_ror\_variable<!-- {{#callable:wwi_ror_variable}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L99>)

Performs a variable right rotation on a vector of 32-bit integers.
- **Inputs**:
    - `a`: A `wwi_t` vector containing 32-bit integers to rotate.
    - `n`: An integer specifying the number of positions to rotate the vector to the right.
- **Logic and Control Flow**:
    - Calculates `n & 31` to ensure the shift amount is within the range of 0 to 31.
    - Performs an unsigned right shift on `a` by `n & 31` positions using `wwi_shru`.
    - Calculates `(-n) & 31` to determine the equivalent left shift amount.
    - Performs a left shift on `a` by `(-n) & 31` positions using `wwi_shl`.
    - Combines the results of the right and left shifts using a bitwise OR operation with `wwi_or`.
- **Output**: Returns a `wwi_t` vector where each 32-bit integer has been right-rotated by `n` positions.


---
### wwi\_rol\_vector<!-- {{#callable:wwi_rol_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L101>)

Performs a bitwise left rotation on each 32-bit lane of vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - `a`: A vector of type `wwi_t` where each lane contains a signed 32-bit integer.
    - `b`: A vector of type `wwi_t` where each lane specifies the number of positions to rotate the corresponding lane in `a`.
- **Logic and Control Flow**:
    - Broadcasts the constant value 31 to all lanes of a vector `m` using `wwi_bcast` to ensure the rotation amount is within the range of 0 to 31.
    - Performs a bitwise AND operation between `b` and `m` to mask the rotation amount, ensuring it is within the valid range.
    - Shifts each lane of `a` to the left by the masked rotation amount using `wwi_shl_vector`.
    - Negates each lane of `b` and masks it with `m` to calculate the right shift amount.
    - Shifts each lane of `a` to the right by the calculated amount using `wwi_shru_vector`.
    - Combines the results of the left and right shifts using a bitwise OR operation with `wwi_or` to complete the rotation.
- **Output**: Returns a vector of type `wwi_t` where each lane contains the result of the left rotation operation.


---
### wwi\_ror\_vector<!-- {{#callable:wwi_ror_vector}} -->
[View Source →](<../../../../../src/util/simd/fd_avx512_wwi.h#L106>)

Performs a bitwise right rotation on each 32-bit lane of vector `a` by the corresponding amount specified in vector `b`.
- **Inputs**:
    - `a`: A vector of type `wwi_t` where each 32-bit lane holds a signed 32-bit integer.
    - `b`: A vector of type `wwi_t` specifying the number of positions to rotate each corresponding lane of `a` to the right.
- **Logic and Control Flow**:
    - Broadcasts the constant value 31 to all lanes of a vector `m` using `wwi_bcast` to ensure the rotation amount is within the range of 0 to 31.
    - Performs a bitwise AND operation between vector `b` and vector `m` to limit the rotation amount to 5 bits (0-31).
    - Calculates the right-shifted version of `a` using `wwi_shru_vector` with the masked rotation amount.
    - Calculates the left-shifted version of `a` using `wwi_shl_vector` with the negated and masked rotation amount.
    - Combines the results of the right and left shifts using a bitwise OR operation with `wwi_or` to complete the rotation.
- **Output**: Returns a vector of type `wwi_t` where each lane contains the result of the right rotation of the corresponding lane in `a` by the amount specified in `b`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)