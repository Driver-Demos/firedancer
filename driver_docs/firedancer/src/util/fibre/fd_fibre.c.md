<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements cooperative threading and scheduling with fibre initialization, management, and communication.

# Purpose
The code provides a cooperative threading library for managing lightweight threads, known as "fibres." It includes functions to initialize, start, and manage the execution of these fibres. The [`fd_fibre_init`](<#fd_fibre_init>) function initializes a fibre, while [`fd_fibre_start`](<#fd_fibre_start>) creates a new fibre with a specified stack size and function to execute. The library uses `getcontext`, `setcontext`, and `swapcontext` to manage context switching between fibres, allowing for cooperative multitasking. The [`fd_fibre_swap`](<#fd_fibre_swap>) function switches execution to a specified fibre, and [`fd_fibre_yield`](<#fd_fibre_yield>) and [`fd_fibre_wait`](<#fd_fibre_wait>) functions allow a fibre to yield control or wait for a specified time.

Additionally, the code includes a scheduling mechanism to manage the execution order of fibres. The [`fd_fibre_schedule`](<#fd_fibre_schedule>) function adds a fibre to the schedule, and [`fd_fibre_schedule_run`](<#fd_fibre_schedule_run>) executes the scheduled fibres based on their readiness. The code also implements a simple inter-fibre communication mechanism using pipes, with functions [`fd_fibre_pipe_new`](<#fd_fibre_pipe_new>), [`fd_fibre_pipe_write`](<#fd_fibre_pipe_write>), and [`fd_fibre_pipe_read`](<#fd_fibre_pipe_read>) to create a pipe, write to it, and read from it, respectively. These pipes allow fibres to communicate by passing data between them, with support for blocking operations until data is available or space is free.
# Imports and Dependencies

---
- `fd_fibre.h`
- `stdio.h`
- `stdlib.h`
- `string.h`
- `errno.h`


# Global Variables

---
### fd\_fibre\_current
- **Type**: ``fd_fibre_t *``
- **Description**: A pointer to the current fibre being executed in the cooperative threading system. It is initialized to `NULL` and updated to point to the current fibre during fibre initialization and context switching.
- **Use**: Used to track and manage the currently executing fibre in the cooperative threading system.


---
### fd\_fibre\_scheduler
- **Type**: ``fd_fibre_t *``
- **Description**: A pointer to a `fd_fibre_t` structure that represents the fibre used as the scheduler in the fibre scheduling system.
- **Use**: Used to switch execution to the fibre scheduler when a fibre needs to wait or yield.


---
### fd\_fibre\_schedule\_queue
- **Type**: ``fd_fibre_t` array`
- **Description**: The `fd_fibre_schedule_queue` is a global array of `fd_fibre_t` structures with a single element. It is initialized with a sentinel value of 1 and its `next` pointer pointing to itself, forming a circular linked list. This setup is used to manage the scheduling of fibres in a cooperative threading environment.
- **Use**: Used as the sentinel node in the fibre scheduling queue to manage and organize the execution order of fibres.


# Functions

---
### fd\_fibre\_run\_fn<!-- {{#callable:fd_fibre_run_fn}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L12>)

Executes a user-defined function and sets a completion flag.
- **Inputs**:
    - `vp`: A pointer to a `fd_fibre_t` structure, which contains the user function and its argument.
- **Logic and Control Flow**:
    - Cast the input pointer `vp` to a `fd_fibre_t` pointer named `fibre`.
    - Call the user-defined function `fibre->fn` with the argument `fibre->arg`.
    - Set the `done` flag of the `fibre` structure to 1, indicating the function has completed execution.
- **Output**: No return value; the function operates on the `fd_fibre_t` structure pointed to by `vp`.


---
### fd\_fibre\_init\_footprint<!-- {{#callable:fd_fibre_init_footprint}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L24>)

Calculates the memory footprint required for initializing a fibre, ensuring it is aligned to a specified boundary.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `fd_ulong_align_up` with the size of `fd_fibre_t` and `FD_FIBRE_ALIGN` to ensure the size is a multiple of the alignment.
- **Output**: Returns an unsigned long integer representing the aligned size of `fd_fibre_t`.


---
### fd\_fibre\_init\_align<!-- {{#callable:fd_fibre_init_align}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L30>)

Returns the alignment requirement for initializing a fibre.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the constant `FD_FIBRE_ALIGN`.
- **Output**: The function returns an `ulong` value representing the alignment requirement for fibre initialization.


---
### fd\_fibre\_init<!-- {{#callable:fd_fibre_init}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L36>)

Initializes a fibre structure with default values and sets the current fibre context.
- **Inputs**:
    - `mem`: A pointer to memory where the fibre structure will be initialized.
- **Logic and Control Flow**:
    - Cast the `mem` pointer to a `fd_fibre_t` pointer and assign it to `fibre`.
    - Use `memset` to zero out the memory for the `fibre` structure.
    - Set `fibre->stack` to `NULL` and `fibre->stack_sz` to `0`.
    - Get the address of `fibre->ctx` and assign it to `ctx`.
    - Call `getcontext` with `ctx` to initialize the context; if it fails, print an error message and abort the program.
    - Set `fd_fibre_current` to the initialized `fibre`.
    - Return the initialized `fibre` pointer.
- **Output**: A pointer to the initialized `fd_fibre_t` structure.


---
### fd\_fibre\_start\_footprint<!-- {{#callable:fd_fibre_start_footprint}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L59>)

Calculates the memory footprint required to start a fibre with a given stack size, ensuring alignment.
- **Inputs**:
    - `stack_size`: The size of the stack in bytes for which the footprint is calculated.
- **Logic and Control Flow**:
    - Aligns the size of `fd_fibre_t` structure to `FD_FIBRE_ALIGN` using `fd_ulong_align_up`.
    - Aligns the given `stack_size` to `FD_FIBRE_ALIGN` using `fd_ulong_align_up`.
    - Returns the sum of the aligned sizes of `fd_fibre_t` and the stack.
- **Output**: Returns the total aligned memory footprint in bytes required to start a fibre with the specified stack size.


---
### fd\_fibre\_start\_align<!-- {{#callable:fd_fibre_start_align}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L65>)

Returns the alignment requirement for starting a fibre.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the constant `FD_FIBRE_ALIGN`.
- **Output**: The function returns an `ulong` representing the alignment requirement for starting a fibre, which is `FD_FIBRE_ALIGN`.


---
### fd\_fibre\_start<!-- {{#callable:fd_fibre_start}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L76>)

Initializes and prepares a new fibre for execution using cooperative threading.
- **Inputs**:
    - `mem`: A pointer to the memory location where the fibre will be initialized.
    - `stack_sz`: The size of the stack to be allocated for the new fibre.
    - `fn`: A function pointer to the user-defined function that the fibre will execute.
    - `arg`: A pointer to the argument that will be passed to the user-defined function.
- **Logic and Control Flow**:
    - Checks if `fd_fibre_current` is `NULL` and aborts if `fd_fibre_init` has not been called.
    - Calculates the aligned memory address for the fibre's stack.
    - Initializes a `fd_fibre_t` structure at the given memory location and sets its stack size and stack pointer.
    - Assigns the user-defined function and its argument to the fibre.
    - Copies the current fibre's context to the new fibre's context.
    - Sets the successor context to the current fibre's context in case the new fibre terminates.
    - Configures the stack for the new fibre's context.
    - Creates a new execution context for the fibre using `makecontext`.
- **Output**: Returns a pointer to the initialized `fd_fibre_t` structure representing the new fibre.


---
### fd\_fibre\_free<!-- {{#callable:fd_fibre_free}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L119>)

Does not perform any operations as the caller is responsible for managing the memory of the fibre.
- **Inputs**:
    - ``fibre``: A pointer to an `fd_fibre_t` structure that represents the fibre to be freed.
- **Logic and Control Flow**:
    - The function takes a pointer to an `fd_fibre_t` structure as an argument.
    - The function does not perform any operations on the `fibre` as the caller is responsible for the memory management.
    - The function explicitly casts the `fibre` to void to avoid unused parameter warnings.
- **Output**: No output is produced as the function does not perform any operations.


---
### fd\_fibre\_swap<!-- {{#callable:fd_fibre_swap}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L129>)

Switches execution context to a specified fibre if it is not already the current one and is not marked as done.
- **Inputs**:
    - `swap_to`: A pointer to the `fd_fibre_t` structure representing the fibre to switch to.
- **Logic and Control Flow**:
    - Check if `swap_to` is the same as `fd_fibre_current`; if so, return immediately.
    - Check if `swap_to` is marked as done; if so, return immediately.
    - Set the `uc_link` of `swap_to`'s context to point to the current fibre's context, allowing it to return to the current context when done.
    - Store the current fibre in `fibre_pop` for later restoration.
    - Set `fd_fibre_current` to `swap_to` to update the current execution context.
    - Attempt to switch context from `fibre_pop` to `swap_to` using `swapcontext`; if it fails, print an error message and abort.
    - After returning from the context switch, restore `fd_fibre_current` to `fibre_pop`.
- **Output**: No return value; the function modifies the global `fd_fibre_current` to point to the new fibre and manages context switching.


---
### fd\_fibre\_set\_clock<!-- {{#callable:fd_fibre_set_clock}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L163>)

Assigns a user-defined clock function to the `fd_fibre_clock` variable.
- **Inputs**:
    - `clock`: A pointer to a function that returns a `long` and takes no arguments, representing the clock function to be set.
- **Logic and Control Flow**:
    - Assign the input `clock` function pointer to the global variable `fd_fibre_clock`.
- **Output**: No output is returned.


---
### fd\_fibre\_yield<!-- {{#callable:fd_fibre_yield}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L170>)

Allows the current fibre to yield control to the scheduler, enabling other fibres to run.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the [`fd_fibre_wait`](<#fd_fibre_wait>) function with a wait time of 0, effectively yielding control immediately.
- **Output**: No output is returned as the function is of type `void`.
- **Functions Called**:
    - [`fd_fibre_wait`](<#fd_fibre_wait>)


---
### fd\_fibre\_wait<!-- {{#callable:fd_fibre_wait}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L177>)

Stops the execution of the current fibre for a specified duration and switches to the fibre scheduler.
- **Inputs**:
    - `wait_ns`: The number of nanoseconds to wait before resuming the current fibre.
- **Logic and Control Flow**:
    - Checks if the fibre scheduler is available; if not, returns immediately.
    - Calculates the wake-up time by adding the current time from `fd_fibre_clock` to `wait_ns`, ensuring a minimum wait of 1 nanosecond.
    - Sets the `sched_time` of the current fibre to the calculated wake-up time.
    - Schedules the current fibre using [`fd_fibre_schedule`](<#fd_fibre_schedule>).
    - Switches execution to the fibre scheduler using [`fd_fibre_swap`](<#fd_fibre_swap>).
- **Output**: No output is returned.
- **Functions Called**:
    - [`fd_fibre_schedule`](<#fd_fibre_schedule>)
    - [`fd_fibre_swap`](<#fd_fibre_swap>)


---
### fd\_fibre\_wait\_until<!-- {{#callable:fd_fibre_wait_until}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L195>)

Stops the execution of the current fibre until a specified time and switches control to the fibre scheduler.
- **Inputs**:
    - `resume_time_ns`: The time in nanoseconds at which the current fibre should resume execution.
- **Logic and Control Flow**:
    - Get the current time using `fd_fibre_clock()` and store it in `now`.
    - If `resume_time_ns` is less than or equal to `now`, set `resume_time_ns` to `now + 1` to ensure another fibre gets a chance to run.
    - Check if `fd_fibre_scheduler` is `NULL`; if so, return immediately as waiting is not possible without a scheduler.
    - Set the `sched_time` of `fd_fibre_current` to `resume_time_ns`.
    - Call `fd_fibre_schedule()` to add the current fibre to the schedule.
    - Switch execution to the fibre scheduler using `fd_fibre_swap(fd_fibre_scheduler)`.
- **Output**: No output is returned as the function is of type `void`.
- **Functions Called**:
    - [`fd_fibre_schedule`](<#fd_fibre_schedule>)
    - [`fd_fibre_swap`](<#fd_fibre_swap>)


---
### fd\_fibre\_wake<!-- {{#callable:fd_fibre_wake}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L215>)

Schedules a fibre for execution if it is not the current fibre.
- **Inputs**:
    - `fibre`: A pointer to the `fd_fibre_t` structure representing the fibre to wake.
- **Logic and Control Flow**:
    - Checks if the `fibre` is the current fibre (`fd_fibre_current`).
    - If `fibre` is the current fibre, the function returns immediately without making changes.
    - If `fibre` is not the current fibre, sets the `sched_time` of the `fibre` to the current time using `fd_fibre_clock()`.
    - Calls [`fd_fibre_schedule`](<#fd_fibre_schedule>) to add the `fibre` to the schedule for execution.
- **Output**: No return value.
- **Functions Called**:
    - [`fd_fibre_schedule`](<#fd_fibre_schedule>)


---
### fd\_fibre\_schedule<!-- {{#callable:fd_fibre_schedule}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L227>)

Schedules a fibre by removing it from the current schedule and re-inserting it based on its wake time.
- **Inputs**:
    - `fibre`: A pointer to the `fd_fibre_t` structure representing the fibre to be scheduled.
- **Logic and Control Flow**:
    - Check if `fd_fibre_clock` is `NULL` and call `fd_fibre_abort()` if true.
    - Initialize `cur_fibre` to point to the start of the schedule queue.
    - Iterate through the schedule queue to remove the specified `fibre` by updating the `next` pointer of the preceding fibre.
    - Break the loop when the sentinel node is reached.
    - Initialize `prior` to point to the start of the schedule queue and set `wake` to the `sched_time` of the `fibre`.
    - Iterate through the schedule queue to find the correct position to insert the `fibre` based on its `sched_time`.
    - Insert the `fibre` into the schedule by updating the `next` pointers of `prior` and `fibre`.
- **Output**: None (void function).


---
### fd\_fibre\_schedule\_run<!-- {{#callable:fd_fibre_schedule_run}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L262>)

Executes the fibre scheduling loop, managing the execution of scheduled fibres based on their scheduled time.
- **Inputs**: None
- **Logic and Control Flow**:
    - Set `fd_fibre_scheduler` to `fd_fibre_current` to mark the current fibre as the scheduler.
    - Enter an infinite loop to process the scheduling queue.
    - Retrieve the next fibre from `fd_fibre_schedule_queue`.
    - If the next fibre is a sentinel, return -1 indicating no fibres are scheduled.
    - Get the current time using `fd_fibre_clock()`.
    - If the next fibre's scheduled time is greater than the current time, return the fibre's scheduled time.
    - Remove the next fibre from the schedule by updating `fd_fibre_schedule_queue->next`.
    - If the fibre is not done, call [`fd_fibre_swap`](<#fd_fibre_swap>) to switch execution to this fibre.
- **Output**: Returns the time of the next ready fibre or -1 if there are no fibres in the schedule.
- **Functions Called**:
    - [`fd_fibre_swap`](<#fd_fibre_swap>)


---
### fd\_fibre\_pipe\_align<!-- {{#callable:fd_fibre_pipe_align}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L289>)

Returns the alignment requirement of the `fd_fibre_pipe_t` type.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the `alignof` operator on the `fd_fibre_pipe_t` type to determine its alignment requirement.
    - Returns the alignment value as an unsigned long integer.
- **Output**: The alignment requirement of the `fd_fibre_pipe_t` type as an unsigned long integer.


---
### fd\_fibre\_pipe\_footprint<!-- {{#callable:fd_fibre_pipe_footprint}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L294>)

Calculates the memory footprint required for a fibre pipe with a specified number of entries.
- **Inputs**:
    - `entries`: The number of entries in the fibre pipe.
- **Logic and Control Flow**:
    - Calculate the total size by adding the size of `fd_fibre_pipe_t` to the product of `entries` and the size of `ulong`.
    - Return the calculated size.
- **Output**: Returns the total memory size in bytes required for the fibre pipe.


---
### fd\_fibre\_pipe\_new<!-- {{#callable:fd_fibre_pipe_new}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L299>)

Initializes a new `fd_fibre_pipe_t` structure in the provided memory with a specified number of entries.
- **Inputs**:
    - `mem`: A pointer to the memory location where the `fd_fibre_pipe_t` structure will be initialized.
    - `entries`: The number of entries the pipe can hold, which determines its capacity.
- **Logic and Control Flow**:
    - Cast the `mem` pointer to a `fd_fibre_pipe_t` pointer and assign it to `pipe`.
    - Calculate the address for the entries array by offsetting from the `pipe` pointer and cast it to a `ulong` pointer.
    - Set the `cap` field of `pipe` to the `entries` value, indicating the capacity of the pipe.
    - Initialize the `head` and `tail` fields of `pipe` to 0, representing the start of the pipe.
    - Set the `reader` and `writer` fields of `pipe` to `NULL`, indicating no current reader or writer.
    - Assign the calculated entries array address to the `entries` field of `pipe`.
    - Return the initialized `pipe` pointer.
- **Output**: Returns a pointer to the newly initialized `fd_fibre_pipe_t` structure.


---
### fd\_fibre\_pipe\_write<!-- {{#callable:fd_fibre_pipe_write}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L315>)

Writes a value to a fibre pipe, waiting for space if necessary, and returns a status indicating success or timeout.
- **Inputs**:
    - `pipe`: A pointer to the `fd_fibre_pipe_t` structure representing the fibre pipe to write to.
    - `value`: The `ulong` value to write into the pipe.
    - `timeout`: The maximum time in nanoseconds to wait for space to become available in the pipe.
- **Logic and Control Flow**:
    - Initialize `prev_writer` to the current writer of the pipe.
    - Calculate `timeout_ts` as the current time plus the `timeout` value.
    - Enter a loop to check for available space in the pipe.
    - Calculate `used` as the difference between `head` and `tail` of the pipe, and `free` as the capacity minus `used`.
    - If there is free space, exit the loop.
    - If no free space, set the current fibre as the writer and check if the timeout has been reached.
    - If timed out, restore the previous writer and return 1 to indicate a timeout.
    - If not timed out, set the current fibre's `sched_time` to `timeout_ts`, schedule it, and switch to the scheduler.
    - Once free space is available, store the `value` in the pipe at the position `head % cap`.
    - Increment the `head` of the pipe.
    - If there is a waiting reader, schedule the current fibre and switch to the reader.
    - Restore the previous writer.
    - Return 0 to indicate a successful write.
- **Output**: Returns 0 if the write is successful, or 1 if the operation times out.
- **Functions Called**:
    - [`fd_fibre_schedule`](<#fd_fibre_schedule>)
    - [`fd_fibre_swap`](<#fd_fibre_swap>)


---
### fd\_fibre\_pipe\_read<!-- {{#callable:fd_fibre_pipe_read}} -->
[View Source →](<../../../../../src/util/fibre/fd_fibre.c#L382>)

Reads a value from a fibre pipe with a timeout mechanism.
- **Inputs**:
    - `pipe`: A pointer to the `fd_fibre_pipe_t` structure representing the fibre pipe from which to read.
    - `value`: A pointer to an `ulong` where the read value will be stored.
    - `timeout`: A `long` representing the timeout duration in the same units as the fibre clock.
- **Logic and Control Flow**:
    - Store the current reader of the pipe in `prev_reader`.
    - Calculate the timeout timestamp by adding `timeout` to the current fibre clock time.
    - Enter a loop to wait for data to be available or until the timeout occurs.
    - Calculate the number of used entries in the pipe by subtracting `tail` from `head`.
    - If data is available (`used` is non-zero), exit the loop.
    - If no data is available, set the current fibre as the reader and check if the timeout has occurred.
    - If the timeout has occurred, restore the previous reader and return 1 to indicate a timeout.
    - If not timed out, set the current fibre's schedule time, schedule it, and swap to the scheduler.
    - Once data is available, retrieve the value from the pipe's entries using the `tail` index and store it in `value`.
    - Increment the `tail` index to mark the entry as read.
    - If there is a waiting writer, schedule the current fibre and swap to the writer.
    - Restore the previous reader and return 0 to indicate success.
- **Output**: Returns 0 on successful read, or 1 if a timeout occurs.
- **Functions Called**:
    - [`fd_fibre_schedule`](<#fd_fibre_schedule>)
    - [`fd_fibre_swap`](<#fd_fibre_swap>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)