<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Documentation for racesan, a fuzzer for testing shared memory concurrent algorithms in Firedancer.

# Purpose
The `racesan` tool is a fuzzer designed to test shared memory concurrent algorithms, specifically for the Firedancer database components on x86 architecture. It provides two primary modes of testing: fault injection and interleaving. Fault injection involves modifying the target algorithm during execution to test its logic, while interleaving races different algorithms against each other to identify potential logic errors. `racesan` requires code modifications to the target algorithms and works with low-level concurrency primitives, but it does not detect true hardware data races. Instead, it focuses on identifying logic errors in single-threaded, deterministic environments. Developers can use `racesan` to insert hooks into critical sections of their algorithms, allowing them to simulate and test for potential data races and concurrency issues.
# Content Summary
The provided content describes the functionality and usage of a tool named "racesan," which is a fuzzer designed to test shared memory concurrent algorithms, specifically for the Firedancer database components on x86 architecture. Racesan operates in two primary modes: fault injection and interleaving. 

1. **Fault Injection**: This mode allows developers to inject modifications into a running target algorithm to test its logic. It uses hooks inserted at critical sections of the code to simulate potential data races. The tool ensures that logic in fault injection routines runs atomically, even though it may appear racy.

2. **Interleaving**: This mode races different algorithms against each other to test for data races. It is used to model more complex scenarios that cannot be effectively tested with fault injection alone.

Racesan requires modifications to the target code and works with low-level concurrency primitives. It is single-threaded and deterministic, focusing on detecting logic errors rather than true hardware data races. Developers must insert hooks in their algorithms to use racesan effectively. The tool uses userland context switching and macros to create interleavings and manage test code execution.

The document provides examples of how to use racesan for both fault injection and interleaving. It includes code snippets demonstrating how to insert hooks and write tests for concurrent algorithms, such as a compare-and-swap based adder. The examples illustrate how to inject faults and test interleavings to ensure the correctness of concurrent logic.

---
Made with ❤️ by [Driver](https://www.driver.ai/)