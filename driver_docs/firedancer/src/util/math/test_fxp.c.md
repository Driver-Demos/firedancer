<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for fixed-point arithmetic operations using 128-bit integers, including addition, subtraction, multiplication, division, and square root.

# Purpose
The code is a C program designed to test fixed-point arithmetic operations using 128-bit integers. It includes functions for addition, subtraction, multiplication, and division with various rounding modes, as well as functions for computing logarithms and exponentials in base 2. The program uses a random number generator to create test cases with specific bit patterns to stress-test the arithmetic operations. The main function runs a series of tests to compare the results of reference implementations with optimized versions, logging any discrepancies. The program also calculates the unit in the last place (ULP) for logarithm and exponential approximations to assess their precision.

The code is structured to conditionally compile based on the availability of 128-bit integer support (`FD_HAS_INT128`). If this support is not available, the program logs a warning and exits. The program includes both single and double precision floating-point operations, depending on the `FD_HAS_DOUBLE` flag. The main function initializes the random number generator, performs the tests, and logs the results. It is designed to be executed as a standalone program, as indicated by the presence of the [`main`](<#main>) function.
# Imports and Dependencies

---
- `../fd_util.h`
- `fd_fxp.h`
- `math.h`


# Functions

---
### make\_rand\_fxp<!-- {{#callable:make_rand_fxp}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L11>)

Generates a random fixed-point number by manipulating a 64-bit input based on control bits.
- **Inputs**:
    - `x`: A 64-bit unsigned long integer that serves as the base for generating the random fixed-point number.
    - `_ctl`: A pointer to a 32-bit unsigned integer that contains control bits used to determine the operations on 'x'.
- **Logic and Control Flow**:
    - Retrieve the control bits from the location pointed to by '_ctl'.
    - Extract the shift amount 's' from the least significant 6 bits of 'ctl' and shift 'ctl' right by 6 bits.
    - Extract the direction 'd' from the least significant bit of 'ctl' and shift 'ctl' right by 1 bit.
    - Extract the invert flag 'i' from the least significant bit of 'ctl' and shift 'ctl' right by 1 bit.
    - Update the value pointed to by '_ctl' with the modified 'ctl'.
    - Shift 'x' left by 's' bits if 'd' is 1, otherwise shift 'x' right by 's' bits.
    - Invert 'x' if 'i' is 1, otherwise leave 'x' unchanged.
- **Output**: Returns the manipulated 64-bit unsigned long integer 'x' as a random fixed-point number.


---
### split\_hi<!-- {{#callable:split_hi}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L23>)

Extracts the high 64 bits from a 128-bit unsigned integer.
- **Inputs**:
    - `x`: A 128-bit unsigned integer (`uint128`).
- **Logic and Control Flow**:
    - Shift the input `x` right by 64 bits.
    - Cast the result to a 64-bit unsigned long integer (`ulong`).
- **Output**: Returns the high 64 bits of the input `x` as a 64-bit unsigned long integer (`ulong`).


---
### split\_lo<!-- {{#callable:split_lo}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L24>)

Extracts the lower 64 bits from a 128-bit unsigned integer.
- **Inputs**:
    - `x`: A 128-bit unsigned integer (`uint128`).
- **Logic and Control Flow**:
    - Casts the 128-bit unsigned integer `x` to a 64-bit unsigned integer (`ulong`).
- **Output**: Returns the lower 64 bits of the input as a 64-bit unsigned integer (`ulong`).


---
### fd\_fxp\_add\_ref<!-- {{#callable:fd_fxp_add_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L26>)

Performs addition of two 64-bit unsigned integers and returns the lower 64 bits of the result while storing the upper 64 bits in a provided pointer.
- **Inputs**:
    - `x`: A 64-bit unsigned integer to add.
    - `y`: Another 64-bit unsigned integer to add.
    - `_c`: A pointer to a 64-bit unsigned integer where the upper 64 bits of the result will be stored.
- **Logic and Control Flow**:
    - Casts `x` and `y` to 128-bit unsigned integers and adds them, storing the result in `z`.
    - Calls [`split_hi`](<#split_hi>) with `z` to extract the upper 64 bits and stores it in the location pointed to by `_c`.
    - Calls [`split_lo`](<#split_lo>) with `z` to extract and return the lower 64 bits of the result.
- **Output**: Returns the lower 64 bits of the 128-bit addition result.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_sub\_ref<!-- {{#callable:fd_fxp_sub_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L35>)

Performs subtraction of two unsigned long integers with borrow handling.
- **Inputs**:
    - `x`: The minuend, an unsigned long integer.
    - `y`: The subtrahend, an unsigned long integer.
    - `_b`: A pointer to an unsigned long integer where the borrow flag will be stored.
- **Logic and Control Flow**:
    - Calculate the borrow flag `b` by checking if `x` is less than `y` and cast the result to an unsigned long integer.
    - Compute the result `z` as a 128-bit integer by left-shifting `b` by 64 bits, adding `x`, and subtracting `y`.
    - Store the borrow flag `b` in the location pointed to by `_b`.
    - Return the lower 64 bits of `z` using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the lower 64 bits of the result of the subtraction as an unsigned long integer.
- **Functions Called**:
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_mul\_rtz\_ref<!-- {{#callable:fd_fxp_mul_rtz_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L45>)

Performs fixed-point multiplication of two unsigned long integers with right truncation of the result.
- **Inputs**:
    - `x`: The first unsigned long integer operand for multiplication.
    - `y`: The second unsigned long integer operand for multiplication.
    - `_c`: A pointer to an unsigned long where the high part of the result will be stored.
- **Logic and Control Flow**:
    - Convert `x` and `y` to 128-bit integers and multiply them to get a 128-bit result `z`.
    - Right shift `z` by 30 bits to perform right truncation.
    - Store the high 64 bits of `z` in the location pointed to by `_c` using the [`split_hi`](<#split_hi>) function.
    - Return the low 64 bits of `z` using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the low 64 bits of the truncated 128-bit multiplication result.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_mul\_raz\_ref<!-- {{#callable:fd_fxp_mul_raz_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L55>)

Performs fixed-point multiplication of two unsigned long integers with rounding towards zero and returns the lower 64 bits of the result, while storing the upper 64 bits in a provided pointer.
- **Inputs**:
    - `x`: The first unsigned long integer operand for multiplication.
    - `y`: The second unsigned long integer operand for multiplication.
    - `_c`: A pointer to an unsigned long where the upper 64 bits of the result will be stored.
- **Logic and Control Flow**:
    - Casts `x` and `y` to `uint128` and multiplies them.
    - Adds `((1UL<<30)-1UL)` to the product to implement rounding towards zero.
    - Shifts the result right by 30 bits to adjust for fixed-point representation.
    - Stores the upper 64 bits of the result in the location pointed to by `_c` using the [`split_hi`](<#split_hi>) function.
    - Returns the lower 64 bits of the result using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the lower 64 bits of the fixed-point multiplication result as an unsigned long integer.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_mul\_rnz\_ref<!-- {{#callable:fd_fxp_mul_rnz_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L64>)

Performs fixed-point multiplication of two unsigned long integers with rounding towards nearest zero and returns the lower 64 bits of the result.
- **Inputs**:
    - `x`: An unsigned long integer representing the first operand.
    - `y`: An unsigned long integer representing the second operand.
    - `_c`: A pointer to an unsigned long integer where the function will store the higher 64 bits of the result.
- **Logic and Control Flow**:
    - Casts `x` and `y` to `uint128` and multiplies them.
    - Adds `(1UL<<29)-1UL` to the product to implement rounding towards nearest zero.
    - Shifts the result right by 30 bits to adjust for fixed-point representation.
    - Stores the higher 64 bits of the result in the location pointed to by `_c` using the [`split_hi`](<#split_hi>) function.
    - Returns the lower 64 bits of the result using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the lower 64 bits of the fixed-point multiplication result.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_mul\_rna\_ref<!-- {{#callable:fd_fxp_mul_rna_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L73>)

Performs fixed-point multiplication of two unsigned long integers with rounding to nearest and assigns the high part of the result to a pointer.
- **Inputs**:
    - `x`: An unsigned long integer representing the first operand.
    - `y`: An unsigned long integer representing the second operand.
    - `_c`: A pointer to an unsigned long integer where the high part of the result will be stored.
- **Logic and Control Flow**:
    - Casts `x` and `y` to `uint128` and multiplies them.
    - Adds `1UL<<29` to the product to facilitate rounding to the nearest.
    - Shifts the result right by 30 bits to adjust the fixed-point position.
    - Stores the high 64 bits of the result in the location pointed to by `_c` using [`split_hi`](<#split_hi>).
    - Returns the low 64 bits of the result using [`split_lo`](<#split_lo>).
- **Output**: Returns the low 64 bits of the fixed-point multiplication result.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_mul\_rne\_ref<!-- {{#callable:fd_fxp_mul_rne_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L82>)

Performs fixed-point multiplication of two unsigned long integers with rounding to nearest even and returns the lower 64 bits of the result, while storing the upper 64 bits in a provided pointer.
- **Inputs**:
    - `x`: The first unsigned long integer operand for multiplication.
    - `y`: The second unsigned long integer operand for multiplication.
    - `_c`: A pointer to an unsigned long where the upper 64 bits of the result will be stored.
- **Logic and Control Flow**:
    - Multiply `x` and `y` as 128-bit integers and store the result in `z`.
    - Extract the lower 30 bits of `z` into `f`.
    - Right shift `z` by 30 bits to prepare for rounding.
    - If `f` is greater than 2^29 or `f` equals 2^29 and the least significant bit of `z` is 1, increment `z` by 1 to round to the nearest even.
    - Store the upper 64 bits of `z` in the location pointed to by `_c`.
    - Return the lower 64 bits of `z`.
- **Output**: Returns the lower 64 bits of the 128-bit multiplication result after rounding.
- **Functions Called**:
    - [`split_lo`](<#split_lo>)
    - [`split_hi`](<#split_hi>)


---
### fd\_fxp\_mul\_rno\_ref<!-- {{#callable:fd_fxp_mul_rno_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L94>)

Performs fixed-point multiplication of two unsigned long integers with rounding to nearest odd and returns the lower 64 bits of the result, while storing the upper 64 bits in a provided pointer.
- **Inputs**:
    - `x`: An unsigned long integer representing the first operand for multiplication.
    - `y`: An unsigned long integer representing the second operand for multiplication.
    - `_c`: A pointer to an unsigned long integer where the upper 64 bits of the result will be stored.
- **Logic and Control Flow**:
    - Multiply `x` and `y` as 128-bit integers and store the result in `z`.
    - Extract the lower 64 bits of `z` and mask it with `((1UL<<30)-1UL)` to get `f`.
    - Right shift `z` by 30 bits.
    - If `f` is greater than `(1UL<<29)` or `f` equals `(1UL<<29)` and the least significant bit of `z` is 0, increment `z`.
    - Store the upper 64 bits of `z` in the location pointed to by `_c`.
    - Return the lower 64 bits of `z`.
- **Output**: Returns the lower 64 bits of the 128-bit multiplication result after rounding.
- **Functions Called**:
    - [`split_lo`](<#split_lo>)
    - [`split_hi`](<#split_hi>)


---
### fd\_fxp\_div\_rtz\_ref<!-- {{#callable:fd_fxp_div_rtz_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L106>)

Performs fixed-point division of `x` by `_y` with rounding towards zero and stores the high part of the result in `_c`.
- **Inputs**:
    - `x`: The dividend, a 64-bit unsigned long integer.
    - `_y`: The divisor, a 64-bit unsigned long integer.
    - `_c`: A pointer to a 64-bit unsigned long integer where the high part of the division result will be stored.
- **Logic and Control Flow**:
    - Check if `_y` is zero; if true, set `*_c` to `ULONG_MAX` and return 0.
    - Shift `x` left by 30 bits to create a 128-bit extended dividend `ex`.
    - Convert `_y` to a 128-bit integer `y`.
    - Perform division of `ex` by `y` to get a 128-bit result `z`.
    - Store the high 64 bits of `z` in `*_c` using [`split_hi`](<#split_hi>).
    - Return the low 64 bits of `z` using [`split_lo`](<#split_lo>).
- **Output**: Returns the low 64 bits of the division result as a 64-bit unsigned long integer.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_div\_raz\_ref<!-- {{#callable:fd_fxp_div_raz_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L118>)

Performs fixed-point division with rounding away from zero and handles division by zero by setting a carry flag.
- **Inputs**:
    - `x`: The dividend, a 64-bit unsigned long integer.
    - `_y`: The divisor, a 64-bit unsigned long integer.
    - `_c`: A pointer to a 64-bit unsigned long integer where the carry or overflow result will be stored.
- **Logic and Control Flow**:
    - Check if the divisor `_y` is zero; if true, set `*_c` to `ULONG_MAX` and return 0.
    - Shift the dividend `x` left by 30 bits to create a 128-bit extended dividend `ex`.
    - Convert the divisor `_y` to a 128-bit integer `y`.
    - Calculate the quotient `z` by dividing `ex + y - 1` by `y`, which implements rounding away from zero.
    - Store the high 64 bits of `z` in `*_c` using the [`split_hi`](<#split_hi>) function.
    - Return the low 64 bits of `z` using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the low 64 bits of the division result as a 64-bit unsigned long integer.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_div\_rnz\_ref<!-- {{#callable:fd_fxp_div_rnz_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L130>)

Performs division of two unsigned long integers with rounding towards the nearest zero and returns the quotient and the high part of the result.
- **Inputs**:
    - `x`: The dividend, an unsigned long integer.
    - `_y`: The divisor, an unsigned long integer.
    - `_c`: A pointer to an unsigned long where the high part of the result will be stored.
- **Logic and Control Flow**:
    - Check if the divisor `_y` is zero; if true, set `*_c` to `ULONG_MAX` and return 0.
    - Shift the dividend `x` left by 30 bits to form `ex`.
    - Convert the divisor `_y` to a 128-bit integer `y`.
    - Calculate the quotient `z` by dividing `ex + ((y - 1) >> 1)` by `y`.
    - Store the high part of `z` in `*_c` using the [`split_hi`](<#split_hi>) function.
    - Return the low part of `z` using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the low part of the quotient as an unsigned long integer.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_div\_rna\_ref<!-- {{#callable:fd_fxp_div_rna_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L142>)

Performs fixed-point division with rounding to the nearest even integer.
- **Inputs**:
    - `x`: The dividend, a 64-bit unsigned long integer.
    - `_y`: The divisor, a 64-bit unsigned long integer.
    - `_c`: A pointer to a 64-bit unsigned long integer where the function stores the high 64 bits of the result.
- **Logic and Control Flow**:
    - Checks if the divisor `_y` is zero; if true, sets `*_c` to `ULONG_MAX` and returns 0.
    - Converts `x` to a 128-bit integer and left shifts it by 30 bits to form `ex`.
    - Converts `_y` to a 128-bit integer `y`.
    - Calculates `z` as the result of dividing `ex + (y >> 1)` by `y`, effectively performing rounding to the nearest even integer.
    - Stores the high 64 bits of `z` in `*_c` using the [`split_hi`](<#split_hi>) function.
    - Returns the low 64 bits of `z` using the [`split_lo`](<#split_lo>) function.
- **Output**: Returns the low 64 bits of the division result as a 64-bit unsigned long integer.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_div\_rne\_ref<!-- {{#callable:fd_fxp_div_rne_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L154>)

Performs fixed-point division with rounding to nearest even, handling division by zero and returning the quotient and carry.
- **Inputs**:
    - `x`: The dividend, a 64-bit unsigned long integer.
    - `_y`: The divisor, a 64-bit unsigned long integer.
    - `_c`: A pointer to a 64-bit unsigned long integer where the carry (high part of the result) will be stored.
- **Logic and Control Flow**:
    - Check if `_y` is zero; if true, set `*_c` to `ULONG_MAX` and return 0.
    - Shift `x` left by 30 bits to form `ex`.
    - Convert `_y` to a 128-bit integer `y`.
    - Divide `ex` by `y` to get the quotient `z`.
    - Calculate the remainder `r2` by subtracting `z*y` from `ex` and shifting left by 1.
    - If `r2` is greater than `y` or `r2` equals `y` and `z` is odd, increment `z`.
    - Store the high 64 bits of `z` in `*_c`.
- **Output**: Returns the low 64 bits of the quotient `z`.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### fd\_fxp\_div\_rno\_ref<!-- {{#callable:fd_fxp_div_rno_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L168>)

Performs fixed-point division with rounding towards nearest odd.
- **Inputs**:
    - `x`: The dividend, a 64-bit unsigned long integer.
    - `_y`: The divisor, a 64-bit unsigned long integer.
    - `_c`: A pointer to a 64-bit unsigned long integer where the function stores the high 64 bits of the result.
- **Logic and Control Flow**:
    - Check if the divisor `_y` is zero; if so, set `*_c` to `ULONG_MAX` and return `0UL`.
    - Shift the dividend `x` left by 30 bits to form `ex`.
    - Convert the divisor `_y` to a 128-bit integer `y`.
    - Perform division of `ex` by `y` to get the quotient `z`.
    - Calculate the remainder `r2` by subtracting `z*y` from `ex` and then shifting left by 1.
    - If `r2` is greater than `y` or `r2` equals `y` and `z` is even, increment `z`.
    - Store the high 64 bits of `z` in `*_c`.
    - Return the low 64 bits of `z`.
- **Output**: Returns the low 64 bits of the quotient as a 64-bit unsigned long integer.
- **Functions Called**:
    - [`split_hi`](<#split_hi>)
    - [`split_lo`](<#split_lo>)


---
### test\_fd\_fxp\_sqrt\_rtz<!-- {{#callable:test_fd_fxp_sqrt_rtz}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L182>)

Checks if the square of `y` is greater than `x` shifted left by 30 bits, or if the difference between `x` shifted left by 30 bits and the square of `y` is greater than twice `y`.
- **Inputs**:
    - `x`: An unsigned long integer representing the value to compare against the square of `y`.
    - `y`: An unsigned long integer representing the value whose square is compared to `x`.
- **Logic and Control Flow**:
    - If `x` is zero, return 1 if `y` is non-zero, otherwise return 0.
    - Check if `y` is within the range [2^15, 2^(32+15)]. If not, return 1.
    - Calculate `xw` as `x` shifted left by 30 bits.
    - Calculate `ysq` as the square of `y`.
    - Return true if `ysq` is greater than `xw` or if the difference between `xw` and `ysq` is greater than twice `y`.
- **Output**: Returns an integer indicating whether the conditions on `x` and `y` are met.


---
### test\_fd\_fxp\_sqrt\_raz<!-- {{#callable:test_fd_fxp_sqrt_raz}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L192>)

Evaluates whether a fixed-point square root approximation is valid based on given conditions.
- **Inputs**:
    - `x`: An unsigned long integer representing the value to be checked.
    - `y`: An unsigned long integer representing the square root approximation to be validated.
- **Logic and Control Flow**:
    - Check if `x` is zero; if true, return the boolean value of `y` (1 if `y` is non-zero, 0 otherwise).
    - Verify if `y` is within the range [2^15, 2^(32+15)]; if not, return 1 indicating an invalid approximation.
    - Calculate `xw` as `x` shifted left by 30 bits, and `ysq` as `y` squared.
    - Return true if `xw` is greater than `ysq` or if the difference `ysq - xw` is greater than `2*y - 2`.
- **Output**: Returns an integer (0 or 1) indicating whether the square root approximation is valid (0) or invalid (1).


---
### test\_fd\_fxp\_sqrt\_rnz<!-- {{#callable:test_fd_fxp_sqrt_rnz}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L202>)

Evaluates whether a given `y` is a valid fixed-point square root of `x` with rounding towards nearest zero.
- **Inputs**:
    - `x`: An unsigned long integer representing the number for which the square root is being tested.
    - `y`: An unsigned long integer representing the candidate square root of `x`.
- **Logic and Control Flow**:
    - If `x` is zero, return true if `y` is non-zero, otherwise return false.
    - Check if `y` is within the range [2^15, 2^(32+15)]. If not, return 1 (false).
    - Calculate `xw` as `x` shifted left by 30 bits.
    - Calculate `ysq` as `y*y - y + 1`.
    - Return true if `ysq` is greater than `xw` or if `xw - ysq` is greater than or equal to `y` shifted left by 1 bit.
- **Output**: Returns an integer indicating whether `y` is a valid fixed-point square root of `x` with rounding towards nearest zero.


---
### fd\_fxp\_log2\_ref<!-- {{#callable:fd_fxp_log2_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L241>)

Calculates the base-2 logarithm of an unsigned long integer and adjusts the exponent accordingly.
- **Inputs**:
    - `x`: An unsigned long integer for which the base-2 logarithm is calculated.
    - `_e`: A pointer to an integer where the function stores the adjusted exponent.
- **Logic and Control Flow**:
    - Check if `x` is zero; if true, set `*_e` to `INT_MIN` and return 0.
    - Calculate the base-2 logarithm of `x` using `log2` and store it in `ef`.
    - Find the most significant bit of `x` using `fd_ulong_find_msb` and store it in `e`.
    - Adjust the exponent by subtracting 30 from `e` and store the result in `*_e`.
    - Calculate the fixed-point representation of the fractional part of the logarithm and return it as an unsigned long integer.
- **Output**: Returns the fixed-point representation of the fractional part of the base-2 logarithm of `x` as an unsigned long integer.


---
### fd\_fxp\_exp2\_ref<!-- {{#callable:fd_fxp_exp2_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L251>)

Calculates the exponential base 2 of a fixed-point number `x` and returns the result as an unsigned long integer.
- **Inputs**:
    - `x`: An unsigned long integer representing a fixed-point number.
- **Logic and Control Flow**:
    - Checks if `x` is greater than or equal to `0x880000000UL`; if true, returns `ULONG_MAX`.
    - Converts `x` to a double and scales it by `1./(double)(1UL<<30)`.
    - Calculates the exponential base 2 of the scaled value using `exp2`.
    - Multiplies the result by `(double)(1UL<<30)` and rounds it to the nearest unsigned long integer.
- **Output**: Returns the exponential base 2 of `x` as an unsigned long integer, or `ULONG_MAX` if `x` is too large.


---
### fd\_fxp\_rexp2\_ref<!-- {{#callable:fd_fxp_rexp2_ref}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L257>)

Calculates the reciprocal of the exponential function `exp2` for a fixed-point input `x`.
- **Inputs**:
    - `x`: A 64-bit unsigned long integer representing a fixed-point number.
- **Logic and Control Flow**:
    - Casts `x` to a double and multiplies it by -1 divided by 2^30.
    - Calculates `exp2` of the resulting value.
    - Multiplies the result by 2^30.
    - Rounds the final result to the nearest unsigned long integer.
- **Output**: Returns the rounded result as a 64-bit unsigned long integer.


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/util/math/test_fxp.c#L401>)

Initializes the environment and logs a warning if the `FD_HAS_INT128` capability is not available, then halts execution.
- **Inputs**:
    - `argc`: The count of command-line arguments.
    - `argv`: The array of command-line arguments.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with `argc` and `argv`.
    - Logs a warning message indicating that the unit test requires `FD_HAS_INT128` capability.
    - Calls `fd_halt` to stop the program execution.
- **Output**: Returns 0, indicating successful execution.



---
Made with ❤️ by [Driver](https://www.driver.ai/)