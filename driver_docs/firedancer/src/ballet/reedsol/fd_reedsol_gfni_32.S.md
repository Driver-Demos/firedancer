<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Assembly implementation of an FFT-like algorithm for computing Reed-Solomon parity using Intel GFNI instructions.

# Purpose
The provided assembly code implements a fast algorithm for computing Reed-Solomon parity using an FFT-like approach. This code is specifically designed to handle 32 data shreds and generate 32 parity shreds, optimizing the process through the use of Intel's GFNI (Galois Field New Instructions) for efficient vector operations. The core of the computation is based on a "butterfly" operation, a common pattern in FFT algorithms, which is adapted here to work with Galois fields. The algorithm involves two main steps: first, an inverse FFT (IFFT) is performed on the data shreds to interpolate the data into a polynomial form, and second, a forward FFT with a shift is applied to evaluate the polynomial at specific points, resulting in the required parity shreds.

The code is highly optimized for performance, leveraging SIMD (Single Instruction, Multiple Data) instructions to process multiple data points simultaneously. It uses a combination of scalar and vector registers to manage data efficiently, with specific registers dedicated to storing data shreds and temporary computation results. The use of pre-encoded constants in a lookup table further enhances the speed of the GFNI operations, which are crucial for the vector scaling required in the butterfly operations. The algorithm's design allows it to be significantly faster than equivalent C implementations, making it suitable for high-performance applications where data integrity and error correction are critical.

Overall, this assembly file is a specialized component of a larger system that deals with data encoding and error correction. Its primary purpose is to provide a highly efficient method for generating parity data, which is essential for reconstructing lost or corrupted data in storage and transmission systems. The use of advanced instruction sets and careful register management highlights the code's focus on maximizing computational throughput and minimizing latency, making it a valuable tool in environments where data reliability and speed are paramount.
# Subroutines

---
### fd\_reedsol\_private\_encode\_32\_32
The `fd_reedsol_private_encode_32_32` function computes Reed-Solomon parity shreds using an FFT-like algorithm optimized for performance with Intel's GFNI instructions.
- **Inputs**:
    - `shred_sz`: The size of each data shred, provided in the RDI register.
    - `data_shred`: A pointer to an array of pointers to the data shreds, provided in the RSI register.
    - `parity_shred`: A pointer to an array of pointers where the computed parity shreds will be stored, provided in the RDX register.
    - `_scratch`: A pointer to scratch memory used during computation, provided in the RCX register.
- **Logic and Control Flow**:
    - The function begins by saving the state of registers that will be modified.
    - It loads initial data from `data_shred` into scalar registers to minimize memory access during computation.
    - The main computation is performed in a loop, where data is processed in 32-byte chunks using a series of butterfly operations, which are FFT-like operations optimized for GFNI instructions.
    - The butterfly operations are used to perform an inverse FFT (IFFT) followed by an FFT with a shift, to compute the parity shreds.
    - The results of these operations are stored in the `parity_shred` array.
    - The loop iterates over the data shreds, advancing the position by 32 bytes each time, until all data is processed.
    - The function concludes by restoring the state of the modified registers and returning.
- **Output**: The function outputs the computed parity shreds, stored in the memory locations pointed to by `parity_shred`.


# Macros

---
### load\_inputs
The `load_inputs` macro loads a vector's worth of data from a specified data shred into a YMM register for further processing.
- **Inputs**:
    - `reg`: The register number (8-31) that specifies which data shred to load into the corresponding YMM register.
- **Logic and Control Flow**:
    - The macro calculates the address of the data shred by multiplying the register number by 8 and adding it to the base address stored in %rsi.
    - It then moves this calculated address into the %rbx register.
    - Finally, it uses the `vmovdqu64` instruction to load a 64-byte vector from the calculated address into the YMM register corresponding to the specified register number.
- **Output**: The macro outputs a 64-byte vector loaded into the specified YMM register from the data shred.


---
### ifft\_butterfly
The `ifft_butterfly` macro performs an inverse FFT butterfly operation on two registers using a constant scalar and a scratch register for temporary storage.
- **Inputs**:
    - `reg0`: The first YMM register to be modified in place.
    - `reg1`: The second YMM register to be modified in place.
    - `const`: A constant scalar used in the butterfly operation, which is an index into a pre-encoded constants table.
    - `scratch_reg`: A scratch YMM register used for temporary storage during the operation.
- **Logic and Control Flow**:
    - The macro first XORs the contents of `reg0` and `reg1`, storing the result in `reg1`.
    - It then performs a GF(2^8) affine transformation on `reg1` using the constant scalar to index into a pre-encoded constants table, storing the result in `scratch_reg`.
    - Finally, it XORs the contents of `reg0` and `scratch_reg`, storing the result back in `reg0`.
- **Output**: The macro modifies `reg0` and `reg1` in place, with `reg0` containing the result of the butterfly operation and `reg1` being used as an intermediate step.


---
### ifft\_butterfly\_c0
The `ifft_butterfly_c0` macro performs an in-place butterfly operation on two YMM registers using XOR without any constant multiplication, utilizing a scratch register for temporary storage.
- **Inputs**:
    - `reg0`: The first YMM register to be used in the butterfly operation.
    - `reg1`: The second YMM register to be used in the butterfly operation.
    - `scratch_reg`: A YMM register used as a temporary scratch space during the operation.
- **Logic and Control Flow**:
    - The macro begins by XORing the contents of `reg0` and `reg1`, storing the result back in `reg1`.
    - No constant multiplication is performed, as indicated by the `_c0` suffix, which implies a constant of zero.
    - The operation modifies `reg0` and `reg1` in place, using `scratch_reg` for temporary storage if needed.
- **Output**: The output is the modified values of `reg0` and `reg1` after the XOR operation, with `reg1` containing the XOR result of the original `reg0` and `reg1`.


---
### fft\_butterfly
The `fft_butterfly` macro performs a butterfly operation on two registers using a constant scalar and a scratch register, modifying the registers in place.
- **Inputs**:
    - `reg0`: The first register involved in the butterfly operation.
    - `reg1`: The second register involved in the butterfly operation.
    - `const`: A constant scalar used in the butterfly operation, which is an index into a pre-encoded constants table.
    - `scratch_reg`: A scratch register used for intermediate calculations during the butterfly operation.
- **Logic and Control Flow**:
    - The macro uses the `vgf2p8affineqb` instruction to perform a GF(2^8) affine transformation on `reg1` using the constant scalar, storing the result in `scratch_reg`.
    - It then performs an XOR operation between `reg0` and `scratch_reg`, storing the result back in `reg0`.
    - Finally, it performs an XOR operation between `reg1` and the modified `reg0`, storing the result back in `reg1`.
- **Output**: The macro modifies `reg0` and `reg1` in place, with `reg0` containing the result of the XOR operation with the affine transformation, and `reg1` containing the result of the XOR operation with the modified `reg0`.


---
### fft\_butterfly\_c0
The `fft_butterfly_c0` macro performs an XOR operation between two YMM registers, modifying the second register in place, as part of a Fast Fourier Transform (FFT) butterfly operation without using a constant scalar.
- **Inputs**:
    - `reg0`: The first YMM register involved in the XOR operation.
    - `reg1`: The second YMM register involved in the XOR operation, which is modified in place.
    - `scratch_reg`: A scratch YMM register that is clobbered during the operation.
- **Logic and Control Flow**:
    - The macro takes three arguments: `reg0`, `reg1`, and `scratch_reg`.
    - It performs an XOR operation between the contents of `reg0` and `reg1`, storing the result back in `reg1`.
    - The `scratch_reg` is specified but not used in this macro, indicating it is clobbered but not actively involved in the operation.
- **Output**: The output is the modified `reg1` register, which contains the result of the XOR operation between the original `reg0` and `reg1` values.


---
### spill\_reload
The `spill_reload` macro is used to temporarily store the contents of a YMM register into scratch memory and reload another YMM register from scratch memory.
- **Inputs**:
    - `spill`: The index of the YMM register whose contents are to be spilled (stored) into scratch memory.
    - `reload`: The index of the YMM register that is to be reloaded from scratch memory.
- **Logic and Control Flow**:
    - The macro uses `vmovdqa64` to move the contents of the YMM register specified by `spill` into a memory location in the scratch space, calculated as `32*(spill)` offset from the base address in `rcx`.
    - It then uses `vmovdqa64` to load the contents from the memory location in the scratch space, calculated as `32*(reload)` offset from the base address in `rcx`, into the YMM register specified by `reload`.
- **Output**: The macro does not produce a direct output but modifies the state of the YMM registers by spilling one register's contents to memory and reloading another register from memory.


---
### parity\_store
The `parity_store` macro stores the generated parity data from a YMM register into a specified location in the parity shreds array, indexed by the current shred position.
- **Inputs**:
    - `reg`: The index of the YMM register containing the parity data to be stored.
- **Logic and Control Flow**:
    - The macro calculates the address in the parity shreds array by multiplying the register index by 8 and adding it to the base address in the RDX register.
    - It then uses the VMOVDQU64 instruction to store the contents of the specified YMM register into the calculated address, offset by the current shred position in RAX.
- **Output**: The macro outputs the parity data from the specified YMM register into the appropriate location in the parity shreds array.



---
Made with ❤️ by [Driver](https://www.driver.ai/)