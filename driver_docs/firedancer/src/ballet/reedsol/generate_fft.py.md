<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Generates C header and implementation files for FFT and IFFT operations on Reed-Solomon erasure codes.

# Purpose
The code is a Python script that generates a C header file and associated C source files for implementing a Fast Fourier Transform (FFT) and its inverse (IFFT) for Reed-Solomon erasure codes. The script uses the Galois field arithmetic provided by the `galois` library to define polynomial transformations between two bases: the "evaluation basis" and the "coefficient basis." The FFT and IFFT operations are defined in terms of these bases, allowing for efficient encoding and decoding of Reed-Solomon codes.

The script generates macros and functions for different sizes of transforms, specifically powers of two from 4 to 256. It defines macros `FD_REEDSOL_GENERATE_FFT` and `FD_REEDSOL_GENERATE_IFFT` to perform the transformations, and it outputs C source files for larger transform sizes to optimize compile times. The generated C code includes definitions for the FFT and IFFT operations, which are vectorized to handle multiple data points simultaneously. The script also includes utility functions for bit reversal and macro printing, which are used to construct the necessary C code for the transformations.
# Imports and Dependencies

---
- `galois`
- `numpy`
- `numpy.linalg`


# Global Variables

---
### header
- **Type**: ``str``
- **Description**: The `header` variable is a string that contains the content of a C header file. This header file is auto-generated and defines macros and function declarations related to a Fast Fourier Transform (FFT)-like operator for Reed-Solomon erasure codes.
- **Use**: Used to write the content to a file named `fd_reedsol_fft.h`, which is part of the code generation process for FFT and IFFT operations.


---
### outf
- **Type**: `file object`
- **Description**: The `outf` variable is a file object that is opened for writing text to the file `fd_reedsol_fft.h`. It is used to write the contents of the `header` string and other generated code to this file.
- **Use**: Used to write the generated header and macro definitions to the file `fd_reedsol_fft.h`.


---
### GF
- **Type**: ``galois.GF``
- **Description**: Represents a Galois Field of order 2^8, which is a finite field with 256 elements. This field is used for arithmetic operations in the context of Reed-Solomon erasure codes and FFT-like transformations.
- **Use**: Used to perform arithmetic operations in the Galois Field GF(2^8) for polynomial transformations and calculations.


---
### svals
- **Type**: ``dict``
- **Description**: A dictionary that stores values for the polynomial basis `s_j(x)` used in the FFT-like operator for Reed-Solomon erasure codes. The keys are tuples `(j, x)`, where `j` is the index of the polynomial basis and `x` is the input value, and the values are elements of the Galois Field GF(2^8).
- **Use**: Stores precomputed values of `s_j(x)` for different indices and input values to facilitate fast polynomial transformations.


---
### sbar
- **Type**: ``dict``
- **Description**: The `sbar` variable is a dictionary that stores normalized polynomial values used in the FFT-like operator for Reed-Solomon erasure codes. It is indexed by tuples `(j, x)`, where `j` is an integer from 0 to 7, and `x` is an integer from 0 to 255. Each entry in `sbar` is calculated as the division of `svals[j, x]` by `svals[j, 1<<j]`, where the division is a field operation in the Galois Field GF(2^8).
- **Use**: Used to store and retrieve normalized polynomial values for FFT and IFFT operations in Reed-Solomon erasure codes.


# Functions

---
### reverse\_bits<!-- {{#callable:firedancer/src/ballet/reedsol/generate_fft.reverse_bits}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_fft.py#L105>)

Reverses the order of bits in an integer for a specified number of bits.
- **Inputs**:
    - `i`: The integer whose bits will be reversed.
    - `l`: The number of bits to consider for reversal.
- **Logic and Control Flow**:
    - Initialize the output variable `out` to 0.
    - Iterate over each bit position `z` from 0 to `l-1`.
    - Check if the `z`-th bit of `i` is set using bitwise AND operation.
    - If the bit is set, set the corresponding bit in `out` at position `l-1-z` using bitwise OR operation.
    - Return the integer `out` with the bits reversed.
- **Output**: An integer with the bits of `i` reversed for the specified number of bits `l`.


---
### print\_macro<!-- {{#callable:firedancer/src/ballet/reedsol/generate_fft.print_macro}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_fft.py#L123>)

Formats and prints a C macro definition with specified arguments and lines of code, ensuring proper indentation and line continuation.
- **Inputs**:
    - `macro_name`: The name of the macro to define.
    - `args`: A list of argument names for the macro.
    - `lines`: A list of strings representing lines of code to include in the macro.
    - `indent`: An optional integer specifying the number of spaces for indentation, defaulting to 2.
- **Logic and Control Flow**:
    - Initialize the first line of the macro definition with the macro name and the first argument.
    - Calculate the maximum width for line formatting based on the longest line of code and the specified indentation.
    - Iterate over the remaining arguments to format them into the macro definition line, ensuring each line does not exceed the maximum width.
    - If adding an argument exceeds the maximum width, print the current line with a line continuation character and start a new line with indentation.
    - Complete the macro definition line with a closing parenthesis and a line continuation character, then print it.
    - Print the opening line of the macro body with a 'do {' statement, followed by a line continuation character.
    - Iterate over the provided lines of code, printing each line with proper indentation and a line continuation character.
    - Print the closing line of the macro body with a 'while( 0 )' statement, followed by a blank line.
- **Output**: The function outputs formatted macro definitions to a file specified by the global variable `outf`.


---
### op\_fft<!-- {{#callable:firedancer/src/ballet/reedsol/generate_fft.op_fft}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_fft.py#L144>)

Recursively computes a list of tuples representing FFT-like operations for a given set of parameters.
- **Inputs**:
    - `h`: The size of the transform, a power of 2.
    - `beta`: A parameter used in the computation, typically related to the polynomial basis.
    - `i_round`: The current round or stage of the FFT computation.
    - `r_offset`: The offset used in the computation, typically related to the position in the data.
- **Logic and Control Flow**:
    - Check if `2**i_round` equals `h`; if true, return an empty list.
    - Initialize an empty list `to_return` to store results.
    - Recursively call `op_fft` with incremented `i_round` and the same `r_offset`, extending `to_return` with the result.
    - Recursively call `op_fft` with incremented `i_round` and `r_offset` incremented by `2**i_round`, extending `to_return` with the result.
    - Calculate `half_len` as `h` divided by `2**(i_round+1)`.
    - Iterate over `j` from 0 to `half_len - 1`.
    - For each `j`, calculate `omega_` as `j*2**(i_round+1)`.
    - Append a tuple to `to_return` containing calculated values based on `r_offset`, `i_round`, `omega_`, and `beta`.
- **Output**: A list of tuples, each representing a step in the FFT-like operation with specific parameters.


---
### op\_ifft<!-- {{#callable:firedancer/src/ballet/reedsol/generate_fft.op_ifft}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_fft.py#L161>)

Performs an inverse fast Fourier transform (IFFT) operation recursively on a given set of parameters.
- **Inputs**:
    - `h`: The size of the transform, a power of 2.
    - `beta`: A parameter used in the IFFT operation, related to the polynomial basis.
    - `i_round`: The current round or stage of the IFFT operation.
    - `r_offset`: The offset used in the calculation of indices during the IFFT operation.
- **Logic and Control Flow**:
    - Checks if `2**i_round` equals `h`, and if true, returns an empty list, indicating the base case of the recursion.
    - Initializes an empty list `butterflies` to store the results of the IFFT operation for the current stage.
    - Calculates `half_len` as `h//2**(i_round+1)`, which determines the number of butterfly operations to perform in the current stage.
    - Iterates over `j` from 0 to `half_len-1`, calculating `omega_` as `j*2**(i_round+1)` for each iteration.
    - Appends a tuple to `butterflies` containing the parameters for the butterfly operation, including indices and the current stage parameters.
    - Recursively calls `op_ifft` twice to process the next stages of the IFFT operation, once with `r_offset` and once with `r_offset+2**i_round`.
    - Extends the `butterflies` list with the results of the recursive calls.
    - Returns the `butterflies` list, which contains all the operations needed for the IFFT.
- **Output**: A list of tuples, each representing a butterfly operation in the IFFT process, with parameters for the operation.



---
Made with ❤️ by [Driver](https://www.driver.ai/)