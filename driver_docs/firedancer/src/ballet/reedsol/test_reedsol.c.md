<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for Reed-Solomon encoding and decoding, including performance and linearity checks.

# Purpose
The code is a C program that implements and tests Reed-Solomon encoding and decoding functionalities. It includes functions for encoding data into parity shreds using Reed-Solomon codes, which are error-correcting codes that can recover lost or corrupted data. The program uses precomputed logarithm and inverse logarithm tables for Galois Field arithmetic, which is essential for the operations involved in Reed-Solomon encoding.

The program defines several key components: [`fd_reedsol_encode_ref`](<#fd_reedsol_encode_ref>) for reference encoding, [`basic_tests`](<#basic_tests>) for basic functionality tests, and [`test_linearity`](<#test_linearity>) to verify the linearity of encoding functions. It also includes performance tests ([`battery_performance_base`](<#battery_performance_base>) and [`battery_performance_generic`](<#battery_performance_generic>)) to measure the efficiency of the encoding process. The [`main`](<#main>) function orchestrates the execution of these tests and performance measurements. The code is structured to be a standalone executable, as indicated by the presence of the [`main`](<#main>) function, and it does not define public APIs or external interfaces for use by other programs.
# Imports and Dependencies

---
- `fd_reedsol_ppt.h`
- `stdio.h`


# Global Variables

---
### log\_tbl
- **Type**: ``short const *``
- **Description**: Points to a table of logarithmic values used in finite field arithmetic, specifically for Reed-Solomon encoding. The table is indexed from 0 to 255, providing precomputed logarithmic values for efficient calculations.
- **Use**: Used to access logarithmic values for elements in a finite field during encoding and decoding processes.


---
### invlog\_tbl
- **Type**: ``uchar const *``
- **Description**: Points to a location in the `fd_reedsol_generic_constants` binary data, offset by 256 times the size of a `short` and 512 times the size of a `uchar`. It is indexed in the range [-512, 512).
- **Use**: Used to access inverse logarithm values for operations in Galois Field arithmetic.


---
### matrix\_32\_32
- **Type**: ``uchar const *``
- **Description**: Points to a 32x32 matrix stored in row-major order. The matrix is located at an offset within the `fd_reedsol_generic_constants` binary data.
- **Use**: Used in Reed-Solomon encoding operations to verify parity shreds against expected values.


---
### data\_shreds
- **Type**: `uchar array`
- **Description**: `data_shreds` is a global array of unsigned characters (`uchar`) with a size determined by the product of `SHRED_SZ` and `FD_REEDSOL_DATA_SHREDS_MAX`. This array is used to store data shreds for Reed-Solomon encoding.
- **Use**: Stores data shreds for encoding operations in Reed-Solomon error correction.


---
### parity\_shreds
- **Type**: `uchar`
- **Description**: An array of unsigned characters used to store parity shreds for Reed-Solomon encoding.
- **Use**: Stores parity data generated during the encoding process.


---
### recovered\_shreds
- **Type**: `uchar array`
- **Description**: An array of unsigned characters (`uchar`) with a size defined by the product of `SHRED_SZ` and `FD_REEDSOL_PARITY_SHREDS_MAX`. This array is used to store recovered parity shreds in the Reed-Solomon encoding process.
- **Use**: Stores the recovered parity shreds during the data recovery process in Reed-Solomon encoding.


---
### mem
- **Type**: `uchar`
- **Description**: An array of unsigned characters with a size defined by the macro `FD_REEDSOL_FOOTPRINT`. The array is aligned in memory according to the alignment specified by `FD_REEDSOL_ALIGN`.
- **Use**: Used as a memory buffer for Reed-Solomon encoding operations.


---
### wrapped\_data\_shred\_cnt
- **Type**: `ulong`
- **Description**: `wrapped_data_shred_cnt` is a static global variable of type `ulong`.
- **Use**: It stores the count of data shreds to be processed in the `wrapped_encode_generic` function.


---
### wrapped\_parity\_shred\_cnt
- **Type**: `ulong`
- **Description**: `wrapped_parity_shred_cnt` is a static global variable of type `ulong`.
- **Use**: It stores the count of parity shreds to be processed in the `wrapped_encode_generic` function.


---
### output
- **Type**: `char`
- **Description**: `output` is a global character array with a size determined by the product of `FD_REEDSOL_DATA_SHREDS_MAX`, `FD_REEDSOL_PARITY_SHREDS_MAX`, and 8. This array is used to store performance data in a formatted string.
- **Use**: Used to store and format performance data for output.


---
### loop\_times
- **Type**: `long`
- **Description**: A two-dimensional array of type `long` with dimensions `[FD_REEDSOL_DATA_SHREDS_MAX+1UL][FD_REEDSOL_PARITY_SHREDS_MAX+1UL]`. This array is used to store timing information for encoding operations.
- **Use**: Stores the time taken for encoding operations with varying numbers of data and parity shreds.


# Functions

---
### gfmul<!-- {{#callable:gfmul}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L20>)

Performs multiplication in the Galois Field GF(2^8) using logarithm and inverse logarithm tables.
- **Inputs**:
    - `a`: An unsigned character representing the first operand in the Galois Field multiplication.
    - `b`: An unsigned character representing the second operand in the Galois Field multiplication.
- **Logic and Control Flow**:
    - Retrieve the logarithm of `a` from the `log_tbl` array.
    - Retrieve the logarithm of `b` from the `log_tbl` array.
    - Add the two logarithms together.
    - Use the sum as an index to retrieve the result from the `invlog_tbl` array.
- **Output**: Returns the result of the Galois Field multiplication as an unsigned character.


---
### gfinv<!-- {{#callable:gfinv}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L23>)

Computes the multiplicative inverse of a Galois Field element using precomputed logarithm and inverse logarithm tables.
- **Inputs**:
    - `a`: An unsigned character representing an element in the Galois Field.
- **Logic and Control Flow**:
    - Retrieve the logarithm of `a` from the `log_tbl` array.
    - Calculate the index for the inverse logarithm by subtracting the logarithm value from 255.
    - Retrieve the inverse logarithm from the `invlog_tbl` array using the calculated index.
    - Return the value from the `invlog_tbl` as the result.
- **Output**: An unsigned character representing the multiplicative inverse of the input element in the Galois Field.


---
### fd\_reedsol\_encode\_ref<!-- {{#callable:fd_reedsol_encode_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L27>)

Encodes data shreds into parity shreds using Reed-Solomon error correction coding.
- **Inputs**:
    - `shred_sz`: The size of each shred in bytes.
    - `data_shred`: A pointer to an array of pointers, each pointing to a data shred.
    - `data_shred_cnt`: The number of data shreds.
    - `parity_shred`: A pointer to an array of pointers, each pointing to a parity shred.
    - `parity_shred_cnt`: The number of parity shreds.
- **Logic and Control Flow**:
    - Initialize `top_matrix` and `main_matrix` for encoding calculations.
    - Set the first row of `top_matrix` to have a leading 1 and the rest 0s.
    - Populate the remaining rows of `top_matrix` using logarithm and inverse logarithm tables.
    - Populate `main_matrix` similarly for parity shreds.
    - Augment `top_matrix` with an identity matrix for Gaussian elimination.
    - Perform Gaussian elimination to invert `top_matrix`.
    - Back substitute to finalize the inversion of `top_matrix`.
    - Multiply `main_matrix` by the right half of `top_matrix` to prepare for encoding.
    - Iterate over each position in the shreds to compute the parity shreds using the encoded matrix.
- **Output**: The function does not return a value; it modifies the `parity_shred` array in place to contain the encoded parity shreds.


---
### basic\_tests<!-- {{#callable:basic_tests}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L119>)

Conducts a series of tests on the Reed-Solomon encoding and decoding functions to verify their correctness and performance.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `FD_TEST` to verify that [`fd_reedsol_strerror`](<fd_reedsol.c.md#fd_reedsol_strerror>) returns the correct error messages for various error codes.
    - Initializes arrays `d` and `p` to point to sections of `data_shreds` and `parity_shreds`, respectively.
    - Sets up an identity matrix in `d` and verifies that the parity shreds match a predefined matrix `matrix_32_32`.
    - Sets up a diagonal matrix with increasing values and verifies the sum of the parity shreds against a known value.
    - Sets all data shreds to 1 and verifies that all parity shreds are also 1.
- **Output**: No output is returned as the function is void and primarily performs tests using assertions.
- **Functions Called**:
    - [`fd_reedsol_strerror`](<fd_reedsol.c.md#fd_reedsol_strerror>)
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)


---
### test\_linearity<!-- {{#callable:test_linearity}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L176>)

Tests the linearity properties of a given linear function by verifying vectorization, additivity, and scalar multiplication properties.
- **Inputs**:
    - `to_test`: A function pointer to the linear function to be tested.
    - `input_cnt`: The number of input vectors to be used in the test.
    - `output_cnt`: The number of output vectors to be used in the test.
    - `rng`: A pointer to a random number generator used for generating random inputs.
    - `test_cnt`: The number of test iterations to perform.
    - `chunk_sz`: The size of each chunk in bytes, which must be less than or equal to 32.
- **Logic and Control Flow**:
    - Checks that `input_cnt` and `output_cnt` do not exceed `LINEAR_MAX_DIM` and `chunk_sz` does not exceed 32.
    - Initializes input vectors to zero and verifies that the output of the function `to_test` is zero, confirming f(0) = 0.
    - Tests vectorization by shifting input columns and verifying that the output columns shift correspondingly.
    - Tests additivity by generating two random input sets, combining them, and verifying that the output of the combined input equals the XOR of the outputs of the individual inputs.
    - Tests scalar multiplication by multiplying inputs with random scalars and verifying that the outputs are scaled accordingly.
- **Output**: No return value; the function uses assertions to validate the linearity properties of the function `to_test`.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)


---
### wrapped\_encode\_generic<!-- {{#callable:wrapped_encode_generic}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L340>)

Encodes data shreds into parity shreds using Reed-Solomon encoding.
- **Inputs**:
    - ``inputs``: Pointer to an array of `linear_chunk_t` representing the data shreds to encode.
    - ``outputs``: Pointer to an array of `linear_chunk_t` where the encoded parity shreds will be stored.
- **Logic and Control Flow**:
    - Initialize a Reed-Solomon encoder using [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>) with a memory buffer `mem` and a fixed size of 32 bytes.
    - Iterate over the number of data shreds (`wrapped_data_shred_cnt`) and add each data shred from `inputs` to the encoder using [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>).
    - Iterate over the number of parity shreds (`wrapped_parity_shred_cnt`) and add each parity shred to `outputs` using [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>).
    - Finalize the encoding process with [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>).
- **Output**: No return value; the function modifies the `outputs` array in place to store the parity shreds.
- **Functions Called**:
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)


---
### test\_linearity\_all<!-- {{#callable:test_linearity_all}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L373>)

Tests the linearity of various FFT, IFFT, PPT, and Reed-Solomon encoding functions using a random number generator.
- **Inputs**:
    - ``rng``: A pointer to a `fd_rng_t` structure used for random number generation.
- **Logic and Control Flow**:
    - Initialize `TC` to 10000UL and `CW` to `GF_WIDTH`.
    - Log a notice about testing the linearity of FFT and IFFT functions.
    - Call [`test_linearity`](<#test_linearity>) for various FFT and IFFT functions with different sizes (4, 8, 16, 32, 64, 128) and their shifted versions.
    - Log a notice about testing the linearity of PPT 16 functions.
    - Call [`test_linearity`](<#test_linearity>) for various PPT 16 functions with size 16.
    - Halve `TC` and log a notice about testing the linearity of PPT 32 functions.
    - Call [`test_linearity`](<#test_linearity>) for various PPT 32 functions with size 32.
    - Halve `TC` again and log a notice about testing the linearity of PPT 64 functions.
    - Call [`test_linearity`](<#test_linearity>) for various PPT 64 functions with size 64.
    - Call [`test_linearity`](<#test_linearity>) for PPT 128 functions with size 128.
    - Log a notice about testing the linearity of `reedsol_encode`.
    - Iterate over `wrapped_data_shred_cnt` and `wrapped_parity_shred_cnt` and call [`test_linearity`](<#test_linearity>) for `wrapped_encode_generic` with these counts, `rng`, 500UL, and 32UL.
- **Output**: No return value; the function performs tests and logs results.
- **Functions Called**:
    - [`test_linearity`](<#test_linearity>)


---
### s\_ref<!-- {{#callable:s_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L450>)

Calculates the product of all `uchar` values in a specified range, using a mask derived from the input `j`.
- **Inputs**:
    - `j`: An integer in the range [0, 6) that determines the mask for the range of `uchar` values to multiply.
    - `x`: An `uchar` value used as the base to calculate the range of values to multiply.
- **Logic and Control Flow**:
    - Calculate a mask using `fd_ulong_mask_lsb(j)` to determine the range of values to multiply.
    - Compute `min_x` as `x` bitwise AND with the negation of the mask, setting the lower bits to zero.
    - Compute `max_x` as `min_x` plus the mask plus 1, defining the upper bound of the range.
    - Initialize `prod` to 1, which will hold the product of the values.
    - Iterate over each `ulong` value `y` from `min_x` to `max_x`, multiplying `prod` by `y` using the [`gfmul`](<#gfmul>) function.
    - Return the final product `prod`.
- **Output**: Returns an `uchar` representing the product of all `uchar` values in the specified range.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)


---
### S\_ref<!-- {{#callable:S_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L461>)

Computes a reference implementation of the `S` function using Galois Field arithmetic.
- **Inputs**:
    - `j`: An integer representing the index, which must be in the range [0, 6).
    - `x`: An unsigned character representing the input value for the function.
- **Logic and Control Flow**:
    - Calls the [`s_ref`](<#s_ref>) function with parameters `j` and `x` to compute an intermediate result.
    - Calls the [`s_ref`](<#s_ref>) function again with parameters `j` and `(uchar)(1<<j)` to compute another intermediate result.
    - Passes the two results to the [`gfmul`](<#gfmul>) function to multiply them in the Galois Field.
    - Returns the result of the multiplication.
- **Output**: Returns an unsigned character that is the result of the Galois Field multiplication of two [`s_ref`](<#s_ref>) function calls.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)
    - [`s_ref`](<#s_ref>)
    - [`gfinv`](<#gfinv>)


---
### X\_ref<!-- {{#callable:X_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L463>)

Computes a product of values derived from the [`S_ref`](<#s_ref>) function based on the bits set in the input `i`.
- **Inputs**:
    - `i`: An unsigned long integer in the range [0, 64) that determines which bits are set for the computation.
    - `x`: An unsigned char used as an input to the [`S_ref`](<#s_ref>) function.
- **Logic and Control Flow**:
    - Initialize `prod` to 1.
    - Iterate over `j` from 0 to 5.
    - For each `j`, check if the `j`-th bit of `i` is set.
    - If the `j`-th bit is set, update `prod` by multiplying it with the result of `gfmul(prod, S_ref(j, x))`.
    - Return the final value of `prod`.
- **Output**: Returns an unsigned char representing the computed product.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)
    - [`S_ref`](<#s_ref>)


---
### test\_fft\_single<!-- {{#callable:test_fft_single}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L470>)

Tests the correctness of a linear function by comparing its output against a reference implementation for a given input size and expected shift.
- **Inputs**:
    - `to_test`: A function pointer to a linear function that takes input and output arrays of type `linear_chunk_t`.
    - `N`: The number of elements in the input and output arrays to test.
    - `expected_shift`: The expected shift value to apply when comparing the output against the reference implementation.
- **Logic and Control Flow**:
    - Initialize arrays `inputs` and `outputs` of type `linear_chunk_t` to store input and output data.
    - Iterate over `outer` from 0 to `N`, setting the first element of each `inputs[i]` to 1 if `i` equals `outer`, otherwise set it to 0.
    - Call the `to_test` function with `inputs` and `outputs` to compute the output.
    - Iterate over `r` from 0 to `N`, and use `FD_TEST` to verify that the first element of `outputs[r]` matches the result of `X_ref(outer, (uchar)(r+expected_shift))`.
- **Output**: No return value; the function performs tests and uses assertions to validate the output.
- **Functions Called**:
    - [`X_ref`](<#x_ref>)


---
### test\_ifft\_single<!-- {{#callable:test_ifft_single}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L485>)

Tests the inverse fast Fourier transform (IFFT) of a linear function by verifying its output against expected polynomial evaluations.
- **Inputs**:
    - `to_test`: A function pointer to a linear function that takes input and output arrays of type `linear_chunk_t`.
    - `N`: The number of elements in the input and output arrays, representing the dimension of the IFFT.
    - `expected_shift`: An expected shift value used in the polynomial evaluation.
- **Logic and Control Flow**:
    - Initialize arrays `inputs` and `outputs` of type `linear_chunk_t` to store input and output data respectively.
    - Iterate over `outer` from 0 to `N-1`, setting `inputs[i][0]` to 1 if `i` equals `outer`, otherwise 0.
    - Call the `to_test` function with `inputs` and `outputs` to perform the IFFT.
    - For each `p` from 0 to `N-1`, initialize `sum` to 0 and iterate over `r` from 0 to `N-1`, updating `sum` by XORing it with the product of `outputs[r][0]` and `X_ref(r, (uchar)(p+expected_shift))`.
    - Use `FD_TEST` to verify that `sum` equals 1 if `outer` equals `p`, otherwise 0.
- **Output**: No return value; the function uses assertions to validate the correctness of the IFFT operation.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)
    - [`X_ref`](<#x_ref>)


---
### test\_inv<!-- {{#callable:test_inv}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L507>)

Tests if two linear functions are inverses of each other by applying them sequentially on identity matrices and checking if the result is still an identity matrix.
- **Inputs**:
    - `f1`: A linear function of type `linear_func_t` to be tested as an inverse.
    - `f2`: Another linear function of type `linear_func_t` to be tested as an inverse.
    - `N`: The dimension of the square matrices to be used in the test.
- **Logic and Control Flow**:
    - Initialize two matrices `A` and `B` with dimensions `N x N`.
    - Set `A` to be an identity matrix by setting `A[i][j]` to 1 if `i == j`, otherwise 0.
    - Apply function `f1` to `A` and store the result in `B`.
    - Apply function `f2` to `B` and store the result back in `A`.
    - Check if `A` is still an identity matrix by verifying `A[i][j]` is 1 if `i == j`, otherwise 0.
    - Set `B` to be an identity matrix by setting `B[i][j]` to 1 if `i == j`, otherwise 0.
    - Apply function `f2` to `B` and store the result in `A`.
    - Apply function `f1` to `A` and store the result back in `B`.
    - Check if `B` is still an identity matrix by verifying `B[i][j]` is 1 if `i == j`, otherwise 0.
- **Output**: No output is returned, but the function uses assertions to verify that `f1` and `f2` are inverses.


---
### test\_fft\_all<!-- {{#callable:test_fft_all}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L527>)

Executes a series of tests on various FFT and IFFT functions to verify their correctness and inverse properties.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls [`test_fft_single`](<#test_fft_single>) and [`test_ifft_single`](<#test_ifft_single>) for FFT and IFFT functions with different sizes (4, 8, 16, 32, 64) and shifts (0, 4, 8, 16, 32, 64).
    - Verifies that each FFT function produces the expected output for a given input by comparing against a reference implementation `X_ref`.
    - Verifies that each IFFT function correctly reconstructs the original input from the FFT output by evaluating the polynomial at each point and comparing against the expected identity matrix.
    - Calls [`test_inv`](<#test_inv>) to check that each pair of FFT and IFFT functions are inverses of each other for sizes up to 32.
    - Comments indicate that [`test_inv`](<#test_inv>) does not support sizes larger than 32, so tests for size 64 are commented out.
- **Output**: No output is returned as the function is void; it performs tests and assertions internally.
- **Functions Called**:
    - [`test_fft_single`](<#test_fft_single>)
    - [`test_ifft_single`](<#test_ifft_single>)
    - [`test_inv`](<#test_inv>)


---
### test\_encode\_vs\_ref<!-- {{#callable:test_encode_vs_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L553>)

Compares the output of the `fd_reedsol_encode` function with a reference implementation to ensure correctness.
- **Inputs**:
    - ``rng``: A pointer to a random number generator of type `fd_rng_t` used to generate random data for testing.
- **Logic and Control Flow**:
    - Initialize arrays `d`, `p`, and `r` to point to data and parity shreds with a specific stride.
    - Iterate over all possible combinations of data shred count (`d_cnt`), parity shred count (`p_cnt`), and shred size (`shred_sz`).
    - For each combination, clear the data and parity shreds using `fd_memset`.
    - Populate data shreds with an identity matrix followed by random data using `fd_rng_uchar`.
    - Initialize the Reed-Solomon encoder with [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>) and add data and parity shreds using [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>) and [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>).
    - Finalize the encoding process with [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>).
    - Use the reference implementation [`fd_reedsol_encode_ref`](<#fd_reedsol_encode_ref>) to encode the data shreds and store the result in `r`.
    - Compare the parity shreds `p` with the reference result `r` using `FD_TEST` to ensure they match.
- **Output**: No direct output is returned; the function uses assertions to verify that the parity shreds match the reference implementation.
- **Functions Called**:
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)
    - [`fd_reedsol_encode_ref`](<#fd_reedsol_encode_ref>)


---
### battery\_performance\_base<!-- {{#callable:battery_performance_base}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L589>)

Measures the performance of Reed-Solomon encoding by initializing data and parity shreds, warming up the instruction cache, and timing the encoding process over a set number of iterations.
- **Inputs**:
    - ``rng``: A pointer to a random number generator (`fd_rng_t`) used to initialize data shreds with random values.
- **Logic and Control Flow**:
    - Initialize `test_count` to 90000UL, which is the number of encoding iterations to perform.
    - Create arrays `d` and `p` to hold pointers to data and parity shreds, respectively, and initialize them to point to sections of `data_shreds` and `parity_shreds`.
    - Fill `data_shreds` with random values using `fd_rng_uchar` and the provided `rng`.
    - Warm up the instruction cache by performing two rounds of Reed-Solomon encoding using [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>), [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>), [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>), and [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>).
    - Measure the time taken for `test_count` iterations of the encoding process by recording the wall clock time before and after the loop, which initializes, processes, and finalizes the encoding for each iteration.
    - Log the average time per encode call and the corresponding data throughput in GiB/s and Gbps.
- **Output**: No return value; the function logs performance metrics to the console.
- **Functions Called**:
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)


---
### battery\_performance\_generic<!-- {{#callable:battery_performance_generic}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L629>)

Measures the performance of encoding data and parity shreds using Reed-Solomon encoding and outputs the results in Gbps.
- **Inputs**:
    - ``rng``: A pointer to a random number generator of type `fd_rng_t` used to generate random data for the shreds.
    - ``max_data_shreds``: The maximum number of data shreds to be used in the performance test.
    - ``max_parity_shreds``: The maximum number of parity shreds to be used in the performance test.
    - ``test_count``: The number of times the encoding process is repeated for performance measurement.
- **Logic and Control Flow**:
    - Initialize arrays `d` and `p` to point to data and parity shreds respectively, based on `max_data_shreds` and `max_parity_shreds`.
    - Fill the `data_shreds` array with random data using the `rng`.
    - Iterate over all combinations of data and parity shreds from 1 to `max_data_shreds` and `max_parity_shreds` respectively.
    - For each combination, initialize the Reed-Solomon encoder and add data and parity shreds to warm up the instruction cache.
    - Measure the time taken to encode the data and parity shreds `test_count` times using `fd_log_wallclock` to calculate the elapsed time.
    - Store the measured time in the `loop_times` array for each combination of data and parity shreds.
    - Format the performance results in Gbps and append them to the `output` string.
    - Print the formatted performance results.
- **Output**: Outputs the performance results of the encoding process in Gbps to the console.
- **Functions Called**:
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)


---
### pi\_ref<!-- {{#callable:pi_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L689>)

Computes the product of the Galois Field multiplication of `x` XORed with each element in `erasures`.
- **Inputs**:
    - `x`: An unsigned character representing the value to be XORed with each element in `erasures`.
    - `erasures`: A pointer to an array of unsigned characters representing the erasures to be XORed with `x`.
    - `erasures_cnt`: An unsigned long integer representing the number of elements in the `erasures` array.
- **Logic and Control Flow**:
    - Initialize `prod` to 1.
    - Iterate over each element in the `erasures` array up to `erasures_cnt`.
    - For each element, compute the XOR of `x` and the current element of `erasures`, then multiply `prod` by the result using the [`gfmul`](<#gfmul>) function.
    - Return the final value of `prod`.
- **Output**: Returns an unsigned character representing the computed product.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)


---
### pi\_prime\_inv\_ref<!-- {{#callable:pi_prime_inv_ref}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L696>)

Computes the inverse of the product of differences between `x` and each element in `erasures`, excluding `x` itself.
- **Inputs**:
    - ``x``: An unsigned character representing the value to compare against each element in `erasures`.
    - ``erasures``: A pointer to an array of unsigned characters representing the erasure values.
    - ``erasures_cnt``: An unsigned long integer representing the number of elements in the `erasures` array.
- **Logic and Control Flow**:
    - Initialize `prod` to 1.
    - Iterate over each element in `erasures` up to `erasures_cnt`.
    - For each element, if it is not equal to `x`, compute the product of `prod` and the result of `x` XOR the current element, using the [`gfmul`](<#gfmul>) function.
    - Return the inverse of `prod` using the [`gfinv`](<#gfinv>) function.
- **Output**: Returns the inverse of the computed product as an unsigned character.
- **Functions Called**:
    - [`gfmul`](<#gfmul>)
    - [`gfinv`](<#gfinv>)


---
### test\_pi<!-- {{#callable:test_pi}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L705>)

Tests the correctness of a function `fn` that generates Pi values for given inputs and erasures.
- **Inputs**:
    - `fn`: A function pointer of type `gen_pi_fn_t` that takes input and output arrays of type `uchar`.
    - `N`: An unsigned long integer representing the number of elements to test, with a maximum value of 256.
    - `rng`: A pointer to a random number generator of type `fd_rng_t` used to generate random values for testing.
- **Logic and Control Flow**:
    - Logs the start of the test with the value of `N` using `FD_LOG_NOTICE`.
    - Defines a maximum value `MAX_N` of 256 and checks if `N` is less than or equal to `MAX_N` using `FD_TEST`.
    - Initializes arrays `in`, `out`, and `erasures` of size `MAX_N`.
    - For each index `i` from 0 to `N-1`, sets `in[i]` to 1, `erasures[0]` to `i`, and calls `fn` with `in` and `out`.
    - Verifies that `out[j]` matches the expected value from [`pi_prime_inv_ref`](<#pi_prime_inv_ref>) or [`pi_ref`](<#pi_ref>) depending on whether `j` equals `i`.
    - For each pair of indices `i` and `j` where `i < j`, sets `in[i]` and `in[j]` to 1, `erasures[0]` to `i`, `erasures[1]` to `j`, and calls `fn` with `in` and `out`.
    - Verifies that `out[k]` matches the expected value from [`pi_prime_inv_ref`](<#pi_prime_inv_ref>) or [`pi_ref`](<#pi_ref>) depending on whether `k` equals `i` or `j`.
    - Repeats the test 1000 times with a varying number of erasures determined by a random condition, updating `in` and `erasures` accordingly.
    - Calls `fn` with `in` and `out` and verifies that `out[i]` matches the expected value from [`pi_prime_inv_ref`](<#pi_prime_inv_ref>) or [`pi_ref`](<#pi_ref>) based on the erasures.
- **Output**: No return value; the function performs tests and logs results using `FD_TEST` and `FD_LOG_NOTICE`.
- **Functions Called**:
    - [`pi_prime_inv_ref`](<#pi_prime_inv_ref>)
    - [`pi_ref`](<#pi_ref>)


---
### test\_pi\_all<!-- {{#callable:test_pi_all}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L767>)

Executes a series of tests on different `gen_pi_fn_t` functions with varying input sizes using a random number generator.
- **Inputs**:
    - ``rng``: A pointer to a `fd_rng_t` structure used for random number generation.
- **Logic and Control Flow**:
    - Calls [`test_pi`](<#test_pi>) with `fd_reedsol_private_gen_pi_16` and size 16.
    - Calls [`test_pi`](<#test_pi>) with `fd_reedsol_private_gen_pi_32` and size 32.
    - Calls [`test_pi`](<#test_pi>) with `fd_reedsol_private_gen_pi_64` and size 64.
    - Calls [`test_pi`](<#test_pi>) with `fd_reedsol_private_gen_pi_128` and size 128.
    - Calls [`test_pi`](<#test_pi>) with `fd_reedsol_private_gen_pi_256` and size 256.
- **Output**: No return value; the function performs tests and logs results.
- **Functions Called**:
    - [`test_pi`](<#test_pi>)


---
### test\_recover<!-- {{#callable:test_recover}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L776>)

Tests the recovery of data and parity shreds using Reed-Solomon encoding and verifies the integrity of the recovery process.
- **Inputs**:
    - ``rng``: A pointer to a random number generator (`fd_rng_t`) used to fill data shreds with random values and to simulate erasures and corruptions.
- **Logic and Control Flow**:
    - Initialize arrays `d`, `p`, and `r` to point to data, parity, and recovery shreds respectively.
    - Fill data shreds with random data using the random number generator `rng`.
    - Iterate over possible counts of data shreds (`d_cnt`) and parity shreds (`p_cnt`).
    - For each combination of `d_cnt` and `p_cnt`, initialize Reed-Solomon encoding and add data and parity shreds.
    - Finalize the encoding process to generate parity shreds.
    - Simulate erasures by selecting a number of shreds (`e_cnt`) to erase using reservoir sampling.
    - Initialize Reed-Solomon recovery and add erased and received shreds accordingly.
    - Verify that the number of erased shreds matches `e_cnt` and finalize the recovery process.
    - Check the return value of the recovery process to ensure it matches expected outcomes (e.g., success or partial recovery).
    - Verify that recovered shreds match the original erased shreds using `memcmp`.
    - Simulate corruption by flipping a bit in each shred and verify that the recovery process detects the corruption.
- **Output**: No direct output is returned, but the function performs tests and assertions to verify the correctness of the recovery process.
- **Functions Called**:
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)
    - [`fd_reedsol_recover_init`](<fd_reedsol.h.md#fd_reedsol_recover_init>)
    - [`fd_reedsol_recover_add_erased_shred`](<fd_reedsol.h.md#fd_reedsol_recover_add_erased_shred>)
    - [`fd_reedsol_recover_add_rcvd_shred`](<fd_reedsol.h.md#fd_reedsol_recover_add_rcvd_shred>)
    - [`fd_reedsol_recover_fini`](<fd_reedsol.c.md#fd_reedsol_recover_fini>)


---
### test\_recover\_performance<!-- {{#callable:test_recover_performance}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L846>)

Measures the performance of the Reed-Solomon recovery process under various conditions of data and parity erasure.
- **Inputs**:
    - ``rng``: A pointer to a random number generator of type `fd_rng_t` used to initialize data shreds with random values.
- **Logic and Control Flow**:
    - Initialize `test_count` to 90000UL, which determines the number of recovery operations to measure.
    - Set up arrays `d`, `p`, and `r` to point to data, parity, and recovered shreds respectively.
    - Fill `data_shreds` with random values using `fd_rng_uchar`.
    - Initialize Reed-Solomon encoding and generate parity shreds using [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>), [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>), and [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>).
    - Warm up the instruction cache by performing recovery operations with no erasures, parity erased, data erased, and even shreds erased.
    - For each condition, measure the time taken for `test_count` recovery operations using `fd_log_wallclock`.
    - Log the average time per recovery operation and the corresponding data rates in GiB/s and Gbps.
- **Output**: No return value; outputs performance metrics to the log.
- **Functions Called**:
    - [`fd_reedsol_encode_init`](<fd_reedsol.h.md#fd_reedsol_encode_init>)
    - [`fd_reedsol_encode_add_parity_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_parity_shred>)
    - [`fd_reedsol_encode_add_data_shred`](<fd_reedsol.h.md#fd_reedsol_encode_add_data_shred>)
    - [`fd_reedsol_encode_fini`](<fd_reedsol.c.md#fd_reedsol_encode_fini>)
    - [`fd_reedsol_recover_init`](<fd_reedsol.h.md#fd_reedsol_recover_init>)
    - [`fd_reedsol_recover_add_rcvd_shred`](<fd_reedsol.h.md#fd_reedsol_recover_add_rcvd_shred>)
    - [`fd_reedsol_recover_fini`](<fd_reedsol.c.md#fd_reedsol_recover_fini>)
    - [`fd_reedsol_recover_add_erased_shred`](<fd_reedsol.h.md#fd_reedsol_recover_add_erased_shred>)


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/ballet/reedsol/test_reedsol.c#L988>)

Initializes the environment, runs a series of tests and performance evaluations on Reed-Solomon encoding and decoding, and then cleans up resources.
- **Inputs**:
    - `argc`: The number of command-line arguments passed to the program.
    - `argv`: An array of strings representing the command-line arguments.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with command-line arguments.
    - Creates a random number generator `rng` using `fd_rng_new` and `fd_rng_join`.
    - Executes [`basic_tests`](<#basic_tests>) to perform basic validation tests.
    - Runs [`battery_performance_base`](<#battery_performance_base>) to measure the base performance of encoding operations.
    - Executes [`battery_performance_generic`](<#battery_performance_generic>) to measure performance with varying data and parity shred counts.
    - Calls [`test_encode_vs_ref`](<#test_encode_vs_ref>) to compare encoding results against a reference implementation.
    - Runs [`test_recover`](<#test_recover>) to test the recovery of data from parity shreds.
    - Executes [`test_recover_performance`](<#test_recover_performance>) to measure recovery performance under different conditions.
    - Calls [`test_pi_all`](<#test_pi_all>) to test the Pi function implementations.
    - Runs [`test_linearity_all`](<#test_linearity_all>) to verify the linearity of various functions.
    - Executes [`test_fft_all`](<#test_fft_all>) to test FFT and IFFT implementations.
    - Deletes the random number generator `rng` using `fd_rng_delete` and `fd_rng_leave`.
    - Logs a notice indicating the tests passed using `FD_LOG_NOTICE`.
    - Calls `fd_halt` to clean up and terminate the program.
- **Output**: Returns 0 to indicate successful execution.
- **Functions Called**:
    - [`basic_tests`](<#basic_tests>)
    - [`battery_performance_base`](<#battery_performance_base>)
    - [`battery_performance_generic`](<#battery_performance_generic>)
    - [`test_encode_vs_ref`](<#test_encode_vs_ref>)
    - [`test_recover`](<#test_recover>)
    - [`test_recover_performance`](<#test_recover_performance>)
    - [`test_pi_all`](<#test_pi_all>)
    - [`test_linearity_all`](<#test_linearity_all>)
    - [`test_fft_all`](<#test_fft_all>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)