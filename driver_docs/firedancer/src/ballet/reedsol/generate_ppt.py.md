<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Generates C header and implementation files for the Principal Pivot Transform in Reed-Solomon FFT operations.

# Purpose
The code is a Python script that generates C header and source files for implementing the Principal Pivot Transform (PPT) for Reed-Solomon error correction codes. The script uses the Galois field arithmetic provided by the `galois` library and matrix operations from `numpy` to compute the necessary transformations. The generated C code is intended to be used in a larger system that requires efficient encoding and decoding of data using Reed-Solomon codes, particularly when the number of data shreds is not a power of two.

The script defines several functions to compute forward and inverse Fast Fourier Transform (FFT) matrices, which are used in the PPT process. It also includes a function to generate the specific operations needed for the PPT based on the size of the data and the number of known elements. The script outputs a header file `fd_reedsol_ppt.h` containing macros and function declarations, and multiple C source files implementing the PPT for different configurations. The generated code is optimized for specific cases where the number of data shreds is less than a power of two, using vectorized operations to improve performance.
# Imports and Dependencies

---
- `galois`
- `numpy`
- `numpy.linalg`


# Global Variables

---
### header
- **Type**: ``str``
- **Description**: A multi-line string that contains the content of a C header file. This header file is auto-generated and includes definitions and documentation for implementing the Principal Pivot Transform (PPT) for the Reed Solomon FFT operator.
- **Use**: Used to write the content to a file named `fd_reedsol_ppt.h`.


---
### outf
- **Type**: ``TextIOWrapper``
- **Description**: The `outf` variable is a file object that is opened for writing text to the file named 'fd_reedsol_ppt.h'. It is created using the `open` function with the mode 'wt', which stands for write text mode.
- **Use**: Used to write the `header` content to the 'fd_reedsol_ppt.h' file.


---
### GF
- **Type**: `galois.GF`
- **Description**: Represents a Galois Field of order 2^8, which is a finite field with 256 elements. This field is used for arithmetic operations in the context of error correction and cryptography.
- **Use**: Used to perform arithmetic operations in the Galois Field of order 2^8, which is essential for the implementation of the Reed-Solomon FFT operator and related transformations.


---
### svals
- **Type**: ``dict``
- **Description**: The `svals` variable is a dictionary that stores precomputed values used in the principal pivot transform for Reed-Solomon FFT operations. It is indexed by tuples of two integers, where the first integer represents a level `j` and the second integer represents an index `x`. The values stored are elements of a Galois Field (`GF`), specifically `GF(2**8)`, which are calculated based on previous values in the dictionary.
- **Use**: Used to store and retrieve precomputed Galois Field values for different levels and indices in the principal pivot transform process.


---
### sbar
- **Type**: ``dict``
- **Description**: The `sbar` variable is a dictionary that stores computed values based on the `svals` dictionary. It is indexed by a tuple `(j, x)`, where `j` ranges from 0 to 6 and `x` ranges from 0 to 127. Each entry in `sbar` is calculated as the division of `svals[j, x]` by `svals[j, 1<<j]`, where `svals` is another dictionary containing values of a Galois Field element.
- **Use**: Stores precomputed values for use in matrix operations within the FFT and IFFT functions.


---
### batches
- **Type**: ``tuple``
- **Description**: A tuple containing a sequence of integers. Each integer in the tuple represents a specific batch size used in the code.
- **Use**: Used to iterate over batch sizes for generating specific implementation files in a loop.


# Functions

---
### reverse\_bits<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.reverse_bits}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L119>)

Reverses the order of bits in an integer for a specified number of bits.
- **Inputs**:
    - `i`: The integer whose bits will be reversed.
    - `l`: The number of bits to consider for reversal.
- **Logic and Control Flow**:
    - Initialize the output variable `out` to 0.
    - Iterate over each bit position `z` from 0 to `l-1`.
    - Check if the `z`-th bit of `i` is set using bitwise AND operation.
    - If the `z`-th bit is set, set the corresponding bit in `out` at position `l-1-z`.
    - Return the integer `out` with the bits reversed.
- **Output**: An integer with the bits of `i` reversed for the first `l` bits.


---
### m\_fft<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.m_fft}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L137>)

Generates matrices for the Fast Fourier Transform (FFT) using a principal pivot transform approach.
- **Inputs**:
    - `lg_h`: The logarithm base 2 of the size of the matrices to generate.
    - `beta`: An integer used as an offset in the matrix generation process.
- **Logic and Control Flow**:
    - Calculate the size `h` as 2 raised to the power of `lg_h`.
    - Initialize an empty list `to_return` to store the generated matrices.
    - Iterate over `i_round` from 0 to `lg_h - 1`.
    - For each round, initialize two zero matrices `matrA` and `matrB` of size `h x h`.
    - Calculate `half_len` as `h` divided by 2 raised to the power of `i_round + 1`.
    - Iterate over `rr` from 0 to 2 raised to the power of `i_round` minus 1.
    - Reverse the bits of `rr` using the [`reverse_bits`](<#reverse_bits>) function to get `r`.
    - Iterate over `j` from 0 to `half_len - 1`.
    - Calculate `omega_` as `j` multiplied by 2 raised to the power of `i_round + 1`.
    - Calculate `idx` as `r` plus `omega_`.
    - Calculate `offset` as 2 raised to the power of `i_round`.
    - Set specific elements of `matrA` and `matrB` using the Galois field `GF` and the precomputed `sbar` values.
    - Append the Galois field representations of `matrB` and `matrA` to `to_return`.
- **Output**: A list of matrices in the Galois field representation, alternating between `matrB` and `matrA` for each round.
- **Functions Called**:
    - [`firedancer/src/ballet/reedsol/generate_ppt.reverse_bits`](<#reverse_bits>)


---
### m\_ifft<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.m_ifft}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L162>)

Computes the inverse fast Fourier transform (IFFT) matrices for a given logarithmic size and beta value.
- **Inputs**:
    - `lg_h`: The logarithmic size of the matrix, where the actual size is 2 raised to the power of this value.
    - `beta`: An integer used as an offset in the computation of matrix elements.
- **Logic and Control Flow**:
    - Initialize `h` as 2 raised to the power of `lg_h` and an empty list `to_return` to store results.
    - Iterate over `i_round` from 0 to `lg_h - 1`.
    - For each `i_round`, initialize two zero matrices `matrA` and `matrB` of size `h x h` with data type `np.uint8`.
    - Calculate `half_len` as `h` divided by 2 raised to the power of `i_round + 1`.
    - Iterate over `rr` from 0 to 2 raised to the power of `i_round` minus 1.
    - For each `rr`, compute `r` by reversing the bits of `rr` using the [`reverse_bits`](<#reverse_bits>) function.
    - Iterate over `j` from 0 to `half_len - 1`.
    - For each `j`, compute `omega_` as `j` multiplied by 2 raised to the power of `i_round + 1`.
    - Calculate `idx` as `r` plus `omega_` and `offset` as 2 raised to the power of `i_round`.
    - Update `matrA` and `matrB` at specific indices using the calculated `idx`, `offset`, and `sbar` values.
    - Prepend the Galois Field representations of `matrB` and `matrA` to `to_return`.
- **Output**: A list of Galois Field matrices representing the IFFT matrices for each round, in reverse order.
- **Functions Called**:
    - [`firedancer/src/ballet/reedsol/generate_ppt.reverse_bits`](<#reverse_bits>)


---
### fft\_matrix<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.fft_matrix}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L185>)

Computes the Fast Fourier Transform (FFT) matrix for a given logarithmic size and beta value using Galois fields.
- **Inputs**:
    - `lg_h`: The logarithm base 2 of the size of the FFT matrix to compute.
    - `beta`: A parameter used in the FFT computation, affecting the matrix generation.
- **Logic and Control Flow**:
    - Initialize `prod` as an identity matrix of size `2**lg_h` in the Galois field GF(2^8).
    - Iterate over each matrix `m` returned by the [`m_fft`](<#m_fft>) function with inputs `lg_h` and `beta`.
    - For each matrix `m`, convert it to a Galois field matrix and multiply it with `prod`.
    - Update `prod` with the result of the multiplication.
    - Return the final product matrix `prod`.
- **Output**: A Galois field matrix representing the FFT matrix for the given parameters.
- **Functions Called**:
    - [`firedancer/src/ballet/reedsol/generate_ppt.m_fft`](<#m_fft>)


---
### ifft\_matrix<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.ifft_matrix}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L190>)

Computes the inverse fast Fourier transform (IFFT) matrix for a given size and parameter.
- **Inputs**:
    - `lg_h`: The logarithm base 2 of the size of the matrix, determining the dimensions of the IFFT matrix.
    - `beta`: A parameter used in the computation of the IFFT matrix, affecting the transformation.
- **Logic and Control Flow**:
    - Initialize `prod` as an identity matrix of size `2**lg_h` in the Galois Field GF(2^8).
    - Iterate over each matrix `m` returned by the [`m_ifft`](<#m_ifft>) function with inputs `lg_h` and `beta`.
    - For each matrix `m`, multiply `prod` by `GF(m)` to accumulate the product of matrices.
    - Return the final product matrix `prod`.
- **Output**: Returns the product of matrices resulting from the inverse FFT transformation, represented in the Galois Field GF(2^8).
- **Functions Called**:
    - [`firedancer/src/ballet/reedsol/generate_ppt.m_ifft`](<#m_ifft>)


---
### Bmatr<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.Bmatr}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L196>)

Computes a specific submatrix of a transformed FFT matrix using the principal pivot transform.
- **Inputs**:
    - `lg_sz`: The logarithm base 2 of the size of the FFT matrix.
    - `shift`: The shift value applied to the FFT matrix.
- **Logic and Control Flow**:
    - Compute the FFT matrix for size `lg_sz-1` with the given `shift` and `shift+2**(lg_sz-1)`.
    - Create a block matrix with the computed FFT matrices and zero matrices of appropriate size.
    - Compute the inverse of the block matrix and multiply it by the FFT matrix of size `lg_sz` with the given `shift`.
    - Extract a submatrix from the resulting matrix using specific row and column indices.
    - Return the extracted submatrix as a Galois Field matrix.
- **Output**: A Galois Field matrix representing a specific submatrix of the transformed FFT matrix.
- **Functions Called**:
    - [`firedancer/src/ballet/reedsol/generate_ppt.fft_matrix`](<#fft_matrix>)


---
### principal\_pivot\_transform\_k\_no\_x<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.principal_pivot_transform_k_no_x}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L203>)

Computes a sequence of operations for the principal pivot transform based on input parameters.
- **Inputs**:
    - `lg_sz`: The logarithm base 2 of the size of the matrix, which determines the dimension of the transformation.
    - `k`: The number of known elements in the evaluation domain.
    - `alpha_offset`: An offset value used in the transformation calculations.
- **Logic and Control Flow**:
    - Calculate `n` as 2 raised to the power of `lg_sz`.
    - If `n` is greater than or equal to 4, check if `k - alpha_offset` is greater than or equal to `n` and return an IFFT operation if true.
    - If `k - alpha_offset` is less than or equal to 0, return an FFT operation.
    - If `n` equals 2, compute the FFT matrix and determine the appropriate matrix operation based on `k - alpha_offset`.
    - For larger `n`, compute the B matrix and its inverse, then iterate over half of `n` to determine operations based on conditions involving `k` and `alpha_offset`.
    - Recursively call `principal_pivot_transform_k_no_x` with decremented `lg_sz` and adjusted `alpha_offset` to handle subproblems.
    - Append operations to the list based on conditions and return the list of operations.
- **Output**: A list of tuples representing operations to perform, such as FFT, IFFT, COPY_SCRATCH, SCALE, MM22, MULACC, and MULACC_SCRATCH.
- **Functions Called**:
    - [`firedancer/src/ballet/reedsol/generate_ppt.fft_matrix`](<#fft_matrix>)
    - [`firedancer/src/ballet/reedsol/generate_ppt.ifft_matrix`](<#ifft_matrix>)
    - [`firedancer/src/ballet/reedsol/generate_ppt.Bmatr`](<#bmatr>)


---
### print\_macro<!-- {{#callable:firedancer/src/ballet/reedsol/generate_ppt.print_macro}} -->
[View Source →](<../../../../../src/ballet/reedsol/generate_ppt.py#L268>)

Generates and prints a C macro definition with specified arguments and lines, formatted with indentation and line continuation.
- **Inputs**:
    - `macro_name`: The name of the macro to define.
    - `args`: A list of argument names for the macro.
    - `lines`: A list of lines of code to include in the macro body.
    - `indent`: An optional integer specifying the number of spaces for indentation, defaulting to 2.
- **Logic and Control Flow**:
    - Initialize the macro definition with the macro name and the first argument.
    - Calculate the maximum width for line formatting based on the longest line in 'lines' plus indentation and a fixed offset.
    - Iterate over the remaining arguments to format them into the macro definition, ensuring each line does not exceed the maximum width.
    - If adding an argument exceeds the maximum width, print the current line with a continuation character and start a new line with indentation.
    - Complete the macro definition line with a closing parenthesis and a continuation character, then print it.
    - Print the opening line of the macro body with a 'do {' statement, formatted with a continuation character.
    - Iterate over each line in 'lines', printing each with appropriate indentation and a continuation character.
    - Print the closing line of the macro body with a 'while( 0 )' statement.
    - Print a blank line to separate this macro from subsequent content.
- **Output**: Prints the formatted macro definition and its body to the specified output file.



---
Made with ❤️ by [Driver](https://www.driver.ai/)