<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements Reed-Solomon erasure correction using Fast Walsh-Hadamard Transform with AVX optimizations.

# Purpose
The code is a C implementation of a Reed-Solomon error correction algorithm, specifically focusing on the generation of the polynomial `Pi(x)` and its derivative `Pi'(x)` for handling erasures. The implementation uses Fast Walsh-Hadamard Transform (FWHT) to compute these polynomials efficiently. The code is designed to work with different sizes of data, as indicated by functions like [`fd_reedsol_private_gen_pi_16`](<#fd_reedsol_private_gen_pi_16>), [`fd_reedsol_private_gen_pi_32`](<#fd_reedsol_private_gen_pi_32>), and so on, which generate `Pi(x)` for data sizes of 16, 32, 64, 128, and 256 elements.

The code includes conditional compilation to support different arithmetic implementations, such as using AVX instructions for vectorized operations, which can be toggled with the `FD_REEDSOL_ARITH_IMPL` macro. It also provides a non-AVX implementation for environments where AVX is not available. The code defines several macros and inline functions to perform operations like modular arithmetic and vector manipulations, which are crucial for the FWHT and the subsequent polynomial calculations. The implementation is intended for internal use within a larger Reed-Solomon library, as indicated by the inclusion of a private header file and the use of static functions and macros.
# Imports and Dependencies

---
- `fd_reedsol_private.h`
- `../../util/simd/fd_sse.h`


# Global Variables

---
### fwht\_l\_twiddle\_16
- **Type**: ``short[16]``
- **Description**: A static constant array of 16 short integers, aligned to 32 bytes, used in the Fast Walsh-Hadamard Transform (FWHT) operations. The array contains precomputed values for the FWHT of a sequence related to logarithms in a finite field.
- **Use**: Used in FWHT operations to optimize polynomial computations in Reed-Solomon encoding.


---
### fwht\_l\_twiddle\_32
- **Type**: ``short[32]``
- **Description**: The `fwht_l_twiddle_32` is a statically defined constant array of 32 `short` integers. It is aligned to a 32-byte boundary for optimized access in SIMD operations.
- **Use**: Used to store precomputed Fast Walsh-Hadamard Transform (FWHT) coefficients for a size 32 transform.


---
### fwht\_l\_twiddle\_64
- **Type**: ``short[]``
- **Description**: A static constant array of 64 short integers, aligned to 32 bytes, used in Fast Walsh-Hadamard Transform (FWHT) operations. The array contains precomputed values for the FWHT of a specific sequence, which is used in polynomial computations related to Reed-Solomon encoding.
- **Use**: Used as a lookup table for FWHT operations in polynomial computations.


---
### fwht\_l\_twiddle\_128
- **Type**: ``short[128]``
- **Description**: The `fwht_l_twiddle_128` is a statically defined constant array of 128 `short` integers. It is aligned to a 32-byte boundary for optimized access in SIMD operations. The array contains precomputed values used in the Fast Walsh-Hadamard Transform (FWHT) for a size of 128.
- **Use**: Used to store the FWHT of logarithmic values for efficient polynomial computations in Reed-Solomon encoding.


---
### fwht\_l\_twiddle\_256
- **Type**: ``short[256]``
- **Description**: A static constant array of 256 short integers, aligned to 32 bytes, used in Fast Walsh-Hadamard Transform (FWHT) operations. The array contains precomputed values for the FWHT of a sequence related to logarithms in a finite field, as described in the context of Reed-Solomon encoding and decoding.
- **Use**: Used to store precomputed FWHT values for efficient polynomial computations in Reed-Solomon error correction algorithms.


# Functions

---
### ws\_mod255<!-- {{#callable:ws_mod255}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L73>)

Computes the modulo 255 of a given input using bitwise operations and arithmetic shifts.
- **Inputs**:
    - `x`: A vector of type `ws_t` representing the input value to compute modulo 255.
- **Logic and Control Flow**:
    - Broadcasts the constant 0xFF to all elements of a vector using `ws_bcast(0xFF)`.
    - Multiplies the input `x` by the constant 0x8081 using `wh_mulhi` to get the high part of the product.
    - Shifts the result of the multiplication right by 7 bits using `ws_shru`.
    - Adds the shifted result to the original input `x` using `ws_add`.
    - Performs a bitwise AND operation with 0xFF using `ws_and` to compute the modulo 255.
- **Output**: Returns a vector of type `ws_t` where each element is the result of the modulo 255 operation on the corresponding element of the input vector `x`.


---
### add\_mod\_255<!-- {{#callable:add_mod_255}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L163>)

Performs addition of two `wb_t` values modulo 255, accounting for overflow.
- **Inputs**:
    - `a`: First operand of type `wb_t`.
    - `b`: Second operand of type `wb_t`.
- **Logic and Control Flow**:
    - Calculate the sum of `a` and `b` using `wb_add` and store it in `sum`.
    - Determine if overflow occurred by checking if `sum` is less than `a` using `wb_lt`, and store the result in `overflowed`.
    - Subtract `overflowed` from `sum` using `wb_sub` to adjust for overflow and return the result.
- **Output**: Returns the result of the addition modulo 255 as a `wb_t` type.


---
### compact\_ws<!-- {{#callable:compact_ws}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L238>)

Combines two 256-bit vectors of 16-bit integers into a single 256-bit vector of 8-bit integers by shuffling and packing selected bytes.
- **Inputs**:
    - `a`: A 256-bit vector of 16-bit integers (`ws_t`).
    - `b`: Another 256-bit vector of 16-bit integers (`ws_t`).
- **Logic and Control Flow**:
    - Shuffle the bytes of vector `a` using `_mm256_shuffle_epi8` with a specific mask to select and pack certain bytes.
    - Shuffle the bytes of vector `b` using `_mm256_shuffle_epi8` with the same mask to select and pack certain bytes.
    - Extract the lower and upper 128-bit halves of the shuffled result from `a` and combine them using `_mm_or_si128`.
    - Extract the lower and upper 128-bit halves of the shuffled result from `b` and combine them using `_mm_or_si128`.
    - Combine the two 128-bit results into a single 256-bit vector using `_mm256_setr_m128i`.
- **Output**: A 256-bit vector of 8-bit integers (`wb_t`) containing the packed and combined bytes from inputs `a` and `b`.


---
### exp\_76<!-- {{#callable:exp_76}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L257>)

Computes the exponentiation of 76 to the power of each byte in the input vector `x` in the Galois Field GF(2^8).
- **Inputs**:
    - `x`: A vector of type `wb_t` where each byte represents an integer exponent for the base 76 in GF(2^8).
- **Logic and Control Flow**:
    - Decompose `x` into components `xh3`, `xh2`, `xh1`, `xh0`, and `xl` where `0 <= xl < 16` and `0 <= xh_j < 1` for each `j`.
    - Calculate `76^x` as `(76^xl) * (76^0x10)^xh0 * (76^0x20)^xh1 * (76^0x40)^xh2 * (76^0x80)^xh3`, which simplifies to `(76^xl) * 2^xh0 * 4^xh1 * 16^xh2 * 29^xh3`.
    - Use `_mm256_shuffle_epi8` to implement a 4-bit lookup table for `76^xl`.
    - Use `_mm256_blendv_epi8` and `GF_MUL` to conditionally multiply by constants 2, 4, 16, and 29 based on the shifted values of `x`.
    - Return the final computed vector `with3` which contains the result of the exponentiation.
- **Output**: A vector of type `wb_t` containing the result of the exponentiation for each byte in the input vector `x`.


---
### exp\_29<!-- {{#callable:exp_29}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L281>)

Computes the exponentiation of 29 raised to each byte in the input vector `x` within the Galois Field GF(2^8).
- **Inputs**:
    - `x`: A vector of type `wb_t` containing bytes to be exponentiated by 29 in GF(2^8).
- **Logic and Control Flow**:
    - Extracts the lower 4 bits of each byte in `x` using `wb_and` and `wb_bcast`.
    - Uses `_mm256_shuffle_epi8` to perform a 4-bit lookup table operation on the extracted lower bits to get `exp_low`.
    - Blends `exp_low` with the result of `GF_MUL(exp_low, 133)` based on the shifted bits of `x` using `_mm256_blendv_epi8` and `_mm256_slli_epi16`.
    - Repeats the blending process with multipliers 2, 4, and 16, using progressively less significant bits of `x`.
    - Returns the final blended result `with3`.
- **Output**: A vector of type `wb_t` containing the result of 29 raised to the power of each byte in `x`, computed in GF(2^8).


---
### exp\_16<!-- {{#callable:exp_16}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L293>)

Computes the exponentiation of 16 raised to each byte in the input vector `x` within the Galois Field GF(2^8).
- **Inputs**:
    - `x`: A vector of type `wb_t` containing bytes to be exponentiated.
- **Logic and Control Flow**:
    - Extracts the lower 4 bits of each byte in `x` using `wb_and` and `wb_bcast`.
    - Uses `_mm256_shuffle_epi8` to perform a 4-bit lookup table operation on the extracted lower bits to get `exp_low`.
    - Blends `exp_low` with the result of `GF_MUL(exp_low, 95)` based on the shifted bits of `x` using `_mm256_blendv_epi8` and `_mm256_slli_epi16`.
    - Repeats the blending process with `GF_MUL` and different constants (133, 2, 4) for further shifted bits of `x`.
    - Returns the final blended result `with3`.
- **Output**: A vector of type `wb_t` containing the result of the exponentiation for each byte in `x`.


---
### exp\_4<!-- {{#callable:exp_4}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L305>)

Computes 4 raised to the power of each byte in the input vector `x` within the Galois Field GF(2^8).
- **Inputs**:
    - `x`: A vector of type `wb_t` containing bytes for which the function computes 4 raised to the power of each byte in GF(2^8).
- **Logic and Control Flow**:
    - Extracts the lower 4 bits of each byte in `x` using `wb_and` and `wb_bcast`.
    - Uses `_mm256_shuffle_epi8` to perform a lookup for 4 raised to the power of the lower 4 bits of each byte.
    - Blends the result with a multiplication by 157 if the 3rd bit of the byte is set using `_mm256_blendv_epi8` and `GF_MUL`.
    - Blends the result with a multiplication by 95 if the 2nd bit of the byte is set.
    - Blends the result with a multiplication by 133 if the 1st bit of the byte is set.
    - Blends the result with a multiplication by 2 if the 0th bit of the byte is set.
    - Returns the final blended result.
- **Output**: A vector of type `wb_t` containing the result of 4 raised to the power of each byte in the input vector `x` within GF(2^8).


---
### exp\_2<!-- {{#callable:exp_2}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L318>)

Computes 2 raised to the power of each byte in the input vector `x` within the Galois Field GF(2^8).
- **Inputs**:
    - `x`: A vector of type `wb_t` containing bytes for which the function computes the exponentiation.
- **Logic and Control Flow**:
    - Extracts the lower 4 bits of each byte in `x` using `wb_and` and `wb_bcast`.
    - Uses `_mm256_shuffle_epi8` to perform a lookup for the base exponentiation of the lower 4 bits.
    - Applies conditional multiplication using `_mm256_blendv_epi8` and `GF_MUL` based on shifted values of `x`.
    - Performs a series of conditional multiplications to compute the final exponentiation result.
    - Returns the computed vector `with3` as the result.
- **Output**: A vector of type `wb_t` containing the result of 2 raised to the power of each byte in `x`, computed in GF(2^8).


---
### gen\_pi\_noavx\_generic<!-- {{#callable:gen_pi_noavx_generic}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L385>)

Computes the inverse of a polynomial Pi' using the Fast Walsh-Hadamard Transform (FWHT) and stores the result in the output array.
- **Inputs**:
    - `is_erased`: A pointer to an array of unsigned characters indicating erased elements.
    - `output`: A pointer to an array where the function will store the computed output.
    - `sz`: An unsigned long integer representing the size of the input and output arrays.
    - `l_twiddle`: A pointer to an array of short integers used for twiddle factors in the FWHT.
- **Logic and Control Flow**:
    - Initialize a scratch array of size 256 to store intermediate results.
    - Copy the `is_erased` array into the `scratch` array.
    - Perform an unscaled Fast Walsh-Hadamard Transform (FWHT) on the `scratch` array.
    - Multiply each element in the `scratch` array by the corresponding element in the `l_twiddle` array.
    - Perform another unscaled FWHT on the `scratch` array.
    - Negate elements in the `scratch` array corresponding to erased elements using `fd_long_if`.
    - Compute the inverse of the size `sz` modulo 255 and adjust the `scratch` array values accordingly.
    - Convert the `scratch` array values using a lookup table `gf_arith_invlog_tbl` and store the results in the `output` array.
- **Output**: An array of unsigned characters representing the computed inverse of the polynomial Pi'.


---
### fd\_reedsol\_private\_gen\_pi\_16<!-- {{#callable:fd_reedsol_private_gen_pi_16}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L435>)

Generates a polynomial with zeros at specified erasure points using the Fast Walsh-Hadamard Transform (FWHT) and stores the result in the output.
- **Inputs**:
    - `is_erased`: A pointer to an array of unsigned characters indicating which positions are erased (1 for erased, 0 for not erased).
    - `output`: A pointer to an array where the function will store the generated polynomial values.
- **Logic and Control Flow**:
    - Check if `FD_REEDSOL_ARITH_IMPL` is greater than 0 to determine if AVX instructions are used.
    - If `FD_REEDSOL_PI_USE_SHORT` is defined, convert `is_erased` to a vector of shorts and perform FWHT on it.
    - Multiply the transformed vector by a precomputed twiddle factor `fwht_l_twiddle_16`.
    - Perform another FWHT on the product to compute `log_pi`.
    - Adjust the sign of `log_pi` based on erasure positions to compute `1/Pi'`.
    - Add a constant to `log_pi` to ensure it is non-negative and within a specific range.
    - Reduce `log_pi` modulo 255 using a specific formula to ensure it fits within a byte.
    - Compact `log_pi` into a byte vector and exponentiate it using [`exp_76`](<#exp_76>).
    - Store the result in the `output` array.
    - If `FD_REEDSOL_PI_USE_SHORT` is not defined, perform similar operations using byte vectors instead of short vectors.
    - If `FD_REEDSOL_ARITH_IMPL` is not greater than 0, call [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>) to handle the computation without AVX.
- **Output**: The function outputs a polynomial with zeros at the specified erasure points, stored in the `output` array.
- **Functions Called**:
    - [`compact_ws`](<#compact_ws>)
    - [`exp_76`](<#exp_76>)
    - [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>)


---
### fd\_reedsol\_private\_gen\_pi\_32<!-- {{#callable:fd_reedsol_private_gen_pi_32}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L517>)

Generates a polynomial with zeros at specified erasure positions using the Fast Walsh-Hadamard Transform (FWHT) and stores the result in the output buffer.
- **Inputs**:
    - `is_erased`: A pointer to an array of unsigned characters indicating erasure positions, where each element is either 0 (not erased) or 1 (erased).
    - `output`: A pointer to an array of unsigned characters where the function will store the resulting polynomial values.
- **Logic and Control Flow**:
    - Check if `FD_REEDSOL_ARITH_IMPL` is greater than 0 to determine if AVX instructions are used.
    - If `FD_REEDSOL_PI_USE_SHORT` is defined, load and convert `is_erased` to 16-bit integers, then perform FWHT on two vectors.
    - Multiply the transformed vectors by precomputed twiddle factors and perform another FWHT to compute `log_pi`.
    - Adjust the sign of `log_pi` based on erasure positions and add a constant to ensure non-negative values.
    - Reduce `log_pi` modulo 255 using a specific formula to ensure values are within range.
    - Compact the `log_pi` values into a byte vector and compute the exponential using [`exp_29`](<#exp_29>).
    - Store the result in the `output` buffer.
    - If `FD_REEDSOL_PI_USE_SHORT` is not defined, perform similar operations using byte vectors instead of 16-bit integers.
    - If `FD_REEDSOL_ARITH_IMPL` is not greater than 0, call [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>) to handle the computation without AVX.
- **Output**: The function outputs a polynomial with zeros at the specified erasure positions, stored in the `output` buffer as an array of unsigned characters.
- **Functions Called**:
    - [`compact_ws`](<#compact_ws>)
    - [`exp_29`](<#exp_29>)
    - [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>)


---
### fd\_reedsol\_private\_gen\_pi\_64<!-- {{#callable:fd_reedsol_private_gen_pi_64}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L602>)

Generates a polynomial with zeros at specified erasure points using the Fast Walsh-Hadamard Transform (FWHT) and stores the result in the output buffer.
- **Inputs**:
    - `is_erased`: A pointer to an array of unsigned characters indicating which positions are erased (1 for erased, 0 for not erased).
    - `output`: A pointer to an array where the function will store the generated polynomial values.
- **Logic and Control Flow**:
    - Check if `FD_REEDSOL_ARITH_IMPL` is greater than 0 to determine if AVX instructions are used.
    - If `FD_REEDSOL_PI_USE_SHORT` is defined, load and convert `is_erased` data to 16-bit integers and perform FWHT on them.
    - Multiply the transformed data by precomputed twiddle factors and perform another FWHT to get `log_pi`.
    - Adjust the sign of `log_pi` based on erasure information and add a constant to ensure non-negative values.
    - Reduce `log_pi` modulo 255 using a specific formula to ensure values are within range.
    - Compact the `log_pi` values and compute the exponential using a pre-defined function [`exp_16`](<#exp_16>).
    - Store the computed polynomial values in the `output` buffer.
    - If `FD_REEDSOL_PI_USE_SHORT` is not defined, perform similar operations using 8-bit integer vectors.
    - If `FD_REEDSOL_ARITH_IMPL` is not greater than 0, call [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>) to handle the computation without AVX.
- **Output**: The function outputs a polynomial with zeros at the specified erasure points, stored in the `output` buffer as unsigned characters.
- **Functions Called**:
    - [`compact_ws`](<#compact_ws>)
    - [`exp_16`](<#exp_16>)
    - [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>)


---
### fd\_reedsol\_private\_gen\_pi\_128<!-- {{#callable:fd_reedsol_private_gen_pi_128}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L720>)

Generates a transformed output vector from an input vector indicating erased elements using the Fast Walsh-Hadamard Transform (FWHT) and modular arithmetic.
- **Inputs**:
    - `is_erased`: A pointer to an array of unsigned characters indicating which elements are erased.
    - `output`: A pointer to an array where the transformed output will be stored.
- **Logic and Control Flow**:
    - Check if `FD_REEDSOL_ARITH_IMPL` is greater than 0 to determine if AVX implementation is used.
    - If `FD_REEDSOL_PI_USE_SHORT` is defined, load and convert `is_erased` into vectors of shorts, otherwise load them as vectors of unsigned chars.
    - Perform the Fast Walsh-Hadamard Transform (FWHT) on the loaded vectors.
    - Multiply the transformed vectors by precomputed twiddle factors `fwht_l_twiddle_128` to get the product vectors.
    - Add a constant to the product vectors to prevent overflow and reduce them modulo 255.
    - Perform another FWHT on the product vectors to get `log_pi` vectors.
    - Negate elements in `log_pi` corresponding to erased elements to compute `1/Pi'`.
    - Add a constant to `log_pi` vectors and reduce them modulo 255.
    - Compact the `log_pi` vectors and compute the exponential using [`exp_4`](<#exp_4>).
    - Store the computed values in the `output` array.
- **Output**: The function outputs a transformed vector stored in the `output` array, representing the result of the FWHT and modular arithmetic operations on the input `is_erased` vector.
- **Functions Called**:
    - [`compact_ws`](<#compact_ws>)
    - [`exp_4`](<#exp_4>)
    - [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>)


---
### fd\_reedsol\_private\_gen\_pi\_256<!-- {{#callable:fd_reedsol_private_gen_pi_256}} -->
[View Source →](<../../../../../src/ballet/reedsol/fd_reedsol_pi.c#L917>)

Generates a polynomial with zeros at specified erasure points using the Fast Walsh-Hadamard Transform (FWHT) and stores the result in the output buffer.
- **Inputs**:
    - `is_erased`: A pointer to an array of unsigned characters indicating erasure points, where each element is either 0 (not erased) or 1 (erased).
    - `output`: A pointer to an array of unsigned characters where the function will store the generated polynomial values.
- **Logic and Control Flow**:
    - Check if `FD_REEDSOL_ARITH_IMPL` is greater than 0 to determine if AVX instructions are used.
    - If `FD_REEDSOL_PI_USE_SHORT` is defined, load and convert `is_erased` data into 16-bit vectors, otherwise use 8-bit vectors.
    - Perform the Fast Walsh-Hadamard Transform (FWHT) on the loaded vectors to transform the data.
    - Multiply the transformed data by precomputed twiddle factors (`fwht_l_twiddle_256`) to compute the product.
    - Reduce the product modulo 255 to prevent overflow in subsequent steps.
    - Compute the FWHT of the product and adjust signs based on erasure points to compute the inverse polynomial.
    - Reduce the result modulo 255 again to ensure values are within range.
    - Convert the result to exponential form and store it in the `output` buffer.
    - If AVX is not used, call [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>) to perform the same operations without AVX instructions.
- **Output**: The function outputs a polynomial with zeros at the specified erasure points, stored in the `output` buffer as an array of unsigned characters.
- **Functions Called**:
    - [`ws_mod255`](<#ws_mod255>)
    - [`compact_ws`](<#compact_ws>)
    - [`exp_2`](<#exp_2>)
    - [`gen_pi_noavx_generic`](<#gen_pi_noavx_generic>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)