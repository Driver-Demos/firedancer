<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for operations on G1 elements of the BN254 elliptic curve, including addition, doubling, and serialization.

# Purpose
The code provides a set of functions for operations on elliptic curve points in the BN254 curve, specifically for the G1 group. The functions include operations such as checking if a point is zero, setting a point to zero, converting a point to affine coordinates, and serializing a point to bytes. Additionally, the code includes functions for point addition, point doubling, mixed addition (where one point is in affine coordinates), and scalar multiplication. These operations are fundamental for cryptographic applications that use elliptic curves, such as digital signatures and key exchange protocols.

The code is organized as a C source file that likely complements a header file (`fd_bn254.h`) and is intended to be part of a larger library. It defines internal functions for manipulating points on the BN254 curve, which is a specific type of elliptic curve used in cryptography. The functions are designed to handle points in both affine and projective coordinates, optimizing for performance by using inline functions and conditional checks. The code also includes functions for converting points from byte arrays and checking subgroup membership, ensuring that points are valid and belong to the correct subgroup of the elliptic curve.
# Imports and Dependencies

---
- `./fd_bn254.h`


# Functions

---
### fd\_bn254\_g1\_is\_zero<!-- {{#callable:fd_bn254_g1_is_zero}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L5>)

Checks if a given point on the BN254 curve is the point at infinity by examining its Z-coordinate.
- **Inputs**:
    - `p`: A pointer to a `fd_bn254_g1_t` structure representing a point on the BN254 curve.
- **Logic and Control Flow**:
    - Calls the function `fd_bn254_fp_is_zero` with the Z-coordinate of the point `p`.
    - Returns the result of the `fd_bn254_fp_is_zero` function call.
- **Output**: An integer indicating whether the point `p` is the point at infinity (1 if true, 0 otherwise).


---
### fd\_bn254\_g1\_set<!-- {{#callable:fd_bn254_g1_set}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L10>)

Copies the coordinates of a point from one `fd_bn254_g1_t` structure to another.
- **Inputs**:
    - `r`: A pointer to the `fd_bn254_g1_t` structure where the point coordinates will be copied to.
    - `p`: A pointer to the `fd_bn254_g1_t` structure from which the point coordinates will be copied.
- **Logic and Control Flow**:
    - Calls `fd_bn254_fp_set` to copy the `X` coordinate from `p` to `r`.
    - Calls `fd_bn254_fp_set` to copy the `Y` coordinate from `p` to `r`.
    - Calls `fd_bn254_fp_set` to copy the `Z` coordinate from `p` to `r`.
    - Returns the pointer `r`.
- **Output**: Returns a pointer to the `fd_bn254_g1_t` structure `r` with the copied coordinates.


---
### fd\_bn254\_g1\_set\_zero<!-- {{#callable:fd_bn254_g1_set_zero}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L19>)

Sets the `Z` coordinate of a `fd_bn254_g1_t` structure to zero, effectively setting the point to the point at infinity in projective coordinates.
- **Inputs**:
    - `r`: A pointer to a `fd_bn254_g1_t` structure that will be modified to represent the point at infinity.
- **Logic and Control Flow**:
    - Calls `fd_bn254_fp_set_zero` to set the `Z` coordinate of the `fd_bn254_g1_t` structure pointed to by `r` to zero.
    - Returns the pointer `r`.
- **Output**: Returns a pointer to the modified `fd_bn254_g1_t` structure, which now represents the point at infinity.


---
### fd\_bn254\_g1\_to\_affine<!-- {{#callable:fd_bn254_g1_to_affine}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L27>)

Converts a point on the BN254 curve from projective to affine coordinates.
- **Inputs**:
    - ``r``: A pointer to a `fd_bn254_g1_t` structure where the result will be stored.
    - ``p``: A constant pointer to a `fd_bn254_g1_t` structure representing the point to convert.
- **Logic and Control Flow**:
    - Check if the `Z` coordinate of `p` is zero or one using `fd_bn254_fp_is_zero` or `fd_bn254_fp_is_one`; if true, copy `p` to `r` using [`fd_bn254_g1_set`](<#fd_bn254_g1_set>) and return `r`.
    - Calculate the inverse of `p->Z` and store it in `iz` using `fd_bn254_fp_inv`.
    - Square `iz` and store the result in `iz2` using `fd_bn254_fp_sqr`.
    - Multiply `p->X` by `iz2` and store the result in `r->X` using `fd_bn254_fp_mul`.
    - Multiply `p->Y` by `iz2`, then by `iz`, and store the result in `r->Y` using `fd_bn254_fp_mul`.
    - Set `r->Z` to one using `fd_bn254_fp_set_one`.
    - Return the pointer `r`.
- **Output**: A pointer to the `fd_bn254_g1_t` structure `r` containing the affine coordinates of the point.
- **Functions Called**:
    - [`fd_bn254_g1_set`](<#fd_bn254_g1_set>)


---
### fd\_bn254\_g1\_tobytes<!-- {{#callable:fd_bn254_g1_tobytes}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L46>)

Converts a point on the BN254 G1 curve to a 64-byte big-endian representation.
- **Inputs**:
    - `out`: A 64-byte array where the function will store the byte representation of the point.
    - `p`: A pointer to a `fd_bn254_g1_t` structure representing the point on the BN254 G1 curve to convert.
- **Logic and Control Flow**:
    - Check if the point `p` is the zero point using [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>); if true, set all 64 bytes of `out` to zero and return `out`.
    - Convert the point `p` to its affine coordinates using [`fd_bn254_g1_to_affine`](<#fd_bn254_g1_to_affine>).
    - Convert the X and Y coordinates from Montgomery form to standard form using `fd_bn254_fp_from_mont`.
    - Convert the X coordinate to a 32-byte big-endian representation and store it in the first 32 bytes of `out` using `fd_bn254_fp_tobytes_be_nm`.
    - Convert the Y coordinate to a 32-byte big-endian representation and store it in the last 32 bytes of `out` using `fd_bn254_fp_tobytes_be_nm`.
    - Return the `out` array.
- **Output**: A pointer to the `out` array containing the 64-byte big-endian representation of the point.
- **Functions Called**:
    - [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>)
    - [`fd_bn254_g1_to_affine`](<#fd_bn254_g1_to_affine>)


---
### fd\_bn254\_g1\_affine\_add<!-- {{#callable:fd_bn254_g1_affine_add}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L69>)

Computes the sum of two affine points on the BN254 curve and stores the result in affine coordinates.
- **Inputs**:
    - `r`: A pointer to an `fd_bn254_g1_t` structure where the result will be stored.
    - `p`: A constant pointer to an `fd_bn254_g1_t` structure representing the first point in affine coordinates.
    - `q`: A constant pointer to an `fd_bn254_g1_t` structure representing the second point in affine coordinates.
- **Logic and Control Flow**:
    - Check if point `p` is zero; if true, set `r` to `q` and return `r`.
    - Check if point `q` is zero; if true, set `r` to `p` and return `r`.
    - Declare temporary variables `lambda`, `x`, and `y` for intermediate calculations.
    - If `p->X` equals `q->X`, check if `p->Y` equals `q->Y` to determine if the points are equal or opposite.
    - If points are equal, compute the slope `lambda` for point doubling using the formula `lambda = 3 * x1^2 / (2 * y1)`.
    - If points are opposite, set `r` to zero and return `r`.
    - If `p->X` does not equal `q->X`, compute the slope `lambda` for point addition using the formula `lambda = (y1 - y2) / (x1 - x2)`.
    - Compute the new x-coordinate `x3` using the formula `x3 = lambda^2 - x1 - x2`.
    - Compute the new y-coordinate `y3` using the formula `y3 = lambda * (x1 - x3) - y1`.
    - Set the result point `r` with the computed `x3`, `y3`, and set `r->Z` to one.
    - Return the result point `r`.
- **Output**: A pointer to the `fd_bn254_g1_t` structure `r` containing the result of the addition in affine coordinates.
- **Functions Called**:
    - [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>)
    - [`fd_bn254_g1_set`](<#fd_bn254_g1_set>)
    - [`fd_bn254_g1_set_zero`](<#fd_bn254_g1_set_zero>)


---
### fd\_bn254\_g1\_dbl<!-- {{#callable:fd_bn254_g1_dbl}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L125>)

Computes the doubling of a point on the BN254 curve in Jacobian coordinates.
- **Inputs**:
    - `r`: A pointer to a `fd_bn254_g1_t` structure where the result will be stored.
    - `p`: A constant pointer to a `fd_bn254_g1_t` structure representing the point to be doubled.
- **Logic and Control Flow**:
    - Check if the input point `p` is zero using [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>); if true, set the result `r` to zero using [`fd_bn254_g1_set_zero`](<#fd_bn254_g1_set_zero>) and return `r`.
    - Compute the square of the X, Y, and Z coordinates of `p`, storing them in `xx`, `yy`, and `zz` respectively.
    - Compute `y4` as the square of `yy`.
    - Calculate `s` as `2 * ((X1 + YY)^2 - XX - YYYY)` using a series of additions, subtractions, and squarings.
    - Calculate `m` as `3 * XX` since `a` is zero in this context.
    - Compute the new X coordinate `X3` as `M^2 - 2 * S` and store it in `r->X`.
    - Compute the new Z coordinate `Z3` as `(Y1 + Z1)^2 - YY - ZZ` and store it in `r->Z`.
    - Compute the new Y coordinate `Y3` as `M * (S - T) - 8 * YYYY` and store it in `r->Y`.
    - Return the result `r`.
- **Output**: A pointer to the `fd_bn254_g1_t` structure `r` containing the doubled point.
- **Functions Called**:
    - [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>)
    - [`fd_bn254_g1_set_zero`](<#fd_bn254_g1_set_zero>)


---
### fd\_bn254\_g1\_add\_mixed<!-- {{#callable:fd_bn254_g1_add_mixed}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L176>)

Computes the sum of two elliptic curve points `p` and `q` in mixed Jacobian-affine coordinates, where `q` is affine.
- **Inputs**:
    - `r`: A pointer to an `fd_bn254_g1_t` structure where the result will be stored.
    - `p`: A pointer to a constant `fd_bn254_g1_t` structure representing the first point in Jacobian coordinates.
    - `q`: A pointer to a constant `fd_bn254_g1_t` structure representing the second point in affine coordinates (i.e., `q->Z == 1`).
- **Logic and Control Flow**:
    - Check if `p` is the point at infinity using [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>); if true, set `r` to `q` using [`fd_bn254_g1_set`](<#fd_bn254_g1_set>) and return `r`.
    - Compute `Z1Z1` as the square of `p->Z`.
    - Compute `U2` as the product of `q->X` and `Z1Z1`.
    - Compute `S2` as the product of `q->Y`, `p->Z`, and `Z1Z1`.
    - Check if `p` and `q` are equal by comparing `U2` with `p->X` and `S2` with `p->Y`; if true, double `p` using [`fd_bn254_g1_dbl`](<#fd_bn254_g1_dbl>) and return the result.
    - Compute `H` as the difference between `U2` and `p->X`.
    - Compute `HH` as the square of `H`.
    - Compute `I` as four times `HH`.
    - Compute `J` as the product of `H` and `I`.
    - Compute `r` as twice the difference between `S2` and `p->Y`.
    - Compute `V` as the product of `p->X` and `I`.
    - Compute `r->X` as the square of `r`, subtract `J`, and subtract twice `V`.
    - Compute `i` as twice the product of `p->Y` and `J`.
    - Compute `r->Y` as the product of `r` and the difference between `V` and `r->X`, then subtract `i`.
    - Compute `r->Z` as the square of the sum of `p->Z` and `H`, then subtract `Z1Z1` and `HH`.
    - Return `r`.
- **Output**: A pointer to the `fd_bn254_g1_t` structure `r` containing the result of the addition.
- **Functions Called**:
    - [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>)
    - [`fd_bn254_g1_set`](<#fd_bn254_g1_set>)
    - [`fd_bn254_g1_dbl`](<#fd_bn254_g1_dbl>)


---
### fd\_bn254\_g1\_scalar\_mul<!-- {{#callable:fd_bn254_g1_scalar_mul}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L238>)

Computes the scalar multiplication of a point on the BN254 curve in affine coordinates.
- **Inputs**:
    - ``r``: A pointer to an `fd_bn254_g1_t` structure where the result will be stored.
    - ``p``: A constant pointer to an `fd_bn254_g1_t` structure representing the point to be multiplied, assumed to be in affine coordinates (i.e., `p->Z == 1`).
    - ``s``: A constant pointer to an `fd_bn254_scalar_t` structure representing the scalar by which the point `p` is multiplied.
- **Logic and Control Flow**:
    - Initialize `i` to 255 and decrement it until a set bit is found in the scalar `s` or `i` becomes negative.
    - If no set bit is found (`i < 0`), set `r` to the zero point using [`fd_bn254_g1_set_zero`](<#fd_bn254_g1_set_zero>) and return `r`.
    - Set `r` to the value of `p` using [`fd_bn254_g1_set`](<#fd_bn254_g1_set>).
    - Iterate from `i-1` down to 0, doubling `r` using [`fd_bn254_g1_dbl`](<#fd_bn254_g1_dbl>) in each iteration.
    - If the current bit of `s` is set, add `p` to `r` using [`fd_bn254_g1_add_mixed`](<#fd_bn254_g1_add_mixed>).
    - Return the result stored in `r`.
- **Output**: A pointer to the `fd_bn254_g1_t` structure `r`, which contains the result of the scalar multiplication.
- **Functions Called**:
    - [`fd_bn254_g1_set_zero`](<#fd_bn254_g1_set_zero>)
    - [`fd_bn254_g1_set`](<#fd_bn254_g1_set>)
    - [`fd_bn254_g1_dbl`](<#fd_bn254_g1_dbl>)
    - [`fd_bn254_g1_add_mixed`](<#fd_bn254_g1_add_mixed>)


---
### fd\_bn254\_g1\_frombytes\_internal<!-- {{#callable:fd_bn254_g1_frombytes_internal}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L261>)

Extracts the x and y coordinates from a byte array and performs basic checks to initialize a point on the BN254 G1 curve.
- **Inputs**:
    - `p`: A pointer to a `fd_bn254_g1_t` structure where the function will store the resulting point.
    - `in`: A constant byte array of size 64 that contains the serialized x and y coordinates of the point.
- **Logic and Control Flow**:
    - Check if the input byte array `in` is all zeros; if true, set the point `p` to the point at infinity and return `p`.
    - Attempt to deserialize the first 32 bytes of `in` into the x-coordinate of `p` using `fd_bn254_fp_frombytes_be_nm`; if this fails, return `NULL`.
    - Attempt to deserialize the next 32 bytes of `in` into the y-coordinate of `p` and check flags using `fd_bn254_fp_frombytes_be_nm`; if this fails, return `NULL`.
    - If the deserialization of the y-coordinate indicates the point is at infinity, set `p` to the point at infinity and return `p`.
    - Set the z-coordinate of `p` to one, indicating the point is in affine coordinates, and return `p`.
- **Output**: Returns a pointer to the initialized `fd_bn254_g1_t` structure `p`, or `NULL` if the input is invalid.
- **Functions Called**:
    - [`fd_bn254_g1_set_zero`](<#fd_bn254_g1_set_zero>)


---
### fd\_bn254\_g1\_frombytes\_check\_subgroup<!-- {{#callable:fd_bn254_g1_frombytes_check_subgroup}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254_g1.c#L290>)

Converts a byte array to a `fd_bn254_g1_t` point and checks if it belongs to the subgroup.
- **Inputs**:
    - `p`: A pointer to a `fd_bn254_g1_t` structure where the function will store the resulting point.
    - `in`: A 64-byte array representing the input data to convert into a point.
- **Logic and Control Flow**:
    - Call [`fd_bn254_g1_frombytes_internal`](<#fd_bn254_g1_frombytes_internal>) to convert the byte array `in` to a point `p` and check for errors.
    - If the conversion fails, return `NULL`.
    - Check if the point `p` is zero using [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>); if true, return `p`.
    - Convert the coordinates `X` and `Y` of `p` to Montgomery form using `fd_bn254_fp_to_mont`.
    - Set the `Z` coordinate of `p` to one using `fd_bn254_fp_set_one`.
    - Compute `y^2` and `x^3 + b` to verify the curve equation `y^2 = x^3 + b`.
    - If the curve equation does not hold, return `NULL`.
    - Return the point `p` as it belongs to the subgroup.
- **Output**: A pointer to the `fd_bn254_g1_t` structure `p` if successful, or `NULL` if the conversion or checks fail.
- **Functions Called**:
    - [`fd_bn254_g1_frombytes_internal`](<#fd_bn254_g1_frombytes_internal>)
    - [`fd_bn254_g1_is_zero`](<#fd_bn254_g1_is_zero>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)