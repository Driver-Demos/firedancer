<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements compression, decompression, addition, scalar multiplication, and pairing checks for BN254 elliptic curve points.

# Purpose
The code provides functionality for operations on elliptic curve points over the BN254 curve, which is commonly used in cryptographic applications. It includes functions for compressing and decompressing points on the G1 and G2 subgroups of the BN254 curve. The compression functions, [`fd_bn254_g1_compress`](<#fd_bn254_g1_compress>) and [`fd_bn254_g2_compress`](<#fd_bn254_g2_compress>), reduce the size of the point representation by storing only the necessary information to reconstruct the point. The decompression functions, [`fd_bn254_g1_decompress`](<#fd_bn254_g1_decompress>) and [`fd_bn254_g2_decompress`](<#fd_bn254_g2_decompress>), restore the full point representation from the compressed form. These functions handle special cases such as points at infinity and ensure that the points are correctly serialized and deserialized.

Additionally, the code includes operations for adding points and performing scalar multiplication on the G1 subgroup, as well as a pairing check function. The [`fd_bn254_g1_add_syscall`](<#fd_bn254_g1_add_syscall>) function adds two points on the G1 subgroup and returns the result. The [`fd_bn254_g1_scalar_mul_syscall`](<#fd_bn254_g1_scalar_mul_syscall>) function performs scalar multiplication of a point on the G1 subgroup by a given scalar. The [`fd_bn254_pairing_is_one_syscall`](<#fd_bn254_pairing_is_one_syscall>) function checks if the pairing of a set of points results in the identity element, which is a common operation in cryptographic protocols. These functions validate inputs, handle special cases, and ensure that the operations are performed correctly according to the BN254 curve specifications.
# Imports and Dependencies

---
- `./fd_bn254_internal.h`
- `./fd_bn254_field.c`
- `./fd_bn254_field_ext.c`
- `./fd_bn254_g1.c`
- `./fd_bn254_g2.c`
- `./fd_bn254_pairing.c`


# Functions

---
### fd\_bn254\_g1\_compress<!-- {{#callable:fd_bn254_g1_compress}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L11>)

Compresses a 64-byte elliptic curve point into a 32-byte format, handling special cases for points at infinity and negative y-coordinates.
- **Inputs**:
    - `out`: A 32-byte array where the compressed point will be stored.
    - `in`: A 64-byte array representing the elliptic curve point to compress.
- **Logic and Control Flow**:
    - Initialize a `fd_bn254_g1_t` structure `p` to zero.
    - Convert the input bytes to an elliptic curve point using `fd_bn254_g1_frombytes_internal`; return `NULL` if conversion fails.
    - Check if the point is at infinity using `fd_bn254_g1_is_zero`.
    - Extract the infinity flag from the input.
    - If the point is at infinity, set the output to zero and set the infinity flag in the output if it is set in the input, then return the output.
    - Determine if the y-coordinate is negative using `fd_bn254_fp_is_neg_nm`.
    - Copy the first 32 bytes of the input to the output.
    - If the y-coordinate is negative, set the negative flag in the output.
    - Return the output.
- **Output**: A pointer to the 32-byte compressed point, or `NULL` if the input is invalid.


---
### fd\_bn254\_g1\_decompress<!-- {{#callable:fd_bn254_g1_decompress}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L42>)

Decompresses a compressed point on the BN254 G1 curve from 32 bytes to 64 bytes.
- **Inputs**:
    - `out`: A 64-byte array where the decompressed point will be stored.
    - `in`: A 32-byte array containing the compressed point to decompress.
- **Logic and Control Flow**:
    - Check if the input is all zeros; if true, set the output to all zeros and return it.
    - Convert the input bytes to a field element `x` and check for point at infinity and negative flag.
    - If the point is at infinity, set the output to all zeros and return it.
    - Convert `x` to Montgomery form, square it, multiply by `x`, and add the constant `b` to get `x^3 + b`.
    - Compute the square root of `x^3 + b` to get `y`; if it fails, return NULL.
    - Convert `y` from Montgomery form and adjust its sign if necessary.
    - Copy the input to the output, clear the flag bits, and append `y` to the output.
    - Return the output array.
- **Output**: A pointer to the 64-byte decompressed point, or NULL if decompression fails.


---
### fd\_bn254\_g2\_compress<!-- {{#callable:fd_bn254_g2_compress}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L87>)

Compresses a point on the BN254 G2 curve from 128 bytes to 64 bytes, handling special cases for points at infinity and negative Y coordinates.
- **Inputs**:
    - `out`: A 64-byte array where the compressed point will be stored.
    - `in`: A 128-byte array representing the point on the BN254 G2 curve to be compressed.
- **Logic and Control Flow**:
    - Initialize a `fd_bn254_g2_t` structure `p` to zero.
    - Convert the input bytes to a point on the BN254 G2 curve using `fd_bn254_g2_frombytes_internal`; return `NULL` if conversion fails.
    - Check if the point is at infinity using `fd_bn254_g2_is_zero`.
    - Extract the infinity flag from the input array.
    - If the point is at infinity, set the output array to zero and set the infinity flag in the output if it is set in the input, then return the output.
    - Otherwise, copy the first 64 bytes of the input to the output.
    - Check if the Y coordinate is negative using `fd_bn254_fp2_is_neg_nm`.
    - If the Y coordinate is negative, set the negative flag in the output.
    - Return the output array.
- **Output**: A pointer to the 64-byte compressed point, or `NULL` if the input cannot be converted to a point on the curve.


---
### fd\_bn254\_g2\_decompress<!-- {{#callable:fd_bn254_g2_decompress}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L116>)

Decompresses a compressed point on the BN254 G2 curve from 64 bytes to 128 bytes.
- **Inputs**:
    - `out`: A pointer to an array of 128 unsigned characters where the decompressed point will be stored.
    - `in`: A constant pointer to an array of 64 unsigned characters representing the compressed point.
- **Logic and Control Flow**:
    - Check if the input `in` is all zeros; if true, set `out` to all zeros and return `out`.
    - Initialize variables `x`, `x2`, `x3_plus_b`, and `y` for field operations, and flags `is_inf` and `is_neg`.
    - Convert the input bytes to a field element `x` and check for the point at infinity and negative flag; return `NULL` if conversion fails.
    - If the point is at infinity (`is_inf` is true), set `out` to represent the point at infinity and return `out`.
    - Convert `x` to Montgomery form, square it to get `x2`, and multiply by `x` to get `x3_plus_b`.
    - Add the constant `fd_bn254_const_twist_b_mont` to `x3_plus_b`.
    - Compute the square root of `x3_plus_b` to get `y`; return `NULL` if the square root does not exist.
    - Convert `y` from Montgomery form back to normal form.
    - If the sign of `y` does not match the `is_neg` flag, negate `y`.
    - Copy the input `in` to the first 64 bytes of `out`, masking the first byte with `FLAG_MASK`.
    - Convert `y` to bytes and store it in the second half of `out`.
    - Return `out`.
- **Output**: A pointer to the `out` array containing the decompressed point, or `NULL` if an error occurs.


---
### fd\_bn254\_g1\_add\_syscall<!-- {{#callable:fd_bn254_g1_add_syscall}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L162>)

Adds two elliptic curve points from the BN254 curve and outputs the result.
- **Inputs**:
    - ``out``: A 64-byte array where the function will store the serialized result of the point addition.
    - ``in``: A pointer to an array of bytes containing the serialized input points, expected to be 128 bytes long.
    - ``in_sz``: The size of the input array `in`, which should not exceed 128 bytes.
- **Logic and Control Flow**:
    - Check if `in_sz` is greater than 128 bytes; if so, return -1.
    - Initialize a 128-byte buffer `buf` with zeros and copy the input data into it.
    - Declare three elliptic curve point variables `r`, `a`, and `b`.
    - Deserialize and validate the first point from the first 64 bytes of `buf` into `a`; return -1 if validation fails.
    - Deserialize and validate the second point from the next 64 bytes of `buf` into `b`; return -1 if validation fails.
    - Add the two points `a` and `b` using `fd_bn254_g1_affine_add` and store the result in `r`.
    - Serialize the result point `r` into the `out` array.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success, or -1 if the input size is invalid or if point validation fails.


---
### fd\_bn254\_g1\_scalar\_mul\_syscall<!-- {{#callable:fd_bn254_g1_scalar_mul_syscall}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L188>)

Performs scalar multiplication on a point in the BN254 G1 group and outputs the result.
- **Inputs**:
    - `out`: A 64-byte array to store the serialized result of the scalar multiplication.
    - `in`: A constant input array containing the point and scalar, expected to be 96 bytes long.
    - `in_sz`: The size of the input array, used to check if it exceeds the expected size.
    - `check_correct_sz`: A flag to determine whether to check the input size against 96 or 128 bytes.
- **Logic and Control Flow**:
    - Determine the expected input size (`check_sz`) based on `check_correct_sz` flag (96 or 128 bytes).
    - If `in_sz` exceeds `check_sz`, return -1 indicating an error.
    - Initialize a 96-byte buffer `buf` with zeros and copy the input data into it, up to 96 bytes.
    - Validate the point in the input by checking its subgroup membership using `fd_bn254_g1_frombytes_check_subgroup`.
    - If the point is invalid, return -1 indicating an error.
    - Convert the scalar from big-endian format using `fd_uint256_bswap`.
    - Perform scalar multiplication on the point using `fd_bn254_g1_scalar_mul`.
    - Serialize the result into the `out` array using `fd_bn254_g1_tobytes`.
    - Return 0 to indicate successful execution.
- **Output**: Returns 0 on success, or -1 if the input size is incorrect or the point is invalid.


---
### fd\_bn254\_pairing\_is\_one\_syscall<!-- {{#callable:fd_bn254_pairing_is_one_syscall}} -->
[View Source →](<../../../../../src/ballet/bn254/fd_bn254.c#L222>)

Checks if the result of a pairing operation on elliptic curve points is equal to one and outputs the result as a serialized big-endian integer.
- **Inputs**:
    - `out`: A 32-byte array where the function will store the result of the pairing check, serialized as a big-endian integer.
    - `in`: An array of bytes representing serialized elliptic curve points for the pairing operation.
    - `in_sz`: The size of the input array `in`, which should be a multiple of 192.
- **Logic and Control Flow**:
    - Calculate the number of elements by dividing `in_sz` by 192.
    - Initialize arrays `p` and `q` to store G1 and G2 elliptic curve points, respectively.
    - Set the initial value of `r` to one using `fd_bn254_fp12_set_one`.
    - Iterate over each element, deserializing and checking subgroup membership for G1 and G2 points.
    - Skip pairs where either point is at infinity.
    - Aggregate results using the Miller loop and multiply into `r` when the batch size is reached or at the end of the loop.
    - Perform a final exponentiation on `r`.
    - Set the output to zero and update the last byte to one if `r` is equal to one.
- **Output**: Returns 0 on success, with `out` containing 0 or 1 serialized as a big-endian uint256, indicating whether the pairing result is one.



---
Made with ❤️ by [Driver](https://www.driver.ai/)