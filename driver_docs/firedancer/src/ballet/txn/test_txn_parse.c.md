<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for transaction parsing correctness, mutation, and performance using various transaction fixtures.

# Purpose
The code is a C program designed to test the parsing and validation of binary transaction data. It includes several binary transaction fixtures, each representing different scenarios such as transactions that never landed on a blockchain, transactions that did land on a mainnet, and transactions with specific characteristics like maximum size or invalid instructions. The program uses these fixtures to verify the correctness of transaction parsing by checking various attributes such as signature count, account addresses, and instruction data. It also includes tests for mutation and performance to ensure the robustness of the transaction parsing logic.

The program defines a main function that initializes the environment, runs correctness tests on the transactions, and measures the performance of the parsing function. It uses functions like `fd_txn_parse` to parse transactions and `FD_TEST` to assert expected outcomes. The code also includes mechanisms to handle memory safety, such as using red zones to detect buffer overflows. The program is structured to provide detailed feedback on the parsing process, including success and failure counts, and it logs performance metrics to help evaluate the efficiency of the parsing operations.
# Imports and Dependencies

---
- `fd_txn.h`
- `../../util/sanitize/fd_sanitize.h`


# Global Variables

---
### out\_buf
- **Type**: `uchar array`
- **Description**: `out_buf` is a global array of unsigned characters with a size defined by the sum of `FD_TXN_MAX_SZ` and `RED_ZONE_SZ`. It is used to store parsed transaction data and includes a red zone for memory safety checks.
- **Use**: Used to store the output of parsed transactions and to ensure memory safety by including a red zone.


---
### test\_buf
- **Type**: ``uchar[]``
- **Description**: An array of unsigned characters with a size defined by the macro `FD_TXN_MAX_SZ`. This array is used to store transaction data during parsing operations.
- **Use**: Used as a buffer to hold transaction data for parsing and validation in various test functions.


---
### payload\_c
- **Type**: ``uchar[]``
- **Description**: An array of unsigned characters with a size defined by `FD_TXN_MTU`. It is used to store a payload for transaction processing.
- **Use**: Used to hold and manipulate transaction payload data during parsing and testing operations.


---
### min\_okay
- **Type**: `uchar array`
- **Description**: An array of unsigned characters with a size defined by `FD_TXN_MTU`. It is used to store the minimum valid values for each byte in a transaction payload during mutation tests.
- **Use**: Used in the `test_mutate` function to define the lower bounds for valid transaction payload bytes.


---
### max\_okay
- **Type**: ``uchar[]``
- **Description**: An array of unsigned characters with a size defined by `FD_TXN_MTU`. It is used to store the maximum allowable values for each byte in a transaction payload during mutation testing.
- **Use**: Used in the `test_mutate` function to define the upper bounds for valid transaction payload bytes.


# Functions

---
### txn1\_correctness<!-- {{#callable:txn1_correctness}} -->
[View Source →](<../../../../../src/ballet/txn/test_txn_parse.c#L34>)

Validates the correctness of a parsed transaction against expected values and structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize `counters` to zero and define static arrays for expected signature and account bytes.
    - Parse `transaction1` using [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>) and store the result in `parsed`.
    - Check that the output size `out_sz` is non-zero, indicating successful parsing.
    - Verify that the `success_cnt` is 1 and `failure_cnt` is 0 in `counters`.
    - Confirm that the transaction version is `FD_TXN_VLEGACY` and the signature count is 4.
    - Retrieve signatures using [`fd_txn_get_signatures`](<fd_txn.h.md#fd_txn_get_signatures>) and verify each signature byte against `first_sig_byte`.
    - Ensure the message offset is correctly calculated based on signature offset and count.
    - Check the counts of readonly signed, readonly unsigned, and account addresses against expected values.
    - Verify each account address byte against `first_acct_byte`.
    - Confirm the recent blockhash offset value is 155.
    - Check that address table lookup, additional writable, and additional counts are zero.
    - Verify the instruction count is 7 and validate specific fields of the first, second, and seventh instructions.
    - Use `memcmp` to ensure the data of the first instruction matches `ix0_data`.
- **Output**: No output is returned; the function uses assertions to validate transaction correctness.
- **Functions Called**:
    - [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>)
    - [`fd_txn_get_signatures`](<fd_txn.h.md#fd_txn_get_signatures>)


---
### txn2\_correctness<!-- {{#callable:txn2_correctness}} -->
[View Source →](<../../../../../src/ballet/txn/test_txn_parse.c#L81>)

Validates the correctness of a parsed transaction by checking various transaction fields and their expected values.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize `fd_txn_parse_counters_t` structure `counters` to zero.
    - Define static arrays `first_sig_byte`, `first_acct_byte`, and `first_lut_writable` with specific byte values for validation.
    - Parse the transaction `transaction2` using [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>), storing the result in `parsed` and the size in `out_sz`.
    - Check that `out_sz` is non-zero, indicating successful parsing.
    - Verify that `counters.success_cnt` is 1 and `counters.failure_cnt` is 0, ensuring the transaction parsed successfully without errors.
    - Check that `parsed->transaction_version` is `FD_TXN_V0` and `parsed->signature_cnt` is 1.
    - Retrieve signatures using [`fd_txn_get_signatures`](<fd_txn.h.md#fd_txn_get_signatures>) and validate the first byte of each signature against `first_sig_byte`.
    - Ensure `parsed->message_off` is correctly calculated based on signature offsets and counts.
    - Validate account address count and specific bytes in `transaction2` against `first_acct_byte`.
    - Check various transaction fields such as `readonly_signed_cnt`, `readonly_unsigned_cnt`, `acct_addr_cnt`, `recent_blockhash_off`, `addr_table_lookup_cnt`, `addr_table_adtl_writable_cnt`, `addr_table_adtl_cnt`, and `instr_cnt` against expected values.
    - Iterate over instructions in `parsed->instr` and validate fields like `program_id`, `acct_cnt`, `data_sz`, and specific bytes in `transaction2`.
    - Retrieve address tables using [`fd_txn_get_address_tables_const`](<fd_txn.h.md#fd_txn_get_address_tables_const>) and validate fields like `addr_off`, `writable_cnt`, `readonly_cnt`, and specific bytes in `transaction2` against `first_lut_writable`.
- **Output**: No output is returned; the function performs validation checks using assertions.
- **Functions Called**:
    - [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>)
    - [`fd_txn_get_signatures`](<fd_txn.h.md#fd_txn_get_signatures>)
    - [`fd_txn_get_address_tables_const`](<fd_txn.h.md#fd_txn_get_address_tables_const>)


---
### test\_mutate<!-- {{#callable:test_mutate}} -->
[View Source →](<../../../../../src/ballet/txn/test_txn_parse.c#L141>)

Tests the mutation of a transaction payload to ensure its validity and robustness against changes.
- **Inputs**:
    - `payload`: A pointer to the transaction payload data to be tested.
    - `len`: The length of the transaction payload data.
- **Logic and Control Flow**:
    - Initialize `fd_txn_parse_counters_t` structure `counters` to zero.
    - Copy the input `payload` to `payload_c`.
    - Parse the transaction from `payload_c` into `out_buf` and check the output size `out_sz`.
    - Calculate the transaction footprint and verify it matches `out_sz`.
    - Get constant address tables from the parsed transaction.
    - Initialize `min_okay` and `max_okay` arrays with the payload data.
    - Define macro `MUT_OKAY` to set ranges for valid byte values in the payload.
    - Set valid ranges for various parts of the transaction using `MUT_OKAY` and direct assignments.
    - Modify instruction data and account references in `payload_c` to test robustness against changes.
    - Parse the modified `payload_c` and verify it matches the original parsed transaction.
    - Iterate over each byte in `payload_c` to test truncated versions and mutations.
    - For each byte, test all possible mutations and verify the parsed transaction's validity.
    - Check that the success and failure counters match expected values.
- **Output**: No return value; the function performs tests and uses assertions to validate transaction parsing and mutation.
- **Functions Called**:
    - [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>)
    - [`fd_txn_footprint`](<fd_txn.h.md#fd_txn_footprint>)
    - [`fd_txn_get_address_tables_const`](<fd_txn.h.md#fd_txn_get_address_tables_const>)


---
### test\_performance<!-- {{#callable:test_performance}} -->
[View Source →](<../../../../../src/ballet/txn/test_txn_parse.c#L224>)

Measures the average time taken to parse a transaction payload a specified number of times.
- **Inputs**:
    - ``payload``: A pointer to the transaction data to be parsed.
    - ``sz``: The size of the transaction data in bytes.
- **Logic and Control Flow**:
    - Initialize `test_count` to 10,000,000, which is the number of times the parsing will be performed.
    - Record the start time using `fd_log_wallclock()`.
    - Iterate `test_count` times, parsing the transaction data with `fd_txn_parse()` and checking the result with `FD_TEST()`.
    - Record the end time using `fd_log_wallclock()`.
    - Calculate the average time per parse by dividing the total time by `test_count`.
    - Log the average time per parse in nanoseconds using `FD_LOG_NOTICE()`.
- **Output**: No return value; logs the average time per parse to the console.
- **Functions Called**:
    - [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>)


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/ballet/txn/test_txn_parse.c#L235>)

Initializes the environment, tests transaction correctness, performance, and mutation, and validates transaction parsing with memory safety checks.
- **Inputs**:
    - `argc`: The number of command-line arguments.
    - `argv`: An array of command-line argument strings.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with command-line arguments.
    - Creates and joins a random number generator using `fd_rng_new` and `fd_rng_join`.
    - Executes [`txn1_correctness`](<#txn1_correctness>) and [`txn2_correctness`](<#txn2_correctness>) to test the correctness of transactions 1 and 2.
    - Runs [`test_performance`](<#test_performance>) on transactions 1 and 2 to measure parsing performance.
    - Executes [`test_mutate`](<#test_mutate>) on transactions 1 and 2 to test mutation handling.
    - Sets a memory region to a specific value and poisons it for memory safety checks using `fd_memset` and `fd_asan_poison`.
    - Validates transaction parsing for transactions 3 to 6 using `FD_TEST` and [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>).
    - Unpoisons the memory region and checks its integrity.
    - Deletes the random number generator using `fd_rng_delete`.
    - Logs a success message and halts the program with `fd_halt`.
- **Output**: Returns 0 to indicate successful execution.
- **Functions Called**:
    - [`txn1_correctness`](<#txn1_correctness>)
    - [`txn2_correctness`](<#txn2_correctness>)
    - [`test_performance`](<#test_performance>)
    - [`test_mutate`](<#test_mutate>)
    - [`fd_txn_parse`](<fd_txn.h.md#fd_txn_parse>)
    - [`fd_txn_footprint`](<fd_txn.h.md#fd_txn_footprint>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)