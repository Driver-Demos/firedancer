<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements SHA-256 hashing functions with support for initialization, appending, and finalizing hashes.

# Purpose
The code is a C implementation of the SHA-256 cryptographic hash function. It provides functions to initialize, update, and finalize a SHA-256 hash computation. The code includes both a reference implementation and an optimized implementation that uses SIMD instructions if available. The primary functions include [`fd_sha256_init`](<#fd_sha256_init>), [`fd_sha256_append`](<#fd_sha256_append>), and [`fd_sha256_fini`](<#fd_sha256_fini>), which are used to process data incrementally. Additionally, the [`fd_sha256_hash`](<#fd_sha256_hash>) function provides a streamlined way to compute the hash of a data block in one step. The code also supports repeated hashing of 32-byte blocks with the [`fd_sha256_hash_32_repeated`](<#fd_sha256_hash_32_repeated>) function.

The file includes several utility functions for memory alignment and management, such as [`fd_sha256_align`](<#fd_sha256_align>), [`fd_sha256_footprint`](<#fd_sha256_footprint>), [`fd_sha256_new`](<#fd_sha256_new>), [`fd_sha256_join`](<#fd_sha256_join>), [`fd_sha256_leave`](<#fd_sha256_leave>), and [`fd_sha256_delete`](<#fd_sha256_delete>). These functions ensure that the memory used for SHA-256 computations is correctly aligned and managed. The code is designed to be used as part of a larger system, as indicated by the inclusion of headers like `fd_sha256.h` and `fd_sha256_constants.h`. The implementation is based on OpenSSL's SHA-256 code and is adapted for use in the Firedancer base machine model, allowing for potential high-performance optimizations.
# Imports and Dependencies

---
- `fd_sha256.h`
- `fd_sha256_constants.h`
- `../../util/simd/fd_sse.h`


# Functions

---
### fd\_sha256\_align<!-- {{#callable:fd_sha256_align}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L9>)

Returns the alignment requirement for SHA-256 operations.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the value of `FD_SHA256_ALIGN`.
- **Output**: An `ulong` representing the alignment requirement for SHA-256 operations.


---
### fd\_sha256\_footprint<!-- {{#callable:fd_sha256_footprint}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L14>)

Returns the constant `FD_SHA256_FOOTPRINT`.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the value of `FD_SHA256_FOOTPRINT`.
- **Output**: The function returns an `ulong` representing the SHA-256 footprint constant.


---
### fd\_sha256\_new<!-- {{#callable:fd_sha256_new}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L19>)

Initializes a new SHA-256 context in shared memory.
- **Inputs**:
    - `shmem`: A pointer to the shared memory where the SHA-256 context will be initialized.
- **Logic and Control Flow**:
    - Cast `shmem` to a `fd_sha256_t` pointer named `sha`.
    - Check if `shmem` is NULL; if true, log a warning and return NULL.
    - Check if `shmem` is not aligned according to `fd_sha256_align()`; if true, log a warning and return NULL.
    - Get the footprint size using `fd_sha256_footprint()`.
    - Set the memory at `sha` to zero for the size of the footprint using `fd_memset()`.
    - Use `FD_COMPILER_MFENCE()` to ensure memory operations are completed.
    - Set `sha->magic` to `FD_SHA256_MAGIC` using `FD_VOLATILE`.
    - Use `FD_COMPILER_MFENCE()` again to ensure memory operations are completed.
    - Return the pointer to the initialized `sha`.
- **Output**: A pointer to the initialized SHA-256 context, or NULL if initialization fails.
- **Functions Called**:
    - [`fd_sha256_align`](<#fd_sha256_align>)
    - [`fd_sha256_footprint`](<#fd_sha256_footprint>)


---
### fd\_sha256\_join<!-- {{#callable:fd_sha256_join}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L44>)

Validates and returns a pointer to a `fd_sha256_t` structure if the input is non-null, properly aligned, and has a valid magic number.
- **Inputs**:
    - `shsha`: A pointer to a memory location that is expected to contain a `fd_sha256_t` structure.
- **Logic and Control Flow**:
    - Check if `shsha` is NULL; if true, log a warning and return NULL.
    - Check if `shsha` is aligned according to [`fd_sha256_align`](<#fd_sha256_align>); if not, log a warning and return NULL.
    - Cast `shsha` to a `fd_sha256_t` pointer and store it in `sha`.
    - Check if `sha->magic` equals `FD_SHA256_MAGIC`; if not, log a warning and return NULL.
    - Return the `sha` pointer.
- **Output**: A pointer to a `fd_sha256_t` structure if all checks pass, otherwise NULL.
- **Functions Called**:
    - [`fd_sha256_align`](<#fd_sha256_align>)


---
### fd\_sha256\_leave<!-- {{#callable:fd_sha256_leave}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L67>)

Returns the input `fd_sha256_t` pointer if it is not NULL, otherwise logs a warning and returns NULL.
- **Inputs**:
    - `sha`: A pointer to an `fd_sha256_t` structure, which represents the SHA-256 state.
- **Logic and Control Flow**:
    - Check if the `sha` pointer is NULL using `FD_UNLIKELY`; if it is NULL, log a warning with the message "NULL sha" and return NULL.
    - If `sha` is not NULL, cast it to a `void *` and return it.
- **Output**: A `void *` pointer to the `fd_sha256_t` structure if `sha` is not NULL, otherwise NULL.


---
### fd\_sha256\_delete<!-- {{#callable:fd_sha256_delete}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L78>)

Validates and deletes a SHA-256 context by checking its alignment and magic number, then resets its magic number to zero.
- **Inputs**:
    - `shsha`: A pointer to the SHA-256 context to be deleted.
- **Logic and Control Flow**:
    - Check if `shsha` is NULL; if true, log a warning and return NULL.
    - Check if `shsha` is aligned according to [`fd_sha256_align`](<#fd_sha256_align>); if not, log a warning and return NULL.
    - Cast `shsha` to `fd_sha256_t *` and store it in `sha`.
    - Check if `sha->magic` equals `FD_SHA256_MAGIC`; if not, log a warning and return NULL.
    - Use memory fences to ensure memory operations are completed before and after setting `sha->magic` to 0.
    - Return the pointer `sha` cast to `void *`.
- **Output**: A pointer to the deleted SHA-256 context, or NULL if any validation fails.
- **Functions Called**:
    - [`fd_sha256_align`](<#fd_sha256_align>)


---
### fd\_sha256\_core\_ref<!-- {{#callable:fd_sha256_core_ref}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L134>)

Processes SHA-256 hash computation on a given block of data, updating the hash state for each block processed.
- **Inputs**:
    - `state`: A pointer to an array of 8 unsigned integers representing the current hash state.
    - `block`: A pointer to a constant array of unsigned characters representing the data block to process.
    - `block_cnt`: An unsigned long integer representing the number of blocks to process.
- **Logic and Control Flow**:
    - Defines several macros for bitwise operations and logical functions used in SHA-256 computation.
    - Casts the input block to an array of unsigned integers `W`.
    - Initializes working variables `a` to `h` with the current state values.
    - Processes the first 16 words of the block, performing byte swapping and updating the working variables using SHA-256 specific operations.
    - Continues processing for the remaining 48 words, updating the message schedule array `X` and the working variables.
    - Updates the hash state by adding the working variables `a` to `h` to the current state values.
    - Advances the block pointer `W` by 16 words and decrements the block count, repeating the process for each block.
- **Output**: Updates the `state` array with the new hash state after processing the specified number of blocks.


---
### fd\_sha256\_core\_shaext<!-- {{#callable:fd_sha256_core_shaext}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L277>)

Processes SHA-256 hash computation using SHA extensions for multiple data blocks.
- **Inputs**:
    - `state`: A pointer to an array of 8 unsigned integers representing the current hash state, which must be 64-byte aligned.
    - `block`: A pointer to the input data blocks, ideally 128-byte aligned, with a size of 64 bytes multiplied by `block_cnt`.
    - `block_cnt`: The number of 64-byte blocks to process, which must be a positive integer.
- **Logic and Control Flow**:
    - Load the initial state into two vector registers `stateABCD` and `stateEFGH`.
    - Permute the state vectors to create `baseFEBA` and `baseHGDC`.
    - Iterate over each block, initializing `stateFEBA` and `stateHGDC` with `baseFEBA` and `baseHGDC`.
    - Load and byte-swap four 16-byte segments from the current block.
    - Perform four rounds of SHA-256 operations using the `FOUR_ROUNDS` macro for each segment and subsequent computed segments using the `NEXT_W` macro.
    - Update `baseFEBA` and `baseHGDC` by adding the current `stateFEBA` and `stateHGDC`.
    - After processing all blocks, permute the final state vectors and store them back into the `state` array.
- **Output**: The function updates the `state` array with the new hash state after processing the specified number of blocks.


---
### fd\_sha256\_init<!-- {{#callable:fd_sha256_init}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L330>)

Initializes the SHA-256 state with predefined constants and resets buffer usage and bit count.
- **Inputs**:
    - `sha`: A pointer to an `fd_sha256_t` structure that holds the SHA-256 state.
- **Logic and Control Flow**:
    - Set `sha->state[0]` to `FD_SHA256_INITIAL_A`.
    - Set `sha->state[1]` to `FD_SHA256_INITIAL_B`.
    - Set `sha->state[2]` to `FD_SHA256_INITIAL_C`.
    - Set `sha->state[3]` to `FD_SHA256_INITIAL_D`.
    - Set `sha->state[4]` to `FD_SHA256_INITIAL_E`.
    - Set `sha->state[5]` to `FD_SHA256_INITIAL_F`.
    - Set `sha->state[6]` to `FD_SHA256_INITIAL_G`.
    - Set `sha->state[7]` to `FD_SHA256_INITIAL_H`.
    - Set `sha->buf_used` to `0UL`.
    - Set `sha->bit_cnt` to `0UL`.
    - Return the pointer `sha`.
- **Output**: Returns the pointer to the initialized `fd_sha256_t` structure.


---
### fd\_sha256\_append<!-- {{#callable:fd_sha256_append}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L345>)

Appends data to an ongoing SHA-256 hash computation, updating the internal state and buffer as needed.
- **Inputs**:
    - `sha`: A pointer to an `fd_sha256_t` structure representing the current state of the SHA-256 computation.
    - `_data`: A pointer to the data to append to the SHA-256 computation.
    - `sz`: The size in bytes of the data to append.
- **Logic and Control Flow**:
    - Check if `sz` is zero; if so, return `sha` immediately as there is no data to append.
    - Unpack the internal state, buffer, and counters from the `sha` structure.
    - Update the `bit_cnt` by adding the number of bits in the new data (`sz << 3`).
    - If there are buffered bytes from previous appends, check if the new data can complete the current block.
    - If the new data is not enough to complete the block, copy it to the buffer, update `buf_used`, and return `sha`.
    - If the block can be completed, copy enough data to complete the block, process it with `fd_sha256_core`, and reset `buf_used`.
    - Process the bulk of the new data in blocks using `fd_sha256_core`.
    - Buffer any leftover bytes that do not form a complete block, update `buf_used`, and return `sha`.
- **Output**: Returns a pointer to the updated `fd_sha256_t` structure.


---
### fd\_sha256\_fini<!-- {{#callable:fd_sha256_fini}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L411>)

Finalizes the SHA-256 hash computation by processing any remaining data and storing the result in the provided buffer.
- **Inputs**:
    - `sha`: A pointer to an `fd_sha256_t` structure containing the current state of the SHA-256 computation.
    - `_hash`: A pointer to a buffer where the final hash value will be stored.
- **Logic and Control Flow**:
    - Unpack the inputs from the `fd_sha256_t` structure, including `state`, `buf`, `buf_used`, and `bit_cnt`.
    - Append the terminating message byte `0x80` to the buffer and increment `buf_used`.
    - Check if there is enough space to store the message length in bits at the end of the buffer; if not, clear the rest of the buffer, update the hash with `fd_sha256_core`, and reset `buf_used`.
    - Clear the buffer up to the last 64 bits, append the message size in bits to the last 64 bits, and update the hash with `fd_sha256_core`.
    - Perform byte swaps on the `state` array to convert the hash to big-endian format.
    - Copy the final hash value from `state` to the `_hash` buffer using `memcpy`.
- **Output**: Returns a pointer to the `_hash` buffer containing the finalized SHA-256 hash value.


---
### fd\_sha256\_hash<!-- {{#callable:fd_sha256_hash}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L458>)

Computes the SHA-256 hash of the given data.
- **Inputs**:
    - `_data`: Pointer to the input data to hash.
    - `sz`: Size of the input data in bytes.
    - `_hash`: Pointer to the buffer where the resulting hash will be stored.
- **Logic and Control Flow**:
    - Initialize the SHA-256 state with predefined constants.
    - Calculate the number of complete blocks in the input data and process them using `fd_sha256_core`.
    - Copy any remaining data into a buffer, append the padding byte `0x80`, and handle cases where the buffer is nearly full.
    - Calculate the total bit count of the input data and store it in the buffer in big-endian format.
    - Process the final block with `fd_sha256_core`.
    - Perform byte swapping on the state to convert it to big-endian format.
    - Copy the final hash value from the state to the output buffer.
- **Output**: Returns a pointer to the buffer containing the 32-byte SHA-256 hash.


---
### fd\_sha256\_hash\_32\_repeated<!-- {{#callable:fd_sha256_hash_32_repeated}} -->
[View Source →](<../../../../../src/ballet/sha256/fd_sha256.c#L511>)

Computes the SHA-256 hash of a 32-byte input repeatedly for a specified number of iterations.
- **Inputs**:
    - `_data`: A pointer to the input data, expected to be 32 bytes in size.
    - `_hash`: A pointer to the memory location where the resulting hash will be stored.
    - `cnt`: The number of times the hash computation should be repeated.
- **Logic and Control Flow**:
    - If `FD_HAS_SHANI` is defined, use SIMD instructions for optimized SHA-256 computation.
    - Load the input data into two 128-bit vectors, `w0003` and `w0407`, and initialize constants `w080b` and `w0c0f` for padding.
    - Initialize the state vectors `stateFEBA` and `stateHGDC` with predefined SHA-256 initial values.
    - For each iteration, perform a series of SHA-256 rounds using the `FOUR_ROUNDS` macro and update the state vectors.
    - After all iterations, store the final state vectors into the `hash` output after byte-swapping.
    - If `FD_HAS_SHANI` is not defined, use a buffer to prepare the input data with padding and bit count.
    - Initialize the state array with SHA-256 initial values and call `fd_sha256_core` for each iteration.
    - Byte-swap the state array and copy the result to the `hash` output.
- **Output**: Returns a pointer to the `hash` where the final 32-byte SHA-256 hash is stored.



---
Made with ❤️ by [Driver](https://www.driver.ai/)