<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implementation of uint256 Montgomery multiplication and utility functions for field arithmetic.

# Purpose
The code is a C implementation for arithmetic operations on 256-bit unsigned integers, specifically focusing on Montgomery multiplication. It is part of a larger library intended for cryptographic computations, as indicated by references to field arithmetic for elliptic curves like `bn254`, `ed25519`, and `secp256k1`. The file includes utility functions for operations such as subtraction with borrow and vector multiplication, which are optimized for different architectures, including x86 and systems with 128-bit integer support.

The primary function, `fd_uint256_mul_mod_p`, performs Montgomery multiplication using the Coarsely Integrated Operand Scanning (CIOS) method. This function is designed to be efficient for moduli less than \(2^{255}\) and is intended to be wrapped by specific field multiplication functions. The code includes macros to ensure inlining and loop unrolling for performance optimization, particularly when compiled with GCC. The file is not meant to be included directly; instead, it should be accessed through a header file, as indicated by the initial preprocessor directive.
# Imports and Dependencies

---
- `x86intrin.h`


# Functions

---
### fd\_ulong\_sub\_borrow<!-- {{#callable:fd_ulong_sub_borrow}} -->
[View Source →](<../../../../../src/ballet/bigint/fd_uint256_mul.h#L37>)

Subtracts two unsigned long integers with an optional borrow and sets a borrow flag if needed.
- **Inputs**:
    - `r`: Pointer to an unsigned long where the result of the subtraction (a0 - a1) will be stored.
    - `b`: Pointer to an integer where the borrow flag will be stored; it indicates if a borrow occurred during the subtraction.
    - `a0`: The minuend, an unsigned long integer.
    - `a1`: The subtrahend, an unsigned long integer.
    - `bi`: An integer representing the initial borrow flag; if non-zero, it indicates that a borrow is already in effect before the subtraction.
- **Logic and Control Flow**:
    - If the macro `FD_HAS_X86` is defined, use the intrinsic `_subborrow_u64` to perform the subtraction with borrow, storing the result in `r` and the borrow flag in `b`.
    - If `FD_HAS_X86` is not defined, increment `a1` by 1 if `bi` is non-zero to account for the initial borrow.
    - Subtract `a1` from `a0` and store the result in `r`.
    - Set the borrow flag `b` to 1 if `a0` is less than `a1`, otherwise set it to 0.
- **Output**: The function does not return a value, but it outputs the result of the subtraction in `r` and the borrow flag in `b`.


---
### fd\_ulong\_vec\_mul<!-- {{#callable:fd_ulong_vec_mul}} -->
[View Source →](<../../../../../src/ballet/bigint/fd_uint256_mul.h#L93>)

Performs element-wise multiplication of a 4-element vector by a scalar, storing the lower and higher 64-bit results separately.
- **Inputs**:
    - `l`: An array of 4 unsigned long integers to store the lower 64 bits of the multiplication results.
    - `h`: An array of 4 unsigned long integers to store the higher 64 bits of the multiplication results.
    - `a`: A constant array of 4 unsigned long integers representing the vector to be multiplied.
    - `b`: An unsigned long integer representing the scalar multiplier.
- **Logic and Control Flow**:
    - Call [`fd_ulong_mul128`](<#fd_ulong_mul128>) for each element of the vector `a` with the scalar `b`, storing the lower 64 bits of the result in the corresponding index of `l` and the higher 64 bits in `h`.
- **Output**: No return value; results are stored in the `l` and `h` arrays.
- **Functions Called**:
    - [`fd_ulong_mul128`](<#fd_ulong_mul128>)


---
### fd\_ulong\_add\_carry4<!-- {{#callable:fd_ulong_add_carry4}} -->
[View Source →](<../../../../../src/ballet/bigint/fd_uint256_mul.h#L101>)

Adds four unsigned long integers with carry handling and stores the result and carry.
- **Inputs**:
    - ``l``: Pointer to store the lower part of the result.
    - ``h``: Pointer to store the carry as an unsigned char.
    - ``a0``: First unsigned long integer to add.
    - ``a1``: Second unsigned long integer to add.
    - ``a2``: Third unsigned long integer to add.
    - ``a3``: Fourth unsigned char to add.
- **Logic and Control Flow**:
    - Calculate `r0` as the sum of `a0` and `a1`, and determine if there is a carry `c0` by checking if `r0` is less than `a0`.
    - Calculate `r1` as the sum of `a2` and `a3`, and determine if there is a carry `c1` by checking if `r1` is less than `a2`.
    - Store the sum of `r0` and `r1` in `*l`.
    - Calculate the total carry `*h` by checking if `*l` is less than `r0` and adding `c0` and `c1`.
- **Output**: Stores the lower part of the sum in `*l` and the carry in `*h`.


---
### fd\_ulong\_mul128<!-- {{#callable:fd_ulong_mul128}} -->
[View Source →](<../../../../../src/ballet/bigint/fd_uint256_mul.h#L77>)

Performs a 128-bit multiplication of two 64-bit unsigned integers and stores the result in two 64-bit unsigned integers representing the lower and upper parts of the product.
- **Inputs**:
    - `l`: Pointer to a `ulong` where the lower 64 bits of the product will be stored.
    - `h`: Pointer to a `ulong` where the upper 64 bits of the product will be stored.
    - `a`: First 64-bit unsigned integer operand.
    - `b`: Second 64-bit unsigned integer operand.
- **Logic and Control Flow**:
    - Calculate the product of the lower 32 bits of `a` and `b`, storing the result in `lo_lo`.
    - Calculate the product of the upper 32 bits of `a` and the lower 32 bits of `b`, storing the result in `hi_lo`.
    - Calculate the product of the lower 32 bits of `a` and the upper 32 bits of `b`, storing the result in `lo_hi`.
    - Calculate the product of the upper 32 bits of `a` and `b`, storing the result in `hi_hi`.
    - Compute the cross product sum `cross` by adding the upper 32 bits of `lo_lo`, the lower 32 bits of `hi_lo`, and `lo_hi`.
    - Compute the upper part of the product `upper` by adding the upper 32 bits of `hi_lo`, the upper 32 bits of `cross`, and `hi_hi`.
    - Store `upper` in the location pointed to by `h`.
    - Store the lower 32 bits of `lo_lo` combined with the shifted `cross` in the location pointed to by `l`.
- **Output**: The function outputs the lower and upper 64 bits of the 128-bit product through the pointers `l` and `h`, respectively.



---
Made with ❤️ by [Driver](https://www.driver.ai/)