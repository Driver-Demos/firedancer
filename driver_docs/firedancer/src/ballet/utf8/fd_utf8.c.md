<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

A basic UTF-8 validator imported from Rust, with a function to verify UTF-8 string validity.

# Purpose
The code is a C implementation of a UTF-8 string validator. It includes a static array, `fd_utf8_char_width`, which maps each byte value to the expected width of a UTF-8 character. The function [`fd_utf8_verify`](<#fd_utf8_verify>) checks if a given string is valid UTF-8. It takes a pointer to a character string and its size as input parameters. The function iterates over the string, using the `fd_utf8_char_width` array to determine the number of bytes that should follow a leading byte in a UTF-8 sequence. It validates the sequence based on UTF-8 encoding rules, returning 1 if the string is valid and 0 if it is not.

The code is designed to handle different UTF-8 character widths, including 1-byte, 2-byte, 3-byte, and 4-byte sequences. It uses conditional checks to ensure that each byte in a multi-byte sequence falls within the valid range for that sequence. The function uses macros like `FD_UNLIKELY` to optimize branch prediction for error conditions. The code is intended to be part of a larger system, as indicated by the inclusion of the header file `fd_utf8.h`, and it does not define any public APIs or external interfaces. The comment suggests a future enhancement to add a high-performance AVX version of the validator.
# Imports and Dependencies

---
- `fd_utf8.h`


# Global Variables

---
### fd\_utf8\_char\_width
- **Type**: ``uchar const[256]``
- **Description**: Defines a lookup table that maps each possible byte value (0-255) to the width of the UTF-8 character it starts. The table uses values 0, 1, 2, 3, and 4 to indicate invalid bytes, single-byte characters, and the number of bytes in multi-byte characters, respectively.
- **Use**: Used to determine the number of bytes in a UTF-8 character based on its starting byte.


# Functions

---
### fd\_utf8\_verify<!-- {{#callable:fd_utf8_verify}} -->
[View Source →](<../../../../../src/ballet/utf8/fd_utf8.c#L27>)

Validates if a given string is a well-formed UTF-8 sequence.
- **Inputs**:
    - `str`: A pointer to the input string to validate.
    - `sz`: The size of the input string in bytes.
- **Logic and Control Flow**:
    - Initialize `cur` as a pointer to the start of the input string `str` and check if it is `NULL`; if so, return 1.
    - Set `end` as a pointer to the end of the string by adding `sz` to `cur`.
    - Iterate over the string from `cur` to `end`.
    - For each byte, check if it is a non-ASCII character (>= 0x80).
    - Determine the width of the UTF-8 character using `fd_utf8_char_width` and check if there are enough bytes remaining; if not, return 0.
    - For a width of 2, check the validity of the second byte; if invalid, return 0.
    - For a width of 3, check the validity of the second and third bytes; if invalid, return 0.
    - For a width of 4, check the validity of the second, third, and fourth bytes; if invalid, return 0.
    - If the byte is an ASCII character, increment `cur` by 1.
    - If all characters are valid, return 1.
- **Output**: Returns 1 if the string is a valid UTF-8 sequence, otherwise returns 0.



---
Made with ❤️ by [Driver](https://www.driver.ai/)