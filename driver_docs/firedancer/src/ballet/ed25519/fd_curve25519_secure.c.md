<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements secure constant-time operations for Curve25519, including scalar multiplication and table selection.

# Purpose
The code provides secure cryptographic operations related to the Curve25519 elliptic curve, specifically focusing on constant-time implementations to prevent side-channel attacks. It includes functions for scalar multiplication and point selection on the elliptic curve, ensuring that operations are performed in a manner that does not leak sensitive information through timing variations. The file conditionally includes different implementations based on the availability of AVX512 instructions, which can optimize performance on supported hardware.

Key components include the [`fd_ed25519_scalar_radix16`](<#fd_ed25519_scalar_radix16>) function, which converts a scalar into a radix-16 representation, and [`fd_ed25519_table_select`](<#fd_ed25519_table_select>), which selects pre-computed points from a table in constant time. The main function, `fd_ed25519_scalar_mul_base_const_time`, performs scalar multiplication of the base point on the elliptic curve, using the previously defined functions to ensure constant-time execution. The code also includes mechanisms to clear sensitive data from memory and registers after use, enhancing security. This file is intended to be part of a larger cryptographic library, providing secure operations for applications that require elliptic curve cryptography.
# Imports and Dependencies

---
- `fd_curve25519.h`
- `avx512/fd_curve25519_secure.c`
- `ref/fd_curve25519_secure.c`


# Functions

---
### fd\_ed25519\_scalar\_radix16<!-- {{#callable:fd_ed25519_scalar_radix16}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519_secure.c#L19>)

Converts a 32-byte scalar into a 64-entry array with values in the range [-8, 8] using radix-16 representation.
- **Inputs**:
    - `secret_e`: A 64-entry array of type `char` that will store the output values in the range [-8, 8].
    - `secret_a`: A 32-byte array of type `uchar` representing the input scalar, assumed to be valid.
    - `tmp_secret_carry`: A pointer to a `char` used to store carry values during computation.
- **Logic and Control Flow**:
    - Initialize `tmp_secret_carry` to 0.
    - Iterate over each byte of `secret_a` (32 iterations):
    - For each byte, split it into two 4-bit values and store them in consecutive positions in `secret_e`.
    - After the loop, `secret_e[0:62]` contains values in [0, 15] and `secret_e[63]` contains a value in [0, 7].
    - Iterate over the first 63 entries of `secret_e`:
    - Add `tmp_secret_carry` to the current entry of `secret_e`.
    - Calculate a new `tmp_secret_carry` by right-shifting the sum of the current entry and 8 by 4 bits.
    - Adjust the current entry of `secret_e` by subtracting the carry shifted left by 4 bits.
    - Add `tmp_secret_carry` to `secret_e[63]` after the loop.
- **Output**: The `secret_e` array is modified to contain the radix-16 representation of the input scalar with values in the range [-8, 8].


---
### const\_time\_eq<!-- {{#callable:const_time_eq}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519_secure.c#L42>)

Determines if two unsigned characters are equal in constant time, returning 1 if equal and 0 otherwise.
- **Inputs**:
    - `secret_a`: An unsigned character to compare.
    - `secret_b`: Another unsigned character to compare.
- **Logic and Control Flow**:
    - Compute the bitwise XOR of `secret_a` and `secret_b` to check for equality.
    - Subtract 1 from the result of the XOR operation, which will be 0 if the inputs are equal and non-zero otherwise.
    - Right shift the result by 31 bits to produce either 0 or 1, ensuring constant time execution.
- **Output**: Returns 1 if `secret_a` is equal to `secret_b`, otherwise returns 0.


---
### fd\_ed25519\_table\_select<!-- {{#callable:fd_ed25519_table_select}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519_secure.c#L64>)

Selects a precomputed point from a table based on a secret value, in constant time.
- **Inputs**:
    - `r`: A pointer to `fd_ed25519_point_t` where the selected point will be stored.
    - `tmp`: A pointer to `fd_ed25519_point_t` used as a temporary storage during selection.
    - `j`: An integer index for selecting the row in the precomputed table.
    - `secret`: A signed character representing the secret value used for selection, ranging from -8 to 7.
    - `tmp_secret_idx`: A pointer to an unsigned character where the computed index from the secret will be stored.
    - `tmp_secret_sgn`: A pointer to an unsigned character where the sign of the secret will be stored.
- **Logic and Control Flow**:
    - Compute the sign of `secret` and store it in `*tmp_secret_sgn` using bitwise operations.
    - Calculate the absolute index from `secret` and store it in `*tmp_secret_idx`.
    - Initialize `tmp` to zero using `fd_ed25519_point_set_zero_precomputed`.
    - Iterate over the precomputed table indices (0 to 7) and use [`fd_ed25519_point_if`](<ref/fd_curve25519_secure.c.md#fd_ed25519_point_if>) to conditionally select the point corresponding to `*tmp_secret_idx`.
    - Negate the selected point if `*tmp_secret_sgn` indicates a negative `secret`, using `fd_ed25519_point_neg_if`.
- **Output**: The function does not return a value but modifies the point `r` to store the selected precomputed point.
- **Functions Called**:
    - [`fd_ed25519_point_if`](<ref/fd_curve25519_secure.c.md#fd_ed25519_point_if>)
    - [`const_time_eq`](<#const_time_eq>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)