<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements secure and optimized operations for Curve25519, including point serialization, scalar multiplication, and multi-scalar multiplication.

# Purpose
The code is a C source file that implements operations for elliptic curve cryptography using the Curve25519 and Ed25519 curves. It includes functions for point serialization and deserialization, scalar multiplication, and multi-scalar multiplication on the Ed25519 curve. The file conditionally includes different implementations based on the availability of AVX512 instructions, which suggests optimization for different hardware capabilities. The code also defines constants and uses pre-computed tables to optimize scalar multiplication operations.

The primary functions in the file include [`fd_ed25519_point_frombytes`](<#fd_ed25519_point_frombytes>) and [`fd_ed25519_point_tobytes`](<#fd_ed25519_point_tobytes>) for converting between byte arrays and elliptic curve points, [`fd_ed25519_scalar_mul`](<#fd_ed25519_scalar_mul>) for performing scalar multiplication, and [`fd_ed25519_multi_scalar_mul`](<#fd_ed25519_multi_scalar_mul>) for handling multiple scalar multiplications. The file also contains functions for affine addition and doubling of points. The use of windowed non-adjacent form (WNAF) and pre-computed tables indicates an emphasis on efficient computation, which is critical in cryptographic applications. The file is intended to be part of a larger cryptographic library, providing specific functionality related to elliptic curve operations.
# Imports and Dependencies

---
- `fd_curve25519.h`
- `../hex/fd_hex.h`
- `fd_curve25519_secure.c`
- `avx512/fd_curve25519.c`
- `ref/fd_curve25519.c`


# Functions

---
### fd\_ed25519\_point\_frombytes<!-- {{#callable:fd_ed25519_point_frombytes}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L22>)

Converts a 32-byte buffer into an Ed25519 point, verifying the point's validity and adjusting the sign of the x-coordinate if necessary.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the resulting point will be stored.
    - `buf`: A constant 32-byte array representing the encoded Ed25519 point.
- **Logic and Control Flow**:
    - Convert the y-coordinate from the byte array using `fd_f25519_frombytes` and store it in `y`.
    - Extract the expected sign of the x-coordinate from the most significant bit of the last byte of `buf`.
    - Compute `u = y^2 - 1` and `v = dy^2 + 1` using `fd_f25519_sqr`, `fd_f25519_mul`, `fd_f25519_sub`, and `fd_f25519_add`.
    - Calculate the square root of the ratio `u/v` to find `x` using `fd_f25519_sqrt_ratio`.
    - If the square root does not exist, return `NULL`.
    - Check if the sign of `x` matches the expected sign; if not, negate `x` using `fd_f25519_neg`.
    - Compute `t = x * y` using `fd_f25519_mul`.
    - Construct the Ed25519 point from `x`, `y`, `1`, and `t` using `fd_ed25519_point_from`.
    - Return the pointer `r` to the constructed point.
- **Output**: A pointer to the `fd_ed25519_point_t` structure containing the decoded point, or `NULL` if the point is invalid.


---
### fd\_ed25519\_point\_tobytes<!-- {{#callable:fd_ed25519_point_tobytes}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L51>)

Converts an Ed25519 point to a 32-byte representation.
- **Inputs**:
    - `out`: A 32-byte array where the function will store the byte representation of the point.
    - `a`: A pointer to an `fd_ed25519_point_t` structure representing the point to convert.
- **Logic and Control Flow**:
    - Declare temporary variables `x`, `y`, `z`, and `t` of type `fd_f25519_t` to hold intermediate field elements.
    - Call [`fd_ed25519_point_to`](<ref/fd_curve25519.h.md#fd_ed25519_point_to>) to decompose the point `a` into its coordinates `x`, `y`, `z`, and `t`.
    - Compute the inverse of `z` and store it in `t` using `fd_f25519_inv`.
    - Multiply `x` and `y` by `t` to convert them to affine coordinates using `fd_f25519_mul2`.
    - Convert `y` to bytes and store the result in `out` using `fd_f25519_tobytes`.
    - Modify the last byte of `out` by XORing it with the sign bit of `x` shifted left by 7 positions using `fd_f25519_sgn`.
- **Output**: Returns the pointer to the `out` array containing the 32-byte representation of the point.
- **Functions Called**:
    - [`fd_ed25519_point_to`](<ref/fd_curve25519.h.md#fd_ed25519_point_to>)


---
### fd\_ed25519\_scalar\_mul<!-- {{#callable:fd_ed25519_scalar_mul}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L68>)

Performs scalar multiplication of an Ed25519 point by a 32-byte scalar using a windowed non-adjacent form (WNAF) method.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the result will be stored.
    - `n`: A constant 32-byte array representing the scalar multiplier.
    - `a`: A constant pointer to an `fd_ed25519_point_t` structure representing the point to be multiplied.
- **Logic and Control Flow**:
    - Convert the scalar `n` into a windowed non-adjacent form (WNAF) and store it in `nslide`.
    - Initialize a pre-computed table `ai` with multiples of the point `a` and a temporary point `a2` for doubling operations.
    - Set the first element of `ai` to `a` and compute `2A` in `a2`.
    - Pre-compute multiples of `a` (3A, 5A, ..., 15A) and store them in `ai` using a loop.
    - Initialize the result point `r` to zero.
    - Find the highest non-zero index in `nslide` to start the main loop.
    - Iterate over `nslide` from the highest non-zero index down to zero, performing point doubling and conditional point addition or subtraction based on the sign of `nslide[i]`.
    - In the last iteration, compute the final result using `fd_ed25519_point_add_final_mul`; otherwise, use `fd_ed25519_point_add_final_mul_projective` to ignore `r->T`.
- **Output**: Returns a pointer to the `fd_ed25519_point_t` structure `r` containing the result of the scalar multiplication.
- **Functions Called**:
    - [`fd_ed25519_point_set`](<ref/fd_curve25519.h.md#fd_ed25519_point_set>)
    - [`fd_ed25519_point_dbln`](<ref/fd_curve25519.h.md#fd_ed25519_point_dbln>)
    - [`fd_curve25519_into_precomputed`](<ref/fd_curve25519.h.md#fd_curve25519_into_precomputed>)
    - [`fd_ed25519_point_set_zero`](<ref/fd_curve25519.h.md#fd_ed25519_point_set_zero>)


---
### fd\_ed25519\_double\_scalar\_mul\_base<!-- {{#callable:fd_ed25519_double_scalar_mul_base}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L109>)

Computes the double scalar multiplication of an Ed25519 point with a base point using two scalars.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the result will be stored.
    - `n1`: A 32-byte array representing the first scalar for multiplication.
    - `a`: A pointer to a constant `fd_ed25519_point_t` structure representing the point to be multiplied by the first scalar.
    - `n2`: A 32-byte array representing the second scalar for multiplication with the base point.
- **Logic and Control Flow**:
    - Convert the scalars `n1` and `n2` into windowed non-adjacent form (WNAF) representations `n1slide` and `n2slide`.
    - Initialize a pre-computed table `ai` for the point `a` and compute its multiples.
    - Set the result point `r` to zero.
    - Iterate from the most significant bit to the least significant bit of the scalars, performing a double-and-add operation.
    - For each bit, if the corresponding entry in `n1slide` or `n2slide` is non-zero, add or subtract the appropriate pre-computed multiple of `a` or the base point to/from the result.
    - In the last iteration, compute the final result using `fd_ed25519_point_add_final_mul`; otherwise, use `fd_ed25519_point_add_final_mul_projective` to ignore the `r->T` component.
- **Output**: Returns a pointer to the `fd_ed25519_point_t` structure `r` containing the result of the double scalar multiplication.
- **Functions Called**:
    - [`fd_ed25519_point_set`](<ref/fd_curve25519.h.md#fd_ed25519_point_set>)
    - [`fd_ed25519_point_dbln`](<ref/fd_curve25519.h.md#fd_ed25519_point_dbln>)
    - [`fd_curve25519_into_precomputed`](<ref/fd_curve25519.h.md#fd_curve25519_into_precomputed>)
    - [`fd_ed25519_point_set_zero`](<ref/fd_curve25519.h.md#fd_ed25519_point_set_zero>)


---
### fd\_ed25519\_multi\_scalar\_mul<!-- {{#callable:fd_ed25519_multi_scalar_mul}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L209>)

Performs multi-scalar multiplication on a set of Ed25519 points and scalars, accumulating the results into a single point.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the result will be stored.
    - `n`: An array of unsigned characters representing the scalars, with each scalar being 32 bytes long.
    - `a`: An array of `fd_ed25519_point_t` structures representing the points to be multiplied by the scalars.
    - `sz`: An unsigned long integer representing the number of points and scalars.
- **Logic and Control Flow**:
    - Initialize the result point `r` to zero using [`fd_ed25519_point_set_zero`](<ref/fd_curve25519.h.md#fd_ed25519_point_set_zero>).
    - Iterate over the points and scalars in batches of size `FD_BALLET_CURVE25519_MSM_BATCH_SZ`.
    - For each batch, calculate the minimum of the remaining size and the batch size to determine `batch_sz`.
    - Call `fd_ed25519_multi_scalar_mul_with_opts` to perform the multi-scalar multiplication for the current batch, storing the intermediate result in `h`.
    - Add the intermediate result `h` to the accumulated result `r` using [`fd_ed25519_point_add`](<avx512/fd_curve25519.c.md#fd_ed25519_point_add>).
    - Continue until all points and scalars have been processed.
    - Return the accumulated result `r`.
- **Output**: A pointer to the `fd_ed25519_point_t` structure `r` containing the result of the multi-scalar multiplication.
- **Functions Called**:
    - [`fd_ed25519_point_set_zero`](<ref/fd_curve25519.h.md#fd_ed25519_point_set_zero>)
    - [`fd_ed25519_point_add`](<avx512/fd_curve25519.c.md#fd_ed25519_point_add>)


---
### fd\_ed25519\_multi\_scalar\_mul\_base<!-- {{#callable:fd_ed25519_multi_scalar_mul_base}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L228>)

Performs multi-scalar multiplication using a base point and a set of scalars and points, returning the result in the provided point structure.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the result will be stored.
    - `n`: An array of unsigned characters representing the scalars, with each scalar being 32 bytes long.
    - `a`: An array of `fd_ed25519_point_t` structures representing the points to be multiplied by the scalars.
    - `sz`: An unsigned long integer representing the number of scalars and points.
- **Logic and Control Flow**:
    - Checks if `sz` is greater than `FD_BALLET_CURVE25519_MSM_BATCH_SZ`; if true, returns `NULL`.
    - Calls `fd_ed25519_multi_scalar_mul_with_opts` with the provided parameters and a base size of 1 to perform the multi-scalar multiplication.
- **Output**: Returns a pointer to the `fd_ed25519_point_t` structure containing the result of the multi-scalar multiplication, or `NULL` if the size exceeds the batch size limit.


---
### fd\_curve25519\_affine\_add<!-- {{#callable:fd_curve25519_affine_add}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L243>)

Adds two Ed25519 points and converts the result into affine coordinates.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the result will be stored.
    - `a`: A pointer to a constant `fd_ed25519_point_t` structure representing the first point to add.
    - `b`: A pointer to a constant `fd_ed25519_point_t` structure representing the second point to add.
- **Logic and Control Flow**:
    - Calls `fd_ed25519_point_add_with_opts` to add points `a` and `b`, storing the result in `r` with specific options (1, 0, 0).
    - Calls [`fd_curve25519_into_affine`](<avx512/fd_curve25519.c.md#fd_curve25519_into_affine>) to convert the result stored in `r` into affine coordinates.
    - Returns the pointer `r` containing the result in affine coordinates.
- **Output**: A pointer to the `fd_ed25519_point_t` structure `r` containing the result of the addition in affine coordinates.
- **Functions Called**:
    - [`fd_curve25519_into_affine`](<avx512/fd_curve25519.c.md#fd_curve25519_into_affine>)


---
### fd\_curve25519\_affine\_dbln<!-- {{#callable:fd_curve25519_affine_dbln}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_curve25519.c#L251>)

Performs multiple doublings of an elliptic curve point and converts the result to affine coordinates.
- **Inputs**:
    - `r`: A pointer to an `fd_ed25519_point_t` structure where the result will be stored.
    - `a`: A constant pointer to an `fd_ed25519_point_t` structure representing the point to be doubled.
    - `n`: An integer specifying the number of times the point `a` should be doubled.
- **Logic and Control Flow**:
    - Calls [`fd_ed25519_point_dbln`](<ref/fd_curve25519.h.md#fd_ed25519_point_dbln>) to perform `n` doublings of the point `a`, storing the result in `r`.
    - Calls [`fd_curve25519_into_affine`](<avx512/fd_curve25519.c.md#fd_curve25519_into_affine>) to convert the resulting point in `r` to affine coordinates.
- **Output**: Returns a pointer to the `fd_ed25519_point_t` structure `r` containing the result in affine coordinates.
- **Functions Called**:
    - [`fd_ed25519_point_dbln`](<ref/fd_curve25519.h.md#fd_ed25519_point_dbln>)
    - [`fd_curve25519_into_affine`](<avx512/fd_curve25519.c.md#fd_curve25519_into_affine>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)