<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for encoding and decoding elliptic curve points using AVX-512 instructions based on RFC 8032.

# Purpose
The code provides functionality for encoding and decoding elliptic curve points as specified in RFC 8032. It includes three main functions: [`fd_r43x6_ge_encode`](<#fd_r43x6_ge_encode>), [`fd_r43x6_ge_decode`](<#fd_r43x6_ge_decode>), and [`fd_r43x6_ge_decode2`](<#fd_r43x6_ge_decode2>). The [`fd_r43x6_ge_encode`](<#fd_r43x6_ge_encode>) function encodes a curve point into a 32-octet string using little-endian format, where the y-coordinate is encoded directly, and the least significant bit of the x-coordinate is stored in the most significant bit of the final octet. The [`fd_r43x6_ge_decode`](<#fd_r43x6_ge_decode>) function decodes a 32-octet string back into a curve point by interpreting the string as an integer, recovering the y-coordinate, and calculating the x-coordinate using the curve equation. The [`fd_r43x6_ge_decode2`](<#fd_r43x6_ge_decode2>) function is an optimized version for decoding two points concurrently, improving performance for high-performance computing (HPC) applications.

The code is part of a C library intended to be used in cryptographic applications that require encoding and decoding of elliptic curve points. It uses specific data types and functions, such as `fd_r43x6_t` and `fd_r43x6_mul_fast`, to perform arithmetic operations on the curve points. The functions are designed to handle edge cases, such as when no valid square root exists for the x-coordinate, and they return error codes to indicate failure. The code is structured to be efficient and, in some parts, constant time to prevent timing attacks, although constant time execution is not strictly required by the specification.
# Imports and Dependencies

---
- `fd_r43x6_ge.h`


# Functions

---
### fd\_r43x6\_ge\_encode<!-- {{#callable:fd_r43x6_ge_encode}} -->
[View Source →](<../../../../../../src/ballet/ed25519/avx512/fd_r43x6_ge.c#L5>)

Encodes a curve point (x, y) into a 32-octet string using little-endian format.
- **Inputs**:
    - `P03`: A `wwl_t` type representing part of the input point data.
    - `P14`: A `wwl_t` type representing part of the input point data.
    - `P25`: A `wwl_t` type representing part of the input point data.
- **Logic and Control Flow**:
    - Unpack the input point `P` into components `X`, `Y`, `Z`, and `T` using `FD_R43X6_QUAD_UNPACK`.
    - Invert `Z` to compute `one_Z`.
    - Multiply `X` and `Y` by `one_Z` to get `x` and `y`.
    - Extract limbs from `x` and `y` using `fd_r43x6_extract_limbs`.
    - Propagate carries in `x` and `y` using `fd_r43x6_biased_carry_propagate_limbs`.
    - Reduce `x` and `y` to be nearly reduced using `fd_r43x6_mod_nearly_reduced_limbs`.
    - Encode the `y`-coordinate as a little-endian string of 32 octets, setting the most significant bit of the final octet to zero.
    - Copy the least significant bit of the `x`-coordinate to the most significant bit of the final octet of the `y`-coordinate.
    - Pack the modified `y` limbs into a `wv_t` type using [`fd_r43x6_pack`](<fd_r43x6.h.md#fd_r43x6_pack>).
- **Output**: Returns a `wv_t` type representing the encoded 32-octet string of the curve point.
- **Functions Called**:
    - [`fd_r43x6_invert`](<fd_r43x6.c.md#fd_r43x6_invert>)
    - [`fd_r43x6_mul_fast`](<fd_r43x6.h.md#fd_r43x6_mul_fast>)
    - [`fd_r43x6_pack`](<fd_r43x6.h.md#fd_r43x6_pack>)


---
### fd\_r43x6\_ge\_decode<!-- {{#callable:fd_r43x6_ge_decode}} -->
[View Source →](<../../../../../../src/ballet/ed25519/avx512/fd_r43x6_ge.c#L48>)

Decodes a 32-octet string into a point on a curve, handling special cases for square roots and bit manipulations.
- **Inputs**:
    - `_P03`: Pointer to store the first part of the decoded point.
    - `_P14`: Pointer to store the second part of the decoded point.
    - `_P25`: Pointer to store the third part of the decoded point.
    - `_vs`: Pointer to the 32-octet string to decode.
- **Logic and Control Flow**:
    - Copy the 32-octet string into a 4-element array of `ulong` integers, interpreting it as a little-endian integer.
    - Extract the least significant bit of the last element as `x_0` and clear this bit to recover the y-coordinate.
    - Unpack the y-coordinate using [`fd_r43x6_unpack`](<fd_r43x6.h.md#fd_r43x6_unpack>).
    - Calculate `u = y^2 - 1` and `v = d y^2 + 1` using the curve equation.
    - Compute the candidate root `x` using modular arithmetic and a single modular powering operation.
    - Check three cases to determine if `x` is a valid square root, adjusting `x` if necessary.
    - Use `x_0` to select the correct square root, failing if `x` is zero and `x_0` is one.
    - If `x_0` does not match `x mod 2`, adjust `x` by negating it.
    - Pack the decoded point into the provided pointers and return 0 on success.
    - If any checks fail, set the output pointers to zero and return -1.
- **Output**: Returns 0 on successful decoding, or -1 if decoding fails.
- **Functions Called**:
    - [`fd_r43x6_unpack`](<fd_r43x6.h.md#fd_r43x6_unpack>)
    - [`fd_r43x6_pow22523`](<fd_r43x6.c.md#fd_r43x6_pow22523>)
    - [`fd_r43x6_is_nonzero`](<fd_r43x6.h.md#fd_r43x6_is_nonzero>)
    - [`fd_r43x6_diagnose`](<fd_r43x6.h.md#fd_r43x6_diagnose>)


---
### fd\_r43x6\_ge\_decode2<!-- {{#callable:fd_r43x6_ge_decode2}} -->
[View Source →](<../../../../../../src/ballet/ed25519/avx512/fd_r43x6_ge.c#L163>)

Decodes two encoded elliptic curve points from byte arrays into internal representations, handling potential decoding failures.
- **Inputs**:
    - `_Pa03`: Pointer to store the first part of the decoded point A.
    - `_Pa14`: Pointer to store the second part of the decoded point A.
    - `_Pa25`: Pointer to store the third part of the decoded point A.
    - `_vsa`: Pointer to the byte array representing the encoded point A.
    - `_Pb03`: Pointer to store the first part of the decoded point B.
    - `_Pb14`: Pointer to store the second part of the decoded point B.
    - `_Pb25`: Pointer to store the third part of the decoded point B.
    - `_vsb`: Pointer to the byte array representing the encoded point B.
- **Logic and Control Flow**:
    - Initialize constants `one`, `d`, and `sqrt_m1` for calculations.
    - Copy the byte arrays `_vsa` and `_vsb` into aligned arrays `_sa` and `_sb`.
    - Extract the y-coordinates and the least significant bit of the x-coordinates from `_sa` and `_sb`.
    - Clear the most significant bit of the y-coordinates in `_sa` and `_sb`.
    - Unpack the y-coordinates into `fd_r43x6_t` format for both points.
    - Calculate `ysqa` and `ysqb` as the square of the y-coordinates for both points.
    - Compute `ua`, `ub`, `va`, and `vb` using the curve equation components for both points.
    - Calculate powers and products to find potential x-coordinates `xa` and `xb`.
    - Check conditions to determine if the calculated x-coordinates are valid square roots.
    - Adjust x-coordinates based on the least significant bit of the original x-coordinates.
    - Pack the decoded points into the provided pointers `_Pa` and `_Pb`.
    - Return 0 if successful, or -1/-2 if decoding fails for point A or B respectively.
- **Output**: Returns 0 on successful decoding of both points, -1 if decoding of point A fails, and -2 if decoding of point B fails.
- **Functions Called**:
    - [`fd_r43x6_ge_decode`](<#fd_r43x6_ge_decode>)
    - [`fd_r43x6_unpack`](<fd_r43x6.h.md#fd_r43x6_unpack>)
    - [`fd_r43x6_is_nonzero`](<fd_r43x6.h.md#fd_r43x6_is_nonzero>)
    - [`fd_r43x6_diagnose`](<fd_r43x6.h.md#fd_r43x6_diagnose>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)