<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for converting between byte arrays and Ristretto255 points, mapping and hashing to the Ristretto255 curve.

# Purpose
The code provides functions for working with the Ristretto255 group, which is a prime-order group based on the Edwards25519 curve. It includes functions to convert between byte representations and Ristretto255 points, map arbitrary data to the Ristretto255 curve, and hash data to a point on the curve. The functions [`fd_ristretto255_point_frombytes`](<#fd_ristretto255_point_frombytes>) and [`fd_ristretto255_point_tobytes`](<#fd_ristretto255_point_tobytes>) handle the conversion of points to and from a 32-byte representation, ensuring that only canonical points are accepted. The [`fd_ristretto255_map_to_curve`](<#fd_ristretto255_map_to_curve>) function implements the Elligator2 map, which maps arbitrary data to a point on the Ristretto255 curve, following the specifications from the Ristretto group documentation. The [`fd_ristretto255_hash_to_curve`](<#fd_ristretto255_hash_to_curve>) function hashes a 64-byte input to a Ristretto255 point by mapping two halves of the input separately and then adding the resulting points.

The code is intended to be part of a library that provides cryptographic operations on the Ristretto255 group. It relies on several helper functions and constants, such as `fd_f25519_frombytes`, `fd_f25519_tobytes`, and `fd_f25519_sqrt_ratio`, which perform operations on field elements in the finite field F25519. The functions defined in this code are likely to be used in cryptographic protocols that require secure and efficient operations on elliptic curve points, such as digital signatures or key exchange mechanisms. The code does not define a public API or external interfaces directly but provides essential building blocks for higher-level cryptographic operations.
# Imports and Dependencies

---
- `fd_ristretto255.h`


# Functions

---
### fd\_ristretto255\_point\_frombytes<!-- {{#callable:fd_ristretto255_point_frombytes}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_ristretto255.c#L3>)

Converts a 32-byte array into a Ristretto255 point, ensuring the point is canonical and valid.
- **Inputs**:
    - `h`: A pointer to an `fd_ristretto255_point_t` structure where the resulting point will be stored.
    - `buf`: A constant 32-byte array representing the input data to be converted into a Ristretto255 point.
- **Logic and Control Flow**:
    - Convert the 32-byte input `buf` into a field element `s` using `fd_f25519_frombytes`.
    - Convert `s` back to bytes and store in `s_check` to verify canonical form.
    - Check if `buf` is canonical and if the sign bit is set; return `NULL` if not canonical.
    - Compute `ss` as the square of `s`.
    - Calculate `u1` as `1 - ss` and `u2` as `1 + ss`.
    - Compute `u2sq` as the square of `u2`.
    - Calculate `v` as the negation of `D * u1^2` minus `u2sq`.
    - Compute the inverse square root of `v * u2sq` and store in `inv_sq`; check if the result is a square.
    - Calculate `den_x` as `inv_sq * u2` and `den_y` as `inv_sq * den_x * v`.
    - Compute `x` as the absolute value of `2 * s * den_x`.
    - Calculate `y` as `u1 * den_y`.
    - Compute `t` as `x * y`.
    - Return `NULL` if the point is not a square, if the sign of `t` is set, or if `y` is zero.
    - Return the point using `fd_ed25519_point_from` with `x`, `y`, `1`, and `t`.
- **Output**: A pointer to the resulting `fd_ristretto255_point_t` if successful, or `NULL` if the input does not represent a valid canonical point.


---
### fd\_ristretto255\_point\_tobytes<!-- {{#callable:fd_ristretto255_point_tobytes}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_ristretto255.c#L73>)

Converts a `fd_ristretto255_point_t` point to a 32-byte representation in a buffer.
- **Inputs**:
    - `buf`: A 32-byte buffer to store the byte representation of the point.
    - `h`: A pointer to a `fd_ristretto255_point_t` structure representing the point to convert.
- **Logic and Control Flow**:
    - Extracts the coordinates `x`, `y`, `z`, and `t` from the point `h` using [`fd_ed25519_point_to`](<ref/fd_curve25519.h.md#fd_ed25519_point_to>) function.
    - Calculates `u1` as the product of `(z + y)` and `(z - y)`.
    - Calculates `u2` as the product of `x` and `y`.
    - Computes the inverse square root of `u1 * u2^2` and stores it in `inv_sqrt`.
    - Calculates `den1` and `den2` as the products of `inv_sqrt` with `u1` and `u2`, respectively.
    - Computes `z_inv` as the product of `den1`, `den2`, and `t`.
    - Calculates `ix0` and `iy0` as the products of `x` and `y` with `SQRT_M1`, respectively.
    - Calculates `enchanted_denominator` as the product of `den1` and `INVSQRT_A_MINUS_D`.
    - Determines `rotate` by checking if `t * z_inv` is negative using `fd_f25519_sgn`.
    - Selects `x` and `y` based on the value of `rotate` using `fd_f25519_if`.
    - Selects `den_inv` based on the value of `rotate` using `fd_f25519_if`.
    - Negates `y` if `x * z_inv` is negative using `fd_f25519_sgn` and `fd_f25519_if`.
    - Calculates `s` as the absolute value of `den_inv * (z - y)` using `fd_f25519_abs`.
    - Converts `s` to bytes and stores it in `buf` using `fd_f25519_tobytes`.
- **Output**: Returns the pointer to the 32-byte buffer `buf` containing the byte representation of the point.
- **Functions Called**:
    - [`fd_ed25519_point_to`](<ref/fd_curve25519.h.md#fd_ed25519_point_to>)


---
### fd\_ristretto255\_map\_to\_curve<!-- {{#callable:fd_ristretto255_map_to_curve}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_ristretto255.c#L158>)

Maps a 32-byte input to a point on the Ristretto255 curve using the Elligator2 mapping.
- **Inputs**:
    - `h`: A pointer to an `fd_ristretto255_point_t` structure where the resulting point will be stored.
    - `buf`: A constant 32-byte array used as input to map to the curve.
- **Logic and Control Flow**:
    - Convert the input `buf` to a field element `r0` and compute `r` as the product of `SQRT_M1` and the square of `r0`.
    - Calculate `u` as the product of `(r + 1)` and `ONE_MINUS_D_SQ`.
    - Set `c` to `-1`.
    - Compute `v` as the product of `(c - r*D)` and `(r + D)`.
    - Determine if `u/v` is a square and compute `s` using `SQRT_RATIO_M1`.
    - Calculate `s_prime` as the negative absolute value of `s*r0`.
    - Select `s` as `s` if `was_square` is true, otherwise `s_prime`; similarly, select `c` as `c` if `was_square` is true, otherwise `r`.
    - Compute `N` as `c * (r - 1) * D_MINUS_ONE_SQ - v`.
    - Calculate `w0`, `w1`, `w2`, and `w3` using `s`, `v`, `N`, and `s^2`.
    - Compute the coordinates `x`, `y`, `z`, and `t` using `w0`, `w1`, `w2`, and `w3`.
    - Return the point constructed from `x`, `y`, `z`, and `t`.
- **Output**: Returns a pointer to the `fd_ristretto255_point_t` structure containing the mapped point.


---
### fd\_ristretto255\_hash\_to\_curve<!-- {{#callable:fd_ristretto255_hash_to_curve}} -->
[View Source →](<../../../../../src/ballet/ed25519/fd_ristretto255.c#L225>)

Maps a 64-byte input to a Ristretto255 curve point by splitting the input and mapping each half separately, then adding the results.
- **Inputs**:
    - `h`: A pointer to a `fd_ristretto255_point_t` structure where the resulting curve point will be stored.
    - `s`: A constant 64-byte array used as the input data to be hashed to the curve.
- **Logic and Control Flow**:
    - Declare two temporary `fd_ristretto255_point_t` structures `p1` and `p2` to hold intermediate curve points.
    - Call [`fd_ristretto255_map_to_curve`](<#fd_ristretto255_map_to_curve>) with `p1` and the first 32 bytes of `s` to map the first half of the input to a curve point.
    - Call [`fd_ristretto255_map_to_curve`](<#fd_ristretto255_map_to_curve>) with `p2` and the second 32 bytes of `s` to map the second half of the input to another curve point.
    - Add the two curve points `p1` and `p2` using `fd_ristretto255_point_add` and store the result in `h`.
    - Return the pointer `h` containing the resulting curve point.
- **Output**: A pointer to the `fd_ristretto255_point_t` structure `h` containing the resulting curve point.
- **Functions Called**:
    - [`fd_ristretto255_map_to_curve`](<#fd_ristretto255_map_to_curve>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)