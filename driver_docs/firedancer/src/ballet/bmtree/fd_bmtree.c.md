<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for binary Merkle trees using SHA-256, supporting different tree widths and operations like hashing, merging, and proof management.

# Purpose
The code defines a template for creating binary Merkle trees using the SHA-256 hash function. It is designed to be included multiple times with different configurations, allowing for the creation of Merkle trees with varying widths. The primary components of this code include the definition of a `bmt_node` structure, which represents a node in the Merkle tree, and a series of functions that provide the functionality to hash leaf nodes, merge nodes, and manage the tree's structure. The code also includes functions for initializing, appending to, and finalizing a Merkle tree commitment, as well as functions for generating and verifying inclusion proofs.

The code is structured to be used as a header-only library, providing a public API for interacting with the Merkle tree. It includes functions such as `bmtree_hash_leaf` for hashing leaf nodes, `bmtree_private_merge` for merging nodes, and `bmtree_commit_init`, `bmtree_commit_append`, and `bmtree_commit_fini` for managing the lifecycle of a Merkle tree commitment. The code also includes functionality for handling inclusion proofs, which are used to verify the presence of a leaf node within the tree. The implementation makes use of AVX instructions for performance optimization when available, and it is designed to be flexible, allowing for different hash sizes and prefix sizes to be specified.
# Imports and Dependencies

---
- `fd_bmtree.h`
- `../sha256/fd_sha256.h`
- `../../util/tmpl/fd_smallset.c`
- `x86intrin.h`


# Functions

---
### fd\_bmtree\_hash\_leaf<!-- {{#callable:fd_bmtree_hash_leaf}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L51>)

Computes the SHA-256 hash of a data block with a specified prefix and stores the result in a binary Merkle tree node.
- **Inputs**:
    - ``node``: A pointer to an `fd_bmtree_node_t` structure where the resulting hash will be stored.
    - ``data``: A pointer to the data block to be hashed.
    - ``data_sz``: The size of the data block in bytes.
    - ``prefix_sz``: The size of the prefix to be used in the hash computation.
- **Logic and Control Flow**:
    - Initialize a SHA-256 context using `fd_sha256_init`.
    - Append the prefix to the SHA-256 context using `fd_sha256_append`.
    - Append the data block to the SHA-256 context using `fd_sha256_append`.
    - Finalize the SHA-256 hash computation using `fd_sha256_fini`, storing the result in `node->hash`.
    - Return the `node` pointer.
- **Output**: Returns a pointer to the `fd_bmtree_node_t` structure containing the computed hash.


---
### fd\_bmtree\_private\_merge<!-- {{#callable:fd_bmtree_private_merge}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L77>)

Computes the SHA-256 hash of a concatenated prefix and two node hashes, storing the result in the provided node.
- **Inputs**:
    - ``node``: A pointer to an `fd_bmtree_node_t` structure where the resulting hash will be stored.
    - ``a``: A pointer to a constant `fd_bmtree_node_t` structure representing the first node to merge.
    - ``b``: A pointer to a constant `fd_bmtree_node_t` structure representing the second node to merge.
    - ``hash_sz``: An unsigned long integer specifying the size of the hash in bytes.
    - ``prefix_sz``: An unsigned long integer specifying the size of the prefix in bytes.
- **Logic and Control Flow**:
    - If `FD_HAS_AVX` is defined, use AVX instructions to load the prefix, node `a`, and node `b` into 256-bit registers.
    - Store these registers into a memory buffer, aligning the prefix, `a`, and `b` hashes sequentially.
    - Call `fd_sha256_hash` to compute the hash of the concatenated buffer and store the result in `node`.
    - If `FD_HAS_AVX` is not defined, initialize a SHA-256 context and append the prefix, `a` hash, and `b` hash sequentially.
    - Finalize the SHA-256 hash computation and store the result in `node->hash`.
    - Return the `node` pointer.
- **Output**: Returns a pointer to the `fd_bmtree_node_t` structure containing the computed hash.


---
### fd\_bmtree\_depth<!-- {{#callable:fd_bmtree_depth}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L146>)

Calculates the number of layers in a binary Merkle tree based on the number of leaf nodes.
- **Inputs**:
    - `leaf_cnt`: The number of leaf nodes in the binary Merkle tree.
- **Logic and Control Flow**:
    - Checks if `leaf_cnt` is less than or equal to 1.
    - If true, returns `leaf_cnt` as the depth of the tree.
    - If false, calculates the most significant bit of `leaf_cnt - 1` using `fd_ulong_find_msb_w_default` and adds 2 to determine the depth.
- **Output**: Returns the number of layers in the binary Merkle tree as an unsigned long integer.


---
### fd\_bmtree\_node\_cnt<!-- {{#callable:fd_bmtree_node_cnt}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L155>)

Calculates the total number of nodes in a binary Merkle tree given the number of leaf nodes.
- **Inputs**:
    - `leaf_cnt`: The number of leaf nodes in the binary Merkle tree.
- **Logic and Control Flow**:
    - Check if `leaf_cnt` is zero; if true, return zero as there are no nodes.
    - Initialize `cnt` to zero and decrement `leaf_cnt` by one.
    - Iterate over 64 possible layers, right-shifting `leaf_cnt` by the loop index `i` to calculate the number of nodes at each layer and accumulate this in `cnt`.
    - Add a correction term to `cnt` using the most significant bit of the original `leaf_cnt` to account for the root node.
    - Return the total node count `cnt`.
- **Output**: The total number of nodes in the binary Merkle tree, including both leaf and non-leaf nodes.


---
### fd\_bmtree\_commit\_align<!-- {{#callable:fd_bmtree_commit_align}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L179>)

Returns the alignment requirement for a `bmtree_commit_t` memory region.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the constant `FD_BMTREE_COMMIT_ALIGN`.
- **Output**: The function returns an `ulong` representing the alignment requirement for a `bmtree_commit_t`.


---
### fd\_bmtree\_commit\_footprint<!-- {{#callable:fd_bmtree_commit_footprint}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L181>)

Calculates the memory footprint required for a binary Merkle tree commit structure based on the number of layers in the inclusion proof.
- **Inputs**:
    - `inclusion_proof_layer_cnt`: The number of layers in the inclusion proof for the binary Merkle tree.
- **Logic and Control Flow**:
    - Calculate the number of nodes in a complete binary tree with `inclusion_proof_layer_cnt` layers as `(2^inclusion_proof_layer_cnt) - 1`.
    - Add the size of one extra `fd_bmtree_node_t` to the total size to avoid branches when appending commits.
    - Calculate the size of the inclusion proofs as `(((1UL<<inclusion_proof_layer_cnt)+63UL)/64UL)*sizeof(ulong)`.
    - Sum the sizes of `fd_bmtree_commit_t`, the nodes, and the inclusion proofs.
    - Align the total size to the alignment required by `fd_bmtree_commit_align()`.
- **Output**: Returns the aligned memory footprint size in bytes as an `ulong`.
- **Functions Called**:
    - [`fd_bmtree_commit_align`](<#fd_bmtree_commit_align>)


---
### fd\_bmtree\_commit\_init<!-- {{#callable:fd_bmtree_commit_init}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L195>)

Initializes a `fd_bmtree_commit_t` structure for a binary Merkle tree commitment calculation.
- **Inputs**:
    - `mem`: A pointer to a memory region that is assumed to be unused and has the required alignment and footprint for a `fd_bmtree_commit_t` structure.
    - `hash_sz`: The size of the hash used in the Merkle tree.
    - `prefix_sz`: The size of the prefix used in the Merkle tree.
    - `inclusion_proof_layer_cnt`: The number of layers in the inclusion proof, which determines the size of the inclusion proof array.
- **Logic and Control Flow**:
    - Cast the `mem` pointer to a `fd_bmtree_commit_t` pointer and store it in `state`.
    - Calculate `inclusion_proof_sz` as `(1UL << inclusion_proof_layer_cnt) - 1UL`.
    - Initialize `state->leaf_cnt` to `0UL`.
    - Set `state->hash_sz` to `hash_sz`.
    - Set `state->prefix_sz` to `prefix_sz`.
    - Set `state->inclusion_proof_sz` to `inclusion_proof_sz`.
    - Calculate the pointer `state->inclusion_proofs_valid` to point to the location after `state->inclusion_proofs` plus `inclusion_proof_sz`.
    - Use `fd_memset` to zero out the memory region pointed to by `state->inclusion_proofs_valid`.
    - Return the `state` pointer.
- **Output**: Returns a pointer to the initialized `fd_bmtree_commit_t` structure.


---
### fd\_bmtree\_commit\_append<!-- {{#callable:fd_bmtree_commit_append}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L216>)

Appends new leaf nodes to a binary Merkle tree and updates the tree's state accordingly.
- **Inputs**:
    - `state`: A pointer to an `fd_bmtree_commit_t` structure representing the current state of the binary Merkle tree.
    - `new_leaf`: A pointer to an array of `fd_bmtree_node_t` structures representing the new leaf nodes to append.
    - `new_leaf_cnt`: An unsigned long integer representing the number of new leaf nodes to append.
- **Logic and Control Flow**:
    - Initialize `leaf_cnt` from `state->leaf_cnt` and `node_buf` from `state->node_buf`.
    - Iterate over each new leaf node using `new_leaf_idx` from 0 to `new_leaf_cnt - 1`.
    - For each new leaf, copy it to a temporary node `tmp`.
    - Initialize `layer` to 0, `inc_idx` to `2 * leaf_cnt`, and increment `leaf_cnt`.
    - While the right node in the last pair is available (`!(cursor & 1UL)`), update the inclusion proofs and merge nodes to form a new branch node.
    - Update `inc_idx`, increment `layer`, and shift `cursor` right by 1.
    - After the loop, store the left node (or root node) in `node_buf[layer]` and update the inclusion proofs.
    - Update `state->leaf_cnt` with the new `leaf_cnt`.
- **Output**: Returns a pointer to the updated `fd_bmtree_commit_t` state.
- **Functions Called**:
    - [`fd_bmtree_private_merge`](<#fd_bmtree_private_merge>)


---
### fd\_bmtree\_commit\_fini<!-- {{#callable:fd_bmtree_commit_fini}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L281>)

Finalizes a binary Merkle tree commitment by computing the root hash if necessary and returns a pointer to it.
- **Inputs**:
    - `state`: A pointer to an `fd_bmtree_commit_t` structure representing the current state of the Merkle tree commitment.
- **Logic and Control Flow**:
    - Retrieve the number of leaves (`leaf_cnt`) and the node buffer (`node_buf`) from the `state`.
    - Calculate the pointer to the root node using the depth of the tree derived from `leaf_cnt`.
    - Check if the number of leaves is not a power of two; if so, further hashing is required.
    - Determine the starting layer where the number of nodes is odd and initialize a temporary node with the value from `node_buf`.
    - Iterate upwards through the tree layers, merging nodes as necessary until reaching the root node.
    - Update the root node with the final computed hash value.
- **Output**: Returns a pointer to the hash of the root node of the Merkle tree.
- **Functions Called**:
    - [`fd_bmtree_depth`](<#fd_bmtree_depth>)
    - [`fd_bmtree_private_merge`](<#fd_bmtree_private_merge>)


---
### fd\_bmtree\_get\_proof<!-- {{#callable:fd_bmtree_get_proof}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L321>)

Generates a Merkle proof for a specified leaf index in a binary Merkle tree.
- **Inputs**:
    - `state`: A pointer to an `fd_bmtree_commit_t` structure representing the state of the Merkle tree.
    - `dest`: A pointer to a memory location where the function will store the generated Merkle proof.
    - `leaf_idx`: An unsigned long integer representing the index of the leaf for which the proof is generated.
- **Logic and Control Flow**:
    - Retrieve the number of leaves (`leaf_cnt`) and hash size (`hash_sz`) from the `state` structure.
    - Check if `leaf_idx` is greater than or equal to `leaf_cnt`; if true, return 0 indicating an invalid index.
    - Initialize `inc_idx` to `leaf_idx * 2`, `layer` to 0, and `layer_cnt` to `leaf_cnt`.
    - Enter a loop that continues while `layer_cnt` is greater than 1.
    - Calculate `sibling_idx` as the XOR of `inc_idx` and `1 << (layer + 1)`.
    - Calculate `max_idx_for_layer` using `fd_ulong_insert_lsb` to determine the maximum index for the current layer.
    - Adjust `sibling_idx` using `fd_ulong_if` to ensure it does not exceed `max_idx_for_layer`.
    - Check if `sibling_idx` is greater than or equal to `state->inclusion_proof_sz`; if true, return -1 indicating an error.
    - Copy the hash from `state->inclusion_proofs` at `sibling_idx` to `dest` at the position `layer * hash_sz`.
    - Increment `layer`, update `layer_cnt` by right-shifting it by 1, and update `inc_idx` using `fd_ulong_insert_lsb`.
    - Exit the loop when `layer_cnt` is no longer greater than 1.
    - Return the number of layers processed as an integer.
- **Output**: Returns the number of layers in the proof as an integer, or 0 if the leaf index is invalid, or -1 if an error occurs during proof generation.


---
### fd\_bmtree\_from\_proof<!-- {{#callable:fd_bmtree_from_proof}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L350>)

Reconstructs the root of a binary Merkle tree from a given leaf node and its proof.
- **Inputs**:
    - `leaf`: A pointer to the leaf node from which the tree reconstruction starts.
    - `leaf_idx`: The index of the leaf node in the tree.
    - `root`: A pointer to where the reconstructed root node will be stored.
    - `proof`: A pointer to the proof data used to reconstruct the tree.
    - `proof_depth`: The depth of the proof, indicating how many layers of the tree are included in the proof.
    - `hash_sz`: The size of the hash used in the nodes.
    - `prefix_sz`: The size of the prefix used in the hash computation.
- **Logic and Control Flow**:
    - Initialize a temporary array `tmp` to store nodes during reconstruction, with `tmp[0]` set to the input `leaf` node.
    - Check if the `proof_depth` is sufficient for the given `leaf_idx` using [`fd_bmtree_depth`](<#fd_bmtree_depth>); return `NULL` if not.
    - Initialize `inc_idx` as `leaf_idx * 2UL` to track the index in the proof.
    - Iterate over each layer of the proof up to `proof_depth`.
    - For each layer, copy the proof data into `tmp[1]`.
    - Determine the left and right nodes (`tmp_l` and `tmp_r`) for merging based on the current `inc_idx`.
    - Merge the nodes using [`fd_bmtree_private_merge`](<#fd_bmtree_private_merge>) to compute the parent node and store it in `tmp[0]`.
    - Update `inc_idx` for the next layer using `fd_ulong_insert_lsb`.
    - After processing all layers, copy the final node in `tmp` to `root` and return `root`.
- **Output**: A pointer to the reconstructed root node, or `NULL` if the proof is insufficient.
- **Functions Called**:
    - [`fd_bmtree_depth`](<#fd_bmtree_depth>)
    - [`fd_bmtree_private_merge`](<#fd_bmtree_private_merge>)


---
### fd\_bmtree\_commitp\_insert\_with\_proof<!-- {{#callable:fd_bmtree_commitp_insert_with_proof}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L384>)

Inserts a new leaf into a binary Merkle tree with a given proof and optionally returns the root node.
- **Inputs**:
    - `state`: A pointer to the `fd_bmtree_commit_t` structure representing the current state of the Merkle tree.
    - `idx`: An unsigned long integer representing the index where the new leaf should be inserted.
    - `new_leaf`: A pointer to the `fd_bmtree_node_t` structure representing the new leaf node to be inserted.
    - `proof`: A pointer to a constant unsigned char array containing the proof for the new leaf.
    - `proof_depth`: An unsigned long integer representing the depth of the proof.
    - `opt_root`: A pointer to an `fd_bmtree_node_t` structure where the root node will be stored if not NULL.
- **Logic and Control Flow**:
    - Calculate `inc_idx` as `2 * idx` and retrieve `inclusion_proof_sz` and `hash_sz` from `state`.
    - Check if `inc_idx` is greater than or equal to `inclusion_proof_sz` or if `proof_depth` is invalid; return 0 if true.
    - Initialize the first node buffer with `new_leaf`.
    - Iterate over each layer up to `proof_depth`, checking sibling and current node hashes against the proof; return 0 if any check fails.
    - Calculate the parent index and update the node buffer with merged nodes if necessary.
    - Continue iterating up to layer 63, checking bounds and sibling availability, and merging nodes as needed.
    - Cache the nodes from the main branch and the inclusion proof in `state`.
    - If `opt_root` is not NULL, store the root node in `opt_root`.
    - Return 1 to indicate successful insertion.
- **Output**: Returns 1 if the insertion is successful, otherwise returns 0.
- **Functions Called**:
    - [`fd_bmtree_private_merge`](<#fd_bmtree_private_merge>)


---
### fd\_bmtree\_commitp\_fini<!-- {{#callable:fd_bmtree_commitp_fini}} -->
[View Source →](<../../../../../src/ballet/bmtree/fd_bmtree.c#L467>)

Finalizes the binary Merkle tree commitment process and returns the root hash if successful.
- **Inputs**:
    - `state`: A pointer to the `fd_bmtree_commit_t` structure representing the current state of the Merkle tree commitment.
    - `leaf_cnt`: The number of leaf nodes in the Merkle tree.
- **Logic and Control Flow**:
    - Check if `leaf_cnt` is zero; if so, return `NULL`.
    - If `leaf_cnt` is not a power of two, perform additional hashing to complete the tree.
    - Start at the first layer where the number of nodes is odd and calculate the index `inc_idx`.
    - Check if `inc_idx` is within bounds and if the node exists; if not, return `NULL`.
    - Ascend the tree, merging nodes until reaching the root, checking for sibling nodes as needed.
    - Cache the path of nodes traversed during the ascent.
    - Verify that all required nodes up to the root index are present; if any are missing, return `NULL`.
    - Update the `leaf_cnt` in the state and return the root hash.
- **Output**: Returns a pointer to the root hash of the Merkle tree if successful, or `NULL` if an error occurs.
- **Functions Called**:
    - [`fd_bmtree_private_merge`](<#fd_bmtree_private_merge>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)