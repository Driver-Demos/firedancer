<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements 4-bit GCM multiplication and hashing functions for AES encryption, adapted from OpenSSL.

# Purpose
The code in `fd_aes_gcm_ref.c` is a C implementation of the Galois/Counter Mode (GCM) for AES encryption, specifically focusing on a 4-bit table-driven approach. This file is part of a cryptographic library and was originally imported from the OpenSSL project. It provides functions to initialize and perform GCM multiplication and hashing operations using a 4-bit lookup table. The primary functions include [`fd_gcm_init_4bit`](<#fd_gcm_init_4bit>), which initializes a hash table for GCM operations, [`fd_gcm_gmult_4bit`](<#fd_gcm_gmult_4bit>), which performs GCM multiplication, and [`fd_gcm_ghash_4bit`](<#fd_gcm_ghash_4bit>), which computes the GCM hash over a data stream.

The code defines a macro `REDUCE1BIT` to perform bit reduction operations, which are essential for the GCM algorithm. It also includes a static array `rem_4bit` used for remainder calculations during the multiplication and hashing processes. The implementation is designed to balance security and performance by using a 4-bit table, which is considered to provide a good trade-off between memory usage and computational efficiency. The file does not define a public API but rather serves as an internal component of a larger cryptographic system, focusing on the specific task of handling GCM operations for AES encryption.
# Imports and Dependencies

---
- `fd_aes_gcm.h`


# Global Variables

---
### rem\_4bit
- **Type**: ``static const ulong[16]``
- **Description**: An array of 16 `ulong` values, each packed using the `PACK` macro. The values are constants used in the Galois/Counter Mode (GCM) cryptographic operations.
- **Use**: Used in the GCM multiplication and hashing functions to perform bitwise operations and transformations on data.


# Functions

---
### fd\_gcm\_init\_4bit<!-- {{#callable:fd_gcm_init_4bit}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_gcm_ref_ghash.c#L66>)

Initializes a 16-entry lookup table for Galois/Counter Mode (GCM) encryption using a 4-bit table-driven approach.
- **Inputs**:
    - `Htable`: An array of 16 `fd_gcm128_t` structures that will be initialized to store precomputed values for GCM encryption.
    - `H`: A constant array of two `ulong` values representing the initial hash subkey used for GCM encryption.
- **Logic and Control Flow**:
    - Initialize `Htable[0]` to zero.
    - Set `V` to the values in `H`.
    - Assign `V` to `Htable[8]` and apply `REDUCE1BIT` to `V`.
    - Assign the reduced `V` to `Htable[4]`, `Htable[2]`, and `Htable[1]`, applying `REDUCE1BIT` after each assignment.
    - Compute `Htable[3]` as the XOR of `V` and `Htable[2]`.
    - Assign `Htable[4]` to `V` and compute `Htable[5]`, `Htable[6]`, and `Htable[7]` as the XOR of `V` with `Htable[1]`, `Htable[2]`, and `Htable[3]` respectively.
    - Assign `Htable[8]` to `V` and compute `Htable[9]` to `Htable[15]` as the XOR of `V` with `Htable[1]` to `Htable[7]` respectively.
- **Output**: The function does not return a value; it initializes the `Htable` array with precomputed values for GCM encryption.


---
### fd\_gcm\_gmult\_4bit<!-- {{#callable:fd_gcm_gmult_4bit}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_gcm_ref_ghash.c#L108>)

Performs a 4-bit Galois field multiplication on a 128-bit block using a precomputed hash table.
- **Inputs**:
    - `Xi`: An array of two `ulong` values representing a 128-bit block to be multiplied.
    - `Htable`: A constant array of 16 `fd_gcm128_t` structures representing the precomputed hash table for multiplication.
- **Logic and Control Flow**:
    - Initialize `Z` with the values from `Htable` indexed by the lower 4 bits of the last byte of `Xi`.
    - Enter a loop that iterates 16 times, processing each 4-bit segment of `Xi`.
    - In each iteration, calculate the remainder of `Z.lo` and perform a right shift on `Z` by 4 bits.
    - XOR the high part of `Z` with a precomputed value from `rem_4bit` based on the remainder.
    - XOR `Z` with the values from `Htable` indexed by the current 4-bit segment of `Xi`.
    - Continue the loop until all 4-bit segments of `Xi` are processed.
    - Swap the byte order of `Z.hi` and `Z.lo` and store them back into `Xi`.
- **Output**: The function modifies the `Xi` array in place to contain the result of the multiplication.


---
### fd\_gcm\_ghash\_4bit<!-- {{#callable:fd_gcm_ghash_4bit}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_gcm_ref_ghash.c#L159>)

Performs a 4-bit Galois/Counter Mode (GCM) hash operation on input data blocks using a precomputed hash table.
- **Inputs**:
    - `Xi`: An array of two unsigned long integers representing the initial hash value, which will be updated with the result.
    - `Htable`: A constant array of 16 `fd_gcm128_t` structures representing the precomputed hash table for GCM.
    - `inp`: A pointer to the input data (unsigned char) to be hashed.
    - `len`: The length of the input data in bytes, which must be a multiple of 16.
- **Logic and Control Flow**:
    - Initialize a `fd_gcm128_t` structure `Z` and variables `cnt`, `rem`, `nlo`, and `nhi`.
    - Enter a loop that processes 16-byte blocks of input data until `len` is zero.
    - For each block, set `cnt` to 15 and compute `nlo` and `nhi` from the last byte of `Xi` XORed with the last byte of `inp`.
    - Initialize `Z` with the hash table values corresponding to `nlo`.
    - Enter a nested loop that iterates 16 times, processing each byte of the block.
    - In each iteration, compute `rem` from the lower 4 bits of `Z.lo`, shift `Z` right by 4 bits, and XOR `Z.hi` with a precomputed value from `rem_4bit`.
    - XOR `Z` with the hash table values corresponding to `nhi`.
    - Decrement `cnt` and break the loop if `cnt` is less than 0.
    - Update `nlo` and `nhi` for the next byte of the block and repeat the nested loop.
    - After processing the block, update `Xi` with the byte-swapped values of `Z.hi` and `Z.lo`.
    - Advance the `inp` pointer by 16 bytes and decrement `len` by 16.
- **Output**: Updates the `Xi` array with the resulting hash value after processing all input data blocks.



---
Made with ❤️ by [Driver](https://www.driver.ai/)