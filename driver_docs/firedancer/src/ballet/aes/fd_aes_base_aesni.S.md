<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Assembly code for AES encryption and decryption using AES-NI instructions, modified from OpenSSL's AES ASM code generator.

# Purpose
This assembly source code file is an implementation of AES (Advanced Encryption Standard) encryption and decryption using AES-NI (Advanced Encryption Standard New Instructions), which are a set of instructions that provide hardware acceleration for AES operations on x86-64 architectures. The code is generated by an AES ASM code generator from OpenSSL and is specifically tailored to utilize the AES-NI instructions for enhanced performance. The file includes functions for encrypting and decrypting data using various AES modes, such as ECB (Electronic Codebook) and CTR (Counter) modes, as well as functions for setting encryption and decryption keys.

The most important technical components of this file are the functions that perform encryption and decryption operations. These functions, such as `fd_aesni_encrypt`, `fd_aesni_decrypt`, `fd_aesni_ecb_encrypt`, and `fd_aesni_ctr32_encrypt_blocks`, leverage the AES-NI instructions to efficiently process data blocks. The file also includes key expansion routines, which are crucial for generating the necessary round keys from the initial encryption key. These routines ensure that the encryption and decryption processes are secure and adhere to the AES standard.

Overall, this code provides a focused functionality centered around AES encryption and decryption, optimized for performance on hardware that supports AES-NI. The common theme across the various components is the use of AES-NI instructions to accelerate cryptographic operations, making this implementation suitable for applications requiring high-speed encryption and decryption, such as secure communications and data protection.
# Global Variables

---
### \.Lbswap\_mask
- **Type**: `.byte array`
- **Description**: The variable `.Lbswap_mask` is a byte array consisting of 16 bytes, each representing a sequential decrement from 15 to 0. This array is typically used as a mask for byte-swapping operations, which are common in cryptographic algorithms to ensure data is in the correct byte order for processing.
- **Use**: This variable is used to facilitate byte-swapping operations in cryptographic functions, ensuring data is correctly ordered for processing.


---
### \.Lincrement32
- **Type**: `array of 32-bit integers`
- **Description**: The variable `.Lincrement32` is an array of four 32-bit integers, with the first three elements set to 6 and the last element set to 0. This array is likely used as a constant increment value in a loop or counter operation, possibly related to AES encryption or decryption processes.
- **Use**: This variable is used to provide a constant increment value, potentially for counter operations in AES encryption or decryption routines.


---
### \.Lincrement64
- **Type**: `long`
- **Description**: The variable `.Lincrement64` is a global variable defined as a long integer array with four elements. Each element in the array is initialized to specific values, with the first element set to 1 and the remaining three elements set to 0. This configuration suggests that the array is used to represent a 64-bit increment value, where the first element acts as the increment step and the rest are padding or placeholders for higher-order bits.
- **Use**: This variable is used to increment a 64-bit counter, likely in cryptographic operations such as AES counter mode (CTR), where it provides the increment value for the counter.


---
### \.Lincrement1
- **Type**: `.byte`
- **Description**: The variable `.Lincrement1` is a byte array consisting of 16 bytes, where the first 15 bytes are set to 0 and the last byte is set to 1. This pattern is often used as an increment value in cryptographic operations, particularly in counter (CTR) modes of encryption.
- **Use**: This variable is used to increment a counter by 1, typically in cryptographic operations such as AES in CTR mode.


---
### \.Lkey\_rotate
- **Type**: `long`
- **Description**: The variable `.Lkey_rotate` is a global constant defined in the assembly code. It is a 128-bit value represented by four 32-bit integers, each set to the hexadecimal value `0x0c0f0e0d`. This value is used in the AES key expansion process, specifically for the 256-bit key expansion routine.
- **Use**: This variable is used in the AES key expansion process to assist in the generation of round keys for encryption.


---
### \.Lkey\_rotate192
- **Type**: `long`
- **Description**: The variable `.Lkey_rotate192` is a global variable defined as a long integer array. It contains four identical 32-bit integer values, each set to `0x04070605`. This pattern is used in the AES key expansion process for 192-bit keys.
- **Use**: This variable is used in the AES key expansion process to assist in rotating and transforming the key material during the generation of round keys for 192-bit AES encryption.


---
### \.Lkey\_rcon1
- **Type**: ``.long``
- **Description**: The variable `.Lkey_rcon1` is a global variable defined as a sequence of four 32-bit integers, each with the value 1. It is used in the AES key expansion process, specifically as part of the round constant (Rcon) values used in the key schedule for AES encryption.
- **Use**: This variable is used in the AES key expansion process to provide round constants for the key schedule.


---
### \.Lkey\_rcon1b
- **Type**: `long`
- **Description**: The variable `.Lkey_rcon1b` is a global constant defined in the assembly code as a 128-bit value, where each 32-bit segment is set to the hexadecimal value `0x1b`. This value is used in the AES key expansion process, specifically for the Rijndael key schedule, as part of the round constant (Rcon) values.
- **Use**: This variable is used during the AES key expansion process to assist in generating the round keys by providing a constant value for the Rcon operation.


# Subroutines

---
### fd\_aesni\_encrypt
The `fd_aesni_encrypt` function performs AES encryption using the AES-NI instruction set for hardware acceleration.
- **Inputs**:
    - `%rdi`: Pointer to the input data to be encrypted.
    - `%rsi`: Pointer to the output buffer where the encrypted data will be stored.
    - `%rdx`: Pointer to the AES key schedule.
- **Logic and Control Flow**:
    - Load the input data from the address in %rdi into the xmm2 register.
    - Load the number of rounds from the key schedule at offset 240 into the eax register.
    - Load the first two round keys from the key schedule into xmm0 and xmm1.
    - Advance the key schedule pointer by 32 bytes.
    - Perform an XOR operation between xmm0 and xmm2 to apply the first round key.
    - Enter a loop that continues until the number of rounds (stored in eax) is zero.
    - Within the loop, perform the AES encryption round using the AESENC instruction (represented by the byte sequence 102,15,56,220,209).
    - Decrement the round counter in eax and load the next round key into xmm1.
    - Advance the key schedule pointer by 16 bytes.
    - Repeat the loop until all rounds are completed.
    - Perform the final AES encryption round using the AESENCLAST instruction (represented by the byte sequence 102,15,56,221,209).
    - Clear the xmm0 and xmm1 registers by XORing them with themselves.
    - Store the encrypted data from xmm2 into the output buffer at the address in %rsi.
    - Clear the xmm2 register by XORing it with itself.
    - Return from the function.
- **Output**: The function outputs the encrypted data in the buffer pointed to by %rsi.


---
### fd\_aesni\_decrypt
The `fd_aesni_decrypt` function performs AES decryption using the AES-NI instruction set for hardware-accelerated decryption.
- **Inputs**:
    - `%rdi`: Pointer to the input data to be decrypted.
    - `%rsi`: Pointer to the output buffer where decrypted data will be stored.
    - `%rdx`: Pointer to the AES key schedule used for decryption.
- **Logic and Control Flow**:
    - The function begins by loading the input data from the address pointed to by %rdi into the xmm2 register.
    - It retrieves the number of decryption rounds from the key schedule at an offset of 240 bytes and stores it in the %eax register.
    - The initial round key is loaded from the key schedule into the xmm0 register, and the next round key is loaded into xmm1.
    - The input data in xmm2 is XORed with the initial round key in xmm0.
    - A loop labeled .Loop_dec1_2 is entered, which performs the AES decryption rounds using the AES-NI instruction `aesdec` (represented by the byte sequence 102,15,56,222,209).
    - Within the loop, the next round key is loaded into xmm1, and the loop counter in %eax is decremented until it reaches zero, at which point the loop exits.
    - After the loop, the final AES decryption round is performed using the `aesdeclast` instruction (represented by the byte sequence 102,15,56,223,209).
    - The decrypted data in xmm2 is stored at the address pointed to by %rsi.
    - Finally, the function clears the xmm0, xmm1, and xmm2 registers and returns.
- **Output**: The function outputs the decrypted data to the memory location pointed to by %rsi.


---
### \_aesni\_encrypt2
The `_aesni_encrypt2` function performs AES encryption using the AES-NI instruction set for optimized performance.
- **Inputs**:
    - `%rcx`: Pointer to the AES key schedule.
    - `%eax`: Number of rounds to perform, shifted left by 4.
- **Logic and Control Flow**:
    - Load the first 16 bytes of the key schedule into %xmm0 and the next 16 bytes into %xmm1.
    - Perform an XOR operation between %xmm0 and %xmm2, and %xmm0 and %xmm3.
    - Load the next 32 bytes of the key schedule into %xmm0 and adjust the pointer %rcx to point to the next block of the key schedule.
    - Negate %rax and add 16 to it to prepare for the loop counter.
    - Enter a loop labeled .Lenc_loop2, which continues until %rax is zero.
    - Within the loop, perform AES encryption round operations using AES-NI instructions, updating %xmm1 and %xmm0 with the key schedule data.
    - Increment %rax by 32 and check if it is non-zero to continue the loop.
    - Exit the loop and finalize the encryption process.
- **Output**: The function does not return a value but modifies the state of the xmm registers to reflect the encrypted data.


---
### \_aesni\_decrypt2
The `_aesni_decrypt2` function performs AES decryption using the AES-NI instruction set for optimized performance.
- **Inputs**:
    - `%rcx`: Pointer to the decryption key schedule.
    - `%eax`: Number of decryption rounds, multiplied by 16.
- **Logic and Control Flow**:
    - Load the first 128 bits of the key schedule into %xmm0 and %xmm1.
    - Perform an XOR operation between %xmm0 and %xmm2, and %xmm0 and %xmm3 to initialize decryption.
    - Load the next 128 bits of the key schedule into %xmm0.
    - Calculate the address for the next key schedule block and adjust %rcx accordingly.
    - Negate %rax and add 16 to it to prepare for the decryption loop.
    - Enter the decryption loop labeled `.Ldec_loop2`.
    - Within the loop, use AES-NI instructions to perform decryption operations on the data blocks.
    - Continue looping until all rounds are completed, as indicated by the zero flag on %rax.
    - Exit the loop and complete the decryption process.
- **Output**: The function does not return a value directly; it modifies the data in place using the provided key schedule.


---
### \_aesni\_encrypt3
The `_aesni_encrypt3` function performs AES encryption using the AES-NI instruction set, processing three blocks of data in parallel.
- **Inputs**:
    - `%rcx`: Pointer to the key schedule used for encryption.
    - `%eax`: Number of rounds to perform, derived from the key length.
- **Logic and Control Flow**:
    - Load the first block of data into the XMM0 register from the memory location pointed to by %rcx.
    - Shift the value in %eax left by 4 bits to prepare for loop iteration calculations.
    - Load the second block of data into the XMM1 register from the memory location 16 bytes offset from %rcx.
    - Perform XOR operations on XMM0 with XMM2, XMM3, and XMM4 to initialize these registers for encryption.
    - Load the third block of data into the XMM0 register from the memory location 32 bytes offset from %rcx.
    - Calculate the address for the next block of data by adding 32 bytes and the shifted %eax value to %rcx.
    - Negate the value in %rax and add 16 to it to prepare for loop iterations.
    - Enter the encryption loop labeled `.Lenc_loop3`, which processes the data using AES-NI instructions.
    - Within the loop, perform AES encryption operations using the AESENC instruction (represented by the byte sequences) on the data in the XMM registers.
    - Load the next block of data into XMM1 and adjust %rax for the next iteration.
    - Continue looping until the counter in %rax reaches zero, indicating all blocks have been processed.
    - Exit the loop and return from the function.
- **Output**: The function does not return a value directly; it modifies the data in the XMM registers, which are expected to be stored back to memory by the caller.


---
### \_aesni\_decrypt3
The `_aesni_decrypt3` function performs AES decryption using the AES-NI instruction set for three blocks of data.
- **Inputs**:
    - `%rcx`: Pointer to the key schedule used for decryption.
    - `%eax`: Number of rounds to perform, derived from the key length.
    - `%rax`: Offset used for accessing the key schedule.
- **Logic and Control Flow**:
    - Load the first block of data into %xmm0 and the second block into %xmm1.
    - Perform an XOR operation on %xmm0 with %xmm2, %xmm3, and %xmm4 to initialize the decryption state.
    - Load the third block of data into %xmm0 and adjust the pointer %rcx to point to the next key schedule entry.
    - Negate %rax and add 16 to it to prepare for the decryption loop.
    - Enter the decryption loop labeled `.Ldec_loop3`, which iterates over the blocks using AES-NI instructions to perform decryption.
    - Within the loop, load the next key schedule entry into %xmm1 and adjust %rax by adding 32.
    - Continue the loop until all rounds are completed, using the `jnz` instruction to check for completion.
    - After the loop, finalize the decryption by performing additional AES-NI operations on the blocks.
- **Output**: The function outputs the decrypted data in the same memory location as the input data, effectively overwriting it.


---
### \_aesni\_encrypt4
The `_aesni_encrypt4` function performs AES encryption using the AES-NI instruction set, processing four blocks of data in parallel.
- **Inputs**:
    - `%rcx`: Pointer to the key schedule used for encryption.
    - `%eax`: Number of rounds to perform, derived from the key length.
- **Logic and Control Flow**:
    - Load the first block of data into the XMM0 register from the memory location pointed to by %rcx.
    - Shift the value in %eax left by 4 bits to prepare for loop iteration calculations.
    - Load the second block of data into the XMM1 register from the memory location 16 bytes offset from %rcx.
    - Perform XOR operations on XMM0 with XMM2, XMM3, XMM4, and XMM5 to initialize these registers with the first block of data.
    - Load the third block of data into the XMM0 register from the memory location 32 bytes offset from %rcx.
    - Calculate the address for the next block of data by adding 32 bytes and the shifted %eax value to %rcx.
    - Negate the value in %rax to prepare for loop iteration.
    - Add 16 to %rax to set up the loop counter.
    - Enter the encryption loop labeled `.Lenc_loop4`, which processes the data blocks using AES-NI instructions.
    - Within the loop, perform AES encryption operations on the data blocks using the AESENC instruction (represented by the byte sequences).
    - Load the next block of data into the XMM1 register from the calculated address using %rcx and %rax.
    - Increment %rax by 32 to move to the next block of data.
    - Continue the loop until the counter in %rax reaches zero, at which point the loop exits.
- **Output**: The function does not return a value directly; it modifies the data in the XMM registers, which are expected to be stored back to memory by the caller.


---
### \_aesni\_decrypt4
The `_aesni_decrypt4` function performs AES decryption using the AES-NI instruction set for a block of data with four rounds of decryption.
- **Inputs**:
    - `%rcx`: Pointer to the input data to be decrypted.
    - `%eax`: Number of decryption rounds, initially set to 4.
- **Logic and Control Flow**:
    - Load the input data from the memory location pointed to by `%rcx` into the `%xmm0` register.
    - Shift the value in `%eax` left by 4 bits to prepare for addressing calculations.
    - Load additional data from `%rcx` into `%xmm1` and perform XOR operations with `%xmm0` to initialize decryption state in `%xmm2`, `%xmm3`, `%xmm4`, and `%xmm5`.
    - Adjust the pointer `%rcx` to point to the next block of data by adding 32 bytes offset, adjusted by the shifted `%eax`.
    - Negate the value in `%rax` and add 16 to it to prepare for the decryption loop.
    - Enter the decryption loop labeled `.Ldec_loop4`, which iterates over the data blocks, performing AES decryption using the AES-NI instructions.
    - Within the loop, load data into `%xmm1` and perform decryption operations using AES-NI instructions, adjusting the pointer and counter as necessary.
    - Continue looping until the decryption rounds are completed, as indicated by the zero flag on `%eax`.
    - Exit the loop and return from the function.
- **Output**: The function does not return a value directly; it modifies the data in place, decrypting the input data block using AES-NI instructions.


---
### \_aesni\_encrypt6
The `_aesni_encrypt6` function performs AES encryption using the AES-NI instruction set, processing six blocks of data in parallel.
- **Inputs**:
    - `%rcx`: Pointer to the input data to be encrypted.
    - `%eax`: Number of encryption rounds, shifted left by 4.
- **Logic and Control Flow**:
    - Load the first block of input data into %xmm0 and the second block into %xmm1.
    - Perform XOR operations on %xmm0 with %xmm2, %xmm3, %xmm4, %xmm5, %xmm6, and %xmm7 to initialize the encryption state.
    - Adjust the pointer %rcx to point to the next block of data and negate %rax to prepare for the loop.
    - Enter the encryption loop labeled `.Lenc_loop6_enter`, which processes the data in blocks of 16 bytes.
    - Within the loop, load the next block of data into %xmm1 and update the pointer and counter.
    - Continue the loop until all blocks are processed, using AES-NI instructions to perform encryption operations.
    - Store the encrypted data back to the memory location pointed by %rsi.
- **Output**: The function outputs the encrypted data, stored in the memory location pointed by %rsi.


---
### \_aesni\_decrypt6
The `_aesni_decrypt6` function performs AES decryption using the AES-NI instruction set for optimized performance, processing six blocks of data in parallel.
- **Inputs**:
    - `%rcx`: Pointer to the input data to be decrypted.
    - `%eax`: Number of decryption rounds, multiplied by 16.
- **Logic and Control Flow**:
    - Load the first block of input data into the XMM0 register.
    - Shift the number of rounds left by 4 bits to the left and store it in %eax.
    - Load the second block of input data into the XMM1 register.
    - Perform XOR operations on the input data with the initial key schedule using XMM registers.
    - Adjust the pointer to the key schedule and negate the round counter.
    - Enter the decryption loop, processing six blocks of data in parallel using AES-NI instructions.
    - Continue looping until all blocks are processed, updating the key schedule and input data pointers.
    - Store the decrypted data back to the output location.
- **Output**: The function outputs the decrypted data, stored in the memory location pointed to by the output register.


---
### \_aesni\_encrypt8
The `_aesni_encrypt8` function performs AES encryption on eight blocks of data using the AES-NI instruction set for hardware acceleration.
- **Inputs**:
    - `%rcx`: Pointer to the key schedule used for encryption.
    - `%eax`: Number of rounds to perform, derived from the key length.
    - `%rax`: Used as an index and counter for the loop.
- **Logic and Control Flow**:
    - Load the first block of data into %xmm0 and the second block into %xmm1.
    - Perform XOR operations on %xmm0 with %xmm2, %xmm3, %xmm4, %xmm5, %xmm6, %xmm7, %xmm8, and %xmm9 to initialize the encryption state.
    - Adjust the pointer %rcx to point to the next set of data blocks and negate %rax to prepare for the loop.
    - Enter the main encryption loop labeled .Lenc_loop8, which processes the data blocks using AES-NI instructions.
    - Within the loop, load data into %xmm1, increment %rax, and continue processing until the loop condition is met.
    - After the loop, finalize the encryption by performing additional AES-NI operations on the data blocks.
- **Output**: The function does not return a value but modifies the data blocks in place, storing the encrypted result back into the memory locations pointed to by the input registers.


---
### \_aesni\_decrypt8
The `_aesni_decrypt8` function performs AES decryption on eight blocks of data using the AES-NI instruction set for optimized performance.
- **Inputs**:
    - `%rcx`: Pointer to the input data to be decrypted.
    - `%eax`: Number of rounds to perform, derived from the key schedule.
- **Logic and Control Flow**:
    - Load the first block of input data into the XMM0 register.
    - Shift the number of rounds left by 4 bits to prepare for loop iteration.
    - Load the second block of input data into the XMM1 register.
    - Perform XOR operations on the input data with the key schedule to initialize decryption.
    - Adjust the pointer to the key schedule for further processing.
    - Negate the number of rounds to set up for loop iteration.
    - Enter the decryption loop, processing each block of data using AES-NI instructions.
    - Continue looping until all blocks are processed, updating the pointer and counter as needed.
    - Store the decrypted data back to the output location.
- **Output**: The function outputs the decrypted data blocks, stored in the memory location pointed to by the output register.


---
### fd\_aesni\_ecb\_encrypt
The `fd_aesni_ecb_encrypt` function performs AES encryption or decryption in ECB mode using AES-NI instructions for acceleration.
- **Inputs**:
    - `%rdi`: Pointer to the input data to be encrypted or decrypted.
    - `%rsi`: Pointer to the output buffer where the encrypted or decrypted data will be stored.
    - `%rdx`: Length of the data to be processed, in bytes.
    - `%rcx`: Pointer to the AES key schedule.
    - `%r8d`: Flag indicating whether to encrypt (non-zero) or decrypt (zero).
- **Logic and Control Flow**:
    - The function begins by aligning the data length to a 16-byte boundary and checks if the length is zero, returning immediately if so.
    - It loads the AES key schedule and checks the encryption/decryption flag to determine the operation mode.
    - For encryption, it processes data in blocks of 128 bytes using a loop, calling `_aesni_encrypt8` for each block, and handles any remaining data with smaller block sizes.
    - For decryption, it similarly processes data in blocks of 128 bytes using `_aesni_decrypt8`, and handles remaining data with smaller block sizes.
    - The function uses a series of conditional jumps and calls to specialized subroutines (`_aesni_encrypt2`, `_aesni_encrypt3`, etc.) to handle different block sizes efficiently.
    - The function ends by clearing sensitive data from registers and returning.
- **Output**: The function outputs the encrypted or decrypted data in the buffer pointed to by %rsi.


---
### fd\_aesni\_ctr32\_encrypt\_blocks
The `fd_aesni_ctr32_encrypt_blocks` function performs AES encryption in CTR mode using AES-NI instructions for 32-bit counter blocks.
- **Inputs**:
    - `%rdi`: Pointer to the input data to be encrypted.
    - `%rsi`: Pointer to the output buffer where encrypted data will be stored.
    - `%rdx`: Number of 128-bit blocks to be encrypted.
    - `%rcx`: Pointer to the AES key schedule.
    - `%r8`: Pointer to the counter block.
- **Logic and Control Flow**:
    - The function first checks if the number of blocks to encrypt is 1, in which case it performs a single block encryption using a loop to apply the AES rounds.
    - If more than one block is to be encrypted, it sets up the stack and prepares the counter values for multiple blocks.
    - The function uses a loop to process 8 blocks at a time, updating the counter and performing encryption using AES-NI instructions.
    - For each block, the counter is incremented, and the encrypted counter is XORed with the input data to produce the ciphertext.
    - If there are remaining blocks after processing in chunks of 8, the function handles them in smaller chunks or individually.
    - The function cleans up the stack and registers before returning.
- **Output**: The function outputs the encrypted data in the buffer pointed to by %rsi.


---
### fd\_aesni\_set\_decrypt\_key
The `fd_aesni_set_decrypt_key` function sets up the AES decryption key schedule using AES-NI instructions by reversing the encryption key schedule.
- **Inputs**:
    - `rdx`: Pointer to the memory location where the encryption key schedule is stored.
    - `rsi`: The number of 32-bit words in the key, multiplied by 4, indicating the key length.
- **Logic and Control Flow**:
    - The function begins by calling `__aesni_set_encrypt_key` to set up the encryption key schedule.
    - It checks if the call to `__aesni_set_encrypt_key` was successful by testing the return value in `eax`.
    - If the call was unsuccessful, it jumps to the return label `.Ldec_key_ret`.
    - If successful, it calculates the pointer to the end of the key schedule using `rsi` and `rdx`.
    - The function then enters a loop to reverse the key schedule by swapping elements from the start and end of the schedule.
    - Within the loop, it uses AES-NI instructions to perform the key schedule inversion efficiently.
    - The loop continues until the pointers `rdx` and `rdi` meet or cross each other.
    - Finally, it clears the registers and returns from the function.
- **Output**: The function does not return a value but modifies the memory pointed to by `rdx` to contain the decryption key schedule.


---
### fd\_aesni\_set\_encrypt\_key
The `fd_aesni_set_encrypt_key` function sets up the AES encryption key schedule using AES-NI instructions for hardware-accelerated encryption.
- **Inputs**:
    - `%rdi`: Pointer to the user-provided key.
    - `%rdx`: Pointer to the location where the expanded key schedule will be stored.
    - `%esi`: The size of the key in bits (128, 192, or 256).
- **Logic and Control Flow**:
    - The function begins by checking if the key pointer (%rdi) or the expanded key schedule pointer (%rdx) is null, returning immediately if either is null.
    - It initializes the key schedule by moving the user-provided key into the first position of the expanded key schedule.
    - The function determines the number of rounds based on the key size: 10 rounds for 128-bit keys, 12 rounds for 192-bit keys, and 14 rounds for 256-bit keys.
    - For 128-bit keys, it uses a series of AESKEYGENASSIST instructions to expand the key schedule for 10 rounds.
    - For 192-bit keys, it uses a combination of AESKEYGENASSIST and additional logic to expand the key schedule for 12 rounds.
    - For 256-bit keys, it uses AESKEYGENASSIST and additional logic to expand the key schedule for 14 rounds.
    - The function handles different key sizes by branching to specific sections of code tailored for each key size.
    - If an invalid key size is provided, the function sets the return value to -2 to indicate an error.
    - The function clears sensitive data from registers before returning.
- **Output**: The function outputs the expanded key schedule in the memory location pointed to by %rdx, and returns 0 on success or -2 on error.



---
Made with ❤️ by [Driver](https://www.driver.ai/)