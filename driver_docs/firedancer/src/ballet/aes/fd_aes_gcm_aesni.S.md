<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Assembly code for AES-GCM encryption and decryption optimized for x86_64 CPUs with AES-NI and AVX support.

# Purpose
This assembly source code file implements an optimized version of the AES-GCM (Galois/Counter Mode) cryptographic algorithm for x86_64 CPUs that support AES-NI (Advanced Encryption Standard New Instructions). The file provides two implementations: one utilizing AVX (Advanced Vector Extensions) and another without it. The primary purpose of this code is to enhance the performance of AES-GCM operations by leveraging specific CPU instructions that accelerate encryption and decryption processes. The code is structured to handle both encryption and decryption, as well as the computation of authentication tags, which are crucial for ensuring data integrity and authenticity in secure communications.

The technical components of this file include macros for various cryptographic operations, such as AES encryption rounds, GHASH multiplication, and counter block generation. The code is designed to efficiently manage CPU registers and memory operations, using techniques like Karatsuba multiplication to optimize GHASH computations. The file also includes mechanisms to handle partial data blocks and ensure that operations are performed in a manner that maximizes parallel execution capabilities of modern CPUs. The use of macros allows for code reuse and reduces redundancy, making the implementation both compact and efficient.

Overall, this file is a specialized collection of cryptographic functions focused on providing high-performance AES-GCM operations on x86_64 architectures. It is tailored to exploit the capabilities of CPUs with AES-NI and AVX support, ensuring that encryption and decryption tasks are executed swiftly and securely. The dual-licensed nature of the file under Apache 2.0 and BSD-2-Clause licenses allows for flexible use and integration into various software projects, promoting widespread adoption and contribution to the cryptographic community.
# Data Structures

---
### aes\_gcm\_key\_aesni
- **Type**: `struct`
- **Members**:
    - `OFFSETOF_AESKEYLEN`: Offset for the AES key length within the structure.
    - `OFFSETOF_H_POWERS`: Offset for the precomputed hash key powers within the structure.
    - `OFFSETOF_H_POWERS_XORED`: Offset for the XOR'd halves of the hash key powers within the structure.
    - `OFFSETOF_H_TIMES_X64`: Offset for the hash key multiplied by x^64 within the structure.
- **Description**: The `aes_gcm_key_aesni` structure is designed to store key-related data for AES-GCM encryption and decryption optimized for x86_64 CPUs with AES-NI support. It includes offsets for various precomputed values necessary for the GHASH operation, such as the AES key length, hash key powers, XOR'd hash key powers, and the hash key multiplied by x^64. These precomputed values are used to accelerate the encryption and decryption processes by minimizing the need for repeated calculations during the AES-GCM operations.


# Subroutines

---
### aes\_gcm\_precompute\_aesni
The `aes_gcm_precompute_aesni` function derives the GHASH subkey and initializes the GHASH-related fields in the AES-GCM key structure using AES-NI instructions.
- **Inputs**:
    - `key`: A pointer to the `aes_gcm_key_aesni` structure which contains the expanded AES key and will be updated with GHASH-related fields.
- **Logic and Control Flow**:
    - The function begins by setting up the necessary registers and local variables, including pointers to the AES key and temporary registers for calculations.
    - It encrypts an all-zero block using the AES key to derive the raw hash subkey, which is then byte-reflected and multiplied by x^-1 to prepare it for GHASH operations.
    - The precomputed hash subkey (H^1) is stored in the key structure, and additional precomputations are performed to derive H^1 * x^64 and the XOR of the halves of H^1, which are also stored in the key structure.
    - The function then computes and stores the remaining key powers H^2 through H^8 by iteratively multiplying the current power by H^1 using the GHASH multiplication macro.
    - The function concludes by returning, having updated the key structure with all necessary GHASH-related precomputations.
- **Output**: The function updates the `aes_gcm_key_aesni` structure with precomputed GHASH subkey values and related fields for efficient AES-GCM operations.


---
### aes\_gcm\_aad\_update\_aesni
The `aes_gcm_aad_update_aesni` function updates the GHASH accumulator with additional authenticated data (AAD) using AES-NI instructions.
- **Inputs**:
    - `key`: A pointer to the `aes_gcm_key_aesni` structure containing the precomputed GHASH key powers.
    - `ghash_acc`: A 16-byte buffer representing the current GHASH accumulator state, which must be all zeroes on the first call.
    - `aad`: A pointer to the additional authenticated data to be processed.
    - `aadlen`: An integer representing the length of the AAD, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Load the byte swap mask and the current GHASH accumulator state from memory.
    - Load the precomputed GHASH key powers H^1 and H^1 * x^64 from the key structure.
    - Iterate over the AAD in 16-byte blocks, byte-reflect each block, and XOR it with the GHASH accumulator.
    - Perform a GHASH multiplication for each block using the precomputed key powers and update the GHASH accumulator.
    - If there is a partial block at the end, load and zero-pad it, then process it similarly to a full block.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The function updates the GHASH accumulator with the processed AAD, modifying the `ghash_acc` buffer in place.


---
### aes\_gcm\_enc\_update\_aesni
The `aes_gcm_enc_update_aesni` function performs AES-GCM encryption by computing the CTR keystream, XORing it with input data, and updating the GHASH accumulator with the ciphertext.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for encryption.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer holding the current GHASH accumulator value.
    - `src`: A pointer to the source data to be encrypted.
    - `dst`: A pointer to the destination buffer where the encrypted data will be stored.
    - `datalen`: An integer representing the length of the data to be processed, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Initialize necessary registers and load the GHASH accumulator and counter values.
    - Check if the data length is sufficient for processing in blocks of 8*16 bytes; if so, enter the main loop.
    - In the main loop, generate 8 counter blocks, perform AES encryption rounds, and update the GHASH accumulator using Karatsuba multiplication for efficiency.
    - If encrypting, XOR the plaintext with the keystream to produce ciphertext, and update the GHASH with the ciphertext blocks.
    - Handle any remaining data that is less than 8*16 bytes by processing one block at a time, performing AES encryption and GHASH updates as needed.
    - For partial blocks, load and zero-pad the data, encrypt the counter block, and update the GHASH accumulator.
    - Finally, reduce the GHASH intermediate values and store the updated GHASH accumulator back to memory.
- **Output**: The function outputs the encrypted data in the destination buffer and updates the GHASH accumulator with the processed ciphertext.


---
### aes\_gcm\_dec\_update\_aesni
The `aes_gcm_dec_update_aesni` function performs AES-GCM decryption and updates the GHASH accumulator using AES-NI instructions on x86_64 architecture.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for decryption.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer holding the current GHASH accumulator value.
    - `src`: A pointer to the source data buffer containing the ciphertext to be decrypted.
    - `dst`: A pointer to the destination buffer where the decrypted data will be stored.
    - `datalen`: An integer representing the length of the data to be processed, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Initialize local variables and load the GHASH accumulator and counter values.
    - Check if the data length is sufficient for processing in blocks of 8*16 bytes and enter the main loop if so.
    - In the main loop, generate counter blocks, perform AES encryption on them, and XOR the result with the ciphertext to produce plaintext.
    - Update the GHASH accumulator with the ciphertext blocks using Karatsuba multiplication for efficiency.
    - Handle any remaining data that is less than 8*16 bytes by processing one block at a time, updating the GHASH accumulator accordingly.
    - Perform a final GHASH reduction to ensure the accumulator is correctly updated.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The function outputs the decrypted data in the destination buffer and updates the GHASH accumulator with the processed ciphertext.


---
### aes\_gcm\_enc\_final\_aesni
The `aes_gcm_enc_final_aesni` function finalizes the AES-GCM encryption process by computing the authentication tag using the GHASH accumulator and the total lengths of the additional authenticated data and encrypted data.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for encryption.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer holding the current GHASH accumulator value.
    - `total_aadlen`: The total length of the additional authenticated data in bytes.
    - `total_datalen`: The total length of the encrypted data in bytes.
- **Logic and Control Flow**:
    - Initialize the BSWAP_MASK and load the AES key length.
    - Set up a counter block with 1 in the low 32-bit word to produce the ciphertext needed to encrypt the authentication tag.
    - Build the lengths block from total_aadlen and total_datalen, convert them to bits, and XOR it into the GHASH accumulator.
    - Load the precomputed hash key powers and perform GHASH multiplication to update the GHASH accumulator with the lengths block.
    - Encrypt the counter block using the AES key schedule to produce the final keystream block.
    - XOR the final keystream block with the GHASH accumulator to produce the authentication tag.
    - Store the computed authentication tag back to the ghash_acc buffer.
- **Output**: The function outputs the computed 16-byte authentication tag by storing it in the ghash_acc buffer.


---
### aes\_gcm\_dec\_final\_aesni
The `aes_gcm_dec_final_aesni` function finalizes the decryption process in AES-GCM mode by computing and verifying the authentication tag.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for GHASH and AES operations.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer containing the current GHASH accumulator value.
    - `total_aadlen`: The total length of the additional authenticated data in bytes.
    - `total_datalen`: The total length of the decrypted data in bytes.
    - `tag`: A pointer to a 16-byte buffer containing the expected authentication tag.
    - `taglen`: The length of the tag to be verified, between 4 and 16 bytes.
- **Logic and Control Flow**:
    - Initialize local variables and load necessary constants and precomputed values from the key structure.
    - Set up a counter block with a value of 1 in the low 32-bit word to generate the ciphertext needed for the authentication tag.
    - Build the lengths block using the total AAD and data lengths, convert them to bits, and XOR it into the GHASH accumulator.
    - Perform AES encryption on the counter block while simultaneously multiplying the GHASH accumulator by the hash key H^1 using interleaved instructions for performance optimization.
    - Undo the byte reflection of the GHASH accumulator and encrypt it to produce the computed authentication tag.
    - Compare the computed tag with the expected tag in constant time by XORing them and using the `ptest` instruction to verify if the first `taglen` bytes are zero.
    - Return true if the tags match, otherwise return false.
- **Output**: Returns a boolean value indicating whether the computed authentication tag matches the expected tag.


---
### aes\_gcm\_precompute\_aesni\_avx
The `aes_gcm_precompute_aesni_avx` function precomputes the GHASH subkey and initializes related fields in the AES-GCM key structure using AES-NI and AVX instructions.
- **Inputs**:
    - `key`: A pointer to the `aes_gcm_key_aesni` structure which contains the expanded AES key and will be updated with precomputed GHASH values.
- **Logic and Control Flow**:
    - The function begins by setting up the necessary registers and pointers for the AES key and GHASH subkey calculations.
    - It encrypts an all-zero block using the AES key to derive the raw GHASH subkey, iterating through the AES rounds until the last round key is reached.
    - The raw GHASH subkey is byte-reflected and multiplied by x^-1 to prepare it for GHASH operations, then stored as H^1 in the key structure.
    - The function computes H^1 * x^64 and stores it in the key structure, which is used for GHASH multiplication optimizations.
    - It calculates and stores the XOR of the halves of H^1, which is used in Karatsuba multiplication for GHASH.
    - The function iteratively computes and stores the powers of H from H^2 to H^8, using the previously computed values and the GHASH multiplication macro.
    - Finally, the function returns, having updated the key structure with all necessary precomputed GHASH values.
- **Output**: The function updates the `aes_gcm_key_aesni` structure with precomputed GHASH subkey values and related fields for optimized AES-GCM operations.


---
### aes\_gcm\_aad\_update\_aesni\_avx
The `aes_gcm_aad_update_aesni_avx` function processes Additional Authenticated Data (AAD) in GCM mode, updating the GHASH accumulator using AES-NI and AVX instructions.
- **Inputs**:
    - `key`: A pointer to the `aes_gcm_key_aesni` structure containing the precomputed GHASH key powers.
    - `ghash_acc`: A 16-byte buffer representing the current GHASH accumulator state.
    - `aad`: A pointer to the Additional Authenticated Data to be processed.
    - `aadlen`: The length of the AAD in bytes, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Load the byte swap mask and the initial GHASH accumulator state from memory.
    - Load the precomputed GHASH key powers H^1 and H^1 * x^64 from the key structure.
    - Iterate over the AAD in 16-byte blocks, byte-reflecting each block and XORing it with the GHASH accumulator.
    - Perform GHASH multiplication using the precomputed key powers and update the GHASH accumulator.
    - If there is a partial block at the end, load and process it similarly, ensuring it is zero-padded as needed.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The function updates the GHASH accumulator with the processed AAD data.


---
### aes\_gcm\_enc\_update\_aesni\_avx
The `aes_gcm_enc_update_aesni_avx` function performs AES-GCM encryption using AES-NI and AVX instructions, updating the GHASH accumulator and processing data in blocks.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for encryption.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer holding the current GHASH accumulator value.
    - `src`: A pointer to the source data to be encrypted.
    - `dst`: A pointer to the destination buffer where the encrypted data will be stored.
    - `datalen`: An integer representing the length of the data to be processed, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Initialize key length and round key pointers based on the AES key length.
    - Load the GHASH accumulator and counter values from memory.
    - Check if the data length is sufficient for processing in 8-block chunks; if so, enter the main loop.
    - In the main loop, generate counter blocks, perform AES encryption, and update the GHASH accumulator using Karatsuba multiplication for efficiency.
    - For each 8-block chunk, interleave AES encryption and GHASH updates to optimize performance on CPUs with parallel execution capabilities.
    - If encrypting, XOR the plaintext with the keystream to produce ciphertext, and update the GHASH with the ciphertext blocks.
    - Handle any remaining data that is less than 8 blocks by processing one block at a time, updating the GHASH accumulator as needed.
    - Perform a final GHASH reduction to ensure the accumulator is correctly updated.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The function outputs the encrypted data in the destination buffer and updates the GHASH accumulator in place.


---
### aes\_gcm\_dec\_update\_aesni\_avx
The `aes_gcm_dec_update_aesni_avx` function performs AES-GCM decryption using AES-NI and AVX instructions, updating the GHASH accumulator with the decrypted data.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for encryption and decryption.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer that holds the current GHASH accumulator value.
    - `src`: A pointer to the source data buffer containing the ciphertext to be decrypted.
    - `dst`: A pointer to the destination buffer where the decrypted data will be stored.
    - `datalen`: An integer representing the length of the data to be processed, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Initialize local variables and load the GHASH accumulator and counter values from memory.
    - Check if the data length is sufficient for processing in blocks of 8*16 bytes and enter the main loop if so.
    - In the main loop, generate counter blocks, perform AES encryption on them, and XOR the result with the ciphertext to produce plaintext.
    - Update the GHASH accumulator with the decrypted ciphertext using Karatsuba multiplication for efficiency.
    - Handle any remaining data that is less than 8*16 bytes by processing one block at a time, updating the GHASH accumulator accordingly.
    - Perform a final GHASH reduction to ensure the accumulator is correctly updated.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The function outputs the decrypted data in the destination buffer and updates the GHASH accumulator with the processed data.


---
### aes\_gcm\_enc\_final\_aesni\_avx
The `aes_gcm_enc_final_aesni_avx` function finalizes the AES-GCM encryption process by computing the authentication tag using the GHASH accumulator and the total lengths of the additional authenticated data and encrypted data.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for encryption.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer holding the current GHASH accumulator value.
    - `total_aadlen`: A 64-bit integer representing the total length of the additional authenticated data in bytes.
    - `total_datalen`: A 64-bit integer representing the total length of the encrypted data in bytes.
- **Logic and Control Flow**:
    - Initialize local variables and load necessary constants and precomputed values from the key structure.
    - Set up a counter block with a value of 1 in the low 32-bit word to generate the ciphertext needed for encrypting the authentication tag.
    - Build the lengths block by combining the total lengths of the additional authenticated data and encrypted data, converting them from bytes to bits, and XOR it into the GHASH accumulator.
    - Load the necessary AES round keys and perform AES encryption on the counter block while simultaneously multiplying the GHASH accumulator by the hash key H^1 using interleaved AES and GHASH instructions to optimize performance.
    - Undo the byte reflection of the GHASH accumulator and encrypt it to produce the final authentication tag.
    - Store the computed authentication tag back to the `ghash_acc` buffer.
- **Output**: The function outputs the computed 16-byte authentication tag, which is stored in the `ghash_acc` buffer.


---
### aes\_gcm\_dec\_final\_aesni\_avx
The `aes_gcm_dec_final_aesni_avx` function finalizes the decryption process in AES-GCM mode by computing and verifying the authentication tag using AES-NI and AVX instructions.
- **Inputs**:
    - `key`: A pointer to the AES-GCM key structure containing precomputed values for GHASH and AES operations.
    - `le_ctr`: A pointer to a 4-element array representing the current counter in little-endian format.
    - `ghash_acc`: A pointer to a 16-byte buffer containing the current GHASH accumulator value.
    - `total_aadlen`: The total length of the additional authenticated data in bytes.
    - `total_datalen`: The total length of the decrypted data in bytes.
    - `tag`: A pointer to a 16-byte buffer containing the expected authentication tag.
    - `taglen`: The length of the tag to be verified, ranging from 4 to 16 bytes.
- **Logic and Control Flow**:
    - Initialize local variables and load necessary constants and precomputed values from the key structure.
    - Set up a counter block with a value of 1 in the low 32-bit word to generate the ciphertext needed for the authentication tag.
    - Build the lengths block by combining total AAD length and total data length, convert them to bits, and XOR with the GHASH accumulator.
    - Perform AES encryption on the counter block while simultaneously multiplying the GHASH accumulator by the hash key H^1 using interleaved AES and GHASH instructions for performance optimization.
    - Undo the byte reflection of the GHASH accumulator and encrypt it to produce the computed authentication tag.
    - Compare the computed tag with the expected tag in constant time by XORing them and using the ptest instruction to verify if the first taglen bytes are zero, indicating a match.
    - Return true if the tags match, otherwise return false.
- **Output**: Returns a boolean value indicating whether the computed authentication tag matches the expected tag.


# Macros

---
### \_vpclmulqdq
The `_vpclmulqdq` macro performs a carry-less multiplication of two 64-bit operands using the `vpclmulqdq` instruction if AVX is available, otherwise it falls back to using `movdqa` and `pclmulqdq` instructions.
- **Inputs**:
    - `imm`: An immediate value specifying the control byte for the carry-less multiplication.
    - `src1`: The first source operand, which is an xmm register.
    - `src2`: The second source operand, which is an xmm register.
    - `dst`: The destination operand, which is an xmm register where the result is stored.
- **Logic and Control Flow**:
    - Check if AVX is enabled using the `USE_AVX` flag.
    - If AVX is enabled, execute the `vpclmulqdq` instruction with the given immediate, source operands, and destination.
    - If AVX is not enabled, move the second source operand to the destination using `movdqa`.
    - Perform the carry-less multiplication using `pclmulqdq` with the immediate and the first source operand, storing the result in the destination.
- **Output**: The result of the carry-less multiplication is stored in the `dst` xmm register.


---
### \_vpshufb
The `_vpshufb` macro performs a byte-wise shuffle of a source register using a shuffle mask, utilizing AVX instructions if available, or falling back to SSE instructions if not.
- **Inputs**:
    - `src1`: The source register containing the data to be shuffled.
    - `src2`: The register containing the shuffle mask.
    - `dst`: The destination register where the shuffled result will be stored.
- **Logic and Control Flow**:
    - Check if AVX is enabled using the `USE_AVX` flag.
    - If AVX is enabled, execute the `vpshufb` instruction with `src1`, `src2`, and `dst` as arguments.
    - If AVX is not enabled, move the contents of `src2` to `dst` using `movdqa`.
    - Execute the `pshufb` instruction with `src1` and `dst` to perform the shuffle operation.
- **Output**: The output is the shuffled data stored in the `dst` register, with the shuffle operation determined by the mask in `src2`.


---
### \_vpand
The `_vpand` macro performs a bitwise AND operation between two source operands and stores the result in a destination operand, using AVX instructions if available, or falling back to SSE instructions if not.
- **Inputs**:
    - `src1`: The first source operand for the AND operation.
    - `src2`: The second source operand for the AND operation.
    - `dst`: The destination operand where the result of the AND operation is stored.
- **Logic and Control Flow**:
    - Check if AVX is enabled using the `USE_AVX` flag.
    - If AVX is enabled, execute the `vpand` instruction with `src1`, `src2`, and `dst`.
    - If AVX is not enabled, move `src1` to `dst` using `movdqu`, then perform the `pand` instruction with `src2` and `dst`.
- **Output**: The result of the bitwise AND operation is stored in the `dst` operand.


---
### \_xor\_mem\_to\_reg
The `_xor_mem_to_reg` macro performs an XOR operation between an unaligned memory operand and an xmm register, using a temporary xmm register if AVX is not available.
- **Inputs**:
    - `mem`: The memory operand to be XORed, which is unaligned.
    - `reg`: The xmm register that will be XORed with the memory operand.
    - `tmp`: A temporary xmm register used to hold the memory operand if AVX is not available.
- **Logic and Control Flow**:
    - If AVX is available, the macro uses the `vpxor` instruction to XOR the memory operand directly with the xmm register.
    - If AVX is not available, the macro first moves the memory operand into the temporary xmm register using `movdqu`, then performs the XOR operation with the `pxor` instruction.
- **Output**: The result of the XOR operation is stored back in the xmm register specified by `reg`.


---
### \_test\_mem
The `_test_mem` macro tests an unaligned memory operand against an xmm register, using AVX instructions if available, or falling back to SSE instructions otherwise.
- **Inputs**:
    - `mem`: The unaligned memory operand to be tested against the xmm register.
    - `reg`: The xmm register against which the memory operand is tested.
    - `tmp`: A temporary xmm register used in the fallback path when AVX is not available.
- **Logic and Control Flow**:
    - If AVX is available (`USE_AVX` is set), the macro uses the `vptest` instruction to test the memory operand against the xmm register directly.
    - If AVX is not available, the macro first loads the memory operand into the temporary xmm register using `movdqu`, then uses the `ptest` instruction to test the temporary register against the xmm register.
- **Output**: The result of the test is not directly output by the macro, but the `vptest` or `ptest` instruction sets the ZF and CF flags based on the result of the test.


---
### \_load\_partial\_block
The `_load_partial_block` macro loads a specified number of bytes (1 to 15) from a source pointer into an xmm register, zeroing out any remaining bytes.
- **Inputs**:
    - `src`: The pointer to the source memory location from which bytes are to be loaded.
    - `dst`: The xmm register where the loaded bytes will be stored.
    - `tmp64`: A temporary 64-bit register used for intermediate storage during the loading process.
    - `tmp32`: A temporary 32-bit register used for intermediate storage during the loading process.
- **Logic and Control Flow**:
    - Subtract 8 from the byte count in %ecx to determine if more than 8 bytes need to be loaded.
    - If more than 8 bytes are needed, load the first 8 bytes into the destination register and the last 8 bytes into %rax, then shift and combine them.
    - If 4 to 8 bytes are needed, load the first 4 bytes into %eax and the last 4 bytes into a temporary register, then combine them.
    - If 1 to 3 bytes are needed, load the first byte into %eax and the last 2 bytes into a temporary register, then combine them.
    - Store the combined result into the destination xmm register.
- **Output**: The xmm register `dst` contains the loaded bytes from `src`, with any remaining bytes zeroed out.


---
### \_store\_partial\_block
The `_store_partial_block` macro stores a specified number of bytes from an XMM register to a memory location, handling cases where the number of bytes is less than 16 by using conditional logic to store the appropriate number of bytes.
- **Inputs**:
    - `src`: The XMM register containing the data to be stored.
    - `dst`: The memory location where the data from the XMM register will be stored.
- **Logic and Control Flow**:
    - Subtract 8 from the byte count in %ecx to determine if the length is less than 8 bytes.
    - If the length is 8 or more, extract the upper 8 bytes from the XMM register and store them at the destination offset by the remaining length minus 8 bytes, then store the lower 8 bytes directly.
    - If the length is less than 8, add 4 to the byte count to determine if the length is less than 4 bytes.
    - If the length is between 4 and 7, extract the upper 4 bytes from the XMM register and store them at the destination offset by the remaining length minus 4 bytes, then store the lower 4 bytes directly.
    - If the length is less than 4, extract and store each byte individually until the length is satisfied.
- **Output**: The specified number of bytes from the XMM register are stored in the memory location pointed to by `dst`, with any remaining bytes in the register not being stored.


---
### \_ghash\_mul\_step
The `_ghash_mul_step` macro performs one step of the GHASH multiplication by multiplying parts of two inputs and combining them with a polynomial reduction.
- **Inputs**:
    - `i`: The step index, ranging from 0 to 9, indicating which part of the multiplication and reduction process to execute.
    - `a`: The first input operand for the GHASH multiplication, representing a part of the hash key.
    - `a_times_x64`: The precomputed value of the first input operand multiplied by x^64, used for polynomial reduction.
    - `b`: The second input operand for the GHASH multiplication, representing a part of the data block.
    - `gfpoly`: The polynomial used for reduction, typically a constant value.
    - `t0`: A temporary register used to store intermediate results during the multiplication and reduction process.
    - `t1`: Another temporary register used to store intermediate results during the multiplication and reduction process.
- **Logic and Control Flow**:
    - The macro is executed in a loop with `i` ranging from 0 to 9, performing different operations based on the value of `i`.
    - For `i == 0`, it calculates the middle intermediate (MI) part by multiplying the lower parts of `a` and `b`.
    - For `i == 1`, it calculates another part of MI by multiplying the lower part of `a_times_x64` and `b`.
    - For `i == 2`, it combines the results of the previous two steps using XOR to form the complete MI.
    - For `i == 3`, it calculates the high intermediate (HI) part by multiplying the higher parts of `a` and `b`.
    - For `i == 4`, it calculates another part of HI by multiplying the higher part of `a_times_x64` and `b`.
    - For `i == 5`, it combines the results of the previous two steps using XOR to form the complete HI.
    - For `i == 6`, it prepares MI for folding into HI by shuffling its halves.
    - For `i == 7`, it performs polynomial reduction on the lower part of MI using the `gfpoly`.
    - For `i == 8`, it combines the shuffled MI with HI using XOR.
    - For `i == 9`, it completes the reduction by XORing the reduced MI into HI.
- **Output**: The macro modifies the `b` register to contain the reduced product of the GHASH multiplication step.


---
### \_ghash\_mul
The `_ghash_mul` macro performs a GHASH multiplication of two operands, `a` and `b`, using Karatsuba multiplication and stores the reduced product in `b`.
- **Inputs**:
    - `a`: The first operand for the GHASH multiplication.
    - `a_times_x64`: The precomputed value of `a` multiplied by x^64, used in the multiplication process.
    - `b`: The second operand for the GHASH multiplication, which will also store the result.
    - `gfpoly`: The polynomial used for reduction in the GHASH multiplication.
    - `t0`: A temporary register used during the multiplication process.
    - `t1`: Another temporary register used during the multiplication process.
- **Logic and Control Flow**:
    - The macro iterates over a sequence of steps (0 to 9) to perform the GHASH multiplication using Karatsuba method.
    - In step 0, it calculates the middle intermediate (MI) by multiplying the lower half of `a` with the higher half of `b`.
    - In step 1, it calculates another part of MI by multiplying the lower half of `a_times_x64` with the lower half of `b`.
    - In step 2, it combines the results of the previous two steps using XOR to complete the MI calculation.
    - In steps 3 to 5, it calculates the higher intermediate (HI) by multiplying the higher halves of `a` and `b`, and the higher half of `a_times_x64` with the lower half of `b`, then combines them using XOR.
    - In steps 6 to 9, it folds MI into HI using a series of shuffle and XOR operations, and reduces the result using the polynomial `gfpoly`.
- **Output**: The macro outputs the reduced product of the GHASH multiplication in the register `b`.


---
### \_ghash\_mul\_noreduce
The `_ghash_mul_noreduce` macro performs a GHASH multiplication using Karatsuba method without reducing the result, storing intermediate values in specified registers.
- **Inputs**:
    - `a`: The first operand for the GHASH multiplication.
    - `a_xored`: The two halves of 'a' XOR'd together, i.e., a_L + a_H.
    - `b`: The second operand for the GHASH multiplication, which is clobbered during the operation.
    - `lo`: Register to accumulate the low part of the unreduced product, initially zero.
    - `mi`: Register to accumulate the middle part of the unreduced product, initially zero.
    - `hi`: Register to accumulate the high part of the unreduced product, initially zero.
    - `t0`: A temporary register used during the computation.
- **Logic and Control Flow**:
    - Compute the low part of the product by multiplying the low halves of 'a' and 'b' using `_vpclmulqdq` and XOR the result into 'lo'.
    - Compute the sum of the low and high halves of 'b' and store it in 't0'.
    - Compute the high part of the product by multiplying the high halves of 'a' and 'b' using `pclmulqdq` and XOR the result into 'hi'.
    - Compute the middle part of the product by multiplying the XOR'd halves of 'a' and the sum of the halves of 'b' using `pclmulqdq` and XOR the result into 'mi'.
- **Output**: The macro does not produce a final reduced output; instead, it updates the 'lo', 'mi', and 'hi' registers with the unreduced product of the GHASH multiplication.


---
### \_ghash\_reduce
The `_ghash_reduce` macro reduces the product from the GHASH multiplication process into a final result stored in a destination register.
- **Inputs**:
    - `lo`: The low part of the unreduced product from the GHASH multiplication.
    - `mi`: The middle part of the unreduced product from the GHASH multiplication.
    - `hi`: The high part of the unreduced product from the GHASH multiplication.
    - `dst`: The destination register where the reduced result will be stored.
    - `t0`: A temporary register used during the reduction process.
- **Logic and Control Flow**:
    - Load the Galois field polynomial constant into the temporary register `t0`.
    - XOR the low and high parts of the product into the middle part to prepare for reduction.
    - Shuffle the low part and XOR it into the middle part, then perform a polynomial multiplication with the Galois field polynomial to reduce it.
    - XOR the shuffled result into the middle part, completing the reduction of the low part into the middle part.
    - Shuffle the middle part and XOR it into the high part, then perform a polynomial multiplication with the Galois field polynomial to reduce it.
    - XOR the shuffled result into the high part, completing the reduction of the middle part into the high part.
    - Store the final reduced result in the destination register `dst`.
- **Output**: The output is the reduced GHASH product stored in the `dst` register.


---
### \_ghash\_update\_begin\_8x
The `_ghash_update_begin_8x` macro initializes the GHASH update process for a set of 8 ciphertext blocks by performing the first step of the unreduced multiplication and setting up necessary registers.
- **Inputs**:
    - `enc`: A flag indicating whether the operation is encryption (1) or decryption (0).
- **Logic and Control Flow**:
    - Initialize the inner block counter by setting the EAX register to zero.
    - Load the highest hash key power, H^8, into the TMP0 register from the key structure.
    - Depending on the `enc` flag, load the first ciphertext block from either the DST (if encrypting) or SRC (if decrypting) into the TMP1 register.
    - Byte-reflect the loaded ciphertext block using the BSWAP_MASK and store the result in TMP1.
    - Add the GHASH accumulator (GHASH_ACC) to the byte-reflected ciphertext block to form the block 'b' that needs to be multiplied with the hash key power 'a'.
    - Compute the sum of the lower and higher halves of the GHASH_ACC and store the result in the MI register.
    - Perform the Karatsuba multiplication: calculate the low part (LO) of the product by multiplying the lower halves of TMP0 and GHASH_ACC, and store the result in the LO register.
    - Calculate the high part (HI) of the product by multiplying the higher halves of TMP0 and GHASH_ACC, and store the result in the GHASH_ACC register.
    - Calculate the middle part (MI) of the product by multiplying the sum of the lower and higher halves of TMP0 and GHASH_ACC, and store the result in the MI register.
- **Output**: The macro sets up the initial state for the GHASH update by preparing the LO, MI, and GHASH_ACC registers with the unreduced product of the first ciphertext block and the highest hash key power.


---
### \_ghash\_update\_continue\_8x
The `_ghash_update_continue_8x` macro performs an unreduced multiplication of a ciphertext block by a hash key power and accumulates the result into intermediate GHASH values for a set of 8 blocks.
- **Inputs**:
    - `enc`: A flag indicating whether the operation is encryption (1) or decryption (0).
- **Logic and Control Flow**:
    - Increment the inner block counter by 8.
    - Load the next lowest hash key power from the key structure using the updated counter.
    - Load the next ciphertext block from either the source or destination, depending on the encryption flag, and byte-reflect it using a shuffle mask.
    - Perform a polynomial multiplication of the lower halves of the hash key power and the ciphertext block, accumulate the result into the low part of the GHASH intermediate value.
    - Compute the sum of the lower and upper halves of the ciphertext block, store it in a temporary register.
    - Perform a polynomial multiplication of the upper halves of the hash key power and the ciphertext block, accumulate the result into the high part of the GHASH intermediate value.
    - Perform a polynomial multiplication of the XOR of the halves of the hash key power and the sum of the halves of the ciphertext block, accumulate the result into the middle part of the GHASH intermediate value.
- **Output**: The macro updates the intermediate GHASH values (LO, MI, and GHASH_ACC) with the results of the polynomial multiplications for the current ciphertext block.


---
### \_ghash\_update\_end\_8x\_step
The `_ghash_update_end_8x_step` macro completes the GHASH reduction process for a set of 8 ciphertext blocks by folding the intermediate results into the GHASH accumulator.
- **Inputs**:
    - `i`: An iteration index that determines which part of the reduction process to execute.
- **Logic and Control Flow**:
    - If `i` is 0, the macro initializes a temporary register with the GF polynomial, XORs the low and middle parts of the unreduced product, and performs a series of shuffle and multiply operations to fold the low part into the middle part.
    - If `i` is 1, the macro continues by shuffling the middle part, performing a polynomial multiplication, and XORing the results to fold the middle part into the high part, which is also the GHASH accumulator.
- **Output**: The macro updates the GHASH accumulator with the reduced product of the GHASH multiplication process.


---
### \_aes\_gcm\_precompute
The `_aes_gcm_precompute` macro initializes the GHASH-related fields in an AES-GCM key structure by deriving the GHASH subkey from the expanded AES key.
- **Inputs**:
    - `KEY`: A pointer to the `aes_gcm_key_aesni` structure, which contains the expanded AES key and where the GHASH-related fields will be initialized.
- **Logic and Control Flow**:
    - Load the AES key length from the `KEY` structure and calculate the pointer to the last round key.
    - Encrypt an all-zero block using the AES key to derive the raw hash subkey, storing the result in `H_POW1`.
    - Reflect the bytes of the raw hash subkey and multiply it by x^1 to preprocess it for GHASH operations, storing the result back in `H_POW1`.
    - Store the preprocessed hash subkey as `H^1` in the `KEY` structure.
    - Compute `H^1 * x^64` and store it in the `KEY` structure.
    - Compute and store the XOR of the halves of `H^1` in the `KEY` structure.
    - Iteratively compute and store the powers `H^2` through `H^8` and their XOR'd halves in the `KEY` structure using the `_ghash_mul` macro.
- **Output**: The macro outputs the initialized GHASH-related fields in the `aes_gcm_key_aesni` structure, including the precomputed hash key powers and their XOR'd halves.


---
### \_aes\_gcm\_aad\_update
The `_aes_gcm_aad_update` macro processes Additional Authenticated Data (AAD) in GCM mode by updating the GHASH accumulator using the provided key, AAD, and its length.
- **Inputs**:
    - `KEY`: A pointer to the AES-GCM key structure containing precomputed hash key powers.
    - `GHASH_ACC_PTR`: A pointer to the GHASH accumulator, which must be all zeroes on the first call.
    - `AAD`: A pointer to the Additional Authenticated Data to be processed.
    - `AADLEN`: The length of the AAD, which must be a multiple of 16 except on the last call.
- **Logic and Control Flow**:
    - Load the byte swap mask and the GHASH accumulator from memory.
    - Load the precomputed hash key powers H^1 and H^1 * x^64 from the key structure.
    - Process the AAD in blocks of 16 bytes, updating the GHASH accumulator with each block using the GHASH multiplication macro.
    - If there is a partial block at the end, load and process it, updating the GHASH accumulator accordingly.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The updated GHASH accumulator is stored back to the memory location pointed to by `GHASH_ACC_PTR`.


---
### \_ctr\_begin\_8x
The `_ctr_begin_8x` macro initializes and processes eight AES counter blocks by incrementing a little-endian counter, converting them to big-endian, and XORing them with the zero-th AES round key.
- **Inputs**:
    - `LE_CTR`: A little-endian counter value used to generate counter blocks.
    - `KEY`: The zero-th AES round key used for XORing with the counter blocks.
    - `BSWAP_MASK`: A shuffle mask used for byte-swapping the counter blocks.
    - `AESDATA0 to AESDATA7`: Registers to store the processed AES counter blocks.
    - `TMP0`: A temporary register used for incrementing the counter.
    - `TMP1`: A temporary register used for storing the zero-th AES round key.
- **Logic and Control Flow**:
    - Load the constant value 1 into TMP0 for incrementing the counter.
    - Load the zero-th AES round key into TMP1.
    - Iterate over the range 0 to 7 to process each of the eight counter blocks.
    - For each counter block, byte-swap LE_CTR using BSWAP_MASK and store the result in AESDATA[i].
    - XOR the byte-swapped counter block with TMP1 (the zero-th AES round key).
    - Increment LE_CTR by the value in TMP0.
- **Output**: The macro outputs eight processed AES counter blocks stored in AESDATA0 to AESDATA7, ready for further AES encryption rounds.


---
### \_aesenc\_8x
The `_aesenc_8x` macro performs a non-final AES encryption round on eight blocks of data using a specified round key.
- **Inputs**:
    - `round_key`: The AES round key used for the encryption round.
- **Logic and Control Flow**:
    - The macro iterates over eight data blocks, labeled AESDATA0 to AESDATA7.
    - For each block, it applies the `aesenc` instruction using the provided `round_key`.
- **Output**: The output is the eight data blocks, each transformed by the AES encryption round using the specified round key.


---
### \_aesenclast\_8x
The `_aesenclast_8x` macro performs the last round of AES encryption on eight blocks of data using a specified round key.
- **Inputs**:
    - `round_key`: The round key to be used for the last round of AES encryption.
- **Logic and Control Flow**:
    - The macro iterates over eight blocks of data, labeled AESDATA0 to AESDATA7.
    - For each block, it applies the `aesenclast` instruction using the provided `round_key`.
- **Output**: The output is the eight blocks of data, each having undergone the last round of AES encryption with the specified round key.


---
### \_xor\_data\_8x
The `_xor_data_8x` macro XORs eight blocks of data from a source with precomputed keystream blocks and stores the result in a destination.
- **Inputs**:
    - `SRC`: The source memory location containing the data blocks to be XORed with the keystream.
    - `DST`: The destination memory location where the XORed result will be stored.
- **Logic and Control Flow**:
    - The macro iterates over eight blocks of data, each 16 bytes in size.
    - For each block, it uses the `_xor_mem_to_reg` macro to XOR the data from the source with the corresponding keystream block stored in an xmm register.
    - The result of the XOR operation is stored back into the xmm register.
    - After processing all eight blocks, the macro iterates again to store the XORed results from the xmm registers into the destination memory.
- **Output**: The output is the XORed result of the source data blocks and the keystream blocks, stored in the destination memory.


---
### \_aes\_gcm\_update
The `_aes_gcm_update` macro performs AES-GCM encryption or decryption by computing the CTR keystream, XORing it with data, and updating the GHASH accumulator with ciphertext blocks.
- **Inputs**:
    - `enc`: A flag indicating whether the operation is encryption (1) or decryption (0).
- **Logic and Control Flow**:
    - Initialize various registers and load the GHASH accumulator and counter values.
    - Check if the data length is sufficient for processing in blocks of 8*16 bytes; if so, enter the main loop.
    - In the main loop, generate counter blocks, perform AES encryption, and update the GHASH accumulator using Karatsuba multiplication for efficiency.
    - If encrypting, XOR the plaintext with the keystream to produce ciphertext; if decrypting, XOR the ciphertext with the keystream to recover plaintext.
    - Handle any remaining data that is less than 8*16 bytes by processing one block at a time, updating the GHASH accumulator accordingly.
    - Perform a final GHASH reduction to ensure the accumulator is correctly updated.
    - Store the updated GHASH accumulator back to memory.
- **Output**: The macro updates the GHASH accumulator and produces encrypted or decrypted data, depending on the `enc` flag.


---
### \_aes\_gcm\_final
The `_aes_gcm_final` macro finalizes the AES-GCM encryption or decryption process by computing the authentication tag and optionally verifying it against a provided tag.
- **Inputs**:
    - `enc`: A flag indicating whether the operation is encryption (1) or decryption (0).
- **Logic and Control Flow**:
    - Initialize local variables and load necessary constants and data from memory.
    - Set up a counter block with a specific value to generate the ciphertext needed for the authentication tag.
    - Build the lengths block from total AAD and data lengths, convert them to bits, and XOR it into the GHASH accumulator.
    - Load the necessary hash key powers and perform AES encryption on the counter block while simultaneously multiplying the GHASH accumulator by the hash key.
    - Complete the AES encryption and GHASH multiplication, then undo byte reflection on the GHASH accumulator.
    - For encryption, store the computed authentication tag; for decryption, compare the computed tag with the provided tag in constant time and return the result.
- **Output**: For encryption, the computed authentication tag is stored in the GHASH accumulator; for decryption, a boolean indicating whether the computed tag matches the provided tag is returned.



---
Made with  by [Driver](https://www.driver.ai/)