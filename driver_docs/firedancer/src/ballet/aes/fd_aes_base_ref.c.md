<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Optimized ANSI C implementation of the Rijndael cipher (AES) with encryption and decryption functions.

# Purpose
The `fd_aes_ref.c` file is a C source code file that implements the Advanced Encryption Standard (AES) algorithm, which is a symmetric key encryption standard. This file was adapted from the OpenSSL project and provides functions for both encryption and decryption of data using AES. The code includes functions for key expansion, which is necessary for generating the round keys used in the AES encryption and decryption processes. The file defines several static functions such as [`XtimeWord`](<#xtimeword>), [`SubWord`](<#subword>), [`ShiftRows`](<#shiftrows>), [`MixColumns`](<#mixcolumns>), and their inverse operations, which are essential components of the AES algorithm. These functions perform various transformations and permutations on the data to ensure secure encryption.

The file provides a public API through functions like [`fd_aes_ref_set_encrypt_key`](<#fd_aes_ref_set_encrypt_key>), [`fd_aes_ref_set_decrypt_key`](<#fd_aes_ref_set_decrypt_key>), [`fd_aes_ref_encrypt_core`](<#fd_aes_ref_encrypt_core>), and [`fd_aes_ref_decrypt_core`](<#fd_aes_ref_decrypt_core>). These functions allow users to set up encryption and decryption keys and perform the actual encryption and decryption of data blocks. The [`fd_aes_ref_set_encrypt_key`](<#fd_aes_ref_set_encrypt_key>) and [`fd_aes_ref_set_decrypt_key`](<#fd_aes_ref_set_decrypt_key>) functions are responsible for expanding the cipher key into the encryption and decryption key schedules, respectively. The [`fd_aes_ref_encrypt_core`](<#fd_aes_ref_encrypt_core>) and [`fd_aes_ref_decrypt_core`](<#fd_aes_ref_decrypt_core>) functions handle the encryption and decryption of single data blocks, ensuring that input and output can overlap. The file is intended to be used as part of a larger cryptographic library, providing AES functionality to other components or applications.
# Imports and Dependencies

---
- `assert.h`
- `stdlib.h`
- `fd_aes_gcm_ref.h`


# Data Structures

---
### uni
- **Type**: ``union``
- **Members**:
    - ``b``: An array of 8 `uchar` elements.
    - ``w``: An array of 2 `uint` elements.
    - ``d``: A single `ulong` element.
- **Description**: Provides a way to store data in different formats within the same memory location, allowing access as an array of bytes, an array of words, or a single long integer.


# Functions

---
### XtimeWord<!-- {{#callable:XtimeWord}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L56>)

Performs a multiplication of a 32-bit word by the polynomial 'x' in the finite field GF(2^8) and reduces it modulo the polynomial x^8 + x^4 + x^3 + x + 1.
- **Inputs**:
    - `w`: A pointer to a 32-bit unsigned integer that represents the word to be transformed.
- **Logic and Control Flow**:
    - Retrieve the value pointed to by `w` and store it in `a`.
    - Compute `b` as the bitwise AND of `a` and the constant `0x80808080u`.
    - XOR `a` with `b` to clear the highest bit of each byte in `a`.
    - Subtract `b` right-shifted by 7 from `b` itself to prepare for reduction.
    - AND `b` with the constant `0x1B1B1B1Bu` to apply the reduction polynomial.
    - XOR `b` with `a` left-shifted by 1 to complete the multiplication and reduction.
    - Store the result back into the location pointed to by `w`.
- **Output**: The function modifies the input word in place, storing the result of the transformation back into the original memory location.


---
### XtimeLong<!-- {{#callable:XtimeLong}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L69>)

Performs a transformation on a 64-bit unsigned integer by applying bitwise operations and arithmetic shifts.
- **Inputs**:
    - `w`: A pointer to a 64-bit unsigned integer (`ulong`) that will be transformed.
- **Logic and Control Flow**:
    - Retrieve the value pointed to by `w` and store it in `a`.
    - Compute `b` as the bitwise AND of `a` and the constant `0x8080808080808080`.
    - Update `a` by XORing it with `b`.
    - Subtract `b` right-shifted by 7 from `b`.
    - Perform a bitwise AND of `b` with the constant `0x1B1B1B1B1B1B1B1B`.
    - Update `b` by XORing it with `a` left-shifted by 1.
    - Store the result back into the location pointed to by `w`.
- **Output**: The function modifies the value at the pointer `w` in place, with no return value.


---
### SubWord<!-- {{#callable:SubWord}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L128>)

Transforms a 32-bit word using a series of bitwise operations and substitutions as part of the AES encryption process.
- **Inputs**:
    - `w`: A pointer to a 32-bit unsigned integer that will be transformed.
- **Logic and Control Flow**:
    - Initialize local variables `x`, `y`, `a1`, `a2`, `a3`, `a4`, `a5`, and `a6`.
    - Assign the value pointed to by `w` to `x`.
    - Perform a series of bitwise operations and substitutions on `x` and `y` using masks and shifts to transform the word.
    - Use intermediate variables `a1` to `a6` to store results of transformations and further manipulate `x`.
    - Apply a final transformation to `x` using a constant XOR operation.
    - Store the transformed value back into the location pointed to by `w`.
- **Output**: The transformed 32-bit word is stored back in the location pointed to by `w`.


---
### SubLong<!-- {{#callable:SubLong}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L219>)

Performs a series of bitwise transformations and substitutions on a 64-bit unsigned integer to modify its value.
- **Inputs**:
    - `w`: A pointer to a 64-bit unsigned integer (`ulong`) that will be transformed.
- **Logic and Control Flow**:
    - Initialize `x` with the value pointed to by `w`.
    - Perform a series of bitwise operations and shifts on `x` and `y` to transform the value.
    - Use masks and shifts to manipulate bits in `x` and `y`, applying XOR operations with specific patterns.
    - Store intermediate results in variables `a1` to `a6` to facilitate further transformations.
    - Apply additional bitwise operations and shifts to refine the transformation of `x`.
    - Update the value pointed to by `w` with the final transformed value of `x`.
- **Output**: The function modifies the value of the 64-bit unsigned integer pointed to by `w` in place.


---
### InvSubLong<!-- {{#callable:InvSubLong}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L313>)

Performs the inverse substitution operation on a 64-bit word as part of the AES decryption process.
- **Inputs**:
    - `w`: A pointer to a 64-bit unsigned long integer (`ulong`) that represents the word to be processed.
- **Logic and Control Flow**:
    - Initialize `x` with the value pointed to by `w` and XOR it with a constant `0x6363636363636363UL`.
    - Perform a series of bitwise operations and shifts on `x` and `y` to transform the input word, using constants to mask and manipulate bits.
    - Use intermediate variables `a1` to `a6` to store results of transformations and further manipulate the bits through XOR and shift operations.
    - Reconstruct the transformed word `x` using the intermediate variables and additional bitwise operations.
    - Store the final transformed value back into the location pointed to by `w`.
- **Output**: The function modifies the input word in place, so it does not return a value but updates the value pointed to by `w`.


---
### ShiftRows<!-- {{#callable:ShiftRows}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L408>)

Performs a cyclic shift of rows in a 4x4 matrix representation of the state array for AES encryption.
- **Inputs**:
    - `state`: A pointer to an array of type `ulong` that represents the state matrix in AES encryption.
- **Logic and Control Flow**:
    - Convert the `state` pointer to a `uchar` pointer `s0` to access individual bytes.
    - Iterate over each row index `r` from 0 to 3.
    - For each row, copy the elements of the column into a temporary array `s`.
    - Perform a cyclic shift on the temporary array `s` by using the row index `r` to determine the shift amount.
    - Write the shifted values back into the original `state` array.
- **Output**: The function modifies the `state` array in place, performing a cyclic shift on each row of the 4x4 matrix.


---
### InvShiftRows<!-- {{#callable:InvShiftRows}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L427>)

Performs the inverse row shifting operation on a state matrix in the AES decryption process.
- **Inputs**:
    - `state`: A pointer to an array of `ulong` representing the state matrix to be modified.
- **Logic and Control Flow**:
    - Convert the `state` pointer to a `uchar` pointer `s0`.
    - Iterate over each row index `r` from 0 to 3.
    - For each row, store the elements of the row in a temporary array `s`.
    - Reassign the elements of the row in `s0` using the inverse shift pattern based on the index `r`.
- **Output**: The function modifies the `state` matrix in place, performing an inverse shift on each row.


---
### MixColumns<!-- {{#callable:MixColumns}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L446>)

Performs the MixColumns transformation on a state array as part of the AES encryption process.
- **Inputs**:
    - `state`: A pointer to an array of `ulong` values representing the state to transform.
- **Logic and Control Flow**:
    - Initialize two `uni` type variables `s1` and `s` to hold intermediate state values.
    - Iterate over two columns of the state array using a loop with index `c`.
    - For each column, copy the current state value into `s1.d` and `s.d`.
    - Perform bitwise transformations on `s.d` to mix the bytes within the column.
    - Call [`XtimeLong`](<#xtimelong>) on `s1.d` to perform a multiplication in the Galois Field.
    - Apply further bitwise XOR operations between `s` and `s1` to complete the column mixing.
    - Store the transformed value back into the state array at the current column index.
- **Output**: The function modifies the input `state` array in place, transforming each column according to the MixColumns operation of AES.
- **Functions Called**:
    - [`XtimeLong`](<#xtimelong>)


---
### InvMixColumns<!-- {{#callable:InvMixColumns}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L474>)

Performs the inverse mix columns transformation on the state array as part of the AES decryption process.
- **Inputs**:
    - `state`: A pointer to an array of unsigned long integers representing the state to transform.
- **Logic and Control Flow**:
    - Initialize two union variables `s1` and `s` to hold intermediate state values.
    - Iterate over two columns of the state array.
    - For each column, copy the current state value into `s1` and `s`.
    - Perform bitwise operations to rearrange and mix the bits in `s` using shifts and XOR operations.
    - Call [`XtimeLong`](<#xtimelong>) on `s1.d` to perform a multiplication in the Galois Field.
    - Mix the bytes of `s` using XOR operations with shifted bytes of `s1`.
    - Repeat the [`XtimeLong`](<#xtimelong>) operation and further bitwise operations to complete the inverse mix columns transformation.
    - Store the transformed value back into the state array.
- **Output**: The function modifies the input `state` array in place, applying the inverse mix columns transformation to each column.
- **Functions Called**:
    - [`XtimeLong`](<#xtimelong>)


---
### AddRoundKey<!-- {{#callable:AddRoundKey}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L510>)

Performs a bitwise XOR operation between the `state` and `w` arrays to add a round key in the AES encryption process.
- **Inputs**:
    - `state`: A pointer to an array of `ulong` representing the current state of the AES encryption.
    - `w`: A pointer to a constant array of `ulong` representing the round key to be added to the state.
- **Logic and Control Flow**:
    - Perform a bitwise XOR operation between the first element of `state` and the first element of `w`, and store the result back in the first element of `state`.
    - Perform a bitwise XOR operation between the second element of `state` and the second element of `w`, and store the result back in the second element of `state`.
- **Output**: The function modifies the `state` array in place by XORing it with the `w` array, effectively adding the round key to the state.


---
### Cipher<!-- {{#callable:Cipher}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L517>)

Performs AES encryption on a 128-bit block using a specified number of rounds and a key schedule.
- **Inputs**:
    - ``in``: Pointer to the input data block (128 bits) to encrypt.
    - ``out``: Pointer to the output buffer where the encrypted data will be stored.
    - ``w``: Pointer to the expanded key schedule used for encryption.
    - ``nr``: Number of rounds to perform in the encryption process.
- **Logic and Control Flow**:
    - Copy the input data into a local state array.
    - Apply the initial round key to the state using [`AddRoundKey`](<#addroundkey>).
    - Iterate over the number of rounds minus one, performing the following operations in each round:
    - Apply the [`SubLong`](<#sublong>) transformation to each part of the state.
    - Perform the [`ShiftRows`](<#shiftrows>) operation on the state.
    - Execute the [`MixColumns`](<#mixcolumns>) transformation on the state.
    - Add the round key to the state using [`AddRoundKey`](<#addroundkey>).
    - After the loop, perform the final round without the [`MixColumns`](<#mixcolumns>) transformation.
    - Copy the final state to the output buffer.
- **Output**: The function does not return a value; it writes the encrypted data to the `out` buffer.
- **Functions Called**:
    - [`AddRoundKey`](<#addroundkey>)
    - [`SubLong`](<#sublong>)
    - [`ShiftRows`](<#shiftrows>)
    - [`MixColumns`](<#mixcolumns>)


---
### InvCipher<!-- {{#callable:InvCipher}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L545>)

Performs the inverse AES cipher operation on a block of data using a given key schedule.
- **Inputs**:
    - ``in``: Pointer to the input data block to decrypt, expected to be 16 bytes.
    - ``out``: Pointer to the output buffer where the decrypted data will be stored, expected to be 16 bytes.
    - ``w``: Pointer to the key schedule, an array of `ulong` values used in the decryption process.
    - ``nr``: Number of rounds in the AES decryption process, determined by the key size.
- **Logic and Control Flow**:
    - Copy 16 bytes from `in` to `state` array.
    - Apply the [`AddRoundKey`](<#addroundkey>) function to `state` using the last round key from `w`.
    - Iterate from `nr-1` to 1, performing the following steps in each iteration:
    - - Apply [`InvShiftRows`](<#invshiftrows>) to `state`.
    - - Apply [`InvSubLong`](<#invsublong>) to each half of `state`.
    - - Apply [`AddRoundKey`](<#addroundkey>) to `state` using the current round key from `w`.
    - - Apply [`InvMixColumns`](<#invmixcolumns>) to `state`.
    - After the loop, apply [`InvShiftRows`](<#invshiftrows>) to `state`.
    - Apply [`InvSubLong`](<#invsublong>) to each half of `state`.
    - Apply [`AddRoundKey`](<#addroundkey>) to `state` using the first round key from `w`.
    - Copy 16 bytes from `state` to `out`.
- **Output**: The function outputs the decrypted data block in the `out` buffer, which is 16 bytes in size.
- **Functions Called**:
    - [`AddRoundKey`](<#addroundkey>)
    - [`InvShiftRows`](<#invshiftrows>)
    - [`InvSubLong`](<#invsublong>)
    - [`InvMixColumns`](<#invmixcolumns>)


---
### RotWord<!-- {{#callable:RotWord}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L573>)

Rotates the bytes in a 32-bit word to the left by one position.
- **Inputs**:
    - ``x``: A pointer to a 32-bit unsigned integer (`uint`) that represents the word to rotate.
- **Logic and Control Flow**:
    - Cast the input `x` to a pointer to an unsigned character (`uchar *`) and assign it to `w0`.
    - Store the first byte of `w0` in a temporary variable `tmp`.
    - Shift the second byte of `w0` to the first position.
    - Shift the third byte of `w0` to the second position.
    - Shift the fourth byte of `w0` to the third position.
    - Assign the value of `tmp` to the fourth position of `w0`.
- **Output**: The function does not return a value; it modifies the input word in place.


---
### KeyExpansion<!-- {{#callable:KeyExpansion}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L586>)

Expands the cipher key into the encryption key schedule for AES encryption.
- **Inputs**:
    - `key`: A pointer to the input cipher key, which is an array of unsigned characters.
    - `w`: A pointer to the output key schedule, which is an array of unsigned long integers.
    - `nr`: The number of rounds in the AES encryption process.
    - `nk`: The number of 32-bit words in the cipher key.
- **Logic and Control Flow**:
    - Copy the initial key into the beginning of the key schedule `w` using `memcpy`.
    - Initialize the round constant `rcon` to 1.
    - Calculate `n` as half of `nk`.
    - Set `prev.d` to the last word of the initial key schedule.
    - Iterate over the range from `n` to `(nr+1)*2` to fill the key schedule.
    - In each iteration, set `temp` to the second word of `prev`.
    - If `i` is a multiple of `n`, perform a key schedule core transformation on `temp` using [`RotWord`](<#rotword>), [`SubWord`](<#subword>), and XOR with `rcon`, then update `rcon` using [`XtimeWord`](<#xtimeword>).
    - If `nk` is greater than 6 and `i` modulo `n` equals 2, apply [`SubWord`](<#subword>) to `temp`.
    - Update `prev.d` to the word `n` positions before `i` in the key schedule.
    - XOR `prev.w[0]` with `temp` and `prev.w[1]` with `prev.w[0]`.
    - Store `prev.d` in the current position `i` of the key schedule.
- **Output**: The function outputs the expanded key schedule in the array `w`, which is used for AES encryption.
- **Functions Called**:
    - [`RotWord`](<#rotword>)
    - [`SubWord`](<#subword>)
    - [`XtimeWord`](<#xtimeword>)


---
### fd\_aes\_ref\_set\_encrypt\_key<!-- {{#callable:fd_aes_ref_set_encrypt_key}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L620>)

Expands the cipher key into the encryption key schedule for AES encryption.
- **Inputs**:
    - ``userKey``: A pointer to the user-provided cipher key.
    - ``bits``: The length of the cipher key in bits, which must be 128, 192, or 256.
    - ``key``: A pointer to the `fd_aes_key_ref_t` structure where the expanded key schedule will be stored.
- **Logic and Control Flow**:
    - Check if `userKey` or `key` is NULL; if so, return -1.
    - Check if `bits` is not 128, 192, or 256; if so, return -2.
    - Cast `key->rd_key` to a `ulong` pointer `rk` using `fd_type_pun`.
    - Set `key->rounds` to 10, 12, or 14 based on the value of `bits`.
    - Call [`KeyExpansion`](<#keyexpansion>) with `userKey`, `rk`, `key->rounds`, and `bits/32UL` to expand the key.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success, -1 if `userKey` or `key` is NULL, and -2 if `bits` is not a valid key length.
- **Functions Called**:
    - [`KeyExpansion`](<#keyexpansion>)


---
### fd\_aes\_ref\_set\_decrypt\_key<!-- {{#callable:fd_aes_ref_set_decrypt_key}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L647>)

Sets the decryption key for AES by calling the encryption key setup function.
- **Inputs**:
    - ``userKey``: A pointer to the user's key, which is an array of unsigned characters.
    - ``bits``: The length of the key in bits, which must be 128, 192, or 256.
    - ``key``: A pointer to an `fd_aes_key_ref_t` structure where the key schedule will be stored.
- **Logic and Control Flow**:
    - Calls the [`fd_aes_ref_set_encrypt_key`](<#fd_aes_ref_set_encrypt_key>) function with the same parameters to set up the key schedule for decryption.
- **Output**: Returns the result of the [`fd_aes_ref_set_encrypt_key`](<#fd_aes_ref_set_encrypt_key>) function, which is 0 on success, -1 if `userKey` or `key` is NULL, and -2 if `bits` is not 128, 192, or 256.
- **Functions Called**:
    - [`fd_aes_ref_set_encrypt_key`](<#fd_aes_ref_set_encrypt_key>)


---
### fd\_aes\_ref\_encrypt\_core<!-- {{#callable:fd_aes_ref_encrypt_core}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L658>)

Encrypts a single block of data using the AES algorithm with a given key.
- **Inputs**:
    - `in`: Pointer to the input data block to encrypt.
    - `out`: Pointer to the output buffer where the encrypted data will be stored.
    - `key`: Pointer to the AES key structure containing the encryption key and number of rounds.
- **Logic and Control Flow**:
    - Check that `in`, `out`, and `key` are not null using `assert`.
    - Retrieve the round keys from the `key` structure using `fd_type_pun_const`.
    - Call the [`Cipher`](<#cipher>) function with the input data, output buffer, round keys, and number of rounds to perform the encryption.
- **Output**: The function does not return a value; it writes the encrypted data to the `out` buffer.
- **Functions Called**:
    - [`Cipher`](<#cipher>)


---
### fd\_aes\_ref\_decrypt\_core<!-- {{#callable:fd_aes_ref_decrypt_core}} -->
[View Source →](<../../../../../src/ballet/aes/fd_aes_base_ref.c#L673>)

Decrypts a single block of data using the AES decryption algorithm with a given key.
- **Inputs**:
    - `in`: A pointer to the input data block to decrypt.
    - `out`: A pointer to the output buffer where the decrypted data will be stored.
    - `key`: A pointer to the `fd_aes_key_ref_t` structure containing the decryption key and the number of rounds.
- **Logic and Control Flow**:
    - Check that `in`, `out`, and `key` are not null using `assert`.
    - Retrieve the round keys from the `key` structure using `fd_type_pun_const` to cast `key->rd_key` to a `ulong` pointer.
    - Call the [`InvCipher`](<#invcipher>) function with the input data, output buffer, round keys, and number of rounds to perform the decryption.
- **Output**: The function does not return a value; it writes the decrypted data to the buffer pointed to by `out`.
- **Functions Called**:
    - [`InvCipher`](<#invcipher>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)