<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Header file for AVX2-optimized base58 encoding and decoding operations, including vector manipulation functions.

# Purpose
The code is a C source file that provides functions for handling base58 encoding using AVX2 SIMD (Single Instruction, Multiple Data) instructions. It is not a standalone header file and is intended to be included only in specific source files, namely `fd_base58.c` and `test_base58_avx.c`. The file does not have an include guard, indicating its limited scope of use. The primary functionality revolves around converting data into base58 format, which is a binary-to-text encoding scheme commonly used in applications like Bitcoin addresses.

The file defines several inline functions and macros to perform operations on AVX2 registers. These operations include loading and storing 256-bit vectors, converting intermediate forms of data into raw base58 digits, and mapping raw base58 values to their corresponding character representations. Additionally, the code includes functions to count leading zero bytes in vectors and to pack base58 digits into a more compact form. The use of AVX2 instructions allows for efficient parallel processing of data, which is beneficial for performance-critical applications. The file also includes detailed comments explaining the mathematical operations and the rationale behind the use of specific AVX2 instructions.
# Imports and Dependencies

---
- `../../util/simd/fd_avx.h`
- `immintrin.h`


# Functions

---
### wuc\_ld<!-- {{#callable:wuc_ld}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L9>)

Loads a 256-bit value from a memory address aligned to 32 bytes.
- **Inputs**:
    - `p`: A pointer to a memory location of type `uchar const *`, which must be aligned to 32 bytes.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *`.
    - Uses the `_mm256_load_si256` intrinsic to load a 256-bit value from the memory location pointed to by the casted pointer.
- **Output**: Returns a 256-bit value of type `wuc_t`, which is defined as `__m256i`.


---
### wuc\_ldu<!-- {{#callable:wuc_ldu}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L10>)

Loads 32 bytes of unaligned data from a memory location into an AVX2 register.
- **Inputs**:
    - `p`: A pointer to an unaligned memory location of type `uchar` from which 32 bytes will be loaded.
- **Logic and Control Flow**:
    - Casts the input pointer `p` to a pointer of type `__m256i const *` to treat the data as a 256-bit integer vector.
    - Uses the `_mm256_loadu_si256` intrinsic to load 32 bytes from the unaligned memory location pointed to by `p` into an AVX2 register.
- **Output**: Returns a `wuc_t` type, which is an alias for `__m256i`, containing the loaded 32 bytes of data.


---
### wuc\_st<!-- {{#callable:wuc_st}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L11>)

Stores a 256-bit AVX2 vector to a specified memory location using aligned memory access.
- **Inputs**:
    - ``p``: A pointer to the memory location where the 256-bit vector will be stored. It must be aligned to a 32-byte boundary.
    - ``i``: The 256-bit AVX2 vector (`wuc_t`) to store at the memory location pointed to by `p`.
- **Logic and Control Flow**:
    - Uses the `_mm256_store_si256` intrinsic to store the 256-bit vector `i` into the memory location pointed to by `p`.
    - The memory location `p` must be aligned to a 32-byte boundary for this operation to be valid.
- **Output**: No return value; the function performs an in-place store operation.


---
### wuc\_stu<!-- {{#callable:wuc_stu}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L12>)

Stores a 256-bit AVX2 vector into memory without alignment requirements.
- **Inputs**:
    - ``p``: A pointer to the memory location where the 256-bit vector will be stored.
    - ``i``: The 256-bit AVX2 vector (`wuc_t`) to store.
- **Logic and Control Flow**:
    - Uses the `_mm256_storeu_si256` intrinsic to store the 256-bit vector `i` into the memory location pointed to by `p`.
    - The function does not require the memory location to be aligned.
- **Output**: No return value; the function performs a side effect by storing data in memory.


---
### intermediate\_to\_raw<!-- {{#callable:intermediate_to_raw}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L18>)

Converts a vector of intermediate base58 values into a compact form of raw base58 digits using AVX2 instructions.
- **Inputs**:
    - `intermediate`: A vector of type `wl_t` containing intermediate base58 values, each less than 58^5.
- **Logic and Control Flow**:
    - Broadcast constants `cA` and `cB` for division by 58 and 58^2 using magic multiplication.
    - Define macros `DIV58` and `DIV3364` to perform division by 58 and 58^2 using AVX2 instructions.
    - Calculate `div0`, `div1`, `div2`, `div3`, and `div4` as the floor of the division of `intermediate` by increasing powers of 58.
    - Calculate `rem0`, `rem1`, `rem2`, `rem3`, and `rem4` as the remainder of the division results modulo 58.
    - Use `_mm256_shuffle_epi8` and `_mm256_slli_si256` to rearrange and compact the remainder values into a single AVX2 register `shift`.
    - Return the compacted vector `shift` containing the raw base58 digits.
- **Output**: A vector of type `wuc_t` containing 20 raw base58 digits in a compact form, stored in the lower 10 bytes of each 128-bit half of the vector.


---
### raw\_to\_base58<!-- {{#callable:raw_to_base58}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L124>)

Converts each byte in an AVX2 register from raw base58 values to base58 character digits using arithmetic expressions and comparisons.
- **Inputs**:
    - ``in``: An AVX2 register (`wuc_t`) containing bytes in the range [0, 58) representing raw base58 values.
- **Logic and Control Flow**:
    - Compare each byte in `in` with the thresholds 8, 16, 21, 32, and 43 using `_mm256_cmpgt_epi8` to determine if they exceed these values.
    - For each comparison, generate a mask of 0xFF for true and 0x00 for false, which is used to calculate offsets for the base58 conversion.
    - Calculate the offsets by ANDing the masks with -7 or -6, depending on the threshold, to get the required negative offsets.
    - Sum all the negative offsets using `_mm256_add_epi8` to compute the total offset for each byte.
    - Subtract the total offset from each byte in `in` using `_mm256_sub_epi8` to convert the raw base58 values to base58 character digits.
- **Output**: An AVX2 register (`wuc_t`) containing the converted base58 character digits.


---
### count\_leading\_zeros\_26<!-- {{#callable:count_leading_zeros_26}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L163>)

Counts the number of leading zero bytes in the first 26 bytes of an AVX2 register.
- **Inputs**:
    - `in`: An AVX2 register (`wuc_t`) containing the bytes to be analyzed.
- **Logic and Control Flow**:
    - Create a mask `mask0` by comparing each byte in `in` to zero and converting the result to a bitmask using `_mm256_movemask_epi8`.
    - Create a mask `mask` by flipping the low 26 bits of `mask0` and setting bit 26 using `fd_ulong_mask_lsb`.
    - Find the least significant bit set in `mask` using `fd_ulong_find_lsb`.
- **Output**: Returns the number of leading zero bytes as an `ulong`.


---
### count\_leading\_zeros\_32<!-- {{#callable:count_leading_zeros_32}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L170>)

Counts the number of leading zero bytes in a 32-byte AVX2 register.
- **Inputs**:
    - `in`: An AVX2 register of type `wuc_t` containing 32 bytes to be analyzed for leading zeros.
- **Logic and Control Flow**:
    - Create a mask by comparing each byte in `in` to zero using `_mm256_cmpeq_epi8` and then use `_mm256_movemask_epi8` to generate a bitmask where each bit represents whether the corresponding byte in `in` is zero.
    - Invert the lower 33 bits of the mask using `fd_ulong_mask_lsb(33)` and XOR operation to prepare for finding the first non-zero byte.
    - Use `fd_ulong_find_lsb` to find the position of the least significant bit set in the inverted mask, which corresponds to the number of leading zero bytes.
- **Output**: Returns the number of leading zero bytes as an `ulong`.


---
### count\_leading\_zeros\_45<!-- {{#callable:count_leading_zeros_45}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L176>)

Counts the number of leading zero bytes in the first 45 bytes of two 32-byte AVX2 registers.
- **Inputs**:
    - `in0`: The first 32-byte AVX2 register to check for leading zeros.
    - `in1`: The second 32-byte AVX2 register to check for leading zeros.
- **Logic and Control Flow**:
    - Create a mask `mask0` by comparing `in0` with zero and converting the result to a bitmask using `_mm256_movemask_epi8`.
    - Create a mask `mask1` by comparing `in1` with zero and converting the result to a bitmask using `_mm256_movemask_epi8`.
    - Combine `mask0` and `mask1` into a single mask `mask` by shifting `mask1` left by 32 bits, masking it with `fd_ulong_mask_lsb(13)`, and XORing with `mask0`.
    - Invert the lower 46 bits of `mask` using `fd_ulong_mask_lsb(46)` and XOR.
    - Find the least significant bit set in `mask` using `fd_ulong_find_lsb`.
- **Output**: Returns the number of leading zero bytes as an unsigned long integer.


---
### count\_leading\_zeros\_64<!-- {{#callable:count_leading_zeros_64}} -->
[View Source →](<../../../../../src/ballet/base58/fd_base58_avx.h#L185>)

Counts the number of leading zero bytes in two 32-byte AVX2 registers, returning the count up to 64.
- **Inputs**:
    - `in0`: The first 32-byte AVX2 register to check for leading zeros.
    - `in1`: The second 32-byte AVX2 register to check for leading zeros.
- **Logic and Control Flow**:
    - Convert each byte in `in0` and `in1` to a mask of 1s and 0s, where 1 indicates a zero byte.
    - Combine the masks from `in0` and `in1` into a single 64-bit mask, with `in1` shifted left by 32 bits.
    - Invert the combined mask to prepare for finding the least significant bit (LSB).
    - Use `fd_ulong_find_lsb_w_default` to find the position of the first 1 in the inverted mask, which corresponds to the number of leading zeros.
- **Output**: Returns the number of leading zero bytes as an `ulong`, with a maximum value of 64.



---
Made with ❤️ by [Driver](https://www.driver.ai/)