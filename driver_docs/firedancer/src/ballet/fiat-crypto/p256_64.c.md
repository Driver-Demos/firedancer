<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Autogenerated C code for 64-bit Montgomery arithmetic on the P-256 curve, including operations like multiplication, addition, subtraction, and conversion between Montgomery and non-Montgomery domains.

# Purpose
The code is a C implementation of arithmetic operations for the P-256 elliptic curve, which is part of the NIST (National Institute of Standards and Technology) recommended curves for cryptographic applications. The operations are implemented using Montgomery arithmetic, which is a method that allows efficient modular multiplication, a critical operation in elliptic curve cryptography. The code includes functions for addition, subtraction, multiplication, and squaring of field elements in the Montgomery domain, as well as functions to convert to and from this domain. It also provides utility functions for conditional moves, serialization to and from bytes, and a divstep function used in modular inversion.

The code defines several types and macros to support these operations, such as `fiat_p256_uint1` for single-bit values and `fiat_p256_uint128` for 128-bit arithmetic. The functions are designed to work with 64-bit machine words, as indicated by the `machine_wordsize = 64` comment. The code is intended to be used as part of a larger cryptographic library, providing the necessary arithmetic operations for implementing elliptic curve cryptography on the P-256 curve. The functions ensure that inputs and outputs are within the bounds of the prime modulus `m = 2^256 - 2^224 + 2^192 + 2^96 - 1`, which defines the field over which the elliptic curve is defined.
# Imports and Dependencies

---
- `stdint.h`


# Global Variables

---
### fiat\_p256\_int128
- **Type**: ``typedef signed __int128``
- **Description**: Represents a signed 128-bit integer type using the `__int128` extension available in some compilers like GCC and Clang. This type is used to handle large integer values that exceed the standard 64-bit integer range.
- **Use**: Used in arithmetic operations that require handling of large integer values, such as in cryptographic computations.


---
### fiat\_p256\_uint128
- **Type**: ``unsigned __int128``
- **Description**: Defines an unsigned 128-bit integer type using the `__int128` extension available in some compilers like GCC and Clang. This type can store large integer values up to 2^128 - 1.
- **Use**: Used to perform arithmetic operations that require 128-bit precision.


# Functions

---
### fiat\_p256\_value\_barrier\_u64<!-- {{#callable:fiat_p256_value_barrier_u64}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L47>)

Acts as a value barrier for a 64-bit unsigned integer to prevent certain compiler optimizations.
- **Inputs**:
    - `a`: A 64-bit unsigned integer input.
- **Logic and Control Flow**:
    - Uses inline assembly to create a barrier for the input value `a`, preventing the compiler from optimizing away certain operations involving `a`.
    - The inline assembly does not perform any operations on `a`, but the `+r` constraint ensures that `a` is treated as both an input and an output, effectively creating a barrier.
- **Output**: Returns the same 64-bit unsigned integer `a` that was input.


---
### fiat\_p256\_addcarryx\_u64<!-- {{#callable:fiat_p256_addcarryx_u64}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L71>)

Performs addition of two 64-bit unsigned integers with an additional carry-in, producing a 64-bit result and a carry-out.
- **Inputs**:
    - `out1`: Pointer to a `uint64_t` where the 64-bit result of the addition will be stored.
    - `out2`: Pointer to a `fiat_p256_uint1` where the carry-out of the addition will be stored.
    - `arg1`: A `fiat_p256_uint1` representing the carry-in for the addition.
    - `arg2`: A `uint64_t` representing the first operand for the addition.
    - `arg3`: A `uint64_t` representing the second operand for the addition.
- **Logic and Control Flow**:
    - Calculate the sum of `arg1`, `arg2`, and `arg3`, storing the result in `x1` as a 128-bit integer.
    - Extract the lower 64 bits of `x1` and store it in `x2`.
    - Extract the upper 64 bits of `x1` and store it in `x3` as the carry-out.
    - Store `x2` in the location pointed to by `out1`.
    - Store `x3` in the location pointed to by `out2`.
- **Output**: The function outputs the 64-bit result of the addition in `out1` and the carry-out in `out2`.


---
### fiat\_p256\_subborrowx\_u64<!-- {{#callable:fiat_p256_subborrowx_u64}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L97>)

Performs subtraction with borrow on two 64-bit unsigned integers and a borrow flag, producing a result and a new borrow flag.
- **Inputs**:
    - `out1`: Pointer to a `uint64_t` where the result of the subtraction will be stored.
    - `out2`: Pointer to a `fiat_p256_uint1` where the new borrow flag will be stored.
    - `arg1`: A `fiat_p256_uint1` representing the initial borrow flag (0 or 1).
    - `arg2`: A `uint64_t` representing the minuend.
    - `arg3`: A `uint64_t` representing the subtrahend.
- **Logic and Control Flow**:
    - Calculate `x1` as the result of `arg2` minus `arg1` minus `arg3`, using 128-bit integer arithmetic to handle overflow.
    - Extract the borrow flag `x2` by right-shifting `x1` by 64 bits, which indicates if the subtraction resulted in a negative value.
    - Extract the lower 64 bits of `x1` as `x3`, which is the result of the subtraction modulo 2^64.
    - Store `x3` in the location pointed to by `out1`.
    - Calculate the new borrow flag by subtracting `x2` from 0 and store it in the location pointed to by `out2`.
- **Output**: The function outputs the result of the subtraction in `out1` and the new borrow flag in `out2`.


---
### fiat\_p256\_mulx\_u64<!-- {{#callable:fiat_p256_mulx_u64}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L122>)

Performs a 64-bit multiplication of two unsigned integers and returns the result as a double-width 128-bit integer split into two 64-bit parts.
- **Inputs**:
    - `out1`: Pointer to a `uint64_t` where the lower 64 bits of the result will be stored.
    - `out2`: Pointer to a `uint64_t` where the upper 64 bits of the result will be stored.
    - `arg1`: First 64-bit unsigned integer operand.
    - `arg2`: Second 64-bit unsigned integer operand.
- **Logic and Control Flow**:
    - Multiply `arg1` and `arg2` to get a 128-bit result stored in `x1` of type `fiat_p256_uint128`.
    - Extract the lower 64 bits of `x1` and store in `x2`.
    - Extract the upper 64 bits of `x1` and store in `x3`.
    - Assign `x2` to the location pointed by `out1`.
    - Assign `x3` to the location pointed by `out2`.
- **Output**: The function does not return a value but outputs the result through the pointers `out1` and `out2`, representing the lower and upper 64 bits of the 128-bit product, respectively.


---
### fiat\_p256\_cmovznz\_u64<!-- {{#callable:fiat_p256_cmovznz_u64}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L146>)

Performs a conditional move of two 64-bit unsigned integers based on a condition flag.
- **Inputs**:
    - ``out1``: Pointer to a 64-bit unsigned integer where the result will be stored.
    - ``arg1``: Condition flag of type `fiat_p256_uint1` (0 or 1) that determines which value to select.
    - ``arg2``: 64-bit unsigned integer to select if `arg1` is 0.
    - ``arg3``: 64-bit unsigned integer to select if `arg1` is 1.
- **Logic and Control Flow**:
    - Negate `arg1` twice to ensure it is either 0 or 1, storing the result in `x1`.
    - Compute `x2` as the bitwise AND of the negated `x1` and the maximum 64-bit unsigned integer value.
    - Use [`fiat_p256_value_barrier_u64`](<#fiat_p256_value_barrier_u64>) to apply a value barrier to `x2` and its negation, ensuring no optimization removes the computation.
    - Compute `x3` as the bitwise OR of the masked `arg3` and `arg2`, using `x2` and its negation as masks.
    - Store the result `x3` in the location pointed to by `out1`.
- **Output**: Stores the selected 64-bit unsigned integer in the location pointed to by `out1`.
- **Functions Called**:
    - [`fiat_p256_value_barrier_u64`](<#fiat_p256_value_barrier_u64>)


---
### fiat\_p256\_mul<!-- {{#callable:fiat_p256_mul}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L167>)

Multiplies two field elements in the Montgomery domain and stores the result in the output parameter.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the first operand.
    - `arg2`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the second operand.
- **Logic and Control Flow**:
    - Initialize local variables to store intermediate results and carry bits.
    - Perform a series of multiplications using [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>) to compute partial products of the input elements.
    - Use [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>) to add these partial products together, managing carry bits appropriately.
    - Multiply the result by constants related to the modulus using [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>) and add the results using [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>).
    - Perform a series of conditional subtractions using [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>) to ensure the result is within the field's modulus.
    - Use [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>) to conditionally select between the result and a reduced version based on the final borrow bit.
    - Store the final result in the `out1` parameter.
- **Output**: The function does not return a value but stores the result of the multiplication in the `out1` parameter.
- **Functions Called**:
    - [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>)
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)


---
### fiat\_p256\_square<!-- {{#callable:fiat_p256_square}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L474>)

Squares a field element in the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A constant pointer to a `fiat_p256_montgomery_domain_field_element` representing the input field element to be squared.
- **Logic and Control Flow**:
    - Initialize multiple `uint64_t` and `fiat_p256_uint1` variables for intermediate calculations.
    - Extract elements from `arg1` into local variables `x1`, `x2`, `x3`, and `x4`.
    - Perform multiple multiplications using [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>) to compute partial products of the input element with itself.
    - Use [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>) to accumulate the results of the multiplications, handling carry bits appropriately.
    - Perform modular reduction using the P-256 prime modulus by multiplying with constants and adding results using [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>).
    - Use [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>) to ensure the result is within the field by subtracting the modulus if necessary.
    - Use [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>) to conditionally select the correct result based on the borrow flag.
    - Store the final result in `out1`.
- **Output**: The function does not return a value but stores the squared result in the `out1` parameter.
- **Functions Called**:
    - [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>)
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)


---
### fiat\_p256\_add<!-- {{#callable:fiat_p256_add}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L782>)

Adds two field elements in the Montgomery domain and reduces the result modulo the prime modulus.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A `fiat_p256_montgomery_domain_field_element` representing the first operand.
    - `arg2`: A `fiat_p256_montgomery_domain_field_element` representing the second operand.
- **Logic and Control Flow**:
    - Initialize temporary variables for intermediate results and carry flags.
    - Use [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>) to add corresponding elements of `arg1` and `arg2`, propagating carries across the elements.
    - Use [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>) to subtract the prime modulus from the result, propagating borrows across the elements.
    - Use [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>) to conditionally select the reduced result if a borrow occurred, otherwise select the original sum.
    - Store the final result in `out1`.
- **Output**: The function does not return a value but stores the result in the `out1` parameter.
- **Functions Called**:
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)


---
### fiat\_p256\_sub<!-- {{#callable:fiat_p256_sub}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L835>)

Subtracts two field elements in the Montgomery domain and ensures the result is within the field's bounds.
- **Inputs**:
    - `out1`: A `fiat_p256_montgomery_domain_field_element` array to store the result of the subtraction.
    - `arg1`: A `fiat_p256_montgomery_domain_field_element` array representing the minuend.
    - `arg2`: A `fiat_p256_montgomery_domain_field_element` array representing the subtrahend.
- **Logic and Control Flow**:
    - Initialize variables for intermediate results and borrow flags.
    - Perform subtraction with borrow for each element of the input arrays `arg1` and `arg2` using [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>).
    - Check if the final borrow flag indicates a negative result, and conditionally set a correction value using [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>).
    - Add the correction value to the subtraction result using [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>) to ensure the result is non-negative and within the field's bounds.
    - Store the final result in the `out1` array.
- **Output**: The result of the subtraction is stored in the `out1` array, which is a `fiat_p256_montgomery_domain_field_element`.
- **Functions Called**:
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)


---
### fiat\_p256\_opp<!-- {{#callable:fiat_p256_opp}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L878>)

Negates a field element in the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A `fiat_p256_montgomery_domain_field_element` array of size 4 to store the result.
    - `arg1`: A `fiat_p256_montgomery_domain_field_element` array of size 4 representing the input field element to negate.
- **Logic and Control Flow**:
    - Initialize temporary variables `x1` to `x17` for intermediate calculations.
    - Perform subtraction with borrow using [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>) to compute the negation of each element of `arg1` starting from zero.
    - Use [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>) to conditionally select between zero and the maximum 64-bit unsigned integer based on the borrow flag `x8`.
    - Add the results of the conditional move to the negated values using [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>) to ensure the result is within the field bounds.
    - Store the final negated values in `out1`.
- **Output**: A `fiat_p256_montgomery_domain_field_element` array `out1` containing the negated field element.
- **Functions Called**:
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)


---
### fiat\_p256\_from\_montgomery<!-- {{#callable:fiat_p256_from_montgomery}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L921>)

Converts a field element from the Montgomery domain to the standard representation.
- **Inputs**:
    - `out1`: A pointer to an array of four 64-bit unsigned integers where the result will be stored.
    - `arg1`: A pointer to an array of four 64-bit unsigned integers representing the input field element in the Montgomery domain.
- **Logic and Control Flow**:
    - Initialize variables to store intermediate results and carry flags.
    - Extract the first element of `arg1` and perform a series of multiplications and additions to compute intermediate values.
    - Iterate over each element of `arg1`, performing Montgomery reduction steps using multiplication and addition with carry operations.
    - Perform subtraction with borrow to ensure the result is within the field's modulus.
    - Use conditional move operations to select the correct result based on the borrow flag.
    - Store the final result in `out1`.
- **Output**: The function outputs the converted field element in the standard representation, stored in the `out1` array.
- **Functions Called**:
    - [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>)
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)


---
### fiat\_p256\_to\_montgomery<!-- {{#callable:fiat_p256_to_montgomery}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1076>)

Converts a field element from the non-Montgomery domain to the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A pointer to a `fiat_p256_montgomery_domain_field_element` where the result will be stored.
    - `arg1`: A `fiat_p256_non_montgomery_domain_field_element` representing the input field element to be converted.
- **Logic and Control Flow**:
    - Initialize variables to hold intermediate results and carry flags.
    - Extract each element of the input array `arg1` into separate variables `x1`, `x2`, `x3`, and `x4`.
    - Perform a series of multiplications and additions using the [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>) and [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>) functions to compute the Montgomery representation of the input.
    - Use the [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>) function to ensure the result is within the field's prime modulus by performing conditional subtraction.
    - Store the final result in the `out1` array.
- **Output**: The function does not return a value but stores the result in the `out1` array, which is the Montgomery domain representation of the input field element.
- **Functions Called**:
    - [`fiat_p256_mulx_u64`](<#fiat_p256_mulx_u64>)
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)


---
### fiat\_p256\_nonzero<!-- {{#callable:fiat_p256_nonzero}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1355>)

Outputs a single non-zero word if the input array is non-zero, and zero otherwise.
- **Inputs**:
    - `out1`: A pointer to a `uint64_t` where the result will be stored.
    - `arg1`: An array of four `uint64_t` values representing the input to check for non-zero.
- **Logic and Control Flow**:
    - Compute the bitwise OR of all elements in `arg1` to determine if any element is non-zero.
    - Store the result of the OR operation in the location pointed to by `out1`.
- **Output**: A single `uint64_t` value stored at `out1`, which is non-zero if any element of `arg1` is non-zero, otherwise zero.


---
### fiat\_p256\_selectznz<!-- {{#callable:fiat_p256_selectznz}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1374>)

Selects one of two 256-bit values based on a condition.
- **Inputs**:
    - ``out1``: An array of four `uint64_t` elements where the selected value will be stored.
    - ``arg1``: A `fiat_p256_uint1` condition flag that determines which value to select.
    - ``arg2``: An array of four `uint64_t` elements representing the first 256-bit value.
    - ``arg3``: An array of four `uint64_t` elements representing the second 256-bit value.
- **Logic and Control Flow**:
    - Declare four `uint64_t` variables `x1`, `x2`, `x3`, and `x4` to hold intermediate results.
    - Use [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>) to conditionally select each element of the output based on `arg1`.
    - If `arg1` is 0, select the corresponding element from `arg2`; otherwise, select from `arg3`.
    - Store the selected elements in `x1`, `x2`, `x3`, and `x4`.
    - Assign the values of `x1`, `x2`, `x3`, and `x4` to the `out1` array.
- **Output**: The function outputs a 256-bit value stored in the `out1` array, which is either `arg2` or `arg3` based on the value of `arg1`.
- **Functions Called**:
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)


---
### fiat\_p256\_to\_bytes<!-- {{#callable:fiat_p256_to_bytes}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1402>)

Converts a 256-bit field element from a 4-element array of 64-bit integers to a 32-byte array in little-endian order.
- **Inputs**:
    - `out1`: A 32-byte array where the function will store the serialized output.
    - `arg1`: A 4-element array of 64-bit integers representing the field element to serialize.
- **Logic and Control Flow**:
    - Extracts each 64-bit integer from `arg1` and processes it in little-endian order.
    - For each 64-bit integer, extracts 8 bytes by masking and shifting operations.
    - Stores each extracted byte into the `out1` array in sequence.
- **Output**: A 32-byte array `out1` containing the serialized field element in little-endian order.


---
### fiat\_p256\_from\_bytes<!-- {{#callable:fiat_p256_from_bytes}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1571>)

Deserializes a 32-byte array into a 4-element array of 64-bit unsigned integers, interpreting the input as a little-endian representation of a large integer.
- **Inputs**:
    - `out1`: A 4-element array of 64-bit unsigned integers where the deserialized result will be stored.
    - `arg1`: A 32-byte array representing a large integer in little-endian order.
- **Logic and Control Flow**:
    - Initialize 60 local variables to store intermediate results and byte values.
    - Extract each byte from `arg1` and shift it to its correct position to form 64-bit integers.
    - Combine the shifted bytes to form four 64-bit integers, each representing a segment of the large integer.
    - Store the resulting 64-bit integers in the `out1` array.
- **Output**: A 4-element array of 64-bit unsigned integers representing the deserialized large integer.


---
### fiat\_p256\_set\_one<!-- {{#callable:fiat_p256_set_one}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1706>)

Sets the output to the representation of the number one in the Montgomery domain for the P-256 curve.
- **Inputs**:
    - `out1`: A `fiat_p256_montgomery_domain_field_element` array of size 4 that will hold the output value.
- **Logic and Control Flow**:
    - Assigns the value `0x1` to `out1[0]`.
    - Assigns the value `0xffffffff00000000` to `out1[1]`.
    - Assigns the value `0xffffffffffffffff` to `out1[2]`.
    - Assigns the value `0xfffffffe` to `out1[3]`.
- **Output**: The function does not return a value but modifies the `out1` array to represent the number one in the Montgomery domain.


---
### fiat\_p256\_msat<!-- {{#callable:fiat_p256_msat}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1723>)

Returns the saturated representation of the prime modulus for the P-256 curve.
- **Inputs**:
    - `out1`: An array of 5 `uint64_t` elements where the function will store the saturated representation of the prime modulus.
- **Logic and Control Flow**:
    - Assigns `UINT64_C(0xffffffffffffffff)` to `out1[0]`.
    - Assigns `UINT32_C(0xffffffff)` to `out1[1]`.
    - Assigns `0x0` to `out1[2]`.
    - Assigns `UINT64_C(0xffffffff00000001)` to `out1[3]`.
    - Assigns `0x0` to `out1[4]`.
- **Output**: The function does not return a value but populates the `out1` array with the saturated representation of the prime modulus.


---
### fiat\_p256\_divstep<!-- {{#callable:fiat_p256_divstep}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L1761>)

Computes a divstep operation for the P-256 curve, updating multiple output arrays based on the input conditions.
- **Inputs**:
    - `out1`: Pointer to a `uint64_t` where the function stores the result of the divstep operation.
    - `out2`: Array of 5 `uint64_t` elements to store the updated value of `arg2` or `arg3` based on conditions.
    - `out3`: Array of 5 `uint64_t` elements to store the result of a conditional operation on `arg2` and `arg3`.
    - `out4`: Array of 4 `uint64_t` elements to store the result of a conditional operation on `arg4` and `arg5`.
    - `out5`: Array of 4 `uint64_t` elements to store the result of a conditional operation on `arg4` and `arg5`.
    - `arg1`: A `uint64_t` input value used in the divstep computation.
    - `arg2`: Array of 5 `uint64_t` elements representing one of the input values for the divstep operation.
    - `arg3`: Array of 5 `uint64_t` elements representing another input value for the divstep operation.
    - `arg4`: Array of 4 `uint64_t` elements representing one of the input values for the divstep operation.
    - `arg5`: Array of 4 `uint64_t` elements representing another input value for the divstep operation.
- **Logic and Control Flow**:
    - Initialize variables and compute the negation of `arg1` with a carry addition to determine `x1` and `x2`.
    - Determine the condition `x3` based on the most significant bit of `x1` and the least significant bit of `arg3[0]`.
    - Use conditional moves ([`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)) to select between `arg1` and `x4`, and between elements of `arg2` and `arg3`, storing results in `x6` to `x11`.
    - Compute the negation of `arg2` with carry additions, storing results in `x12` to `x20`.
    - Use conditional moves to select between elements of `arg3` and the negated `arg2`, storing results in `x22` to `x26`.
    - Use conditional moves to select between elements of `arg4` and `arg5`, storing results in `x27` to `x30`.
    - Double the selected elements from `arg4` or `arg5` and perform subtraction with borrow to compute `x39` to `x47`.
    - Compute the negation of `arg4` with borrow, storing results in `x53` to `x60`, and use conditional moves to select between zero and the negated values, storing results in `x61` to `x68`.
    - Use conditional moves to select between elements of `arg5` and the computed values, storing results in `x70` to `x73`.
    - Determine if `x22` is odd and use conditional moves to select zero or elements of `x7` to `x11`, storing results in `x75` to `x79`.
    - Add the selected values to `x22` to `x26`, storing results in `x80` to `x88`.
    - Use conditional moves to select zero or elements of `x27` to `x30`, storing results in `x90` to `x93`.
    - Add the selected values to `x70` to `x73`, storing results in `x94` to `x100`.
    - Perform subtraction with borrow on the results, storing in `x102` to `x110`.
    - Increment `x6` by 1 and compute right shifts on `x80` to `x88` to store in `x114` to `x118`.
    - Use conditional moves to select between `x39` to `x47` and `x31` to `x37`, storing results in `x119` to `x122`.
    - Use conditional moves to select between `x102` to `x110` and `x94` to `x100`, storing results in `x123` to `x126`.
    - Store the final results in `out1`, `out2`, `out3`, `out4`, and `out5`.
- **Output**: The function updates `out1` with a `uint64_t` result and modifies `out2`, `out3`, `out4`, and `out5` arrays based on the divstep computation.
- **Functions Called**:
    - [`fiat_p256_addcarryx_u64`](<#fiat_p256_addcarryx_u64>)
    - [`fiat_p256_cmovznz_u64`](<#fiat_p256_cmovznz_u64>)
    - [`fiat_p256_subborrowx_u64`](<#fiat_p256_subborrowx_u64>)


---
### fiat\_p256\_divstep\_precomp<!-- {{#callable:fiat_p256_divstep_precomp}} -->
[View Source →](<../../../../../src/ballet/fiat-crypto/p256_64.c#L2006>)

Initializes a 4-element array with precomputed constants for the P-256 curve in Montgomery form.
- **Inputs**:
    - `out1`: A 4-element array of type `uint64_t` where the precomputed values will be stored.
- **Logic and Control Flow**:
    - Assigns the constant `0x67ffffffb8000000` to `out1[0]`.
    - Assigns the constant `0xc000000038000000` to `out1[1]`.
    - Assigns the constant `0xd80000007fffffff` to `out1[2]`.
    - Assigns the constant `0x2fffffffffffffff` to `out1[3]`.
- **Output**: The function does not return a value; it modifies the `out1` array in place.



---
Made with ❤️ by [Driver](https://www.driver.ai/)