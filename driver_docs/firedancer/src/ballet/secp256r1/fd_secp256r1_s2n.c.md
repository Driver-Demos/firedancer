<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements scalar, field, and point operations for the secp256r1 elliptic curve.

# Purpose
The code provides cryptographic operations for the secp256r1 elliptic curve, which is commonly used in cryptographic protocols. It includes functions for handling scalars, field elements, and points on the curve. The scalar operations include checking if a scalar is zero, converting byte arrays to scalars, performing scalar multiplication, and computing the modular inverse of a scalar. Field operations involve setting field elements, converting byte arrays to field elements, and computing square roots in the field. Point operations include converting byte arrays to points, checking point equality, and performing double scalar multiplication with a base point.

The code is structured to perform low-level arithmetic operations using big number arithmetic, as indicated by the use of functions like `bignum_mul_4_8`, `bignum_mod_n256`, and `bignum_montmul_p256`. It uses inline functions to optimize performance, and it relies on external constants and functions, such as those defined in `fd_secp256r1_const_*` and `bignum_*` functions, to perform modular arithmetic and other cryptographic operations. The code is intended to be part of a larger cryptographic library, providing specific functionality for elliptic curve operations on the secp256r1 curve.
# Imports and Dependencies

---
- `stdint.h`
- `s2n-bignum.h`
- `fd_secp256r1_table.c`


# Functions

---
### fd\_secp256r1\_scalar\_is\_zero<!-- {{#callable:fd_secp256r1_scalar_is_zero}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L8>)

Checks if a given scalar is equal to zero.
- **Inputs**:
    - `a`: A pointer to a `fd_secp256r1_scalar_t` structure representing the scalar to check.
- **Logic and Control Flow**:
    - Calls the function `fd_uint256_eq` to compare the scalar `a` with the constant `fd_secp256r1_const_zero`.
    - Returns the result of the comparison, which is an integer indicating whether the scalar is zero.
- **Output**: An integer that is non-zero if the scalar is zero, and zero otherwise.


---
### fd\_secp256r1\_scalar\_frombytes<!-- {{#callable:fd_secp256r1_scalar_frombytes}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L13>)

Converts a 32-byte array into a `fd_secp256r1_scalar_t` scalar, ensuring it is less than a predefined constant `fd_secp256r1_const_n`.
- **Inputs**:
    - `r`: A pointer to a `fd_secp256r1_scalar_t` structure where the result will be stored.
    - `in`: A constant 32-byte array representing the input data to be converted into a scalar.
- **Logic and Control Flow**:
    - Copy 32 bytes from the input array `in` to the buffer `r->buf` using `memcpy`.
    - Perform a byte swap on `r` using `fd_uint256_bswap` to ensure correct endianness.
    - Compare `r` with the constant `fd_secp256r1_const_n` using `fd_uint256_cmp`.
    - If `r` is less than `fd_secp256r1_const_n`, return `r`.
    - If `r` is not less than `fd_secp256r1_const_n`, return `NULL`.
- **Output**: Returns a pointer to `r` if the scalar is valid (less than `fd_secp256r1_const_n`), otherwise returns `NULL`.


---
### fd\_secp256r1\_scalar\_frombytes\_positive<!-- {{#callable:fd_secp256r1_scalar_frombytes_positive}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L24>)

Converts a 32-byte input into a scalar and checks if it is less than or equal to a predefined constant.
- **Inputs**:
    - `r`: A pointer to a `fd_secp256r1_scalar_t` structure where the result will be stored.
    - `in`: A constant array of 32 unsigned characters representing the input bytes to be converted into a scalar.
- **Logic and Control Flow**:
    - Copy 32 bytes from the input array `in` to the buffer `r->buf` using `memcpy`.
    - Swap the byte order of `r` using `fd_uint256_bswap`.
    - Compare `r` with the constant `fd_secp256r1_const_n_m1_half` using `fd_uint256_cmp`.
    - If `r` is less than or equal to `fd_secp256r1_const_n_m1_half`, return `r`.
    - If `r` is greater than `fd_secp256r1_const_n_m1_half`, return `NULL`.
- **Output**: Returns a pointer to `r` if the scalar is less than or equal to `fd_secp256r1_const_n_m1_half`, otherwise returns `NULL`.


---
### fd\_secp256r1\_scalar\_from\_digest<!-- {{#callable:fd_secp256r1_scalar_from_digest}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L35>)

Converts a 32-byte digest into a scalar by copying, byte-swapping, and reducing modulo a predefined constant.
- **Inputs**:
    - `r`: A pointer to an `fd_secp256r1_scalar_t` structure where the resulting scalar will be stored.
    - `in`: A constant 32-byte array representing the input digest.
- **Logic and Control Flow**:
    - Copy the 32-byte input `in` into the buffer `r->buf` of the scalar structure `r`.
    - Perform a byte-swap on the scalar `r` using `fd_uint256_bswap` to ensure correct byte order.
    - Reduce the scalar `r` modulo a predefined constant using `bignum_mod_n256_4` to ensure it fits within the expected range.
- **Output**: No return value; the result is stored in the `fd_secp256r1_scalar_t` structure pointed to by `r`.


---
### fd\_secp256r1\_scalar\_mul<!-- {{#callable:fd_secp256r1_scalar_mul}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L43>)

Multiplies two secp256r1 scalars and reduces the result modulo the curve's order.
- **Inputs**:
    - `r`: A pointer to the result scalar where the function will store the product.
    - `a`: A pointer to the first input scalar to multiply.
    - `b`: A pointer to the second input scalar to multiply.
- **Logic and Control Flow**:
    - Declare an array `t` of 8 unsigned long integers to store the intermediate product.
    - Call `bignum_mul_4_8` to multiply the limbs of `a` and `b`, storing the result in `t`.
    - Call `bignum_mod_n256` to reduce the product in `t` modulo the curve's order, storing the result in `r->limbs`.
    - Return the pointer `r`.
- **Output**: A pointer to the result scalar `r` containing the product of `a` and `b` reduced modulo the curve's order.


---
### fd\_secp256r1\_scalar\_inv<!-- {{#callable:fd_secp256r1_scalar_inv}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L53>)

Computes the modular inverse of a scalar in the secp256r1 curve.
- **Inputs**:
    - `r`: A pointer to a `fd_secp256r1_scalar_t` structure where the result will be stored.
    - `a`: A constant pointer to a `fd_secp256r1_scalar_t` structure representing the scalar to invert.
- **Logic and Control Flow**:
    - Declare an array `t` of 12 unsigned long integers to use as temporary storage.
    - Call the `bignum_modinv` function with parameters: 4 (indicating the number of limbs), `r->limbs` (where the result will be stored), `(ulong *)a->limbs` (the limbs of the scalar to invert), `(ulong *)fd_secp256r1_const_n[0].limbs` (the modulus), and `t` (the temporary storage).
    - Return the pointer `r` containing the result.
- **Output**: A pointer to the `fd_secp256r1_scalar_t` structure `r` containing the modular inverse of the input scalar `a`.


---
### fd\_secp256r1\_fp\_set<!-- {{#callable:fd_secp256r1_fp_set}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L63>)

Copies the field element from source to destination in the secp256r1 finite field.
- **Inputs**:
    - `r`: A pointer to the destination `fd_secp256r1_fp_t` structure where the field element will be copied.
    - `a`: A pointer to the source `fd_secp256r1_fp_t` structure containing the field element to copy.
- **Logic and Control Flow**:
    - Copy the first limb of the source `a` to the destination `r`.
    - Copy the second limb of the source `a` to the destination `r`.
    - Copy the third limb of the source `a` to the destination `r`.
    - Copy the fourth limb of the source `a` to the destination `r`.
    - Return the pointer to the destination `r`.
- **Output**: Returns a pointer to the destination `fd_secp256r1_fp_t` structure `r` after copying.


---
### fd\_secp256r1\_fp\_frombytes<!-- {{#callable:fd_secp256r1_fp_frombytes}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L73>)

Converts a 32-byte array into a field element representation, ensuring it is less than a predefined constant.
- **Inputs**:
    - `r`: A pointer to a `fd_secp256r1_fp_t` structure where the result will be stored.
    - `in`: A constant 32-byte array representing the input data to be converted.
- **Logic and Control Flow**:
    - Copy 32 bytes from the input array `in` to the buffer `r->buf` using `memcpy`.
    - Perform a byte swap on `r` using `fd_uint256_bswap` to convert the byte order.
    - Compare `r` with the constant `fd_secp256r1_const_p` using `fd_uint256_cmp`.
    - If `r` is less than `fd_secp256r1_const_p`, return `r`.
    - If `r` is not less than `fd_secp256r1_const_p`, return `NULL`.
- **Output**: Returns a pointer to `r` if the conversion is successful and the value is less than `fd_secp256r1_const_p`; otherwise, returns `NULL`.


---
### fd\_secp256r1\_fp\_sqrt<!-- {{#callable:fd_secp256r1_fp_sqrt}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L84>)

Computes the square root of a field element in the secp256r1 finite field using a series of Montgomery squaring and multiplication operations.
- **Inputs**:
    - `r`: A pointer to an `fd_secp256r1_fp_t` structure where the result will be stored.
    - `a`: A constant pointer to an `fd_secp256r1_fp_t` structure representing the input field element whose square root is to be computed.
- **Logic and Control Flow**:
    - Initialize temporary variables `_t0` and `_t1` to store intermediate results.
    - Perform a series of Montgomery squaring and multiplication operations on `x`, the limbs of `a`, to compute the potential square root.
    - Check if the square of the computed result equals the original input `a` using `fd_uint256_eq`.
    - If the check fails, return `NULL` indicating that the square root does not exist.
    - If the check passes, set the result `r` to the computed value using [`fd_secp256r1_fp_set`](<#fd_secp256r1_fp_set>) and return `r`.
- **Output**: Returns a pointer to `fd_secp256r1_fp_t` containing the square root of `a` if it exists, otherwise returns `NULL`.
- **Functions Called**:
    - [`fd_secp256r1_fp_set`](<#fd_secp256r1_fp_set>)


---
### fd\_secp256r1\_point\_frombytes<!-- {{#callable:fd_secp256r1_point_frombytes}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L119>)

Converts a 33-byte input into a `fd_secp256r1_point_t` structure representing a point on the secp256r1 elliptic curve.
- **Inputs**:
    - `r`: A pointer to a `fd_secp256r1_point_t` structure where the resulting point will be stored.
    - `in`: A 33-byte array containing the input data, where the first byte is the sign and the remaining 32 bytes represent the x-coordinate.
- **Logic and Control Flow**:
    - Extracts the sign from the first byte of `in` and checks if it is either 2 or 3; returns failure if not.
    - Converts the remaining 32 bytes of `in` to the x-coordinate of the point using [`fd_secp256r1_fp_frombytes`](<#fd_secp256r1_fp_frombytes>); returns failure if conversion fails.
    - Converts the x-coordinate to Montgomery form using `bignum_tomont_p256`.
    - Calculates y^2 = x^3 + ax + b using a series of bignum operations.
    - Computes the square root of y^2 to find y using [`fd_secp256r1_fp_sqrt`](<#fd_secp256r1_fp_sqrt>); returns failure if the square root cannot be computed.
    - Determines the correct y-coordinate based on the sign and adjusts it using `bignum_optneg_p256`.
    - Sets the z-coordinate of the point to one in Montgomery form using [`fd_secp256r1_fp_set`](<#fd_secp256r1_fp_set>).
- **Output**: Returns a pointer to the `fd_secp256r1_point_t` structure `r` if successful, or `FD_SECP256R1_FAILURE` if any step fails.
- **Functions Called**:
    - [`fd_secp256r1_fp_frombytes`](<#fd_secp256r1_fp_frombytes>)
    - [`fd_secp256r1_fp_sqrt`](<#fd_secp256r1_fp_sqrt>)
    - [`fd_secp256r1_fp_set`](<#fd_secp256r1_fp_set>)


---
### fd\_secp256r1\_point\_eq\_x<!-- {{#callable:fd_secp256r1_point_eq_x}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L156>)

Checks if the x-coordinate of a given elliptic curve point equals a specified scalar value after modular reduction.
- **Inputs**:
    - `p`: A pointer to a `fd_secp256r1_point_t` structure representing the elliptic curve point.
    - `r`: A pointer to a `fd_secp256r1_scalar_t` structure representing the scalar value to compare against.
- **Logic and Control Flow**:
    - Check if the z-coordinate of the point `p` is zero using `fd_uint256_eq`; if true, return `FD_SECP256R1_FAILURE`.
    - Calculate the modular inverse of the z-coordinate of `p` and store it in `affine_x`.
    - Square the result to get `Z^2` and store it in `affine_x`.
    - Multiply the x-coordinate of `p` by the result to get `X / Z^2` and store it in `affine_x`.
    - Convert the result from Montgomery form using `bignum_demont_p256` and store it in `affine_x_mod_n`.
    - Reduce the result modulo `n` using `bignum_mod_n256_4` and store it in `affine_x_mod_n`.
    - Compare the reduced x-coordinate `affine_x_mod_n` with the scalar `r` using `fd_uint256_eq`; if they are equal, return `FD_SECP256R1_SUCCESS`.
    - If the comparison fails, return `FD_SECP256R1_FAILURE`.
- **Output**: Returns `FD_SECP256R1_SUCCESS` if the x-coordinate of the point equals the scalar after reduction, otherwise returns `FD_SECP256R1_FAILURE`.


---
### fd\_secp256r1\_double\_scalar\_mul\_base<!-- {{#callable:fd_secp256r1_double_scalar_mul_base}} -->
[View Source →](<../../../../../src/ballet/secp256r1/fd_secp256r1_s2n.c#L179>)

Computes the double scalar multiplication of a base point and another point on the secp256r1 elliptic curve.
- **Inputs**:
    - `r`: A pointer to an `fd_secp256r1_point_t` structure where the result will be stored.
    - `u1`: A pointer to a constant `fd_secp256r1_scalar_t` structure representing the first scalar multiplier.
    - `a`: A pointer to a constant `fd_secp256r1_point_t` structure representing the point to be multiplied by the second scalar.
    - `u2`: A pointer to a constant `fd_secp256r1_scalar_t` structure representing the second scalar multiplier.
- **Logic and Control Flow**:
    - Calculates the scalar multiplication of the base point `G` with the scalar `u1` using `p256_scalarmulbase` and stores the result in `rtmp`.
    - Converts the result in `rtmp` to Montgomery form using `bignum_tomont_p256`.
    - Performs the scalar multiplication of the point `a` with the scalar `u2` using `p256_montjscalarmul` and stores the result in `r`.
    - Adds the result of the two scalar multiplications using `p256_montjmixadd` and stores the final result in `r`.
- **Output**: The function does not return a value; it stores the result of the double scalar multiplication in the `fd_secp256r1_point_t` structure pointed to by `r`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)