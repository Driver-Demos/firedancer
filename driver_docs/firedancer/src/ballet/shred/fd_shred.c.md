<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for parsing and validating shreds, and computing their Merkle roots.

# Purpose
The code provides functionality for parsing and validating data structures known as "shreds" and computing their Merkle roots. It is part of a C library that deals with data integrity and verification, likely in a distributed ledger or blockchain context. The function [`fd_shred_parse`](<#fd_shred_parse>) takes a buffer and its size as input and checks if the buffer contains a valid shred. It performs various checks on the shred's type, size, and internal fields to ensure it meets specific criteria. If the shred is valid, the function returns a pointer to the shred; otherwise, it returns `NULL`.

The function [`fd_shred_merkle_root`](<#fd_shred_merkle_root>) computes the Merkle root of a given shred. It initializes a Merkle tree structure and calculates the Merkle root based on the shred's type and content. The function uses helper functions to determine the shred's type and size of the data protected by the Merkle tree. It then inserts the calculated leaf node into the Merkle tree and generates a proof, storing the result in the provided output parameter. This code is part of a broader system that ensures data integrity and authenticity through cryptographic methods.
# Imports and Dependencies

---
- `fd_shred.h`


# Functions

---
### fd\_shred\_parse<!-- {{#callable:fd_shred_parse}} -->
[View Source →](<../../../../../src/ballet/shred/fd_shred.c#L3>)

Parses and validates a shred buffer to ensure it conforms to expected structure and constraints.
- **Inputs**:
    - ``buf``: A pointer to the buffer containing the shred data to parse.
    - ``sz``: The size of the buffer in bytes.
- **Logic and Control Flow**:
    - Check if the total shred size is less than the minimum required header size; return `NULL` if true.
    - Cast the buffer to a `fd_shred_t` pointer and extract the `variant` to determine the shred type.
    - Validate the shred type against known valid types; return `NULL` if the type is invalid.
    - Calculate the header size and trailer size based on the shred variant and type.
    - For data shreds, calculate the payload size and check if it is valid; return `NULL` if invalid.
    - For code shreds, ensure the total size does not exceed the maximum allowed size; return `NULL` if invalid.
    - Perform additional checks on data shreds to ensure fields like `parent_off` and `slot` are valid; return `NULL` if any check fails.
    - Perform additional checks on code shreds to ensure fields like `idx` and `code_cnt` are valid; return `NULL` if any check fails.
    - Return the parsed `fd_shred_t` pointer if all checks pass.
- **Output**: A pointer to the parsed `fd_shred_t` structure if the buffer is valid, otherwise `NULL`.
- **Functions Called**:
    - [`fd_shred_type`](<fd_shred.h.md#fd_shred_type>)
    - [`fd_shred_header_sz`](<fd_shred.h.md#fd_shred_header_sz>)
    - [`fd_shred_merkle_sz`](<fd_shred.h.md#fd_shred_merkle_sz>)
    - [`fd_shred_is_resigned`](<fd_shred.h.md#fd_shred_is_resigned>)
    - [`fd_shred_is_chained`](<fd_shred.h.md#fd_shred_is_chained>)


---
### fd\_shred\_merkle\_root<!-- {{#callable:fd_shred_merkle_root}} -->
[View Source →](<../../../../../src/ballet/shred/fd_shred.c#L108>)

Calculates the Merkle root of a given shred and stores it in the provided output.
- **Inputs**:
    - `shred`: A pointer to a `fd_shred_t` structure representing the shred for which the Merkle root is calculated.
    - `bmtree_mem`: A pointer to memory allocated for the binary Merkle tree.
    - `root_out`: A pointer to a `fd_bmtree_node_t` where the calculated Merkle root will be stored.
- **Logic and Control Flow**:
    - Initialize a binary Merkle tree using `fd_bmtree_commit_init` with the provided memory and constants for node size, prefix size, and layer count.
    - Determine the type of shred using [`fd_shred_type`](<fd_shred.h.md#fd_shred_type>) and check if it is a data shred using [`fd_shred_is_data`](<fd_shred.h.md#fd_shred_is_data>).
    - Calculate the index of the shred using `fd_ulong_if` based on whether it is a data shred or not.
    - Calculate the depth of the Merkle tree using [`fd_shred_merkle_cnt`](<fd_shred.h.md#fd_shred_merkle_cnt>).
    - Compute the size of the data protected by Reed-Solomon coding, adjusting for various factors such as tree depth and shred type.
    - Calculate the size of the data protected by the Merkle tree for both data and parity shreds.
    - Hash the leaf node using `fd_bmtree_hash_leaf` with the calculated protected size and prefix size.
    - Insert the leaf into the Merkle tree and generate a proof using `fd_bmtree_commitp_insert_with_proof`, storing the result in `root_out`.
- **Output**: Returns an integer status code from `fd_bmtree_commitp_insert_with_proof`, indicating success or failure of the operation.
- **Functions Called**:
    - [`fd_shred_type`](<fd_shred.h.md#fd_shred_type>)
    - [`fd_shred_is_data`](<fd_shred.h.md#fd_shred_is_data>)
    - [`fd_shred_merkle_cnt`](<fd_shred.h.md#fd_shred_merkle_cnt>)
    - [`fd_shred_is_chained`](<fd_shred.h.md#fd_shred_is_chained>)
    - [`fd_shred_is_resigned`](<fd_shred.h.md#fd_shred_is_resigned>)
    - [`fd_shred_merkle_nodes`](<fd_shred.h.md#fd_shred_merkle_nodes>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)