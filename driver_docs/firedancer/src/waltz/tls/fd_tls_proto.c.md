<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements functions for encoding and decoding TLS protocol messages, including client and server hello messages, extensions, and certificate handling.

# Purpose
The code is a C module that implements encoding and decoding functions for the Transport Layer Security (TLS) protocol, specifically for handling TLS handshake messages. It includes functions to encode and decode various TLS handshake messages such as `ClientHello`, `ServerHello`, and `HelloRetryRequest`. The module also handles TLS extensions, including supported versions, key shares, and application-layer protocol negotiation (ALPN). The code uses macros to simplify the encoding and decoding processes, ensuring that the data is correctly formatted according to the TLS protocol specifications.

The module defines several functions that operate on data structures representing TLS handshake messages and extensions. These functions include [`fd_tls_decode_client_hello`](<#fd_tls_decode_client_hello>), [`fd_tls_encode_client_hello`](<#fd_tls_encode_client_hello>), [`fd_tls_decode_server_hello`](<#fd_tls_decode_server_hello>), and [`fd_tls_encode_server_hello`](<#fd_tls_encode_server_hello>), among others. Each function takes input data, processes it according to the TLS protocol, and outputs the result. The module also includes functions for handling specific TLS extensions, such as [`fd_tls_decode_ext_supported_versions`](<#fd_tls_decode_ext_supported_versions>) and [`fd_tls_decode_ext_signature_algorithms`](<#fd_tls_decode_ext_signature_algorithms>). Additionally, the code provides functionality for extracting public keys from X.509 certificates and raw public keys, which are used in the TLS handshake process. The module is intended to be part of a larger TLS library, providing essential functionality for secure communication over networks.
# Imports and Dependencies

---
- `fd_tls.h`
- `fd_tls_proto.h`
- `fd_tls_serde.h`
- `fd_tls_asn1.h`
- `../../ballet/x509/fd_x509_mock.h`


# Global Variables

---
### hello\_retry\_magic
- **Type**: ``uchar const[32]``
- **Description**: The `hello_retry_magic` is a static constant array of 32 unsigned characters. It contains a hardcoded value specified by RFC 8446 for the 'random' field of a RetryHelloRequest in the TLS protocol.
- **Use**: Used to identify a HelloRetryRequest by comparing it with the 'random' field in server hello messages.


# Data Structures

---
### tls\_u24
- **Type**: ``struct``
- **Members**:
    - `fd_tls_u24`: A typedef for a structure used as a helper in code generation.
- **Description**: The `tls_u24` is a typedef for a structure named `fd_tls_u24`, which serves as a helper in code generation. It is part of the TLS (Transport Layer Security) implementation, likely used for handling 24-bit unsigned integer values in the context of TLS protocol operations. The actual structure definition is not provided in the code snippet, indicating it might be defined elsewhere or used as a placeholder for code generation purposes.


# Functions

---
### fd\_tls\_decode\_client\_hello<!-- {{#callable:fd_tls_decode_client_hello}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L34>)

Decodes a TLS ClientHello message from a wire format into a structured format.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_client_hello_t` structure where the decoded ClientHello message will be stored.
    - `wire`: A pointer to the byte array containing the wire format of the ClientHello message.
    - `wire_sz`: The size of the `wire` byte array.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to point to the start of the `wire` array.
    - Decode the static-sized part of the ClientHello message, including `legacy_version`, `random`, and `legacy_session_id_sz`.
    - Check if `legacy_session_id_sz` is valid and update `out->session_id` accordingly.
    - Decode the cipher suite list and update `out->cipher_suites` based on supported cipher suites.
    - Decode the next static-sized part of the ClientHello message, including `legacy_compression_method_cnt` and `legacy_compression_methods`.
    - Check if the legacy compression method is valid.
    - Decode the extensions list, iterating over each extension type and size.
    - For each extension, decode the extension data and update the corresponding fields in `out`.
    - Return the number of bytes processed from the `wire` array.
- **Output**: Returns the number of bytes processed from the `wire` array, or a negative error code if decoding fails.
- **Functions Called**:
    - [`fd_tls_decode_ext_supported_versions`](<#fd_tls_decode_ext_supported_versions>)
    - [`fd_tls_decode_ext_server_name`](<#fd_tls_decode_ext_server_name>)
    - [`fd_tls_decode_ext_supported_groups`](<#fd_tls_decode_ext_supported_groups>)
    - [`fd_tls_decode_ext_signature_algorithms`](<#fd_tls_decode_ext_signature_algorithms>)
    - [`fd_tls_decode_key_share_list`](<#fd_tls_decode_key_share_list>)
    - [`fd_tls_decode_ext_cert_type_list`](<#fd_tls_decode_ext_cert_type_list>)
    - [`fd_tls_decode_ext_quic_tp`](<fd_tls_proto.h.md#fd_tls_decode_ext_quic_tp>)
    - [`fd_tls_decode_ext_alpn`](<#fd_tls_decode_ext_alpn>)


---
### FD\_TLS\_DECODE\_LIST\_BEGIN<!-- {{#callable:fd_tls_decode_ext_cert_type_list::FD_TLS_DECODE_LIST_BEGIN}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L876>)

Decodes a list of certificate types from a TLS message and sets corresponding flags in the output structure.
- **Inputs**:
    - `uchar`: The data type for the certificate type being decoded.
    - `alignof(uchar)`: The alignment requirement for the `uchar` type.
- **Logic and Control Flow**:
    - Declare a variable `cert_type` of type `uchar` to store the certificate type.
    - Call `FD_TLS_DECODE_FIELD` to decode the certificate type into `cert_type`.
    - Use a `switch` statement to check the value of `cert_type`.
    - If `cert_type` is `FD_TLS_CERTTYPE_X509`, set `out->x509` to 1.
    - If `cert_type` is `FD_TLS_CERTTYPE_RAW_PUBKEY`, set `out->raw_pubkey` to 1.
    - For unsupported certificate types, do nothing.
- **Output**: No direct output is returned; the function modifies the `out` structure to indicate the presence of specific certificate types.


---
### fd\_tls\_encode\_client\_hello<!-- {{#callable:fd_tls_encode_client_hello}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L160>)

Encodes a TLS ClientHello message into a wire format.
- **Inputs**:
    - ``in``: A pointer to a `fd_tls_client_hello_t` structure containing the ClientHello data to encode.
    - ``wire``: A pointer to a buffer where the encoded ClientHello message will be stored.
    - ``wire_sz``: The size of the `wire` buffer in bytes.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire`.
    - Define and initialize static fields for the ClientHello message, including `legacy_version`, `legacy_session_id_sz`, `cipher_suite_sz`, `cipher_suites`, `legacy_comp_method_sz`, and `legacy_comp_method`.
    - Use `FD_TLS_ENCODE_STATIC_BATCH` to encode the static fields into the `wire` buffer.
    - Define and initialize extension fields for supported versions, key share, supported groups, and signature algorithms.
    - Use `FD_TLS_ENCODE_STATIC_BATCH` to encode the extension fields into the `wire` buffer.
    - Check if `in->alpn.bufsz` is non-zero, and if so, encode the ALPN extension using `FD_TLS_ENCODE_SUB`.
    - Check if `in->quic_tp.buf` is non-null, and if so, encode the QUIC transport parameters using `FD_TLS_ENCODE_STATIC_BATCH`.
    - Calculate the total size of the extensions and store it in `extension_tot_sz`.
    - Return the total number of bytes written to the `wire` buffer.
- **Output**: Returns the total number of bytes written to the `wire` buffer as a `long`.


---
### fd\_tls\_decode\_server\_hello<!-- {{#callable:fd_tls_decode_server_hello}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L261>)

Decodes a TLS ServerHello message from a wire format into a structured format, verifying protocol version, cipher suite, and extensions.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_server_hello_t` structure where the decoded ServerHello message will be stored.
    - `wire`: A pointer to the byte array containing the ServerHello message in wire format.
    - `wire_sz`: The size of the `wire` byte array.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to point to the start of the `wire` data.
    - Decode the static-sized part of the ServerHello message, including `legacy_version`, `random`, `legacy_session_id_sz`, `cipher_suite`, and `legacy_compression_method`.
    - Check if `legacy_version` is `FD_TLS_VERSION_TLS12`, `legacy_session_id_sz` is 0, and `legacy_compression_method` is 0; return `FD_TLS_ALERT_PROTOCOL_VERSION` if any check fails.
    - Verify that `cipher_suite` is `FD_TLS_CIPHER_SUITE_AES_128_GCM_SHA256`; return `FD_TLS_ALERT_ILLEGAL_PARAMETER` if not.
    - Check if the `random` field matches `hello_retry_magic` to reject HelloRetryRequest; return `FD_TLS_ALERT_ILLEGAL_PARAMETER` if it matches.
    - Begin decoding extensions using `FD_TLS_DECODE_LIST_BEGIN`.
    - For each extension, read `ext_type` and `ext_sz`, and check if `ext_sz` exceeds `wire_sz`; return `FD_TLS_ALERT_DECODE_ERROR` if it does.
    - Decode extension data based on `ext_type`:
    - - For `FD_TLS_EXT_SUPPORTED_VERSIONS`, verify `chosen_version` is `FD_TLS_VERSION_TLS13`; return `FD_TLS_ALERT_PROTOCOL_VERSION` if not.
    - - For `FD_TLS_EXT_KEY_SHARE`, call [`fd_tls_decode_key_share`](<#fd_tls_decode_key_share>) to decode the key share.
    - - For `FD_TLS_EXT_QUIC_TRANSPORT_PARAMS`, copy transport parameters as-is.
    - Return `FD_TLS_ALERT_ILLEGAL_PARAMETER` for unsolicited extensions.
    - Check if `ext_parse_res` is negative or not equal to `ext_sz`; return `ext_parse_res` or `FD_TLS_ALERT_DECODE_ERROR` respectively if any check fails.
    - Update `wire_laddr` and `wire_sz` to point to the next extension.
    - End decoding extensions using `FD_TLS_DECODE_LIST_END`.
    - Verify that the `key_share` extension contains `has_x25519`; return `FD_TLS_ALERT_MISSING_EXTENSION` if not.
    - Return the number of bytes processed from the `wire` data.
- **Output**: Returns the number of bytes processed from the `wire` data if successful, or a negative TLS alert error code if an error occurs.
- **Functions Called**:
    - [`fd_tls_decode_key_share`](<#fd_tls_decode_key_share>)


---
### fd\_tls\_encode\_server\_hello<!-- {{#callable:fd_tls_encode_server_hello}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L358>)

Encodes a TLS ServerHello message into a wire format.
- **Inputs**:
    - `in`: A pointer to a `fd_tls_server_hello_t` structure containing the server hello data to encode.
    - `wire`: A pointer to a buffer where the encoded server hello message will be stored.
    - `wire_sz`: The size of the `wire` buffer in bytes.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the buffer.
    - Define and initialize static fields for the server hello message, including `legacy_version`, `legacy_session_id_sz`, `cipher_suite`, and `legacy_compression_method`.
    - Use the `FD_TLS_ENCODE_STATIC_BATCH` macro to encode these static fields into the `wire` buffer.
    - Define and initialize variables for encoding extensions, including `ext_supported_versions_ext_type`, `ext_supported_versions`, `ext_key_share_ext_type`, `ext_key_share_group`, and `ext_key_share_sz`.
    - Use the `FD_TLS_ENCODE_STATIC_BATCH` macro to encode the extensions into the `wire` buffer.
    - Calculate the total size of the extensions and store it in `extension_tot_sz` after byte-swapping.
    - Return the total number of bytes written to the `wire` buffer as a `long`.
- **Output**: Returns the number of bytes written to the `wire` buffer as a `long`.


---
### fd\_tls\_encode\_hello\_retry\_request<!-- {{#callable:fd_tls_encode_hello_retry_request}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L413>)

Encodes a TLS HelloRetryRequest message into a wire format.
- **Inputs**:
    - ``in``: A pointer to a `fd_tls_server_hello_t` structure containing the server hello data to encode.
    - ``wire``: A pointer to a buffer where the encoded message will be stored.
    - ``wire_sz``: The size of the `wire` buffer.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the buffer.
    - Set up static fields for the HelloRetryRequest, including `legacy_version`, `legacy_session_id_sz`, `cipher_suite`, and `legacy_compression_method`.
    - Use `FD_TLS_ENCODE_STATIC_BATCH` to encode these static fields into the `wire` buffer.
    - Define and encode extensions, starting with `extension_tot_sz` to track the total size of extensions.
    - Encode the `ext_supported_versions` extension with type `FD_TLS_EXT_SUPPORTED_VERSIONS` and version `FD_TLS_VERSION_TLS13`.
    - Encode the `ext_key_share` extension with type `FD_TLS_EXT_KEY_SHARE` and group `FD_TLS_GROUP_X25519`.
    - Calculate the total size of extensions and store it in `extension_tot_sz`.
    - Return the total number of bytes written to the `wire` buffer.
- **Output**: Returns the number of bytes written to the `wire` buffer as a `long`.


---
### fd\_tls\_decode\_enc\_ext<!-- {{#callable:fd_tls_decode_enc_ext}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L462>)

Decodes TLS encoded extension data from a wire format into a structured format.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_enc_ext_t` structure where the decoded extension data will be stored.
    - `wire`: A pointer to the input byte array containing the encoded extension data.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire`.
    - Begin decoding a list of extensions using `FD_TLS_DECODE_LIST_BEGIN`.
    - For each extension, read the `ext_type` and `ext_sz` fields using `FD_TLS_DECODE_STATIC_BATCH`.
    - Check if the extension data exceeds the bounds of the list using `FD_UNLIKELY` and return a decode error if it does.
    - Use a switch statement to handle different `ext_type` values:
    - For `FD_TLS_EXT_ALPN`, call [`fd_tls_decode_ext_alpn`](<#fd_tls_decode_ext_alpn>) to decode ALPN data and check for errors.
    - For `FD_TLS_EXT_QUIC_TRANSPORT_PARAMS`, check the size and store the buffer and size in `out->quic_tp`.
    - For `FD_TLS_EXT_SERVER_CERT_TYPE` and `FD_TLS_EXT_CLIENT_CERT_TYPE`, check the size and store the certificate type in the respective fields of `out`.
    - Ignore unknown extensions by default.
    - Update `wire_laddr` and `wire_sz` to point to the next extension.
    - End the decoding list with `FD_TLS_DECODE_LIST_END`.
- **Output**: Returns the number of bytes processed from the input `wire` or a negative error code if decoding fails.
- **Functions Called**:
    - [`fd_tls_decode_ext_alpn`](<#fd_tls_decode_ext_alpn>)


---
### fd\_tls\_encode\_cert\_x509<!-- {{#callable:fd_tls_encode_cert_x509}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L522>)

Encodes an X.509 certificate into a TLS wire format.
- **Inputs**:
    - `x509`: Pointer to the X.509 certificate data to encode.
    - `x509_sz`: Size of the X.509 certificate data in bytes.
    - `wire`: Pointer to the buffer where the encoded TLS data will be stored.
    - `wire_sz`: Size of the buffer for the encoded TLS data.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the buffer position.
    - Set `msg_type` to `FD_TLS_MSG_CERT` to indicate a certificate message.
    - Calculate the sizes for the message, certificate list, and certificate using [`fd_uint_to_tls_u24`](<fd_tls_proto.h.md#fd_uint_to_tls_u24>) and store them in `msg_sz`, `cert_list_sz`, and `cert_sz`.
    - Set `certificate_request_context_sz` to 0, as server certificates do not have a request context.
    - Set `ext_sz` to 0, indicating no certificate extensions.
    - Use `FD_TLS_ENCODE_STATIC_BATCH` macro to encode the fields into the `wire` buffer.
    - Return the number of bytes written to the `wire` buffer by subtracting the initial `wire` address from `wire_laddr`.
- **Output**: Returns the number of bytes written to the `wire` buffer as a long integer.
- **Functions Called**:
    - [`fd_uint_to_tls_u24`](<fd_tls_proto.h.md#fd_uint_to_tls_u24>)


---
### fd\_tls\_encode\_enc\_ext<!-- {{#callable:fd_tls_encode_enc_ext}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L561>)

Encodes various TLS extensions into a wire format buffer.
- **Inputs**:
    - ``in``: A pointer to a `fd_tls_enc_ext_t` structure containing the TLS extensions to encode.
    - ``wire``: A pointer to a buffer where the encoded extensions will be written.
    - ``wire_sz``: The size of the `wire` buffer.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire`.
    - Check if the ALPN extension is present in `in`; if so, encode the ALPN extension header and data using `FD_TLS_ENCODE_SUB`.
    - Check if the QUIC transport parameters extension is present in `in`; if so, encode the extension type, size, and data using `FD_TLS_ENCODE_STATIC_BATCH`.
    - Check if the server certificate type extension is present in `in`; if so, encode the extension type, size, and certificate type using `FD_TLS_ENCODE_STATIC_BATCH`.
    - Check if the client certificate type extension is present in `in`; if so, encode the extension type, size, and certificate type using `FD_TLS_ENCODE_STATIC_BATCH`.
    - Return the number of bytes written to the `wire` buffer by calculating the difference between `wire_laddr` and the original `wire` address.
- **Output**: Returns the number of bytes written to the `wire` buffer as a `long` integer.


---
### fd\_tls\_encode\_raw\_public\_key<!-- {{#callable:fd_tls_encode_raw_public_key}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L621>)

Encodes a raw public key into a TLS certificate message format.
- **Inputs**:
    - `key`: A pointer to a 32-byte Ed25519 public key.
    - `wire`: A pointer to the buffer where the encoded TLS message will be stored.
    - `wire_sz`: The size of the buffer pointed to by `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the buffer position.
    - Set `msg_type` to `FD_TLS_MSG_CERT` to indicate a certificate message.
    - Calculate `rpk_sz` as the size of the Ed25519 public key prefix plus 32 bytes for the key.
    - Convert sizes to TLS u24 format for `msg_sz`, `cert_list_sz`, and `cert_sz` using [`fd_uint_to_tls_u24`](<fd_tls_proto.h.md#fd_uint_to_tls_u24>).
    - Set `certificate_request_context_sz` to 0, as server certificates do not have a request context.
    - Set `ext_sz` to 0, indicating no certificate extensions.
    - Use `FD_TLS_ENCODE_STATIC_BATCH` macro to encode the fields into the `wire` buffer.
    - Return the number of bytes written to `wire` by subtracting the initial `wire` address from `wire_laddr`.
- **Output**: Returns the number of bytes written to the `wire` buffer as a `long`.
- **Functions Called**:
    - [`fd_uint_to_tls_u24`](<fd_tls_proto.h.md#fd_uint_to_tls_u24>)


---
### fd\_tls\_decode\_cert\_verify<!-- {{#callable:fd_tls_decode_cert_verify}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L661>)

Decodes a TLS CertificateVerify message and validates its signature algorithm and size.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_cert_verify_t` structure where the decoded CertificateVerify message will be stored.
    - `wire`: A pointer to the input byte array containing the CertificateVerify message to decode.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the input data.
    - Define a local variable `sig_sz` to store the size of the signature.
    - Use the macro `FD_TLS_DECODE_STATIC_BATCH` to decode the signature algorithm, signature size, and signature from the input data into `out->sig_alg`, `sig_sz`, and `out->sig`, respectively.
    - Check if the decoded signature algorithm is `FD_TLS_SIGNATURE_ED25519` and if the signature size is 0x40 (64 bytes).
    - If the check fails, return a negative value indicating `FD_TLS_ALERT_ILLEGAL_PARAMETER`.
    - If the check passes, return the number of bytes processed from the input data.
- **Output**: Returns the number of bytes processed from the input data if successful, or a negative value indicating an error if the signature algorithm or size is invalid.


---
### fd\_tls\_encode\_cert\_verify<!-- {{#callable:fd_tls_encode_cert_verify}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L683>)

Encodes a TLS CertificateVerify message into a wire format.
- **Inputs**:
    - ``in``: A pointer to a `fd_tls_cert_verify_t` structure containing the signature algorithm and signature to encode.
    - ``wire``: A pointer to a buffer where the encoded message will be stored.
    - ``wire_sz``: The size of the `wire` buffer.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire`.
    - Define `sig_sz` as 0x40, representing the size of the signature.
    - Use the macro `FD_TLS_ENCODE_STATIC_BATCH` to encode the fields: signature algorithm, signature size, and signature data into the `wire` buffer.
    - Return the number of bytes written to the `wire` buffer, calculated as the difference between `wire_laddr` and the original `wire` address.
- **Output**: Returns the number of bytes written to the `wire` buffer as a `long`.


---
### fd\_tls\_decode\_ext\_server\_name<!-- {{#callable:fd_tls_decode_ext_server_name}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L701>)

Decodes a TLS server name extension from a wire format into a structured format.
- **Inputs**:
    - `out`: A pointer to `fd_tls_ext_server_name_t` where the decoded server name will be stored.
    - `wire`: A pointer to the input byte array containing the encoded server name extension.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to point to the start of the `wire` array.
    - Begin decoding a list of server names using `FD_TLS_DECODE_LIST_BEGIN`.
    - Read the `name_type` and `name_sz` fields from the wire data using `FD_TLS_DECODE_STATIC_BATCH`.
    - Check if the name size exceeds the bounds of the list; if so, return a decode error.
    - If the `name_type` is `FD_TLS_SERVER_NAME_TYPE_DNS`, `name_sz` is less than 254, and `out->host_name_len` is 0, copy the server name to `out->host_name` and set `out->host_name_len`.
    - Move the `wire_laddr` pointer forward by `name_sz` bytes to process the next name.
    - End the decoding list with `FD_TLS_DECODE_LIST_END`.
- **Output**: Returns the number of bytes processed from the `wire` array as a long integer, or a negative error code if a decode error occurs.


---
### fd\_tls\_decode\_ext\_supported\_groups<!-- {{#callable:fd_tls_decode_ext_supported_groups}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L742>)

Decodes the 'supported groups' extension from a TLS message and updates the output structure with supported groups information.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_ext_supported_groups_t` structure where the decoded supported groups information will be stored.
    - `wire`: A pointer to the input byte array containing the encoded 'supported groups' extension data.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the input data.
    - Begin decoding a list of `ushort` values using the `FD_TLS_DECODE_LIST_BEGIN` macro.
    - For each `ushort` value decoded, store it in the `group` variable.
    - Check if the `group` is `FD_TLS_GROUP_X25519`; if so, set `out->x25519` to 1 to indicate support for this group.
    - Ignore any unsupported groups by doing nothing in the default case of the switch statement.
    - End the decoding list with the `FD_TLS_DECODE_LIST_END` macro.
    - Return the number of bytes processed by subtracting the initial `wire` address from the current `wire_laddr`.
- **Output**: Returns the number of bytes processed as a `long` integer, indicating the difference between the initial and final positions in the input data.


---
### fd\_tls\_decode\_ext\_supported\_versions<!-- {{#callable:fd_tls_decode_ext_supported_versions}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L766>)

Decodes the supported TLS versions from a wire format and updates the output structure to indicate support for TLS 1.3 if present.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_ext_supported_versions_t` structure where the decoded supported versions will be stored.
    - `wire`: A pointer to the input data in wire format containing the supported versions.
    - `wire_sz`: The size of the input data in bytes.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the input data.
    - Begin decoding a list of `uchar` elements aligned to `ushort` boundaries using `FD_TLS_DECODE_LIST_BEGIN`.
    - For each element in the list, decode a `ushort` value into `group` using `FD_TLS_DECODE_FIELD`.
    - Check if `group` equals `FD_TLS_VERSION_TLS13`; if true, set `out->tls13` to 1 to indicate support for TLS 1.3.
    - Ignore any unsupported TLS versions by doing nothing in the default case of the switch statement.
    - End the decoding list with `FD_TLS_DECODE_LIST_END`.
- **Output**: Returns the number of bytes processed from the input data as a `long` integer.


---
### fd\_tls\_decode\_ext\_signature\_algorithms<!-- {{#callable:fd_tls_decode_ext_signature_algorithms}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L790>)

Decodes a list of signature algorithms from a wire format and updates the output structure to indicate support for the `ED25519` algorithm.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_ext_signature_algorithms_t` structure that will be updated to indicate which signature algorithms are supported.
    - `wire`: A pointer to the input data in wire format containing the list of signature algorithms.
    - `wire_sz`: The size of the input data in bytes.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the input data.
    - Begin decoding a list of `ushort` values using the `FD_TLS_DECODE_LIST_BEGIN` macro.
    - For each `ushort` value decoded, store it in the `group` variable.
    - Check if the `group` value matches `FD_TLS_SIGNATURE_ED25519`.
    - If it matches, set the `ed25519` field of the `out` structure to 1 to indicate support for the `ED25519` algorithm.
    - Ignore any unsupported signature algorithms by doing nothing in the default case of the switch statement.
    - End the decoding list with the `FD_TLS_DECODE_LIST_END` macro.
- **Output**: Returns the number of bytes processed from the input data as a `long` integer.


---
### fd\_tls\_decode\_key\_share<!-- {{#callable:fd_tls_decode_key_share}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L814>)

Decodes a TLS key share from a wire format into a structured format.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_key_share_t` structure where the decoded key share will be stored.
    - `wire`: A pointer to the input byte array containing the wire format of the key share.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire`.
    - Read the group and key exchange data size (`kex_data_sz`) from the wire using `FD_TLS_DECODE_STATIC_BATCH`.
    - Check if `kex_data_sz` exceeds `wire_sz`; if true, return a decode error.
    - Switch on the `group` value to handle different key share groups.
    - For `FD_TLS_GROUP_X25519`, check if `kex_data_sz` is 32; if not, return a decode error.
    - If valid, set `out->has_x25519` to 1 and copy 32 bytes from `wire_laddr` to `out->x25519`.
    - Advance `wire_laddr` by `kex_data_sz` and reduce `wire_sz` by `kex_data_sz`.
    - Return the number of bytes processed.
- **Output**: Returns the number of bytes processed from the input wire format, or a negative error code if decoding fails.


---
### fd\_tls\_decode\_key\_share\_list<!-- {{#callable:fd_tls_decode_key_share_list}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L853>)

Decodes a list of key shares from a given wire format into a `fd_tls_key_share_t` structure.
- **Inputs**:
    - `out`: A pointer to a `fd_tls_key_share_t` structure where the decoded key shares will be stored.
    - `wire`: A pointer to the input byte array containing the wire format of the key share list.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the input data.
    - Begin decoding a list of key shares using the `FD_TLS_DECODE_LIST_BEGIN` macro with `ushort` as the element type and `alignof(uchar)` for alignment.
    - For each key share in the list, call `fd_tls_decode_key_share` to decode the key share and store it in `out`.
    - End the decoding process with the `FD_TLS_DECODE_LIST_END` macro.
    - Calculate the number of bytes processed by subtracting the original `wire` address from `wire_laddr`.
- **Output**: Returns the number of bytes processed as a `long` integer.


---
### fd\_tls\_decode\_ext\_cert\_type\_list<!-- {{#callable:fd_tls_decode_ext_cert_type_list}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L868>)

Decodes a list of certificate types from a TLS extension and updates the output structure with the supported types.
- **Inputs**:
    - `out`: A pointer to `fd_tls_ext_cert_type_list_t` structure where the decoded certificate types will be stored.
    - `wire`: A pointer to the input byte array containing the encoded certificate type list.
    - `wire_sz`: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire` for tracking the current position in the input data.
    - Set the `present` field of the `out` structure to 1, indicating that the extension is present.
    - Begin decoding the list of certificate types using the `FD_TLS_DECODE_LIST_BEGIN` macro.
    - For each certificate type in the list, decode it into a `uchar` variable `cert_type`.
    - Use a switch statement to check the value of `cert_type` and set the corresponding field in the `out` structure (`x509` or `raw_pubkey`) to 1 if the type is supported.
    - Ignore any unsupported certificate types.
    - End the decoding list with the `FD_TLS_DECODE_LIST_END` macro.
    - Return the number of bytes processed as the difference between the current `wire_laddr` and the initial `wire` address.
- **Output**: Returns the number of bytes processed as a `long`, indicating the difference between the current position and the start of the input data.


---
### fd\_tls\_encode\_ext\_cert\_type\_list<!-- {{#callable:fd_tls_encode_ext_cert_type_list}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L892>)

Encodes a list of certificate types into a wire format for TLS communication.
- **Inputs**:
    - `in`: A `fd_tls_ext_cert_type_list_t` structure containing the certificate types to encode.
    - `wire`: A pointer to the buffer where the encoded data will be written.
    - `wire_sz`: The size of the buffer `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` to the address of `wire`.
    - Calculate the number of certificate types in `in.uc` using `fd_uchar_popcnt` and store it in `cnt`.
    - Encode `cnt` into the wire buffer using `FD_TLS_ENCODE_FIELD`.
    - Skip `cnt` fields in the wire buffer using `FD_TLS_SKIP_FIELDS`.
    - If `in.x509` is true, encode `FD_TLS_CERTTYPE_X509` into the wire buffer.
    - If `in.raw_pubkey` is true, encode `FD_TLS_CERTTYPE_RAW_PUBKEY` into the wire buffer.
- **Output**: Returns the number of bytes written to the wire buffer as a `long`.


---
### fd\_tls\_decode\_ext\_cert\_type<!-- {{#callable:fd_tls_decode_ext_cert_type}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L911>)

Decodes a certificate type from a TLS extension field and updates the output structure with the decoded value.
- **Inputs**:
    - ``out``: A pointer to an `fd_tls_ext_cert_type_t` structure where the decoded certificate type will be stored.
    - ``wire``: A pointer to the input byte array containing the encoded certificate type data.
    - ``wire_sz``: The size of the input byte array `wire`.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` with the address of `wire` to track the current position in the input data.
    - Use the macro `FD_TLS_DECODE_FIELD` to decode the certificate type from the input data and store it in `out->cert_type`.
    - Calculate the number of bytes processed by subtracting the original `wire` address from `wire_laddr`.
- **Output**: Returns the number of bytes processed as a `long` integer, indicating the offset from the start of the input data.


---
### fd\_tls\_encode\_ext\_cert\_type<!-- {{#callable:fd_tls_encode_ext_cert_type}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L920>)

Encodes a certificate type into a wire format and returns the number of bytes written.
- **Inputs**:
    - `in`: A `fd_tls_ext_cert_type_t` structure containing the certificate type to encode.
    - `wire`: A pointer to a constant unsigned character array where the encoded data will be written.
    - `wire_sz`: An unsigned long integer representing the size of the `wire` buffer.
- **Logic and Control Flow**:
    - Initialize `wire_laddr` with the address of `wire`.
    - Encode the `cert_type` field from the `in` structure into the `wire` buffer using the `FD_TLS_ENCODE_FIELD` macro.
    - Calculate the number of bytes written by subtracting the original `wire` address from the current `wire_laddr`.
- **Output**: Returns a long integer representing the number of bytes written to the `wire` buffer.


---
### fd\_tls\_decode\_ext\_opaque<!-- {{#callable:fd_tls_decode_ext_opaque}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L929>)

Assigns the input buffer and its size to the output structure and returns the size of the buffer.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_ext_opaque_t` structure where the function will store the buffer and its size.
    - `wire`: A pointer to an array of unsigned characters representing the buffer to be decoded.
    - `wire_sz`: An unsigned long integer representing the size of the buffer `wire`.
- **Logic and Control Flow**:
    - Assign the pointer `wire` to the `buf` field of the `out` structure.
    - Assign the value of `wire_sz` to the `bufsz` field of the `out` structure.
    - Return the value of `wire_sz` cast to a long integer.
- **Output**: Returns the size of the buffer `wire_sz` as a long integer.


---
### fd\_tls\_decode\_ext\_alpn<!-- {{#callable:fd_tls_decode_ext_alpn}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L938>)

Decodes the ALPN (Application-Layer Protocol Negotiation) extension from a TLS wire format into a structured format.
- **Inputs**:
    - `out`: A pointer to an `fd_tls_ext_alpn_t` structure where the decoded ALPN extension will be stored.
    - `wire`: A pointer to the input byte array containing the ALPN extension data in wire format.
    - `wire_sz`: The size of the `wire` byte array.
- **Logic and Control Flow**:
    - Convert the `wire` pointer to an unsigned long integer `wire_laddr` for address arithmetic.
    - Decode the ALPN size `alpn_sz` from the `wire` using the `FD_TLS_DECODE_FIELD` macro.
    - Check if the decoded `alpn_sz` is not equal to `wire_sz`. If they are not equal, return a negative value indicating a decode error.
    - Call [`fd_tls_decode_ext_opaque`](<#fd_tls_decode_ext_opaque>) to decode the opaque ALPN data and add 2 to the result to account for the size field.
- **Output**: Returns a long integer representing the total number of bytes processed, or a negative value if a decode error occurs.
- **Functions Called**:
    - [`fd_tls_decode_ext_opaque`](<#fd_tls_decode_ext_opaque>)


---
### fd\_tls\_encode\_ext\_alpn<!-- {{#callable:fd_tls_encode_ext_alpn}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L950>)

Encodes an ALPN extension into a wire format buffer.
- **Inputs**:
    - ``in``: A pointer to a `fd_tls_ext_alpn_t` structure containing the ALPN data to encode.
    - ``wire``: A pointer to a buffer where the encoded ALPN extension will be stored.
    - ``wire_sz``: The size of the `wire` buffer in bytes.
- **Logic and Control Flow**:
    - Calculate the total size of the ALPN extension, which is 2 bytes for the size field plus the size of the ALPN buffer (`in->bufsz`).
    - Check if the calculated size exceeds the available buffer size (`wire_sz`).
    - If the size exceeds `wire_sz`, return a negative error code indicating an internal error.
    - Store the size of the ALPN buffer in the first two bytes of the `wire` buffer in big-endian format.
    - Copy the ALPN buffer (`in->buf`) into the `wire` buffer starting at the third byte.
    - Return the total size of the encoded ALPN extension.
- **Output**: Returns the total size of the encoded ALPN extension on success, or a negative error code if the buffer is too small.


---
### fd\_tls\_client\_handle\_x509<!-- {{#callable:fd_tls_client_handle_x509}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L970>)

Extracts the Ed25519 subject public key from an ASN.1 DER-encoded X.509 certificate without validating the certificate's signature.
- **Inputs**:
    - `cert`: A pointer to the ASN.1 DER-encoded certificate data.
    - `cert_sz`: The size of the certificate data in bytes.
    - `out_pubkey`: A pointer to a location where the function will store the extracted public key on success.
- **Logic and Control Flow**:
    - Call `fd_x509_mock_pubkey` with `cert` and `cert_sz` to attempt to extract the public key.
    - Check if the returned `pubkey` is NULL, indicating failure to extract the public key.
    - If `pubkey` is NULL, return `FD_TLS_ALERT_UNSUPPORTED_CERTIFICATE`.
    - If `pubkey` is not NULL, store the `pubkey` in `out_pubkey`.
    - Return 0U to indicate success.
- **Output**: Returns 0U on success, or a positive TLS alert error code if the public key extraction fails.


---
### fd\_tls\_extract\_cert\_pubkey\_<!-- {{#callable:fd_tls_extract_cert_pubkey_}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L981>)

Extracts the public key from the first certificate in a certificate chain based on the specified certificate type.
- **Inputs**:
    - `res`: A pointer to a `fd_tls_extract_cert_pubkey_res_t` structure where the result will be stored.
    - `cert_chain`: A pointer to the certificate chain data.
    - `cert_chain_sz`: The size of the certificate chain data.
    - `cert_type`: The type of certificate, which can be `FD_TLS_CERTTYPE_X509` or `FD_TLS_CERTTYPE_RAW_PUBKEY`.
- **Logic and Control Flow**:
    - Initialize the `res` structure to zero using `fd_memset`.
    - Set `wire_laddr` to the address of `cert_chain` and `wire_sz` to `cert_chain_sz`.
    - Skip the 'opaque certificate_request_context<0..2^8-1>' field using `FD_TLS_SKIP_FIELD` and `FD_TLS_SKIP_FIELDS`.
    - Retrieve the size of the certificate list using `FD_TLS_SKIP_FIELD` and convert it to a uint using [`fd_tls_u24_bswap`](<fd_tls_proto.h.md#fd_tls_u24_bswap>) and [`fd_tls_u24_to_uint`](<fd_tls_proto.h.md#fd_tls_u24_to_uint>).
    - If the certificate list size is zero, set the alert and reason in `res` to `FD_TLS_ALERT_BAD_CERTIFICATE` and `FD_TLS_REASON_CERT_CHAIN_EMPTY`, respectively, and return -1.
    - Retrieve the size of the first certificate using `FD_TLS_SKIP_FIELD` and convert it to a uint using [`fd_tls_u24_bswap`](<fd_tls_proto.h.md#fd_tls_u24_bswap>) and [`fd_tls_u24_to_uint`](<fd_tls_proto.h.md#fd_tls_u24_to_uint>).
    - If the certificate size is greater than `wire_sz`, set the alert and reason in `res` to `FD_TLS_ALERT_DECODE_ERROR` and `FD_TLS_REASON_CERT_PARSE`, respectively, and return -1.
    - Based on `cert_type`, either handle the certificate as a DER-encoded X.509 certificate or as a raw public key.
    - For `FD_TLS_CERTTYPE_X509`, call [`fd_tls_client_handle_x509`](<#fd_tls_client_handle_x509>) to extract the public key. If it fails, set the alert and reason in `res` and return -1.
    - For `FD_TLS_CERTTYPE_RAW_PUBKEY`, call [`fd_ed25519_public_key_from_asn1`](<fd_tls_asn1.c.md#fd_ed25519_public_key_from_asn1>) to extract the public key. If it fails, set the alert and reason in `res` and return -1.
    - Return 0 on successful extraction of the public key.
- **Output**: Returns 0 on success, or -1 on failure, with the `res` structure populated with the public key or error details.
- **Functions Called**:
    - [`fd_tls_u24_bswap`](<fd_tls_proto.h.md#fd_tls_u24_bswap>)
    - [`fd_tls_u24_to_uint`](<fd_tls_proto.h.md#fd_tls_u24_to_uint>)
    - [`fd_tls_client_handle_x509`](<#fd_tls_client_handle_x509>)
    - [`fd_ed25519_public_key_from_asn1`](<fd_tls_asn1.c.md#fd_ed25519_public_key_from_asn1>)


---
### fd\_tls\_extract\_cert\_pubkey<!-- {{#callable:fd_tls_extract_cert_pubkey}} -->
[View Source →](<../../../../../src/waltz/tls/fd_tls_proto.c#L1058>)

Extracts the public key from a certificate chain based on the specified certificate type.
- **Inputs**:
    - `cert_chain`: A pointer to the certificate chain data.
    - `cert_chain_sz`: The size of the certificate chain data.
    - `cert_type`: The type of certificate, indicating how to interpret the certificate data.
- **Logic and Control Flow**:
    - Initialize a result structure `res` of type `fd_tls_extract_cert_pubkey_res_t`.
    - Call the helper function [`fd_tls_extract_cert_pubkey_`](<#fd_tls_extract_cert_pubkey_>) with the result structure and input parameters to extract the public key.
    - Ignore the return value of the helper function [`fd_tls_extract_cert_pubkey_`](<#fd_tls_extract_cert_pubkey_>).
    - Return the result structure `res`.
- **Output**: Returns a structure of type `fd_tls_extract_cert_pubkey_res_t` containing the extracted public key and any associated status information.
- **Functions Called**:
    - [`fd_tls_extract_cert_pubkey_`](<#fd_tls_extract_cert_pubkey_>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)