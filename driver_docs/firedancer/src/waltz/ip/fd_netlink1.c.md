<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements functions for creating, reading, and managing Netlink sockets and messages in Linux.

# Purpose
The code is a C module that provides functionality for interacting with the Linux Netlink protocol, specifically for routing-related messages. It includes functions to create and manage Netlink sockets, read messages from these sockets, and iterate over received Netlink messages. The module defines several functions for initializing and finalizing Netlink communication, such as [`fd_netlink_init`](<#fd_netlink_init>) and [`fd_netlink_fini`](<#fd_netlink_fini>), which handle the setup and teardown of Netlink sockets. The function [`fd_netlink_read_socket`](<#fd_netlink_read_socket>) is responsible for reading data from a Netlink socket, handling specific errors like `ENOBUFS` by incrementing a counter `fd_netlink_enobufs_cnt`.

The module also includes an iterator pattern for processing Netlink messages, with functions like [`fd_netlink_iter_init`](<#fd_netlink_iter_init>), [`fd_netlink_iter_next`](<#fd_netlink_iter_next>), and [`fd_netlink_iter_done`](<#fd_netlink_iter_done>) to manage the iteration state. It provides utility functions to convert routing message types and attributes to human-readable strings, such as [`fd_netlink_rtm_type_str`](<#fd_netlink_rtm_type_str>) and [`fd_netlink_rtattr_str`](<#fd_netlink_rtattr_str>). These functions help in interpreting the Netlink messages by mapping message and attribute types to descriptive strings. The code is intended to be part of a larger system, as indicated by the inclusion of external headers and the use of logging functions like `FD_LOG_WARNING`.
# Imports and Dependencies

---
- `sys/types.h`
- `sys/socket.h`
- `linux/netlink.h`
- `linux/rtnetlink.h`
- `errno.h`
- `unistd.h`
- `fd_netlink1.h`
- `../../util/fd_util.h`


# Global Variables

---
### fd\_netlink\_enobufs\_cnt
- **Type**: ``ulong``
- **Description**: Counts the number of times a `recvfrom` call on a netlink socket fails with the `ENOBUFS` error, indicating that the socket's receive buffer is full and messages are being dropped.
- **Use**: Increments each time a netlink socket receive operation encounters an `ENOBUFS` error.


# Functions

---
### fd\_nl\_create\_socket<!-- {{#callable:fd_nl_create_socket}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L13>)

Creates a Netlink socket and configures it to use extended acknowledgments.
- **Inputs**: None
- **Logic and Control Flow**:
    - Call `socket` with `AF_NETLINK`, `SOCK_RAW`, and `NETLINK_ROUTE` to create a Netlink socket.
    - Check if the socket creation failed; if so, log a warning and return -1.
    - Set the `one` variable to 1 to enable extended acknowledgments.
    - Call `setsockopt` to set the `NETLINK_EXT_ACK` option on the socket.
    - Check if `setsockopt` failed; if so, log a warning, close the socket, and return -1.
    - Return the file descriptor of the created socket.
- **Output**: Returns the file descriptor of the created socket, or -1 if an error occurs.


---
### fd\_nl\_close\_socket<!-- {{#callable:fd_nl_close_socket}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L34>)

Closes a socket if the file descriptor is valid.
- **Inputs**:
    - `fd`: The file descriptor of the socket to close.
- **Logic and Control Flow**:
    - Checks if the file descriptor `fd` is greater than or equal to 0.
    - If the check passes, calls the `close` function on `fd` to close the socket.
- **Output**: No output is returned.


---
### fd\_netlink\_read\_socket<!-- {{#callable:fd_netlink_read_socket}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L41>)

Receives data from a netlink socket and handles specific error conditions.
- **Inputs**:
    - `fd`: The file descriptor of the netlink socket to read from.
    - `buf`: A pointer to a buffer where the received data will be stored.
    - `buf_sz`: The size of the buffer in bytes.
- **Logic and Control Flow**:
    - Enters an infinite loop to continuously attempt to receive data from the socket.
    - Calls `recvfrom` to read data from the socket into the buffer.
    - Checks if the received length `len` is less than or equal to zero.
    - If `len` is zero, continues the loop to attempt another read.
    - If `errno` is `EINTR`, continues the loop to attempt another read.
    - If `errno` is `ENOBUFS`, increments the `fd_netlink_enobufs_cnt` counter and continues the loop.
    - Logs a warning and returns the negative error number if any other error occurs.
    - Returns the length of the received data if successful.
- **Output**: Returns the length of the received data on success, or a negative error number on failure.


---
### fd\_netlink\_init<!-- {{#callable:fd_netlink_init}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L64>)

Initializes a `fd_netlink_t` structure by creating a netlink socket and setting the sequence number.
- **Inputs**:
    - `nl`: A pointer to a `fd_netlink_t` structure that will be initialized.
    - `seq0`: An unsigned integer representing the initial sequence number to set in the `fd_netlink_t` structure.
- **Logic and Control Flow**:
    - Call [`fd_nl_create_socket`](<#fd_nl_create_socket>) to create a netlink socket and assign the file descriptor to `nl->fd`.
    - Check if the socket creation failed (i.e., `nl->fd < 0`), and if so, return `NULL`.
    - Set the sequence number `nl->seq` to `seq0`.
    - Return the pointer `nl`.
- **Output**: Returns a pointer to the initialized `fd_netlink_t` structure, or `NULL` if socket creation fails.
- **Functions Called**:
    - [`fd_nl_create_socket`](<#fd_nl_create_socket>)


---
### fd\_netlink\_fini<!-- {{#callable:fd_netlink_fini}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L73>)

Closes a netlink socket and resets its file descriptor.
- **Inputs**:
    - `nl`: A pointer to an `fd_netlink_t` structure that contains the netlink socket information.
- **Logic and Control Flow**:
    - Calls [`fd_nl_close_socket`](<#fd_nl_close_socket>) with the file descriptor from the `nl` structure to close the socket.
    - Sets the file descriptor in the `nl` structure to -1 to indicate it is no longer valid.
    - Returns the pointer to the `fd_netlink_t` structure.
- **Output**: A pointer to the `fd_netlink_t` structure that was passed as input.
- **Functions Called**:
    - [`fd_nl_close_socket`](<#fd_nl_close_socket>)


---
### fd\_netlink\_iter\_recvmsg<!-- {{#callable:fd_netlink_iter_recvmsg}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L80>)

Receives a message from a netlink socket and updates the iterator with the message data or an error code.
- **Inputs**:
    - ``iter``: A pointer to an `fd_netlink_iter_t` structure that will be updated with the received message data or an error code.
    - ``netlink``: A pointer to an `fd_netlink_t` structure that contains the file descriptor for the netlink socket.
- **Logic and Control Flow**:
    - Call [`fd_netlink_read_socket`](<#fd_netlink_read_socket>) with the netlink socket file descriptor, buffer, and buffer size from `iter` to read a message.
    - Check if the length of the received message (`len`) is less than 0.
    - If `len` is less than 0, set `iter->err` to the negative of `len` and return.
    - Set `iter->msg0` to the start of the buffer (`iter->buf`).
    - Set `iter->msg1` to the end of the received message (`iter->buf + len`).
- **Output**: No direct output; updates the `iter` structure with message data or an error code.
- **Functions Called**:
    - [`fd_netlink_read_socket`](<#fd_netlink_read_socket>)


---
### fd\_netlink\_iter\_bounds\_check<!-- {{#callable:fd_netlink_iter_bounds_check}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L96>)

Checks if the current netlink message in the iterator is within valid bounds and sets an error if it is not.
- **Inputs**:
    - ``iter``: A pointer to an `fd_netlink_iter_t` structure that represents the current state of the netlink message iterator.
- **Logic and Control Flow**:
    - Checks if the iterator is done using [`fd_netlink_iter_done`](<#fd_netlink_iter_done>); if true, returns immediately.
    - Casts the current message pointer `iter->msg0` to a `struct nlmsghdr` pointer `nlh`.
    - Checks if the message header is out-of-bounds by comparing `iter->msg0 + sizeof(struct nlmsghdr)` with `iter->msg1`; if true, logs a warning and sets `iter->err` to `EPROTO`, then returns.
    - Checks if the message length `nlh->nlmsg_len` is less than the size of `struct nlmsghdr`; if true, logs a warning to prevent an infinite loop, sets `iter->err` to `EPROTO`, then returns.
    - Checks if the message end `iter->msg0 + nlh->nlmsg_len` is out-of-bounds by comparing it with `iter->msg1`; if true, logs a warning with details of the current and buffer bounds, sets `iter->err` to `EPROTO`, then returns.
- **Output**: No direct output is returned, but the function sets the `err` field of the `iter` structure to `EPROTO` if any bounds check fails.
- **Functions Called**:
    - [`fd_netlink_iter_done`](<#fd_netlink_iter_done>)


---
### fd\_netlink\_iter\_init<!-- {{#callable:fd_netlink_iter_init}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L120>)

Initializes a `fd_netlink_iter_t` iterator with a buffer and netlink context, and performs a message receive and bounds check.
- **Inputs**:
    - `iter`: A pointer to a `fd_netlink_iter_t` structure to initialize.
    - `netlink`: A pointer to a `fd_netlink_t` structure representing the netlink context.
    - `buf`: A pointer to a buffer where netlink messages will be stored.
    - `buf_sz`: The size of the buffer in bytes.
- **Logic and Control Flow**:
    - Assigns the buffer and its size to the `iter` structure, and initializes `msg0` and `msg1` to point to the start of the buffer.
    - Calls [`fd_netlink_iter_recvmsg`](<#fd_netlink_iter_recvmsg>) to receive a netlink message into the buffer using the provided netlink context.
    - Calls [`fd_netlink_iter_bounds_check`](<#fd_netlink_iter_bounds_check>) to ensure the received message is within the buffer bounds.
    - Returns the initialized `iter` pointer.
- **Output**: Returns a pointer to the initialized `fd_netlink_iter_t` structure.
- **Functions Called**:
    - [`fd_netlink_iter_recvmsg`](<#fd_netlink_iter_recvmsg>)
    - [`fd_netlink_iter_bounds_check`](<#fd_netlink_iter_bounds_check>)


---
### fd\_netlink\_iter\_done<!-- {{#callable:fd_netlink_iter_done}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L138>)

Checks if a netlink message iterator has completed processing.
- **Inputs**:
    - `iter`: A pointer to a constant `fd_netlink_iter_t` structure representing the netlink message iterator.
- **Logic and Control Flow**:
    - Checks if `iter->err` is not zero or if the difference between `iter->msg1` and `iter->msg0` is less than the size of `struct nlmsghdr`.
    - If either condition is true, returns 1 indicating the iteration is done.
    - If not, retrieves a pointer to the netlink message header using `fd_type_pun_const` on `iter->msg0`.
    - Checks if the `nlmsg_type` of the message header is `NLMSG_DONE`.
    - Returns 1 if `nlmsg_type` is `NLMSG_DONE`, otherwise returns 0.
- **Output**: Returns 1 if the iteration is done, otherwise returns 0.


---
### fd\_netlink\_iter\_next<!-- {{#callable:fd_netlink_iter_next}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L147>)

Advances the netlink iterator to the next message, handling multipart messages and checking bounds.
- **Inputs**:
    - ``iter``: A pointer to the `fd_netlink_iter_t` structure representing the current state of the netlink message iterator.
    - ``netlink``: A pointer to the `fd_netlink_t` structure representing the netlink connection.
- **Logic and Control Flow**:
    - Check if the iterator is done using [`fd_netlink_iter_done`](<#fd_netlink_iter_done>); if so, return the iterator as is.
    - Retrieve the current netlink message header using `fd_type_pun_const`.
    - Check if the current message is not a multipart message by examining the `nlmsg_flags` field; if not, set the iterator's error to -1 and return the iterator.
    - Advance the iterator's message pointer `msg0` by the aligned length of the current message using `NLMSG_ALIGN`.
    - If the advanced message pointer `msg0` is greater than or equal to `msg1`, call [`fd_netlink_iter_recvmsg`](<#fd_netlink_iter_recvmsg>) to receive more messages.
    - Perform a bounds check on the iterator using [`fd_netlink_iter_bounds_check`](<#fd_netlink_iter_bounds_check>).
    - Return the updated iterator.
- **Output**: A pointer to the updated `fd_netlink_iter_t` structure.
- **Functions Called**:
    - [`fd_netlink_iter_done`](<#fd_netlink_iter_done>)
    - [`fd_netlink_iter_recvmsg`](<#fd_netlink_iter_recvmsg>)
    - [`fd_netlink_iter_bounds_check`](<#fd_netlink_iter_bounds_check>)


---
### fd\_netlink\_rtm\_type\_str<!-- {{#callable:fd_netlink_rtm_type_str}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L169>)

Maps a routing message type integer to its corresponding string representation.
- **Inputs**:
    - `rtm_type`: An integer representing the routing message type.
- **Logic and Control Flow**:
    - Use a `switch` statement to evaluate the `rtm_type` input.
    - For each case, return the corresponding string representation of the routing message type.
    - If `rtm_type` does not match any predefined case, return "unknown".
- **Output**: A constant character pointer to the string representation of the routing message type.


---
### fd\_netlink\_rtattr\_str<!-- {{#callable:fd_netlink_rtattr_str}} -->
[View Source →](<../../../../../src/waltz/ip/fd_netlink1.c#L188>)

Maps a routing attribute type to its corresponding string representation.
- **Inputs**:
    - `rta_type`: An integer representing the routing attribute type.
- **Logic and Control Flow**:
    - Use a switch statement to match the `rta_type` with predefined constants.
    - Return a string that corresponds to the matched routing attribute type.
    - If `rta_type` does not match any predefined constants, return "unknown".
- **Output**: A constant character pointer to the string representation of the routing attribute type.



---
Made with ❤️ by [Driver](https://www.driver.ai/)