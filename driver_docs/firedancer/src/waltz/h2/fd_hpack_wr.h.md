<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

APIs for generating HPACK header entries with simple serialization methods.

# Purpose
The code in `fd_hpack_wr.h` provides a set of functions to generate HPACK header entries for HTTP/2 communication. HPACK is a compression format used in HTTP/2 to efficiently encode HTTP headers. This file defines several inline functions that facilitate the creation of various HTTP/2 headers, such as `:method`, `:scheme`, `:path`, `user-agent`, `authorization`, and `:authority`. The functions use a buffer (`fd_h2_rbuf_t`) to store the serialized header data, and they ensure that the buffer has enough space before writing to it.

The code includes functions like [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>) to encode integers using a variable-length format, which is a common requirement in HPACK encoding. The file also contains conditional compilation directives to optimize encoding for x86 architectures using specific CPU instructions. The functions are designed to be simple and efficient, focusing on generating the necessary header data for HTTP/2 communication without additional complexity. The file is intended to be included in other C source files, providing a straightforward API for header serialization in HTTP/2 applications.
# Imports and Dependencies

---
- `fd_h2_base.h`
- `fd_h2_rbuf.h`
- `immintrin.h`


# Functions

---
### fd\_hpack\_wr\_varint<!-- {{#callable:fd_hpack_wr_varint}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L16>)

Encodes a variable-length integer into a byte array using a specified prefix and addend.
- **Inputs**:
    - `code`: An array of 9 unsigned characters where the encoded integer will be stored.
    - `prefix`: An unsigned integer that specifies the prefix to be used in the encoding.
    - `addend`: An unsigned integer that is added to the prefix to determine the initial encoding value.
    - `number`: An unsigned long integer in the range [0, 2^56) that represents the number to encode.
- **Logic and Control Flow**:
    - Check if `number` is less than `addend`; if true, store the result of `prefix | number` in `code[0]` and set `sz` to 1.
    - If `number` is not less than `addend`, store the result of `prefix | addend` in `code[0]` and calculate `tail` as `number - addend`.
    - If the platform supports x86 with BMI2, use `_pdep_u64` to encode `tail` into `enc`; otherwise, manually encode `tail` into `enc` using bitwise operations.
    - Find the most significant bit (MSB) of `enc` using `fd_ulong_find_msb_w_default`.
    - Calculate `shift` and `mask` based on the MSB, and store the result of `enc | mask` in `code+1` using `FD_STORE`.
    - Set `sz` to 2 plus the integer division of MSB by 8.
- **Output**: Returns the size of the encoded integer in bytes as an unsigned long integer.


---
### fd\_hpack\_wr\_private\_indexed<!-- {{#callable:fd_hpack_wr_private_indexed}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L54>)

Encodes an indexed header field into the transmission buffer if there is enough space available.
- **Inputs**:
    - ``rbuf_tx``: A pointer to the `fd_h2_rbuf_t` structure representing the transmission buffer.
    - ``idx``: An unsigned long integer representing the index of the header field to encode.
- **Logic and Control Flow**:
    - Check if there is enough free space in the transmission buffer `rbuf_tx` using [`fd_h2_rbuf_free_sz`](<fd_h2_rbuf.h.md#fd_h2_rbuf_free_sz>); if not, return 0.
    - Create a single-byte array `code` with the value obtained from `FD_HPACK_INDEXED_SHORT(idx)`.
    - Push the `code` array into the transmission buffer `rbuf_tx` using [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>).
    - Return 1 to indicate success.
- **Output**: Returns 1 if the header field is successfully encoded and pushed into the buffer, otherwise returns 0.
- **Functions Called**:
    - [`fd_h2_rbuf_free_sz`](<fd_h2_rbuf.h.md#fd_h2_rbuf_free_sz>)
    - [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>)


---
### fd\_hpack\_wr\_private\_name\_indexed\_0<!-- {{#callable:fd_hpack_wr_private_name_indexed_0}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L63>)

Encodes a header field with a specified key and value length into a buffer if there is enough space.
- **Inputs**:
    - ``rbuf_tx``: A pointer to a `fd_h2_rbuf_t` buffer where the encoded header field will be written.
    - ``key``: An unsigned long integer representing the key of the header field.
    - ``value_len``: An unsigned long integer representing the length of the value, which must be in the range [0, 128).
- **Logic and Control Flow**:
    - Initialize a `prefix` array with the first element set to the `key` value.
    - Check if the free space in `rbuf_tx` is less than the size of `prefix` plus `value_len`. If true, return 0 indicating failure.
    - Calculate `prefix_len` by adding 1 to the result of [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>), which encodes `value_len` into the `prefix` array starting at the second position.
    - Push the `prefix` array into `rbuf_tx` using [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>) with the calculated `prefix_len`.
    - Return 1 indicating success.
- **Output**: Returns 1 if the encoding is successful and 0 if there is not enough space in the buffer.
- **Functions Called**:
    - [`fd_h2_rbuf_free_sz`](<fd_h2_rbuf.h.md#fd_h2_rbuf_free_sz>)
    - [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>)
    - [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>)


---
### fd\_hpack\_wr\_method\_post<!-- {{#callable:fd_hpack_wr_method_post}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L76>)

Encodes the HTTP/2 POST method header using HPACK indexed representation.
- **Inputs**:
    - ``rbuf_tx``: A pointer to an `fd_h2_rbuf_t` structure, which is the buffer where the encoded header will be written.
- **Logic and Control Flow**:
    - Calls the [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>) function with `rbuf_tx` and the index `0x03` to encode the POST method header.
    - Returns the result of the [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>) function call, which indicates success or failure of the encoding operation.
- **Output**: Returns an integer indicating success (1) or failure (0) of writing the encoded POST method header to the buffer.
- **Functions Called**:
    - [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>)


---
### fd\_hpack\_wr\_scheme<!-- {{#callable:fd_hpack_wr_scheme}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L81>)

Determines the scheme (HTTP or HTTPS) for HPACK header serialization and writes it to the buffer.
- **Inputs**:
    - ``rbuf_tx``: A pointer to an `fd_h2_rbuf_t` structure, which represents the buffer where the HPACK header entry will be written.
    - ``is_https``: An integer flag indicating whether the scheme is HTTPS (non-zero value) or HTTP (zero value).
- **Logic and Control Flow**:
    - Checks if `is_https` is non-zero.
    - If `is_https` is non-zero, calls [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>) with `rbuf_tx` and index `0x07` to write the HTTPS scheme.
    - If `is_https` is zero, calls [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>) with `rbuf_tx` and index `0x06` to write the HTTP scheme.
- **Output**: Returns the result of the [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>) function, which is an integer indicating success (1) or failure (0) of writing to the buffer.
- **Functions Called**:
    - [`fd_hpack_wr_private_indexed`](<#fd_hpack_wr_private_indexed>)


---
### fd\_hpack\_wr\_path<!-- {{#callable:fd_hpack_wr_path}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L94>)

Writes a ':path:' header to the provided buffer.
- **Inputs**:
    - ``rbuf_tx``: A pointer to the `fd_h2_rbuf_t` buffer where the ':path:' header will be written.
    - ``path``: A constant character pointer to the path string to be written.
    - ``path_len``: An unsigned long integer representing the length of the path, which must be in the range [0,128).
- **Logic and Control Flow**:
    - Check if the function [`fd_hpack_wr_private_name_indexed_0`](<#fd_hpack_wr_private_name_indexed_0>) returns false when called with `rbuf_tx`, `0x04`, and `path_len`; if so, return 0.
    - Call [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>) to write the `path` to `rbuf_tx` with the specified `path_len`.
    - Return 1 to indicate success.
- **Output**: Returns an integer, 0 if the operation fails, or 1 if it succeeds.
- **Functions Called**:
    - [`fd_hpack_wr_private_name_indexed_0`](<#fd_hpack_wr_private_name_indexed_0>)
    - [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>)


---
### fd\_hpack\_wr\_trailers<!-- {{#callable:fd_hpack_wr_trailers}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L105>)

Writes the 'te: trailers' header to the provided buffer if there is enough space.
- **Inputs**:
    - ``rbuf_tx``: A pointer to an `fd_h2_rbuf_t` buffer where the 'te: trailers' header will be written.
- **Logic and Control Flow**:
    - Define a static character array `code` containing the serialized 'te: trailers' header.
    - Check if the free space in `rbuf_tx` is less than the size of `code` minus one; if true, return 0.
    - Push the `code` array into `rbuf_tx` using [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>).
    - Return 1 to indicate success.
- **Output**: Returns 1 if the header is successfully written to the buffer, otherwise returns 0 if there is insufficient space.
- **Functions Called**:
    - [`fd_h2_rbuf_free_sz`](<fd_h2_rbuf.h.md#fd_h2_rbuf_free_sz>)
    - [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>)


---
### fd\_hpack\_wr\_user\_agent<!-- {{#callable:fd_hpack_wr_user_agent}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L119>)

Writes a 'user-agent' header to the provided buffer using a private name indexed method.
- **Inputs**:
    - ``rbuf_tx``: A pointer to the `fd_h2_rbuf_t` buffer where the 'user-agent' header will be written.
    - ``user_agent_len``: The length of the 'user-agent' value, which must be in the range [0,128).
- **Logic and Control Flow**:
    - Calls [`fd_hpack_wr_private_name_indexed_0`](<#fd_hpack_wr_private_name_indexed_0>) with `rbuf_tx`, a key of `0x7a`, and `user_agent_len` as arguments.
    - Returns the result of the [`fd_hpack_wr_private_name_indexed_0`](<#fd_hpack_wr_private_name_indexed_0>) function call.
- **Output**: Returns an integer indicating success (1) or failure (0) of writing the 'user-agent' header to the buffer.
- **Functions Called**:
    - [`fd_hpack_wr_private_name_indexed_0`](<#fd_hpack_wr_private_name_indexed_0>)


---
### fd\_hpack\_wr\_auth\_bearer<!-- {{#callable:fd_hpack_wr_auth_bearer}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L128>)

Writes an 'authorization: Bearer xxx' header using a never-indexed literal to prevent compression attacks.
- **Inputs**:
    - ``rbuf_tx``: A pointer to the `fd_h2_rbuf_t` buffer where the header will be written.
    - ``auth_token``: A constant character pointer to the authorization token string.
    - ``auth_token_len``: The length of the authorization token.
- **Logic and Control Flow**:
    - Initialize a `prefix` array with specific values to start the header.
    - Calculate `value_len` as the sum of 7 and `auth_token_len`.
    - Check if the free size in `rbuf_tx` is less than the sum of `prefix` size and `value_len`; if true, return 0.
    - Calculate `prefix_len` by adding 2 to the result of [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>) with `prefix+2`, 0x00, 0x7f, and `value_len`.
    - Push `prefix` with `prefix_len` to `rbuf_tx`.
    - Push the string "Bearer " with length 7 to `rbuf_tx`.
    - Push `auth_token` with `auth_token_len` to `rbuf_tx`.
    - Return 1 to indicate success.
- **Output**: Returns 1 if the header is successfully written, otherwise returns 0 if there is insufficient space in `rbuf_tx`.
- **Functions Called**:
    - [`fd_h2_rbuf_free_sz`](<fd_h2_rbuf.h.md#fd_h2_rbuf_free_sz>)
    - [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>)
    - [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>)


---
### fd\_hpack\_wr\_authority<!-- {{#callable:fd_hpack_wr_authority}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack_wr.h#L145>)

Writes an ':authority: host[:port]' header to a buffer, including the port if it is non-zero.
- **Inputs**:
    - `rbuf_tx`: A pointer to the `fd_h2_rbuf_t` buffer where the header will be written.
    - `host`: A constant character pointer to the host string.
    - `host_len`: An unsigned long representing the length of the host string.
    - `port`: An unsigned short representing the port number, which is included in the header if non-zero.
- **Logic and Control Flow**:
    - Initialize a character array `suffix_cstr` to store the port as a string.
    - Calculate the length of the port string using `fd_ushort_base10_dig_cnt`.
    - Initialize the `suffix_cstr` and append a colon and the port number as text.
    - Calculate the length of the `suffix_cstr`.
    - Determine the total length of the header value by adding `host_len` and `suffix_len`.
    - Prepare a prefix array with an initial value of 0x01.
    - Check if there is enough space in `rbuf_tx` to store the prefix and the header value; return 0 if not.
    - Calculate the length of the prefix using [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>).
    - Push the prefix, host, and suffix to `rbuf_tx`.
    - Return 1 to indicate success.
- **Output**: Returns 1 if the header is successfully written to the buffer, otherwise returns 0 if there is insufficient space.
- **Functions Called**:
    - [`fd_h2_rbuf_free_sz`](<fd_h2_rbuf.h.md#fd_h2_rbuf_free_sz>)
    - [`fd_hpack_wr_varint`](<#fd_hpack_wr_varint>)
    - [`fd_h2_rbuf_push`](<fd_h2_rbuf.h.md#fd_h2_rbuf_push>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)