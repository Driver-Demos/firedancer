<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements HPACK header compression and decompression for HTTP/2, using static tables and Huffman coding.

# Purpose
The code is a C implementation of an HPACK decoder, which is used in HTTP/2 for header compression. It includes functions to initialize and process HPACK encoded data, specifically focusing on reading and decoding headers from a static table. The static table, `fd_hpack_static_table`, contains predefined HTTP/2 headers and their associated values, which are used to efficiently compress and decompress HTTP headers. The code provides functions such as [`fd_hpack_rd_init`](<#fd_hpack_rd_init>), [`fd_hpack_rd_indexed`](<#fd_hpack_rd_indexed>), and [`fd_hpack_rd_next`](<#fd_hpack_rd_next>) to handle the initialization of the decoder, selection of headers from the static table, and processing of the next header in the encoded data stream, respectively.

The code also includes mechanisms to handle Huffman decoding, which is a part of the HPACK compression strategy. The function [`fd_hpack_rd_next_raw`](<#fd_hpack_rd_next_raw>) processes raw HPACK instructions, while [`fd_hpack_rd_next`](<#fd_hpack_rd_next>) manages the decoding of headers, including Huffman-encoded names and values. The code uses several utility functions and macros, such as `fd_hpack_rd_varint` for reading variable-length integers and `nghttp2_hd_huff_decode` for Huffman decoding. The implementation is designed to handle different types of HPACK instructions, including those for indexed and literal headers, and provides error handling for compression errors.
# Imports and Dependencies

---
- `fd_hpack.h`
- `fd_h2_base.h`
- `fd_hpack_private.h`
- `nghttp2_hd_huffman.h`
- `../../util/log/fd_log.h`


# Global Variables

---
### fd\_hpack\_static\_table
- **Type**: ``fd_hpack_static_entry_t const[62]``
- **Description**: Represents a static table of HTTP/2 header fields used in HPACK compression. Each entry in the table is a `fd_hpack_static_entry_t` structure, which contains a header field name, its length, and a value length.
- **Use**: Used to provide quick access to common HTTP/2 header fields during HPACK compression and decompression.


# Functions

---
### fd\_hpack\_rd\_init<!-- {{#callable:fd_hpack_rd_init}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack.c#L72>)

Initializes an `fd_hpack_rd_t` structure and skips over dynamic table size updates in the source data.
- **Inputs**:
    - `rd`: A pointer to an `fd_hpack_rd_t` structure to initialize.
    - `src`: A pointer to the source data to read from.
    - `srcsz`: The size of the source data in bytes.
- **Logic and Control Flow**:
    - Assigns the `src` and `src_end` fields of the `rd` structure to point to the start and end of the source data, respectively.
    - Enters a loop to skip over dynamic table size updates in the source data.
    - In each iteration, checks if the current byte indicates a dynamic table size update by examining the top three bits.
    - If a dynamic table size update is detected, reads the size using [`fd_hpack_rd_varint`](<fd_hpack_private.h.md#fd_hpack_rd_varint>) and checks if it is non-zero to break the loop.
    - Increments the source pointer to skip the current byte if it is a dynamic table size update.
    - Exits the loop if no more dynamic table size updates are found or if the end of the source data is reached.
    - Returns the initialized `fd_hpack_rd_t` structure.
- **Output**: A pointer to the initialized `fd_hpack_rd_t` structure.
- **Functions Called**:
    - [`fd_hpack_rd_varint`](<fd_hpack_private.h.md#fd_hpack_rd_varint>)


---
### fd\_hpack\_rd\_indexed<!-- {{#callable:fd_hpack_rd_indexed}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack.c#L99>)

Selects a header from the HPACK static table based on an index and populates the header structure.
- **Inputs**:
    - ``hdr``: A pointer to an `fd_h2_hdr_t` structure where the function will store the selected header information.
    - ``idx``: An unsigned long integer representing the index of the header in the HPACK static table.
- **Logic and Control Flow**:
    - Check if `idx` is 0 or greater than 61; if true, return `FD_H2_ERR_COMPRESSION`.
    - Retrieve the entry from `fd_hpack_static_table` using `idx`.
    - Populate the `hdr` structure with the name, name length, value, value length, and hint from the retrieved entry.
    - Return `FD_H2_SUCCESS`.
- **Output**: Returns `FD_H2_SUCCESS` if the header is successfully retrieved and populated, otherwise returns `FD_H2_ERR_COMPRESSION` if the index is invalid.


---
### fd\_hpack\_rd\_next\_raw<!-- {{#callable:fd_hpack_rd_next_raw}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack.c#L114>)

Parses the next HPACK-encoded header from the source buffer and updates the header structure accordingly.
- **Inputs**:
    - ``rd``: A pointer to an `fd_hpack_rd_t` structure that contains the source buffer and its end.
    - ``hdr``: A pointer to an `fd_h2_hdr_t` structure where the parsed header information will be stored.
- **Logic and Control Flow**:
    - Check if the source pointer `rd->src` is out of bounds compared to `rd->src_end` and log a critical error if so.
    - Read the first byte `b0` from the source buffer and increment the source pointer.
    - If `b0` indicates a name and value indexed header, call [`fd_hpack_rd_indexed`](<#fd_hpack_rd_indexed>) to retrieve the header and set the value indexed hint.
    - If `b0` indicates a name and value literal header, read the name and value lengths using [`fd_hpack_rd_varint`](<fd_hpack_private.h.md#fd_hpack_rd_varint>), check for buffer overflows, and update the header structure with the name and value pointers and lengths.
    - If `b0` indicates a name indexed and value literal header, read the name index and value length, check for buffer overflows, retrieve the name using [`fd_hpack_rd_indexed`](<#fd_hpack_rd_indexed>), and update the header structure with the value pointer and length.
    - If `b0` indicates a name and value indexed header with an index greater than or equal to 128, read the index and call [`fd_hpack_rd_indexed`](<#fd_hpack_rd_indexed>) to retrieve the header.
    - Skip over any Dynamic Table Size Updates by checking for specific byte patterns and continue parsing.
    - Return an error if an unknown HPACK instruction is encountered.
- **Output**: Returns a `uint` indicating success (`FD_H2_SUCCESS`) or an error code (`FD_H2_ERR_COMPRESSION`) if parsing fails.
- **Functions Called**:
    - [`fd_hpack_rd_indexed`](<#fd_hpack_rd_indexed>)
    - [`fd_hpack_rd_varint`](<fd_hpack_private.h.md#fd_hpack_rd_varint>)


---
### fd\_hpack\_decoded\_sz\_max<!-- {{#callable:fd_hpack_decoded_sz_max}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack.c#L208>)

Calculates the maximum possible size of decoded data from a given encoded size using HPACK Huffman coding.
- **Inputs**:
    - `enc_sz`: The size of the encoded data in bytes.
- **Logic and Control Flow**:
    - Multiply the input `enc_sz` by 2 to calculate the maximum possible size of the decoded data.
- **Output**: Returns an unsigned long integer representing the maximum possible size of the decoded data.


---
### fd\_hpack\_rd\_next<!-- {{#callable:fd_hpack_rd_next}} -->
[View Source →](<../../../../../src/waltz/h2/fd_hpack.c#L213>)

Processes the next HPACK header field, decoding Huffman-encoded names and values if necessary.
- **Inputs**:
    - `hpack_rd`: A pointer to an `fd_hpack_rd_t` structure that represents the HPACK reader state.
    - `hdr`: A pointer to an `fd_h2_hdr_t` structure where the decoded header field will be stored.
    - `scratch`: A pointer to a pointer to a `uchar` buffer used for temporary storage during decoding.
    - `scratch_end`: A pointer to the end of the `scratch` buffer, used to ensure buffer boundaries are not exceeded.
- **Logic and Control Flow**:
    - Calls [`fd_hpack_rd_next_raw`](<#fd_hpack_rd_next_raw>) to process the next raw HPACK header field and checks for errors.
    - If the header name is Huffman-encoded, checks if there is enough space in the `scratch` buffer for the decoded name and decodes it using [`nghttp2_hd_huff_decode`](<nghttp2_hd_huffman.c.md#nghttp2_hd_huff_decode>).
    - Updates the `hdr->name` and `hdr->name_len` with the decoded name and advances the `scratch` pointer.
    - If the header value is Huffman-encoded, checks if there is enough space in the `scratch` buffer for the decoded value and decodes it using [`nghttp2_hd_huff_decode`](<nghttp2_hd_huffman.c.md#nghttp2_hd_huff_decode>).
    - Updates the `hdr->value` and `hdr->value_len` with the decoded value and advances the `scratch` pointer.
    - Updates the `scratch` pointer to the new position after decoding.
    - Clears the Huffman encoding hints from `hdr->hint`.
    - Returns `FD_H2_SUCCESS` if successful, or an error code if a failure occurs.
- **Output**: Returns `FD_H2_SUCCESS` on success or an error code if a failure occurs during processing.
- **Functions Called**:
    - [`fd_hpack_rd_next_raw`](<#fd_hpack_rd_next_raw>)
    - [`fd_hpack_decoded_sz_max`](<#fd_hpack_decoded_sz_max>)
    - [`nghttp2_hd_huff_decode_context_init`](<nghttp2_hd_huffman.c.md#nghttp2_hd_huff_decode_context_init>)
    - [`nghttp2_hd_huff_decode`](<nghttp2_hd_huffman.c.md#nghttp2_hd_huff_decode>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)