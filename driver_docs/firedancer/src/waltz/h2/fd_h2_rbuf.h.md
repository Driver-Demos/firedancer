<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

A byte-oriented unaligned ring buffer implementation with functions for initialization, data manipulation, and state checks.

# Purpose
The `fd_h2_rbuf.h` file defines a byte-oriented, unaligned ring buffer in C. This header file provides the structure and functions necessary to manage a ring buffer, which is a circular data structure that efficiently handles data streams. The primary structure, `fd_h2_rbuf`, contains pointers and offsets to manage the buffer's start, end, and current read/write positions. The buffer does not require alignment, making it flexible for various use cases.

The file includes several inline functions to initialize the buffer (`fd_h2_rbuf_init`), check the used and free space ([`fd_h2_rbuf_used_sz`](<#fd_h2_rbuf_used_sz>), [`fd_h2_rbuf_free_sz`](<#fd_h2_rbuf_free_sz>)), and manipulate the buffer's contents. Functions like [`fd_h2_rbuf_push`](<#fd_h2_rbuf_push>) and [`fd_h2_rbuf_pop`](<#fd_h2_rbuf_pop>) allow for appending and consuming data, respectively. The file also provides utility functions to peek at the buffer's used and free regions ([`fd_h2_rbuf_peek_used`](<#fd_h2_rbuf_peek_used>), [`fd_h2_rbuf_peek_free`](<#fd_h2_rbuf_peek_free>)) and to manage the buffer's state ([`fd_h2_rbuf_skip`](<#fd_h2_rbuf_skip>), [`fd_h2_rbuf_alloc`](<#fd_h2_rbuf_alloc>)). The header is designed to be included in other C files, providing a reusable component for managing circular buffers in applications.
# Imports and Dependencies

---
- `fd_h2_base.h`
- `../../util/log/fd_log.h`


# Data Structures

---
### fd\_h2\_rbuf
- **Type**: ``struct``
- **Members**:
    - ``buf0``: Points to the first byte of the buffer.
    - ``buf1``: Points one past the last byte of the buffer.
    - ``lo``: Points to a position within the buffer range [`buf0`, `buf1`).
    - ``hi``: Points to a position within the buffer range [`buf0`, `buf1`).
    - ``lo_off``: Represents the offset of the `lo` pointer from `buf0`.
    - ``hi_off``: Represents the offset of the `hi` pointer from `buf0`.
    - ``bufsz``: Stores the size of the buffer.
- **Description**: Defines a byte-oriented, unaligned ring buffer structure with pointers to manage the buffer's start, end, and current read/write positions, along with offsets and buffer size for efficient data handling.


# Functions

---
### fd\_h2\_rbuf\_used\_sz<!-- {{#callable:fd_h2_rbuf_used_sz}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L41>)

Calculates the number of unconsumed bytes in a ring buffer.
- **Inputs**:
    - `rbuf`: A pointer to a constant `fd_h2_rbuf_t` structure representing the ring buffer.
- **Logic and Control Flow**:
    - Subtracts the `lo_off` offset from the `hi_off` offset in the `rbuf` structure to determine the number of unconsumed bytes.
- **Output**: Returns an `ulong` representing the number of unconsumed bytes in the ring buffer.


---
### fd\_h2\_rbuf\_free\_sz<!-- {{#callable:fd_h2_rbuf_free_sz}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L49>)

Calculates the number of bytes available for appending in a ring buffer.
- **Inputs**:
    - `rbuf`: A pointer to a constant `fd_h2_rbuf_t` structure representing the ring buffer.
- **Logic and Control Flow**:
    - Call [`fd_h2_rbuf_used_sz`](<#fd_h2_rbuf_used_sz>) to get the number of used bytes in the buffer and store it in `used`.
    - Calculate the difference between the buffer's end pointer `buf1` and start pointer `buf0`, then subtract `used` from this difference.
    - Use `fd_long_max` to ensure the result is not negative, returning the maximum of 0 and the calculated difference.
- **Output**: Returns the number of bytes that can be appended to the ring buffer as an `ulong`.
- **Functions Called**:
    - [`fd_h2_rbuf_used_sz`](<#fd_h2_rbuf_used_sz>)


---
### fd\_h2\_rbuf\_push<!-- {{#callable:fd_h2_rbuf_push}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L61>)

Appends a chunk of data to a ring buffer, handling potential buffer wrap-around.
- **Inputs**:
    - ``rbuf``: A pointer to the `fd_h2_rbuf_t` structure representing the ring buffer.
    - ``chunk``: A pointer to the data to append to the ring buffer.
    - ``chunk_sz``: The size of the data chunk to append, in bytes.
- **Logic and Control Flow**:
    - Increment `rbuf->hi_off` by `chunk_sz` to update the high offset of the buffer.
    - Check if the current high pointer plus `chunk_sz` exceeds `rbuf->buf1`, indicating a wrap-around is needed.
    - If wrap-around is needed and `lo` is greater than `hi`, log a critical error for buffer overflow.
    - Calculate the parts of the chunk that fit before and after the buffer end, and copy them separately to handle wrap-around.
    - If no wrap-around is needed, perform a single copy of the chunk to the buffer.
    - Update `rbuf->hi` to point to the new high position, wrapping around to `buf0` if necessary.
- **Output**: None (the function modifies the ring buffer in place).


---
### fd\_h2\_rbuf\_peek\_used<!-- {{#callable:fd_h2_rbuf_peek_used}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L100>)

Returns a pointer to the first contiguous fragment of unconsumed data in a ring buffer and sets the sizes of contiguous and split data fragments.
- **Inputs**:
    - `rbuf`: A pointer to the `fd_h2_rbuf_t` structure representing the ring buffer.
    - `sz`: A pointer to an `ulong` where the function will store the size of the contiguous data fragment.
    - `split_sz`: A pointer to an `ulong` where the function will store the size of the split data fragment, if any.
- **Logic and Control Flow**:
    - Calculate the total used size in the buffer using [`fd_h2_rbuf_used_sz`](<#fd_h2_rbuf_used_sz>) function.
    - Determine the end of the used data by adding `used_sz` to `lo`.
    - Check if the end of the used data is within the buffer (`end <= buf1`).
    - If true, set `*sz` to the difference between `hi` and `lo`, and `*split_sz` to 0.
    - If false, set `*sz` to the difference between `buf1` and `lo`, and `*split_sz` to the difference between `hi` and `buf0`.
    - Return the pointer `lo` which points to the start of the contiguous data.
- **Output**: A pointer to the first byte of the contiguous fragment of unconsumed data in the ring buffer.
- **Functions Called**:
    - [`fd_h2_rbuf_used_sz`](<#fd_h2_rbuf_used_sz>)


---
### fd\_h2\_rbuf\_peek\_free<!-- {{#callable:fd_h2_rbuf_peek_free}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L124>)

Returns a pointer to the start of the free region in a ring buffer and calculates the size of contiguous and split free regions.
- **Inputs**:
    - `rbuf`: A pointer to the `fd_h2_rbuf_t` structure representing the ring buffer.
    - `sz`: A pointer to an `ulong` where the function will store the size of the contiguous free region.
    - `split_sz`: A pointer to an `ulong` where the function will store the size of the split free region, if any.
- **Logic and Control Flow**:
    - Calculate the total free size in the buffer using [`fd_h2_rbuf_free_sz`](<#fd_h2_rbuf_free_sz>) function.
    - Determine the end of the free region by adding the free size to the current high pointer `hi`.
    - Check if the end of the free region is within the buffer bounds (`end <= buf1`).
    - If true, set `sz` to the size of the contiguous free region from `hi` to `buf1` and `split_sz` to 0.
    - If false, set `sz` to the size from `hi` to `buf1` and `split_sz` to the size from `buf0` to `lo`.
    - Return the pointer `hi`, which is the start of the free region.
- **Output**: A pointer to the start of the free region in the ring buffer (`hi`).
- **Functions Called**:
    - [`fd_h2_rbuf_free_sz`](<#fd_h2_rbuf_free_sz>)


---
### fd\_h2\_rbuf\_skip<!-- {{#callable:fd_h2_rbuf_skip}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L148>)

Advances the read pointer of a ring buffer by a specified number of bytes, wrapping around if necessary.
- **Inputs**:
    - ``rbuf``: A pointer to an `fd_h2_rbuf_t` structure representing the ring buffer.
    - ``n``: The number of bytes to skip in the ring buffer.
- **Logic and Control Flow**:
    - Retrieve the current position of the read pointer `lo` and the buffer size `bufsz` from the `rbuf` structure.
    - Increment the `lo_off` field of `rbuf` by `n` to update the logical offset of the read pointer.
    - Advance the `lo` pointer by `n` bytes.
    - Check if the new `lo` pointer has reached or exceeded the end of the buffer (`buf1`).
    - If `lo` has exceeded `buf1`, wrap around by subtracting `bufsz` from `lo`.
    - Update the `lo` field of `rbuf` with the new position of the read pointer.
- **Output**: None. The function modifies the `rbuf` structure in place.


---
### fd\_h2\_rbuf\_alloc<!-- {{#callable:fd_h2_rbuf_alloc}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L164>)

Marks the next `n` free bytes in the ring buffer as used.
- **Inputs**:
    - `rbuf`: A pointer to the `fd_h2_rbuf_t` structure representing the ring buffer.
    - `n`: The number of bytes to mark as used in the ring buffer.
- **Logic and Control Flow**:
    - Increment `rbuf->hi_off` by `n` to update the offset of the high watermark.
    - Advance the `hi` pointer by `n` bytes.
    - Check if the `hi` pointer has reached or exceeded `buf1`, the end of the buffer.
    - If `hi` is beyond `buf1`, wrap around by subtracting `bufsz` from `hi`.
    - Update `rbuf->hi` with the new `hi` pointer value.
- **Output**: No return value; the function modifies the `rbuf` structure in place.


---
### fd\_h2\_rbuf\_pop<!-- {{#callable:fd_h2_rbuf_pop}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L186>)

Consumes a specified number of bytes from a ring buffer and returns a pointer to the data, using scratch memory if the data is not contiguous.
- **Inputs**:
    - `rbuf`: A pointer to the `fd_h2_rbuf_t` structure representing the ring buffer.
    - `scratch`: A pointer to a memory area with space for `n` bytes, used if the data is not contiguous.
    - `n`: The number of bytes to consume from the ring buffer.
- **Logic and Control Flow**:
    - Initialize `lo`, `buf0`, `buf1`, and `bufsz` from the `rbuf` structure.
    - Set `ret` to `lo` and increment `rbuf->lo_off` by `n`.
    - Calculate `end` as `lo + n`.
    - If `end` is greater than or equal to `buf1`, adjust `end` by subtracting `bufsz`.
    - If `end` is greater than `buf1`, copy the data in two parts: from `lo` to `buf1` into `scratch`, and from `buf0` to the remaining bytes into `scratch`. Set `ret` to `scratch`.
    - Update `rbuf->lo` to `end`.
- **Output**: Returns a pointer to the consumed bytes, either directly from the buffer or from the `scratch` memory if the data was not contiguous.


---
### fd\_h2\_rbuf\_pop\_copy<!-- {{#callable:fd_h2_rbuf_pop_copy}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L211>)

Copies and removes a specified number of bytes from a ring buffer to an output location.
- **Inputs**:
    - ``rbuf``: A pointer to the `fd_h2_rbuf_t` structure representing the ring buffer.
    - ``out``: A pointer to the destination buffer where the bytes will be copied.
    - ``n``: The number of bytes to copy from the ring buffer.
- **Logic and Control Flow**:
    - Calculate the new position `end` by adding `n` to the current `lo` pointer of the ring buffer.
    - If the new position `end` is greater than or equal to `buf1`, adjust `end` by subtracting `bufsz` to wrap around the buffer.
    - If the new position `end` is greater than `buf1`, split the copy operation into two parts: copy the first part from `lo` to `buf1`, and the second part from `buf0` to the remaining bytes.
    - If the new position `end` is not greater than `buf1`, perform a single copy operation from `lo` to `out`.
    - Update the `lo` pointer of the ring buffer to the new position `end`.
- **Output**: No return value; the function modifies the `rbuf` structure and copies data to the `out` buffer.


---
### fd\_h2\_rbuf\_is\_empty<!-- {{#callable:fd_h2_rbuf_is_empty}} -->
[View Source →](<../../../../../src/waltz/h2/fd_h2_rbuf.h#L235>)

Checks if the ring buffer is empty by comparing the low and high offsets.
- **Inputs**:
    - `rbuf`: A pointer to a constant `fd_h2_rbuf_t` structure representing the ring buffer.
- **Logic and Control Flow**:
    - Compare `rbuf->lo_off` with `rbuf->hi_off`.
    - Return 1 if they are equal, indicating the buffer is empty.
    - Return 0 if they are not equal, indicating the buffer is not empty.
- **Output**: An integer value, 1 if the buffer is empty, 0 otherwise.



---
Made with ❤️ by [Driver](https://www.driver.ai/)