<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Concurrent lock-free double buffer implementation for single producer and multiple consumer threads.

# Purpose
The `fd_dbl_buf.h` file defines a concurrent lock-free double buffer system. This system is designed to facilitate communication between a single producer thread and multiple consumer threads. The double buffer alternates between two buffers, allowing one to hold a message for consumers while the other receives a new message from the producer. This design is optimized for scenarios where updates are infrequent, but polling by consumers is frequent, such as configuration updates. The implementation assumes a memory model that maintains store order across threads, such as x86-TSO, and does not use atomic operations or hardware fences.

The file defines the `fd_dbl_buf_t` type, which is a union that includes both a standard structure and an SSE-optimized structure for systems that support SSE. It provides several functions for managing the double buffer, including [`fd_dbl_buf_new`](<#fd_dbl_buf_new>) for initializing a buffer, [`fd_dbl_buf_insert`](<#fd_dbl_buf_insert>) for adding messages, and [`fd_dbl_buf_try_read`](<#fd_dbl_buf_try_read>) for attempting to read the most recent message. The file also includes macros for alignment and footprint calculations, ensuring that the memory layout is consistent and efficient. The double buffer system is intended for use in environments where the memory region is shared, and it provides functions to join, leave, and delete the buffer, managing the lifecycle of the shared memory region.
# Imports and Dependencies

---
- `../../util/bits/fd_bits.h`
- `../../util/log/fd_log.h`
- `emmintrin.h`


# Data Structures

---
### fd\_dbl\_buf
- **Type**: ``union``
- **Members**:
    - ``magic``: Stores a magic number to identify the double buffer.
    - ``mtu``: Specifies the maximum transmission unit or largest possible message size.
    - ``buf0``: Offset to the first buffer from the beginning of the struct.
    - ``buf1``: Offset to the second buffer from the beginning of the struct.
    - ``seq``: Holds the latest message sequence number.
    - ``sz``: Indicates the size of the latest message.
    - ``pad``: Padding to align the structure.
    - ``magic_mtu``: SSE optimized storage for `magic` and `mtu`.
    - ``buf0_buf1``: SSE optimized storage for `buf0` and `buf1`.
    - ``seq_sz``: SSE optimized storage for `seq` and `sz`.
    - ``pad2``: SSE optimized padding.
- **Description**: A `union` that provides a concurrent lock-free double buffer, which contains two buffers that alternate between holding a message for consumers and receiving a new message from a producer. It supports a single producer thread and multiple consumer threads, optimized for rare updates and frequent polling. The structure includes fields for buffer offsets, message sequence number, and size, with optional SSE optimized fields for enhanced performance.


---
### fd\_dbl\_buf\_t
- **Type**: `union`
- **Members**:
    - `magic`: Holds a magic number to identify the double buffer.
    - `mtu`: Specifies the maximum transmission unit or largest possible message size.
    - `buf0`: Offset to the first buffer from the beginning of the structure.
    - `buf1`: Offset to the second buffer from the beginning of the structure.
    - `seq`: Stores the latest message sequence number.
    - `sz`: Indicates the size of the latest message.
    - `pad`: Padding to align the structure.
    - `magic_mtu`: SSE optimized storage for magic and mtu.
    - `buf0_buf1`: SSE optimized storage for buf0 and buf1.
    - `seq_sz`: SSE optimized storage for seq and sz.
    - `pad2`: SSE optimized padding.
- **Description**: Provides a concurrent lock-free double buffer that supports a single producer thread and multiple consumer threads, optimized for rare updates and frequent polling. It contains two buffers that alternate roles between holding a message for consumers and receiving a new message from a producer. The structure assumes a memory model that preserves store order across threads and does not use atomics or hardware fences.


# Functions

---
### fd\_dbl\_buf\_obj\_mtu<!-- {{#callable:fd_dbl_buf_obj_mtu}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L96>)

Retrieves the maximum message size that a double buffer can store.
- **Inputs**:
    - `buf`: A pointer to an `fd_dbl_buf_t` structure representing the double buffer.
- **Logic and Control Flow**:
    - Accesses the `mtu` field of the `fd_dbl_buf_t` structure pointed to by `buf`.
    - Returns the value of the `mtu` field.
- **Output**: The function returns an `ulong` representing the maximum message size (`mtu`) that the double buffer can store.


---
### fd\_dbl\_buf\_seq\_query<!-- {{#callable:fd_dbl_buf_seq_query}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L103>)

Retrieves the current sequence number from a double buffer.
- **Inputs**:
    - `buf`: A pointer to an `fd_dbl_buf_t` structure representing the double buffer from which to query the sequence number.
- **Logic and Control Flow**:
    - Execute a memory fence operation using `FD_COMPILER_MFENCE()` to ensure memory ordering before accessing the sequence number.
    - Read the sequence number from the `seq` field of the `fd_dbl_buf_t` structure using `FD_VOLATILE_CONST` to prevent compiler optimizations that could reorder operations.
    - Execute another memory fence operation using `FD_COMPILER_MFENCE()` to ensure memory ordering after accessing the sequence number.
    - Return the retrieved sequence number.
- **Output**: The function returns the current sequence number as an `ulong` from the specified double buffer.


---
### fd\_dbl\_buf\_slot<!-- {{#callable:fd_dbl_buf_slot}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L114>)

Returns a pointer to the appropriate buffer based on the sequence number.
- **Inputs**:
    - ``buf``: A pointer to an `fd_dbl_buf_t` structure representing the double buffer.
    - ``seq``: An unsigned long integer representing the sequence number to determine which buffer to access.
- **Logic and Control Flow**:
    - Check if the least significant bit of `seq` is 1.
    - If true, return a pointer to the buffer at offset `buf->buf1` from the start of `buf`.
    - If false, return a pointer to the buffer at offset `buf->buf0` from the start of `buf`.
- **Output**: A pointer to the buffer corresponding to the given sequence number.


---
### fd\_dbl\_buf\_try\_read<!-- {{#callable:fd_dbl_buf_try_read}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L144>)

Attempts to read the most recent message from a double buffer, handling potential overruns.
- **Inputs**:
    - ``buf``: A pointer to the `fd_dbl_buf_t` structure representing the double buffer.
    - ``out``: A pointer to the buffer where the message will be copied.
    - ``out_sz``: The size of the output buffer `out`.
    - ``opt_seqp``: An optional pointer to a `ulong` where the sequence number of the message will be stored, or `NULL` if not needed.
- **Logic and Control Flow**:
    - Query the current sequence number from the double buffer using [`fd_dbl_buf_seq_query`](<#fd_dbl_buf_seq_query>).
    - Determine the source buffer for the current sequence using [`fd_dbl_buf_slot`](<#fd_dbl_buf_slot>).
    - Retrieve the size of the current message from the double buffer.
    - Check if the output buffer size `out_sz` is smaller than the message size `sz`; if so, log an error and terminate.
    - Copy the message from the source buffer to the output buffer using `fd_memcpy`.
    - Re-query the sequence number to check for overruns; if the sequence number has changed, return `ULONG_MAX`.
    - If `opt_seqp` is not `NULL`, store the sequence number in `opt_seqp`.
    - Return the size of the message read.
- **Output**: Returns the size of the message read on success, or `ULONG_MAX` if an overrun occurred.
- **Functions Called**:
    - [`fd_dbl_buf_seq_query`](<#fd_dbl_buf_seq_query>)
    - [`fd_dbl_buf_slot`](<#fd_dbl_buf_slot>)


# Function Declarations (Public API)

---
### fd\_dbl\_buf\_align<!-- {{#callable_declaration:fd_dbl_buf_align}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L61>)

Returns the alignment requirement for a double buffer.
- **Description**: Use this function to obtain the alignment requirement for a double buffer when working with the concurrent lock-free double buffer system. This alignment value is necessary to ensure that memory regions used for double buffers are correctly aligned, which is important for performance and correctness in concurrent environments. This function does not require any parameters and can be called at any time to retrieve the alignment value.
- **Inputs**: None
- **Output**: Returns an unsigned long integer representing the alignment requirement for a double buffer.
- **See Also**: [`fd_dbl_buf_align`](<fd_dbl_buf.c.md#fd_dbl_buf_align>)  (Implementation)


---
### fd\_dbl\_buf\_footprint<!-- {{#callable_declaration:fd_dbl_buf_footprint}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L69>)

Calculates the memory footprint required for a double buffer with a given MTU.
- **Description**: Use this function to determine the amount of memory needed to allocate a double buffer that can handle messages up to a specified maximum transmission unit (MTU) size. This is useful for ensuring that sufficient memory is allocated for the double buffer before initializing it. The function is thread-safe and can be called at any time.
- **Inputs**:
    - `mtu`: Specifies the maximum size of a message that the double buffer can store. Must be a positive integer. If an invalid value is provided, the behavior is undefined.
- **Output**: Returns the size in bytes of the memory footprint required for the double buffer.
- **See Also**: [`fd_dbl_buf_footprint`](<fd_dbl_buf.c.md#fd_dbl_buf_footprint>)  (Implementation)


---
### fd\_dbl\_buf\_new<!-- {{#callable_declaration:fd_dbl_buf_new}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L77>)

Formats a memory region for use as a double buffer.
- **Description**: Use this function to initialize a memory region as a double buffer, which supports a single producer and multiple consumers. The function requires a memory region that matches the alignment and footprint specifications of the double buffer. The sequence number of the active object in the buffer is initialized to `seq0`, and its size is set to zero. Ensure that the memory region is properly aligned and not null before calling this function.
- **Inputs**:
    - `shmem`: Pointer to the memory region to format as a double buffer. Must not be null and must be aligned according to `FD_DBL_BUF_ALIGN`. If invalid, the function returns null.
    - `mtu`: The maximum transmission unit, representing the largest possible message size. It is aligned internally to `FD_DBL_BUF_ALIGN`.
    - `seq0`: Initial sequence number for the active object in the double buffer. It is used to track the order of messages.
- **Output**: Returns a pointer to the formatted double buffer on success, or null if the input memory region is invalid.
- **See Also**: [`fd_dbl_buf_new`](<fd_dbl_buf.c.md#fd_dbl_buf_new>)  (Implementation)


---
### fd\_dbl\_buf\_join<!-- {{#callable_declaration:fd_dbl_buf_join}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L82>)

Joins a shared memory region as a double buffer.
- **Description**: Use this function to join a shared memory region that has been formatted as a double buffer. This function checks if the provided memory region is valid and properly aligned. It also verifies that the memory region has the correct magic number, indicating it is a valid double buffer. If any of these checks fail, the function returns `NULL`. Ensure that the memory region is aligned to `FD_DBL_BUF_ALIGN` and has been initialized with the correct magic number before calling this function.
- **Inputs**:
    - `shbuf`: A pointer to the shared memory region to join as a double buffer. Must not be null. The memory region must be aligned to `FD_DBL_BUF_ALIGN` and contain the correct magic number `FD_DBL_BUF_MAGIC`. If these conditions are not met, the function returns `NULL`.
- **Output**: Returns a pointer to the `fd_dbl_buf_t` structure if successful, or `NULL` if the input is invalid or the memory region is not properly formatted.
- **See Also**: [`fd_dbl_buf_join`](<fd_dbl_buf.c.md#fd_dbl_buf_join>)  (Implementation)


---
### fd\_dbl\_buf\_leave<!-- {{#callable_declaration:fd_dbl_buf_leave}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L85>)

Releases a double buffer from use.
- **Description**: Use this function to release a double buffer when it is no longer needed. This function should be called to leave a double buffer that was previously joined. It is important to ensure that no other operations are performed on the buffer after calling this function, as it indicates that the buffer is no longer in use.
- **Inputs**:
    - `buf`: A pointer to the `fd_dbl_buf_t` structure representing the double buffer to release. Must not be null. The caller retains ownership of the memory.
- **Output**: Returns the same pointer that was passed in, indicating the buffer has been released.
- **See Also**: [`fd_dbl_buf_leave`](<fd_dbl_buf.c.md#fd_dbl_buf_leave>)  (Implementation)


---
### fd\_dbl\_buf\_delete<!-- {{#callable_declaration:fd_dbl_buf_delete}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L91>)

Unformats a double buffer and releases ownership.
- **Description**: Use this function to unformat a memory region that was previously formatted as a double buffer and to release its ownership back to the caller. This function should be called when the double buffer is no longer needed, and the memory region is to be reused or freed. The function requires that the input pointer is not null and is aligned according to `FD_DBL_BUF_ALIGN`. If these conditions are not met, the function logs a warning and returns null.
- **Inputs**:
    - `shbuf`: A pointer to the memory region that backs the double buffer. Must not be null and must be aligned to `FD_DBL_BUF_ALIGN`. If the pointer is null or misaligned, the function logs a warning and returns null.
- **Output**: Returns the input pointer `shbuf` if successful, or null if the input is invalid.
- **See Also**: [`fd_dbl_buf_delete`](<fd_dbl_buf.c.md#fd_dbl_buf_delete>)  (Implementation)


---
### fd\_dbl\_buf\_insert<!-- {{#callable_declaration:fd_dbl_buf_insert}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L124>)

Appends a message to the double buffer.
- **Description**: Use this function to add a new message to the double buffer. It is designed for a single producer thread and is not safe for concurrent use by multiple threads. The function ensures that the message size does not exceed the maximum transmission unit (MTU) of the buffer. It updates the sequence number and stores the message in the appropriate buffer slot. This function is suitable for scenarios where updates are infrequent, and the system architecture supports a memory model that preserves store order across threads.
- **Inputs**:
    - `buf`: A pointer to an `fd_dbl_buf_t` structure representing the double buffer. Must not be null. The caller retains ownership.
    - `msg`: A pointer to the message data to append. Must not be null. The caller retains ownership.
    - `sz`: The size of the message in bytes. The function clamps this value to the buffer's MTU if it exceeds it.
- **Output**: None
- **See Also**: [`fd_dbl_buf_insert`](<fd_dbl_buf.c.md#fd_dbl_buf_insert>)  (Implementation)


---
### fd\_dbl\_buf\_read<!-- {{#callable_declaration:fd_dbl_buf_read}} -->
[View Source →](<../../../../../src/waltz/mib/fd_dbl_buf.h#L161>)

Reads the most recent message from a double buffer.
- **Description**: Use this function to read the most recent message from a double buffer in a thread-safe manner. It is designed for scenarios where a single producer thread writes messages and multiple consumer threads read them. The function blocks until a successful read occurs, ensuring that the message is not overrun by a writer. This function is suitable for applications where updates are rare, but polling is frequent. Ensure that the buffer has been properly initialized and joined before calling this function.
- **Inputs**:
    - `buf`: A pointer to an `fd_dbl_buf_t` structure representing the double buffer. Must not be null and must point to a valid, initialized double buffer.
    - `buf_sz`: The size of the buffer pointed to by `obj`. Must be large enough to hold the message; otherwise, the function will log an error and terminate.
    - `obj`: A pointer to a buffer where the message will be copied. Must not be null and must have at least `buf_sz` bytes available.
    - `opt_seqp`: An optional pointer to a `ulong` where the sequence number of the message will be stored. Can be null if the sequence number is not needed.
- **Output**: Returns the size of the message read. If the read is successful, the message is copied to `obj`, and if `opt_seqp` is not null, the sequence number is stored there.
- **See Also**: [`fd_dbl_buf_read`](<fd_dbl_buf.c.md#fd_dbl_buf_read>)  (Implementation)



---
Made with ❤️ by [Driver](https://www.driver.ai/)