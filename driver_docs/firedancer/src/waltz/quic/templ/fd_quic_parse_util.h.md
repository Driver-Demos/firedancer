<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Utility functions for encoding and decoding QUIC variable-length integers and packet headers.

# Purpose
The code is a C header file that provides utility functions for parsing and encoding QUIC (Quick UDP Internet Connections) protocol data. It includes functions for handling QUIC variable-length integers (varints), which are used in the protocol to efficiently encode integer values. The functions [`fd_quic_varint_min_sz_unsafe`](<#fd_quic_varint_min_sz_unsafe>), [`fd_quic_varint_min_sz`](<#fd_quic_varint_min_sz>), and [`fd_quic_varint_encode`](<#fd_quic_varint_encode>) are used to determine the minimum size of a varint and to encode a given integer into a varint format. The macro `FD_QUIC_ENCODE_VARINT` is provided to encode a varint into a buffer, updating the buffer pointer and size accordingly.

Additionally, the file contains functions for extracting and manipulating specific bits and fields from QUIC packet headers. These include functions like [`fd_quic_h0_hdr_form`](<#fd_quic_h0_hdr_form>), [`fd_quic_h0_long_packet_type`](<#fd_quic_h0_long_packet_type>), and [`fd_quic_h0_pkt_num_len`](<#fd_quic_h0_pkt_num_len>), which are used to interpret the header form, long packet type, and packet number length from a QUIC packet header. The file also includes functions for constructing initial, handshake, and one-RTT packet headers, as well as decoding packet numbers and varints. The code is intended to be used as part of a larger QUIC implementation, providing low-level utilities for handling QUIC protocol specifics.
# Imports and Dependencies

---
- `stddef.h`
- `../fd_quic_common.h`
- `../../../util/bits/fd_bits.h`


# Functions

---
### fd\_quic\_varint\_min\_sz\_unsafe<!-- {{#callable:fd_quic_varint_min_sz_unsafe}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L9>)

Calculates the minimum size in bytes required to encode a given unsigned long integer as a QUIC variable-length integer.
- **Inputs**:
    - `val`: An unsigned long integer representing the value to encode as a QUIC variable-length integer.
- **Logic and Control Flow**:
    - Finds the most significant bit (MSB) of the value `val` ORed with `0x3fUL` using `fd_ulong_find_msb`.
    - Casts the result to an unsigned integer and adds 2.
    - Finds the MSB of the resulting value using `fd_uint_find_msb`.
    - Subtracts 2 from the MSB to determine the size class.
    - Calculates the minimum size by left-shifting 1 by the size class.
- **Output**: Returns an unsigned integer representing the minimum number of bytes needed to encode the input value as a QUIC variable-length integer.


---
### fd\_quic\_varint\_min\_sz<!-- {{#callable:fd_quic_varint_min_sz}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L15>)

Calculates the minimum size in bytes required to encode a QUIC variable-length integer.
- **Inputs**:
    - `val`: An unsigned long integer representing the value to encode as a QUIC variable-length integer.
- **Logic and Control Flow**:
    - Calls `fd_ulong_min` to ensure `val` does not exceed the maximum allowed value of `0x3fffffffffffffffUL`.
    - Passes the result to [`fd_quic_varint_min_sz_unsafe`](<#fd_quic_varint_min_sz_unsafe>) to determine the minimum size in bytes for encoding.
- **Output**: Returns an unsigned integer representing the minimum number of bytes needed to encode the given value as a QUIC variable-length integer.
- **Functions Called**:
    - [`fd_quic_varint_min_sz_unsafe`](<#fd_quic_varint_min_sz_unsafe>)


---
### fd\_quic\_varint\_encode<!-- {{#callable:fd_quic_varint_encode}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L20>)

Encodes a variable-length integer into an 8-byte array using QUIC encoding rules.
- **Inputs**:
    - `out`: An array of 8 unsigned characters where the encoded variable-length integer will be stored.
    - `val`: An unsigned long integer value to encode, with a maximum value of 0x3fffffffffffffffUL.
- **Logic and Control Flow**:
    - Limit `val` to a maximum of 0x3fffffffffffffffUL using `fd_ulong_min` function.
    - Determine the minimum size `sz` required to encode `val` using [`fd_quic_varint_min_sz_unsafe`](<#fd_quic_varint_min_sz_unsafe>).
    - Shift `val` left by the number of bytes needed to align it to the rightmost position in an 8-byte array.
    - Swap the byte order of the shifted value using `fd_ulong_bswap` to prepare it for storage.
    - Clear the two most significant bits of the encoded value and set them to indicate the length of the encoded integer.
    - Store the encoded value in the `out` array using `FD_STORE`.
    - Return the size `sz` of the encoded integer.
- **Output**: Returns the size of the encoded integer in bytes as an unsigned integer.
- **Functions Called**:
    - [`fd_quic_varint_min_sz_unsafe`](<#fd_quic_varint_min_sz_unsafe>)


---
### fd\_quic\_h0\_hdr\_form<!-- {{#callable:fd_quic_h0_hdr_form}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L76>)

Extracts the 'Header Form' bit from a QUIC v1 packet header to determine if it is a long or short header packet.
- **Inputs**:
    - `hdr`: An unsigned character representing the first byte of a QUIC v1 packet header.
- **Logic and Control Flow**:
    - Shift the input `hdr` 7 bits to the right.
    - Return the result of the shift operation.
- **Output**: An unsigned character that is 1 if the packet is a long header packet, or 0 if it is a short header packet.


---
### fd\_quic\_h0\_long\_packet\_type<!-- {{#callable:fd_quic_h0_long_packet_type}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L84>)

Extracts the 'Long Packet Type' from the first byte of a QUIC v1 long header packet.
- **Inputs**:
    - `hdr`: An unsigned character representing the first byte of a QUIC v1 long header packet.
- **Logic and Control Flow**:
    - Shift the input `hdr` 4 bits to the right.
    - Apply a bitwise AND operation with the value 3 to extract the 'Long Packet Type'.
- **Output**: An unsigned character representing the 'Long Packet Type', which is a value in the range [0, 3].


---
### fd\_quic\_h0\_pkt\_num\_len<!-- {{#callable:fd_quic_h0_pkt_num_len}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L89>)

Extracts the packet number length from the first byte of a QUIC packet header.
- **Inputs**:
    - `h0`: An unsigned integer representing the first byte of a QUIC packet header.
- **Logic and Control Flow**:
    - Perform a bitwise AND operation between `h0` and `0x03` to isolate the last two bits of `h0`.
    - Cast the result to an unsigned character (`uchar`) and return it.
- **Output**: An unsigned character representing the packet number length, which is the value of the last two bits of `h0`.


---
### fd\_quic\_initial\_h0<!-- {{#callable:fd_quic_initial_h0}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L94>)

Generates the initial header byte for a QUIC packet with a specified packet number length.
- **Inputs**:
    - `pkt_num_len`: An unsigned integer representing the packet number length, which must be in the range [0,3].
- **Logic and Control Flow**:
    - Takes the input `pkt_num_len` and performs a bitwise OR operation with the constant `0xc0`.
    - Casts the result of the bitwise operation to an `uchar` type.
- **Output**: Returns an `uchar` that represents the initial header byte for a QUIC packet.


---
### fd\_quic\_handshake\_h0<!-- {{#callable:fd_quic_handshake_h0}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L99>)

Generates a QUIC handshake header byte by combining a fixed bit pattern with a packet number length.
- **Inputs**:
    - `pkt_num_len`: An unsigned integer representing the packet number length, which must be in the range [0,3].
- **Logic and Control Flow**:
    - Combine the fixed bit pattern `0xe0` with the `pkt_num_len` using a bitwise OR operation.
    - Cast the result to an unsigned character (`uchar`).
- **Output**: Returns an unsigned character (`uchar`) representing the handshake header byte.


---
### fd\_quic\_one\_rtt\_h0<!-- {{#callable:fd_quic_one_rtt_h0}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L104>)

Encodes the first byte of a QUIC 1-RTT packet header using the spin bit, key phase, and packet number length.
- **Inputs**:
    - `spin_bit`: A bit value (0 or 1) that indicates the spin bit.
    - `key_phase`: A bit value (0 or 1) that indicates the key phase.
    - `pkt_num_len`: An integer value (0 to 3) that indicates the packet number length.
- **Logic and Control Flow**:
    - Combine the constant value `0x40` with the `spin_bit` shifted left by 5 bits.
    - Combine the result with the `key_phase` shifted left by 2 bits.
    - Combine the result with the `pkt_num_len`.
    - Return the final combined value as an unsigned character.
- **Output**: Returns an unsigned character representing the encoded first byte of a QUIC 1-RTT packet header.


---
### fd\_quic\_one\_rtt\_spin\_bit<!-- {{#callable:fd_quic_one_rtt_spin_bit}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L111>)

Extracts the spin bit from a QUIC packet's header byte.
- **Inputs**:
    - `h0`: The header byte of a QUIC packet from which to extract the spin bit.
- **Logic and Control Flow**:
    - Shift the input `h0` right by 5 bits to position the spin bit as the least significant bit.
    - Perform a bitwise AND operation with 1 to isolate the spin bit.
    - Return the result as an unsigned integer.
- **Output**: The function returns the extracted spin bit as an unsigned integer.


---
### fd\_quic\_one\_rtt\_key\_phase<!-- {{#callable:fd_quic_one_rtt_key_phase}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L116>)

Extracts the key phase bit from a QUIC packet's header byte.
- **Inputs**:
    - `h0`: An unsigned integer representing the header byte of a QUIC packet.
- **Logic and Control Flow**:
    - Shift the input `h0` right by 2 bits.
    - Perform a bitwise AND operation with 1 to isolate the key phase bit.
    - Return the result as an unsigned integer.
- **Output**: An unsigned integer representing the key phase bit (either 0 or 1) from the header byte.


---
### fd\_quic\_stream\_type<!-- {{#callable:fd_quic_stream_type}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L121>)

Calculates the stream type for a QUIC stream based on offset, length, and finish flags.
- **Inputs**:
    - `has_off`: A `uint` indicating if the stream has an offset (1 if true, 0 if false).
    - `has_len`: A `uint` indicating if the stream has a length (1 if true, 0 if false).
    - `fin`: A `uint` indicating if the stream is finished (1 if true, 0 if false).
- **Logic and Control Flow**:
    - Shift `has_off` left by 2 bits.
    - Shift `has_len` left by 1 bit.
    - Add the shifted values and `fin` to the base value `0x08`.
    - Cast the result to `uchar` and return it.
- **Output**: Returns a `uchar` representing the stream type.


---
### fd\_quic\_varint\_decode<!-- {{#callable:fd_quic_varint_decode}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L128>)

Decodes a QUIC variable-length integer from a buffer based on the most significant bits.
- **Inputs**:
    - ``buf``: A pointer to an array of unsigned characters (`uchar const *`) that contains the encoded variable-length integer.
    - ``msb2``: An unsigned integer (`uint`) representing the two most significant bits of the first byte, which determines the length of the encoded integer.
- **Logic and Control Flow**:
    - Check the value of `msb2` to determine the size of the encoded integer.
    - If `msb2` is 3, load 8 bytes from `buf`, swap the byte order, and mask with `0x3fffffffffffffff`.
    - If `msb2` is 2, load 4 bytes from `buf`, swap the byte order, and mask with `0x3fffffff`.
    - If `msb2` is 1, load 2 bytes from `buf`, swap the byte order, and mask with `0x3fff`.
    - If `msb2` is 0, read the first byte from `buf` and mask with `0x3f`.
    - If `msb2` is not 0, 1, 2, or 3, the code is unreachable.
- **Output**: Returns the decoded unsigned long integer (`ulong`).


---
### fd\_quic\_pktnum\_decode<!-- {{#callable:fd_quic_pktnum_decode}} -->
[View Source →](<../../../../../../src/waltz/quic/templ/fd_quic_parse_util.h#L145>)

Decodes a QUIC packet number from a buffer of specified size into a 32-bit unsigned integer.
- **Inputs**:
    - ``buf``: A pointer to an array of unsigned characters (`uchar`) that contains the encoded packet number.
    - ``sz``: An unsigned long integer (`ulong`) that specifies the size of the packet number in bytes, ranging from 1 to 4.
- **Logic and Control Flow**:
    - Initialize a `scratch` array of 4 `uchar` elements to zero.
    - Initialize a counter `n` to zero.
    - Use a switch statement to handle different sizes (`sz`) of the packet number.
    - For each case from 4 to 1, copy the corresponding byte from `buf` to the `scratch` array, incrementing `n` after each copy.
    - Use the `FD_LOAD` macro to load the 32-bit unsigned integer from the `scratch` array and return it.
- **Output**: Returns a 32-bit unsigned integer (`ulong`) representing the decoded packet number.



---
Made with ❤️ by [Driver](https://www.driver.ai/)