<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements functions for generating and managing QUIC acknowledgment frames and ranges.

# Purpose
The code is part of a QUIC (Quick UDP Internet Connections) protocol implementation, specifically handling the generation and management of acknowledgment (ACK) frames. It includes functions to manage ACK ranges, extend them, and generate ACK frames for transmission. The code is structured to efficiently handle packet acknowledgment by merging packet numbers into existing ACK ranges when possible, thus optimizing the number of ACK frames sent. The function [`fd_quic_ack_pkt`](<#fd_quic_ack_pkt>) is responsible for determining if a packet number can be merged into an existing ACK range or if a new ACK entry must be created. It also manages the queue of ACKs, ensuring that the queue does not overflow.

The code also includes functions like [`fd_quic_ack_gen_abandon_enc_level`](<#fd_quic_ack_gen_abandon_enc_level>) to discard ACKs for a specific encryption level and [`fd_quic_gen_ack_frames`](<#fd_quic_gen_ack_frames>) to generate ACK frames for transmission. The latter function ensures that ACK frames are only generated when necessary, preventing unnecessary network traffic. The code uses several helper functions and macros, such as [`fd_quic_range_can_extend`](<#fd_quic_range_can_extend>) and [`fd_quic_range_extend`](<#fd_quic_range_extend>), to manage the ACK ranges efficiently. The inclusion of header files like `fd_quic_ack_tx.h` and `fd_quic_private.h` suggests that this code is part of a larger library or application, providing specific functionality related to the QUIC protocol's acknowledgment process.
# Imports and Dependencies

---
- `fd_quic_ack_tx.h`
- `fd_quic_private.h`
- `fd_quic_proto.h`
- `fd_quic_proto.c`


# Functions

---
### fd\_quic\_range\_can\_extend<!-- {{#callable:fd_quic_range_can_extend}} -->
[View Source →](<../../../../../src/waltz/quic/fd_quic_ack_tx.c#L7>)

Checks if a given index can extend the range defined by `offset_lo` and `offset_hi` in a `fd_quic_range_t` structure.
- **Inputs**:
    - `range`: A pointer to a `fd_quic_range_t` structure that contains `offset_lo` and `offset_hi` values defining a range.
    - `idx`: An unsigned long integer representing the index to check against the range.
- **Logic and Control Flow**:
    - Calculate `idx+1UL` and check if it is greater than or equal to `range->offset_lo`.
    - Check if `idx` is less than or equal to `range->offset_hi`.
    - Return the result of the logical AND operation between the two conditions.
- **Output**: Returns an integer that is non-zero if the index can extend the range, otherwise returns zero.


---
### fd\_quic\_range\_extend<!-- {{#callable:fd_quic_range_extend}} -->
[View Source →](<../../../../../src/waltz/quic/fd_quic_ack_tx.c#L13>)

Extends the range of packet numbers in a QUIC acknowledgment range and returns whether the range was modified.
- **Inputs**:
    - `range`: A pointer to an `fd_quic_range_t` structure representing the current range of packet numbers.
    - `idx`: An `ulong` representing the packet number to potentially extend the range with.
- **Logic and Control Flow**:
    - Check if `idx` is less than `range->offset_lo` and store the result in `lo_decreased`.
    - Check if `idx` is greater than or equal to `range->offset_hi` and store the result in `hi_increased`.
    - Update `range->offset_lo` to the minimum of its current value and `idx`.
    - Update `range->offset_hi` to the maximum of its current value and `idx + 1UL`.
    - Return the logical OR of `lo_decreased` and `hi_increased` to indicate if the range was extended.
- **Output**: Returns an `int` that is non-zero if the range was extended, otherwise zero.


---
### fd\_quic\_ack\_pkt<!-- {{#callable:fd_quic_ack_pkt}} -->
[View Source →](<../../../../../src/waltz/quic/fd_quic_ack_tx.c#L23>)

Processes a packet number for acknowledgment, either merging it into an existing acknowledgment or creating a new one.
- **Inputs**:
    - `gen`: A pointer to the `fd_quic_ack_gen_t` structure, which manages the acknowledgment queue.
    - `pkt_number`: The packet number to be acknowledged.
    - `enc_level`: The encryption level of the packet.
    - `now`: The current timestamp to be used for the acknowledgment.
- **Logic and Control Flow**:
    - Check if `pkt_number` is `FD_QUIC_PKT_NUM_UNUSED`; if so, return `FD_QUIC_ACK_TX_NOOP`.
    - Retrieve the most recent acknowledgment from the queue using `gen->head - 1U`.
    - Check if the packet can be merged into the most recent acknowledgment by comparing `enc_level` and using [`fd_quic_range_can_extend`](<#fd_quic_range_can_extend>).
    - If mergeable, update the timestamp if `pkt_number` is greater than or equal to `cached_ack->pkt_number.offset_hi`.
    - Extend the packet number range using [`fd_quic_range_extend`](<#fd_quic_range_extend>) and re-enqueue the acknowledgment if necessary.
    - If the queue is full (`gen->head - gen->tail >= FD_QUIC_ACK_QUEUE_CNT`), return `FD_QUIC_ACK_TX_ENOSPC`.
    - If not mergeable, create a new acknowledgment entry in the queue with the packet number and timestamp, then increment `gen->head`.
- **Output**: Returns an integer status code: `FD_QUIC_ACK_TX_NOOP`, `FD_QUIC_ACK_TX_MERGED`, `FD_QUIC_ACK_TX_ENOSPC`, or `FD_QUIC_ACK_TX_NEW`.
- **Functions Called**:
    - [`fd_quic_range_can_extend`](<#fd_quic_range_can_extend>)
    - [`fd_quic_range_extend`](<#fd_quic_range_extend>)


---
### fd\_quic\_ack\_gen\_abandon\_enc\_level<!-- {{#callable:fd_quic_ack_gen_abandon_enc_level}} -->
[View Source →](<../../../../../src/waltz/quic/fd_quic_ack_tx.c#L75>)

Iterates through the acknowledgment queue and discards acknowledgments with an encryption level less than or equal to the specified level.
- **Inputs**:
    - ``gen``: A pointer to an `fd_quic_ack_gen_t` structure, which represents the acknowledgment generator state.
    - ``enc_level``: An unsigned integer representing the encryption level threshold for discarding acknowledgments.
- **Logic and Control Flow**:
    - Iterate over the acknowledgment queue from `gen->tail` to `gen->head`.
    - For each acknowledgment, check if its encryption level is greater than `enc_level`.
    - If the encryption level is greater, stop the iteration.
    - If the encryption level is less than or equal, log a debug message and increment `gen->tail` to discard the acknowledgment.
- **Output**: No return value; the function modifies the state of the acknowledgment generator by potentially advancing the `tail` index.


---
### fd\_quic\_gen\_ack\_frames<!-- {{#callable:fd_quic_gen_ack_frames}} -->
[View Source →](<../../../../../src/waltz/quic/fd_quic_ack_tx.c#L91>)

Generates ACK frames for QUIC protocol based on pending ACK-eliciting packets and appends them to the payload buffer.
- **Inputs**:
    - `gen`: A pointer to `fd_quic_ack_gen_t`, which contains the state and queue of ACK packets to process.
    - `payload_ptr`: A pointer to the start of the buffer where the ACK frames will be written.
    - `payload_end`: A pointer to the end of the buffer, used to ensure the buffer is not overrun.
    - `enc_level`: The encryption level required for the ACK frames.
    - `now`: The current time in nanoseconds, used to calculate the ACK delay.
- **Logic and Control Flow**:
    - Check if there is an ACK-eliciting packet pending; if not, return `payload_ptr` immediately.
    - Initialize `ranges_sent` to zero to track the number of ACK ranges sent.
    - Iterate over the ACK queue from `tail` to `head`, processing each ACK packet.
    - For each ACK, check if its encryption level matches `enc_level`; if not, break the loop.
    - Calculate the ACK delay in microseconds from the current time `now` and the ACK's timestamp.
    - Skip ACKs with no range (where `offset_lo` equals `offset_hi`).
    - Create an `fd_quic_ack_frame_t` structure for each valid ACK and encode it into the buffer using `fd_quic_encode_ack_frame`.
    - If encoding fails due to insufficient buffer space, break the loop.
    - Update `payload_ptr` and increment `ranges_sent` for each successfully encoded ACK frame.
    - If all ACK frames are processed, reset `gen->is_elicited` to zero; otherwise, log that not all frames were flushed.
    - Log the number of ranges sent and whether all frames were flushed.
- **Output**: Returns the updated `payload_ptr`, pointing to the end of the written ACK frames in the buffer.



---
Made with ❤️ by [Driver](https://www.driver.ai/)