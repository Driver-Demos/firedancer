<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Function to resolve IP literals to address structures, supporting both IPv4 and IPv6 families.

# Purpose
The code defines a function [`fd_lookup_ipliteral`](<#fd_lookup_ipliteral>) that resolves IP address literals into a structured address format. It supports both IPv4 and IPv6 address families. The function takes a buffer to store the resolved address, a string representing the IP address, and the address family as parameters. It uses the `inet_aton` and `inet_pton` functions to convert the string representation of the IP address into binary form. If the conversion is successful, it populates the `buf` with the address and family information. The function also handles IPv6 scope identifiers, which are used to specify the network interface for link-local addresses.

The function returns different status codes based on the outcome of the address resolution. It returns `1` for a successful resolution, `FD_EAI_NODATA` if the address family does not match the resolved address, and `FD_EAI_NONAME` if there is an error with the scope identifier. The code includes necessary headers for network operations and uses macros and functions to handle different address families and scope identifiers. This function is part of a broader network utility, as indicated by the inclusion of custom headers like `fd_cstr.h` and `fd_lookup.h`.
# Imports and Dependencies

---
- `sys/socket.h`
- `netinet/in.h`
- `netdb.h`
- `net/if.h`
- `arpa/inet.h`
- `limits.h`
- `stdlib.h`
- `string.h`
- `ctype.h`
- `../../util/cstr/fd_cstr.h`
- `fd_lookup.h`


# Functions

---
### fd\_lookup\_ipliteral<!-- {{#callable:fd_lookup_ipliteral}} -->
[View Source →](<../../../../../src/waltz/resolv/fd_lookup_ipliteral.c#L14>)

Converts a string representation of an IP address to a binary format and stores it in a buffer, considering the specified address family.
- **Inputs**:
    - `buf`: A buffer to store the resulting binary IP address and related information.
    - `name`: A string representing the IP address to convert.
    - `family`: The address family, either `AF_INET` for IPv4 or `AF_INET6` for IPv6.
- **Logic and Control Flow**:
    - Declare variables for IPv4 and IPv6 addresses.
    - Use `inet_aton` to check if `name` is a valid IPv4 address.
    - If valid and `family` is `AF_INET6`, return `FD_EAI_NODATA` as the family is incorrect.
    - Copy the IPv4 address to `buf`, set the family to `AF_INET`, and scope ID to 0, then return 1.
    - Search for a '%' character in `name` to handle potential scope IDs for IPv6 addresses.
    - If found, copy the part before '%' to a temporary buffer and update `name`.
    - Use `inet_pton` to check if `name` is a valid IPv6 address.
    - If invalid, return 0.
    - If valid and `family` is `AF_INET`, return `FD_EAI_NODATA` as the family is incorrect.
    - Copy the IPv6 address to `buf`, set the family to `AF_INET6`.
    - If a scope ID is present, convert it to a number or resolve it using `if_nametoindex`.
    - Check if the scope ID is valid and within range, otherwise return `FD_EAI_NONAME`.
    - Set the scope ID in `buf` and return 1.
- **Output**: Returns 1 on success, 0 if the address is invalid, or an error code (`FD_EAI_NODATA`, `FD_EAI_NONAME`) if the address family is incorrect or the scope ID is invalid.



---
Made with ❤️ by [Driver](https://www.driver.ai/)