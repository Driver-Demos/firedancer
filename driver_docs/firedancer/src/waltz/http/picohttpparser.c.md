<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

HTTP parser implementation for parsing requests, responses, and headers, with chunked transfer decoding.

# Purpose
The code is a C library for parsing HTTP requests and responses, as well as decoding chunked transfer encoding. It provides functions such as [`phr_parse_request`](<#phr_parse_request>), [`phr_parse_response`](<#phr_parse_response>), and [`phr_parse_headers`](<#phr_parse_headers>) to parse HTTP request lines, response lines, and headers, respectively. The library uses macros and inline functions to efficiently handle character parsing and validation, leveraging SIMD instructions when available for performance optimization. The code also includes a function [`phr_decode_chunked`](<#phr_decode_chunked>) to decode data encoded with chunked transfer encoding, which is a method used in HTTP to send data in a series of chunks.

The library defines several static functions and macros to assist with parsing tasks, such as [`parse_token`](<#parse_token>), [`parse_http_version`](<#parse_http_version>), and [`findchar_fast`](<#findchar_fast>). These functions are used internally to process and validate different parts of HTTP messages, ensuring that the input data conforms to expected formats. The code is designed to handle edge cases and errors, returning specific error codes when parsing fails. The library is intended to be used as part of a larger application that requires HTTP message parsing capabilities, and it provides a public API for this purpose.
# Imports and Dependencies

---
- `assert.h`
- `stddef.h`
- `string.h`
- `nmmintrin.h`
- `x86intrin.h`
- `picohttpparser.h`


# Global Variables

---
### token\_char\_map
- **Type**: ``const char *``
- **Description**: Maps ASCII characters to a binary value indicating if they are valid token characters. The map uses a string of null and one characters to represent invalid and valid token characters, respectively.
- **Use**: Used to quickly check if a character is a valid token character in HTTP parsing.


# Functions

---
### findchar\_fast<!-- {{#callable:findchar_fast}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L105>)

Searches for a character within a buffer that matches a specified range using SSE4.2 instructions if available.
- **Inputs**:
    - ``buf``: Pointer to the start of the buffer to search.
    - ``buf_end``: Pointer to the end of the buffer.
    - ``ranges``: Pointer to the character ranges to search for.
    - ``ranges_size``: Size of the character ranges.
    - ``found``: Pointer to an integer that will be set to 1 if a matching character is found, otherwise 0.
- **Logic and Control Flow**:
    - Set `*found` to 0 to indicate no character found initially.
    - Check if SSE4.2 is available and if the buffer length is at least 16 bytes.
    - If so, load the character ranges into a 128-bit SSE register.
    - Iterate over the buffer in 16-byte chunks using SSE instructions to compare each chunk against the character ranges.
    - If a match is found, update `buf` to point to the matching character, set `*found` to 1, and exit the loop.
    - If no match is found in the current chunk, move to the next 16-byte chunk.
    - If SSE4.2 is not available, suppress unused parameter warnings for `buf_end`, `ranges`, and `ranges_size`.
- **Output**: Returns a pointer to the position in the buffer where a matching character is found, or the end of the buffer if no match is found.


---
### get\_token\_to\_eol<!-- {{#callable:get_token_to_eol}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L134>)

Extracts a token from a buffer until a newline or a non-printable character is found.
- **Inputs**:
    - ``buf``: Pointer to the start of the buffer to parse.
    - ``buf_end``: Pointer to the end of the buffer.
    - ``token``: Pointer to store the start of the token found.
    - ``token_len``: Pointer to store the length of the token found.
    - ``ret``: Pointer to store the return status of the function.
- **Logic and Control Flow**:
    - Initialize `token_start` to `buf` to mark the start of the token.
    - If SSE4.2 is available, use [`findchar_fast`](<#findchar_fast>) to quickly locate non-printable characters using SIMD instructions.
    - If a non-printable character is found, jump to `FOUND_CTL`.
    - If SSE4.2 is not available, manually check each character in chunks of 8 bytes for non-printable characters.
    - If a non-printable character is found, jump to `FOUND_CTL`.
    - Continue checking each character until the end of the buffer is reached or a non-printable character is found.
    - At `FOUND_CTL`, check if the character is a carriage return (`\015`).
    - If it is a carriage return, expect a newline (`\012`) and calculate the token length excluding the CRLF.
    - If it is a newline (`\012`), calculate the token length excluding the newline.
    - If neither, set `ret` to -1 and return `NULL`.
    - Set `*token` to `token_start` and return the updated `buf` pointer.
- **Output**: Returns a pointer to the position in the buffer after the token, or `NULL` if an error occurs.
- **Functions Called**:
    - [`findchar_fast`](<#findchar_fast>)


---
### is\_complete<!-- {{#callable:is_complete}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L197>)

Checks if a buffer contains a complete HTTP message by looking for two consecutive newline sequences.
- **Inputs**:
    - ``buf``: A pointer to the start of the buffer to check.
    - ``buf_end``: A pointer to the end of the buffer.
    - ``last_len``: The length of the last segment of data processed.
    - ``ret``: A pointer to an integer where the function stores the result code.
- **Logic and Control Flow**:
    - Initialize `ret_cnt` to 0 to count consecutive newline sequences.
    - Adjust `buf` to point to the last three characters if `last_len` is greater than or equal to 3.
    - Enter an infinite loop to process each character in the buffer.
    - Check for end-of-file using `CHECK_EOF()` macro; if reached, set `*ret` to -2 and return `NULL`.
    - If the current character is a carriage return (`\015`), increment `buf`, check for end-of-file, and expect a newline (`\012`) using `EXPECT_CHAR()` macro, then increment `ret_cnt`.
    - If the current character is a newline (`\012`), increment `buf` and `ret_cnt`.
    - If the current character is neither a carriage return nor a newline, increment `buf` and reset `ret_cnt` to 0.
    - If `ret_cnt` reaches 2, indicating two consecutive newline sequences, return the current `buf` position.
    - If the loop exits without finding two consecutive newline sequences, set `*ret` to -2 and return `NULL`.
- **Output**: Returns a pointer to the position in the buffer after two consecutive newline sequences, or `NULL` if not found.


---
### parse\_token<!-- {{#callable:parse_token}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L245>)

Parses a token from a buffer until a specified character is found or an invalid token character is encountered.
- **Inputs**:
    - ``buf``: Pointer to the start of the buffer to parse.
    - ``buf_end``: Pointer to the end of the buffer.
    - ``token``: Pointer to store the start of the parsed token.
    - ``token_len``: Pointer to store the length of the parsed token.
    - ``next_char``: Character that indicates the end of the token.
    - ``ret``: Pointer to an integer to store the return status.
- **Logic and Control Flow**:
    - Initialize `buf_start` to the start of the buffer and declare an integer `found`.
    - Call [`findchar_fast`](<#findchar_fast>) to locate the first non-token character using predefined character ranges.
    - If no non-token character is found, check for end-of-file using `CHECK_EOF`.
    - Enter a loop to iterate through the buffer until `next_char` is found or an invalid token character is encountered.
    - If `next_char` is found, break the loop.
    - If an invalid token character is found, set `*ret` to -1 and return `NULL`.
    - Increment the buffer pointer `buf` and check for end-of-file using `CHECK_EOF`.
    - Set `*token` to `buf_start` and calculate `*token_len` as the difference between `buf` and `buf_start`.
    - Return the current position of `buf`.
- **Output**: Returns a pointer to the position in the buffer after the parsed token, or `NULL` if an error occurs.
- **Functions Called**:
    - [`findchar_fast`](<#findchar_fast>)


---
### parse\_http\_version<!-- {{#callable:parse_http_version}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L280>)

Parses the HTTP version from a buffer and updates the minor version and return code.
- **Inputs**:
    - `buf`: A pointer to the start of the buffer containing the HTTP version string.
    - `buf_end`: A pointer to the end of the buffer.
    - `minor_version`: A pointer to an integer where the function will store the parsed minor version number.
    - `ret`: A pointer to an integer where the function will store the return code indicating success or failure.
- **Logic and Control Flow**:
    - Checks if the buffer has at least 9 characters to parse the HTTP version; if not, sets `*ret` to -2 and returns `NULL`.
    - Uses `EXPECT_CHAR_NO_CHECK` macro to verify that the buffer contains the string 'HTTP/1.' at the current position.
    - Uses `PARSE_INT` macro to parse the minor version number from the buffer and store it in `*minor_version`.
    - Returns the updated buffer pointer if parsing is successful.
- **Output**: Returns a pointer to the buffer position after parsing the HTTP version, or `NULL` if parsing fails.


---
### parse\_headers<!-- {{#callable:parse_headers}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L298>)

Parses HTTP headers from a buffer and stores them in a provided array of `phr_header` structures.
- **Inputs**:
    - ``buf``: Pointer to the start of the buffer containing the HTTP headers.
    - ``buf_end``: Pointer to the end of the buffer.
    - ``headers``: Array of `phr_header` structures where parsed headers will be stored.
    - ``num_headers``: Pointer to a size_t variable that holds the number of headers parsed so far and will be updated with the total number of headers parsed.
    - ``max_headers``: Maximum number of headers that can be stored in the `headers` array.
    - ``ret``: Pointer to an integer that will store the return status of the function.
- **Logic and Control Flow**:
    - Iterates over the buffer to parse headers until a CRLF (\r\n) or LF (\n) is encountered, indicating the end of headers.
    - Checks for end-of-file using `CHECK_EOF()` macro and returns NULL if the end of the buffer is reached.
    - If a CRLF or LF is found, the loop breaks, indicating the end of headers.
    - Checks if the number of parsed headers has reached `max_headers`; if so, sets `*ret` to -1 and returns NULL.
    - If the current header is not a continuation of the previous header (not starting with a space or tab), it parses the header name using `parse_token()` and checks for errors.
    - If the header name length is zero, sets `*ret` to -1 and returns NULL.
    - Skips spaces and tabs after the colon in the header line.
    - Parses the header value using `get_token_to_eol()` and removes trailing spaces and tabs from the value.
    - Stores the parsed header name and value in the `headers` array.
- **Output**: Returns a pointer to the position in the buffer after the last parsed header, or NULL if an error occurs.
- **Functions Called**:
    - [`parse_token`](<#parse_token>)
    - [`get_token_to_eol`](<#get_token_to_eol>)


---
### parse\_request<!-- {{#callable:parse_request}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L355>)

Parses an HTTP request from a buffer, extracting the method, path, HTTP version, and headers.
- **Inputs**:
    - ``buf``: Pointer to the start of the buffer containing the HTTP request.
    - ``buf_end``: Pointer to the end of the buffer.
    - ``method``: Pointer to store the start of the HTTP method string.
    - ``method_len``: Pointer to store the length of the HTTP method string.
    - ``path``: Pointer to store the start of the path string.
    - ``path_len``: Pointer to store the length of the path string.
    - ``minor_version``: Pointer to store the minor version of the HTTP protocol.
    - ``headers``: Array of `phr_header` structures to store the parsed headers.
    - ``num_headers``: Pointer to store the number of headers parsed.
    - ``max_headers``: Maximum number of headers that can be stored in the `headers` array.
    - ``ret``: Pointer to store the return code indicating success or type of error.
- **Logic and Control Flow**:
    - Checks for and skips an initial empty line in the buffer, which some clients add after POST content.
    - Parses the HTTP method using [`parse_token`](<#parse_token>), storing the result in `method` and `method_len`.
    - Skips spaces and parses the request path using `ADVANCE_TOKEN`, storing the result in `path` and `path_len`.
    - Validates that both `method_len` and `path_len` are non-zero, returning an error if either is zero.
    - Parses the HTTP version using [`parse_http_version`](<#parse_http_version>), storing the result in `minor_version`.
    - Checks for and skips the line terminator (CRLF or LF) after the request line.
    - Calls [`parse_headers`](<#parse_headers>) to parse the headers from the buffer, storing them in the `headers` array.
- **Output**: Returns a pointer to the position in the buffer after the parsed request, or `NULL` if an error occurs.
- **Functions Called**:
    - [`parse_token`](<#parse_token>)
    - [`parse_http_version`](<#parse_http_version>)
    - [`parse_headers`](<#parse_headers>)


---
### phr\_parse\_request<!-- {{#callable:phr_parse_request}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L401>)

Parses an HTTP request from a buffer and extracts the method, path, HTTP version, and headers.
- **Inputs**:
    - `buf_start`: Pointer to the start of the buffer containing the HTTP request.
    - `len`: Length of the buffer.
    - `method`: Pointer to store the start of the HTTP method string.
    - `method_len`: Pointer to store the length of the HTTP method string.
    - `path`: Pointer to store the start of the path string.
    - `path_len`: Pointer to store the length of the path string.
    - `minor_version`: Pointer to store the HTTP minor version number.
    - `headers`: Array of `phr_header` structures to store the parsed headers.
    - `num_headers`: Pointer to store the number of headers parsed.
    - `last_len`: Length of the last part of the buffer processed, used to check for request completeness.
- **Logic and Control Flow**:
    - Initialize pointers and lengths for method, path, and headers to default values.
    - If `last_len` is not zero, call [`is_complete`](<#is_complete>) to check if the request is complete; return the result if incomplete.
    - Call [`parse_request`](<#parse_request>) to parse the request line and headers; return the result if parsing fails.
    - Return the number of bytes processed from the buffer.
- **Output**: Returns the number of bytes processed if successful, or a negative error code if parsing fails.
- **Functions Called**:
    - [`is_complete`](<#is_complete>)
    - [`parse_request`](<#parse_request>)


---
### parse\_response<!-- {{#callable:parse_response}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L429>)

Parses an HTTP response from a buffer, extracting the HTTP version, status code, message, and headers.
- **Inputs**:
    - ``buf``: Pointer to the start of the buffer containing the HTTP response.
    - ``buf_end``: Pointer to the end of the buffer.
    - ``minor_version``: Pointer to an integer where the function stores the minor version of the HTTP protocol.
    - ``status``: Pointer to an integer where the function stores the HTTP status code.
    - ``msg``: Pointer to a string where the function stores the HTTP status message.
    - ``msg_len``: Pointer to a size_t where the function stores the length of the status message.
    - ``headers``: Pointer to an array of `phr_header` structures where the function stores the parsed headers.
    - ``num_headers``: Pointer to a size_t where the function stores the number of headers parsed.
    - ``max_headers``: Maximum number of headers that can be stored in the `headers` array.
    - ``ret``: Pointer to an integer where the function stores the return status code.
- **Logic and Control Flow**:
    - Calls [`parse_http_version`](<#parse_http_version>) to parse the HTTP version from the buffer.
    - Checks for a space character after the HTTP version and skips any additional spaces.
    - Parses a three-digit status code using the `PARSE_INT_3` macro.
    - Calls [`get_token_to_eol`](<#get_token_to_eol>) to extract the status message, including any preceding spaces.
    - Removes any leading spaces from the status message if present.
    - Returns an error if any garbage is found after the status code.
    - Calls [`parse_headers`](<#parse_headers>) to parse the headers from the buffer.
- **Output**: Returns a pointer to the position in the buffer after the parsed headers, or `NULL` if an error occurs.
- **Functions Called**:
    - [`parse_http_version`](<#parse_http_version>)
    - [`get_token_to_eol`](<#get_token_to_eol>)
    - [`parse_headers`](<#parse_headers>)


---
### phr\_parse\_response<!-- {{#callable:phr_parse_response}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L474>)

Parses an HTTP response from a buffer and extracts the HTTP version, status code, message, and headers.
- **Inputs**:
    - ``buf_start``: Pointer to the start of the buffer containing the HTTP response.
    - ``len``: Length of the buffer.
    - ``minor_version``: Pointer to an integer where the function will store the minor version of the HTTP response.
    - ``status``: Pointer to an integer where the function will store the status code of the HTTP response.
    - ``msg``: Pointer to a string where the function will store the message of the HTTP response.
    - ``msg_len``: Pointer to a size_t where the function will store the length of the message.
    - ``headers``: Pointer to an array of `phr_header` structures where the function will store the headers of the HTTP response.
    - ``num_headers``: Pointer to a size_t indicating the maximum number of headers to parse, and where the function will store the actual number of headers parsed.
    - ``last_len``: Size of the previously parsed buffer, used to check if the response is complete.
- **Logic and Control Flow**:
    - Initialize `minor_version`, `status`, `msg`, `msg_len`, and `num_headers` to default values.
    - Check if `last_len` is not zero and if the response is complete using [`is_complete`](<#is_complete>); return the result if incomplete.
    - Call [`parse_response`](<#parse_response>) to parse the HTTP version, status code, message, and headers from the buffer.
    - Return the number of bytes parsed from the buffer.
- **Output**: Returns the number of bytes parsed from the buffer, or an error code if parsing fails.
- **Functions Called**:
    - [`is_complete`](<#is_complete>)
    - [`parse_response`](<#parse_response>)


---
### phr\_parse\_headers<!-- {{#callable:phr_parse_headers}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L500>)

Parses HTTP headers from a buffer and updates the headers structure with parsed data.
- **Inputs**:
    - ``buf_start``: A pointer to the start of the buffer containing the HTTP headers.
    - ``len``: The length of the buffer.
    - ``headers``: A pointer to an array of `phr_header` structures where parsed headers will be stored.
    - ``num_headers``: A pointer to a size_t variable that indicates the maximum number of headers to parse and will be updated with the actual number of parsed headers.
    - ``last_len``: The length of the last part of the buffer, used to check if the response is complete.
- **Logic and Control Flow**:
    - Initialize `buf` to `buf_start` and `buf_end` to `buf_start + len`.
    - Set `max_headers` to the value pointed by `num_headers`.
    - Reset `*num_headers` to 0.
    - If `last_len` is not zero, call [`is_complete`](<#is_complete>) to check if the response is complete; return `r` if not complete.
    - Call [`parse_headers`](<#parse_headers>) to parse the headers from the buffer; return `r` if parsing fails.
    - Return the number of bytes processed from the buffer.
- **Output**: Returns the number of bytes processed from the buffer, or an error code if parsing fails.
- **Functions Called**:
    - [`is_complete`](<#is_complete>)
    - [`parse_headers`](<#parse_headers>)


---
### decode\_hex<!-- {{#callable:decode_hex}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L530>)

Converts a hexadecimal character to its integer value.
- **Inputs**:
    - `ch`: The character to convert, expected to be a hexadecimal digit ('0'-'9', 'A'-'F', 'a'-'f').
- **Logic and Control Flow**:
    - Check if `ch` is a digit between '0' and '9'.
    - If true, return the integer value by subtracting '0' from `ch`.
    - Check if `ch` is an uppercase letter between 'A' and 'F'.
    - If true, return the integer value by subtracting 'A' from `ch` and adding 10.
    - Check if `ch` is a lowercase letter between 'a' and 'f'.
    - If true, return the integer value by subtracting 'a' from `ch` and adding 10.
    - If `ch` is not a valid hexadecimal character, return -1.
- **Output**: The integer value of the hexadecimal character, or -1 if the character is not a valid hexadecimal digit.


---
### phr\_decode\_chunked<!-- {{#callable:phr_decode_chunked}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L543>)

Decodes a buffer of chunked HTTP data according to the state of the chunked decoder.
- **Inputs**:
    - `decoder`: A pointer to a `phr_chunked_decoder` structure that maintains the state of the decoding process.
    - `buf`: A pointer to a buffer containing the chunked data to decode.
    - `_bufsz`: A pointer to a size_t variable that holds the size of the buffer and is updated to the size of the decoded data.
- **Logic and Control Flow**:
    - Initialize `dst`, `src`, and `bufsz` variables and set `ret` to -2 indicating incomplete data.
    - Enter a loop that processes the buffer based on the current state of the decoder.
    - In the `CHUNKED_IN_CHUNK_SIZE` state, decode the chunk size from hexadecimal digits and update `bytes_left_in_chunk`.
    - Transition to `CHUNKED_IN_CHUNK_EXT` state to skip over any chunk extensions until a newline character is found.
    - If `bytes_left_in_chunk` is zero, check if trailers should be consumed; otherwise, transition to `CHUNKED_IN_CHUNK_DATA`.
    - In the `CHUNKED_IN_CHUNK_DATA` state, move the chunk data to the destination position in the buffer and update `bytes_left_in_chunk`.
    - Transition to `CHUNKED_IN_CHUNK_CRLF` state to verify the presence of a CRLF sequence after the chunk data.
    - In the `CHUNKED_IN_TRAILERS_LINE_HEAD` and `CHUNKED_IN_TRAILERS_LINE_MIDDLE` states, process trailer lines until the end of the trailers is detected.
    - If the buffer is exhausted or an error occurs, exit the loop and return the appropriate status.
- **Output**: Returns the number of bytes remaining in the buffer after decoding, or a negative value indicating an error or incomplete data.
- **Functions Called**:
    - [`decode_hex`](<#decode_hex>)


---
### phr\_decode\_chunked\_is\_in\_data<!-- {{#callable:phr_decode_chunked_is_in_data}} -->
[View Source →](<../../../../../src/waltz/http/picohttpparser.c#L658>)

Checks if the chunked decoder is currently processing chunk data.
- **Inputs**:
    - `decoder`: A pointer to a `phr_chunked_decoder` structure that holds the state of the chunked decoding process.
- **Logic and Control Flow**:
    - Compares the `_state` field of the `decoder` structure to the constant `CHUNKED_IN_CHUNK_DATA`.
    - Returns the result of the comparison as an integer.
- **Output**: Returns 1 if the decoder is in the `CHUNKED_IN_CHUNK_DATA` state, otherwise returns 0.



---
Made with ❤️ by [Driver](https://www.driver.ai/)