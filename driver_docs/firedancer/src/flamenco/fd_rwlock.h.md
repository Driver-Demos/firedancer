<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

A simple read-write spin lock implementation with functions for locking and unlocking in read and write modes.

# Purpose
The code defines a simple read-write spin lock mechanism in C, encapsulated in a header file. It provides a structure `fd_rwlock` with a `ushort` value to manage lock states. The lock can be in one of three states: unlocked, locked by multiple readers, or write-locked. The code includes functions to initialize a new lock ([`fd_rwlock_new`](<#fd_rwlock_new>)), acquire a write lock ([`fd_rwlock_write`](<#fd_rwlock_write>)), release a write lock ([`fd_rwlock_unwrite`](<#fd_rwlock_unwrite>)), acquire a read lock ([`fd_rwlock_read`](<#fd_rwlock_read>)), and release a read lock ([`fd_rwlock_unread`](<#fd_rwlock_unread>)). 

The implementation uses atomic operations and spin-wait loops to manage concurrent access, ensuring thread safety when `FD_HAS_THREADS` is defined. The functions use memory fences (`FD_COMPILER_MFENCE`) to prevent reordering of memory operations, which is crucial for maintaining consistency in multi-threaded environments. The code is intended to be included in other C files, providing a basic synchronization primitive for managing concurrent read and write operations.
# Imports and Dependencies

---
- `../util/fd_util_base.h`


# Data Structures

---
### fd\_rwlock
- **Type**: ``struct``
- **Members**:
    - `value`: Stores the lock state, where 0 is unlocked, 1 to 0xFFFE is locked by N readers, and 0xFFFF is write locked.
- **Description**: Manages a simple read-write spin lock using a `ushort` to represent the lock state, allowing for multiple readers or a single writer to hold the lock at any time.


---
### fd\_rwlock\_t
- **Type**: ``struct``
- **Members**:
    - ``value``: Stores the lock state, where bits 0..16 indicate unlocked, locked by readers, or write locked.
- **Description**: Manages a simple read-write spin lock using a `ushort` to represent the lock state, allowing multiple readers or a single writer to access a shared resource.


# Functions

---
### fd\_rwlock\_new<!-- {{#callable:fd_rwlock_new}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock.h#L18>)

Initializes a read-write lock by setting its value to 0.
- **Inputs**:
    - `lock`: A pointer to an `fd_rwlock_t` structure that represents the read-write lock to initialize.
- **Logic and Control Flow**:
    - Set the `value` field of the `lock` structure to 0, indicating that the lock is unlocked.
    - Return 0.
- **Output**: Returns 0 after initializing the lock.


---
### fd\_rwlock\_write<!-- {{#callable:fd_rwlock_write}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock.h#L24>)

Acquires a write lock on a read-write spin lock by setting its value to `0xFFFF` if it is currently unlocked.
- **Inputs**:
    - `lock`: A pointer to an `fd_rwlock_t` structure representing the read-write lock to acquire for writing.
- **Logic and Control Flow**:
    - If `FD_HAS_THREADS` is defined, enter an infinite loop to attempt acquiring the write lock.
    - Retrieve the current `value` of the lock.
    - Check if the lock is currently unlocked (`value` is 0).
    - If unlocked, attempt to atomically set the lock's `value` to `0xFFFF` using `FD_ATOMIC_CAS`.
    - If the atomic compare-and-swap is successful, exit the function, indicating the lock is acquired.
    - If the lock is not acquired, call `FD_SPIN_PAUSE()` to yield the processor and retry.
    - If `FD_HAS_THREADS` is not defined, directly set the lock's `value` to `0xFFFF`.
    - Call `FD_COMPILER_MFENCE()` to ensure memory ordering.
- **Output**: None. The function modifies the lock in place to indicate it is write-locked.


---
### fd\_rwlock\_unwrite<!-- {{#callable:fd_rwlock_unwrite}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock.h#L40>)

Releases a write lock on a read-write spin lock by setting its value to 0.
- **Inputs**:
    - `lock`: A pointer to an `fd_rwlock_t` structure representing the read-write lock to be released.
- **Logic and Control Flow**:
    - Executes a memory fence operation using `FD_COMPILER_MFENCE()` to ensure memory ordering before releasing the lock.
    - Sets the `value` field of the `lock` structure to 0, indicating that the lock is now unlocked.
- **Output**: None (the function returns void).


---
### fd\_rwlock\_read<!-- {{#callable:fd_rwlock_read}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock.h#L46>)

Increments the read lock count of a read-write lock, allowing multiple readers to access the resource concurrently.
- **Inputs**:
    - `lock`: A pointer to an `fd_rwlock_t` structure representing the read-write lock to be acquired for reading.
- **Logic and Control Flow**:
    - If threading is enabled (`FD_HAS_THREADS` is true), enter an infinite loop to attempt to acquire the read lock.
    - Retrieve the current value of the lock's `value` field.
    - Check if the lock is not write-locked and has fewer than 0xFFFE readers (`value < 0xFFFE`).
    - If the condition is true, attempt to increment the reader count atomically using `FD_ATOMIC_CAS`.
    - If the atomic compare-and-swap operation is successful, exit the function, indicating the read lock is acquired.
    - If the atomic operation fails, pause briefly using `FD_SPIN_PAUSE` and retry.
    - If threading is not enabled, increment the lock's `value` field directly.
    - Ensure memory ordering by calling `FD_COMPILER_MFENCE` after acquiring the lock.
- **Output**: None. The function modifies the state of the `fd_rwlock_t` structure pointed to by `lock`.


---
### fd\_rwlock\_unread<!-- {{#callable:fd_rwlock_unread}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock.h#L64>)

Decrements the read lock count of a read-write lock.
- **Inputs**:
    - `lock`: A pointer to a `fd_rwlock_t` structure representing the read-write lock to modify.
- **Logic and Control Flow**:
    - Executes a memory fence to ensure memory ordering with `FD_COMPILER_MFENCE()`.
    - Checks if threading is enabled with `FD_HAS_THREADS`.
    - If threading is enabled, atomically decrements the `value` field of the lock using `FD_ATOMIC_FETCH_AND_SUB`.
    - If threading is not enabled, simply decrements the `value` field of the lock.
- **Output**: No return value.



---
Made with ❤️ by [Driver](https://www.driver.ai/)