<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

A recursive/reentrant read-write spin lock implementation with support for nested locking up to 32 levels.

# Purpose
The code defines a recursive/reentrant read-write spin lock in C, which allows a single thread to acquire the lock multiple times up to a maximum of 32 nested levels. This lock supports nesting for read-read, write-write, and write-read operations but does not support read-write upgrades to prevent potential deadlocks. The lock is implemented using a structure `fd_rwlock_recursive` that maintains the state of the lock, including the owner of the write lock, the number of recursive write locks, and the number of recursive read locks held by the write owner. The structure also includes padding to ensure proper memory alignment.

The code provides several inline functions to manage the lock, including [`fd_rwlock_recursive_new`](<#fd_rwlock_recursive_new>) to initialize the lock, [`fd_rwlock_recursive_wlock`](<#fd_rwlock_recursive_wlock>) and [`fd_rwlock_recursive_rlock`](<#fd_rwlock_recursive_rlock>) to acquire write and read locks respectively, and [`fd_rwlock_recursive_wunlock`](<#fd_rwlock_recursive_wunlock>) and [`fd_rwlock_recursive_runlock`](<#fd_rwlock_recursive_runlock>) to release write and read locks. The implementation uses atomic operations and spin-waiting to handle lock acquisition and release, ensuring thread safety in a multi-threaded environment. The code also includes critical logging to handle errors such as exceeding recursion depth or unlocking without holding the lock.
# Imports and Dependencies

---
- `../util/log/fd_log.h`


# Data Structures

---
### fd\_rwlock\_recursive
- **Type**: ``struct``
- **Members**:
    - `write_owner`: Stores the thread ID of the write lock owner, or 0 if there is no write owner.
    - `state`: Indicates the lock state, with values representing unlocked, number of active readers, or write locked.
    - `write_count`: Tracks the number of recursive write locks held by the write owner.
    - `write_read_count`: Tracks the number of recursive read locks held by the write owner.
    - `_pad`: Padding to align the structure size to 64 bytes.
- **Description**: A recursive read-write spin lock structure that allows the same thread to acquire the lock multiple times, supporting read-read, write-write, and write-read nesting, but not read-write upgrades. It uses fields to track the lock state, the owner of the write lock, and the number of recursive locks held, with padding to ensure proper memory alignment.


---
### fd\_rwlock\_recursive\_t
- **Type**: ``struct``
- **Members**:
    - `write_owner`: Stores the thread ID of the current write lock owner, or 0 if there is no write owner.
    - `state`: Indicates the lock state, with values representing unlocked, number of active readers, or write locked.
    - `write_count`: Tracks the number of recursive write locks held by the write owner.
    - `write_read_count`: Tracks the number of recursive read locks held by the write owner.
    - `_pad`: Padding to align the structure size to 64 bytes.
- **Description**: A recursive read-write spin lock that allows the same thread to acquire the lock multiple times, supporting up to 32 nested levels. It supports read-read, write-write, and write-read nesting but does not support read-write upgrades to prevent deadlocks. The structure uses a combination of fields to track the lock state, the owner of the write lock, and the count of recursive locks, providing a mechanism to detect lock misuse.


# Functions

---
### fd\_rwlock\_recursive\_tid<!-- {{#callable:fd_rwlock_recursive_tid}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L57>)

Calculates a unique thread identifier by combining the thread's log ID and thread ID.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `fd_log_tid()` to get the thread's log ID and shifts it left by 12 bits.
    - Calls `fd_log_thread_id()` to get the thread's ID.
    - Adds the shifted log ID to the thread ID to form a unique identifier.
- **Output**: Returns an `ulong` representing the unique thread identifier.


---
### fd\_rwlock\_recursive\_new<!-- {{#callable:fd_rwlock_recursive_new}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L64>)

Initializes a `fd_rwlock_recursive_t` lock structure to its default unlocked state.
- **Inputs**:
    - `lock`: A pointer to a `fd_rwlock_recursive_t` structure that will be initialized.
- **Logic and Control Flow**:
    - Set `lock->state` to 0, indicating the lock is unlocked.
    - Set `lock->write_owner` to 0, indicating no thread owns the write lock.
    - Set `lock->write_count` to 0, indicating no recursive write locks are held.
    - Set `lock->write_read_count` to 0, indicating no recursive read locks are held.
- **Output**: No return value; the function initializes the lock structure in place.


---
### fd\_rwlock\_recursive\_wlock<!-- {{#callable:fd_rwlock_recursive_wlock}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L72>)

Acquires a recursive write lock on a `fd_rwlock_recursive_t` structure, allowing the same thread to lock multiple times up to a defined maximum depth.
- **Inputs**:
    - `lock`: A pointer to a `fd_rwlock_recursive_t` structure representing the lock to acquire.
- **Logic and Control Flow**:
    - Check if the current thread already owns the write lock by comparing `lock->write_owner` with the current thread ID `tid`.
    - If the current thread owns the lock, increment `lock->write_count` and check if the total lock depth exceeds `FD_RWLOCK_RECURSIVE_MAX_DEPTH`. If exceeded, log a critical error.
    - If the current thread does not own the lock, enter a loop to acquire the write lock.
    - In the loop, check if the lock is currently unlocked (`lock->state == 0`).
    - If unlocked, attempt to atomically set the lock state to `0xFFFF` to acquire the write lock. If successful, set `lock->write_owner` to `tid`, `lock->write_count` to 1, and `lock->write_read_count` to 0, then return.
    - If the lock is not unlocked, use `FD_SPIN_PAUSE()` to wait and retry acquiring the lock.
- **Output**: None (the function modifies the lock state in place).
- **Functions Called**:
    - [`fd_rwlock_recursive_tid`](<#fd_rwlock_recursive_tid>)


---
### fd\_rwlock\_recursive\_rlock<!-- {{#callable:fd_rwlock_recursive_rlock}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L120>)

Acquires a recursive read lock on a `fd_rwlock_recursive_t` structure, allowing for nested read locks by the same thread.
- **Inputs**:
    - `lock`: A pointer to a `fd_rwlock_recursive_t` structure representing the lock to acquire.
- **Logic and Control Flow**:
    - If threads are enabled (`FD_HAS_THREADS` is true), get the current thread ID using `fd_rwlock_recursive_tid()`.
    - Check if the current thread already owns the write lock by comparing `lock->write_owner` with the current thread ID.
    - If the write lock is owned by the current thread, increment `lock->write_read_count` to track the nested read lock and check if the recursion depth exceeds `FD_RWLOCK_RECURSIVE_MAX_DEPTH`.
    - If the write lock is not owned by the current thread, attempt to acquire a normal read lock by checking if `lock->state` is less than `0xFFFE` and using `FD_ATOMIC_CAS` to increment the state atomically.
    - If `lock->state` equals `0xFFFE`, log a critical error indicating too many read lock acquisitions.
    - If threads are not enabled, check if the write lock is owned by the current thread (`lock->write_owner == 1`), and increment `lock->write_read_count` if true; otherwise, increment `lock->state` for a normal read lock.
- **Output**: None. The function modifies the state of the `fd_rwlock_recursive_t` structure to reflect the acquisition of a read lock.
- **Functions Called**:
    - [`fd_rwlock_recursive_tid`](<#fd_rwlock_recursive_tid>)


---
### fd\_rwlock\_recursive\_unlock<!-- {{#callable:fd_rwlock_recursive_unlock}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L162>)

Releases a recursive read or write lock held by the current thread, updating lock state accordingly.
- **Inputs**:
    - `lock`: A pointer to the `fd_rwlock_recursive_t` structure representing the lock to be released.
    - `is_write`: An integer indicating whether the lock to be released is a write lock (non-zero) or a read lock (zero).
- **Logic and Control Flow**:
    - Execute a memory fence operation using `FD_COMPILER_MFENCE()` to ensure memory operations are completed in order.
    - If threading is enabled (`FD_HAS_THREADS` is true), retrieve the current thread ID using `fd_rwlock_recursive_tid()`.
    - Check if the current thread owns the write lock by comparing `lock->write_owner` with the current thread ID.
    - If the current thread owns the write lock, verify that the total lock count (`lock->write_count + lock->write_read_count`) is not zero; log a critical error if it is.
    - If `is_write` is true, decrement `lock->write_count` and log a critical error if it is already zero.
    - If `is_write` is false, decrement `lock->write_read_count` and log a critical error if it is already zero.
    - Log a critical error if `lock->write_count` is zero and `lock->write_read_count` is greater than zero.
    - If `lock->write_count` is zero, release the write lock by setting `lock->write_owner` to zero, executing a memory fence, and setting `lock->state` to zero.
    - If the current thread does not own the write lock, ensure `is_write` is false; log a critical error if it is true, then decrement `lock->state` atomically.
    - If threading is not enabled, check if `lock->write_owner` is 1, indicating a write lock is held.
    - If `is_write` is true, decrement `lock->write_count`; otherwise, decrement `lock->write_read_count`.
    - If the total lock count (`lock->write_count + lock->write_read_count`) is zero, release the write lock by setting `lock->write_owner` and `lock->state` to zero.
    - If no write lock is held, decrement `lock->state`.
- **Output**: The function does not return a value.
- **Functions Called**:
    - [`fd_rwlock_recursive_tid`](<#fd_rwlock_recursive_tid>)


---
### fd\_rwlock\_recursive\_wunlock<!-- {{#callable:fd_rwlock_recursive_wunlock}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L223>)

Releases a write lock on a recursive read-write lock.
- **Inputs**:
    - `lock`: A pointer to a `fd_rwlock_recursive_t` structure representing the lock to be released.
- **Logic and Control Flow**:
    - Calls the [`fd_rwlock_recursive_unlock`](<#fd_rwlock_recursive_unlock>) function with the `lock` and `1` as arguments to indicate a write unlock operation.
- **Output**: No direct output; the function modifies the state of the lock to release a write lock.
- **Functions Called**:
    - [`fd_rwlock_recursive_unlock`](<#fd_rwlock_recursive_unlock>)


---
### fd\_rwlock\_recursive\_runlock<!-- {{#callable:fd_rwlock_recursive_runlock}} -->
[View Source →](<../../../../src/flamenco/fd_rwlock_recursive.h#L227>)

Releases a recursive read lock on the specified lock object.
- **Inputs**:
    - `lock`: A pointer to a `fd_rwlock_recursive_t` structure representing the lock to be released.
- **Logic and Control Flow**:
    - Calls the [`fd_rwlock_recursive_unlock`](<#fd_rwlock_recursive_unlock>) function with the `lock` and `0` as arguments to indicate a read unlock operation.
- **Output**: No return value.
- **Functions Called**:
    - [`fd_rwlock_recursive_unlock`](<#fd_rwlock_recursive_unlock>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)