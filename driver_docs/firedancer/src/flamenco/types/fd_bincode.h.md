<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines data structures and functions for encoding and decoding binary data with error handling.

# Purpose
The code is a C header file that provides functionality for encoding and decoding binary data. It defines structures and functions to handle binary encoding and decoding contexts, specifically for primitive data types such as `uint8`, `uint16`, `uint32`, `uint64`, `int64`, and `double`. The file includes macros to generate encoding and decoding functions for these types, ensuring that data is correctly read from or written to a buffer without exceeding its bounds. The file also defines error codes to handle common issues such as buffer overflows and underflows during these operations.

Additionally, the code provides specialized functions for encoding and decoding boolean values, byte arrays, and compact 16-bit unsigned integers. It includes support for variable-length integer encoding using a method similar to the `serde_varint` algorithm. The file also defines several macros for decoding data into different memory regions, such as a scratch region or a shared memory area (`spad`). These macros facilitate the allocation and management of memory during the decoding process, ensuring that the operations are performed safely and efficiently.
# Imports and Dependencies

---
- `../../util/fd_util.h`


# Data Structures

---
### fd\_bincode\_encode\_ctx
- **Type**: ``struct``
- **Members**:
    - ``data``: Points to the current position in the data buffer.
    - ``dataend``: Points to the end of the data buffer.
- **Description**: Facilitates encoding operations by maintaining pointers to the current position and the end of a data buffer, ensuring that encoding does not exceed buffer limits.


---
### fd\_bincode\_encode\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``data``: Current position in the data buffer.
    - ``dataend``: End of the data buffer.
- **Description**: Used for encoding operations, `fd_bincode_encode_ctx_t` maintains the current position and the end of the data buffer to ensure that encoding does not exceed buffer limits.


---
### fd\_bincode\_decode\_ctx
- **Type**: ``struct``
- **Members**:
    - ``data``: Points to the current position in the data buffer.
    - ``dataend``: Points to the end of the data buffer.
- **Description**: Facilitates the decoding process by maintaining pointers to the current position and the end of a data buffer, ensuring that decoding operations do not exceed buffer boundaries.


---
### fd\_bincode\_decode\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``data``: Current position in the data buffer.
    - ``dataend``: End of the data buffer.
- **Description**: Used for decoding operations, `fd_bincode_decode_ctx_t` maintains the current position and the end of the data buffer to ensure that decoding does not exceed buffer limits.


# Functions

---
### fd\_bincode\_bool\_decode<!-- {{#callable:fd_bincode_bool_decode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L94>)

Decodes a boolean value from a binary context, ensuring it is valid and updating the context position.
- **Inputs**:
    - ``self``: A pointer to an `uchar` where the decoded boolean value will be stored.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position and end of the data buffer for decoding.
- **Logic and Control Flow**:
    - Set `ptr` to the current data position in `ctx`.
    - Check if there is at least one byte available in the buffer; if not, return `FD_BINCODE_ERR_UNDERFLOW`.
    - Check if the byte at `ptr` is a valid boolean (0 or 1); if not, return `FD_BINCODE_ERR_ENCODING`.
    - Store the byte at `ptr` in `self`.
    - Advance the data position in `ctx` by one byte.
    - Return `FD_BINCODE_SUCCESS` to indicate successful decoding.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` for success, `FD_BINCODE_ERR_UNDERFLOW` if the buffer is too small, or `FD_BINCODE_ERR_ENCODING` if the data is not a valid boolean.


---
### fd\_bincode\_bool\_decode\_footprint<!-- {{#callable:fd_bincode_bool_decode_footprint}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L111>)

Checks if a boolean value can be decoded from the current position in the data buffer and updates the context accordingly.
- **Inputs**:
    - `ctx`: A pointer to an `fd_bincode_decode_ctx_t` structure that contains the current position and end of the data buffer.
- **Logic and Control Flow**:
    - Cast `ctx->data` to a `uchar` pointer `ptr`.
    - Check if `ptr + 1` exceeds `ctx->dataend`; if true, return `FD_BINCODE_ERR_UNDERFLOW`.
    - Check if the value at `ptr` has bits other than the least significant bit set; if true, return `FD_BINCODE_ERR_ENCODING`.
    - Update `ctx->data` to point to `ptr + 1`.
    - Return `FD_BINCODE_SUCCESS`.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` on success, `FD_BINCODE_ERR_UNDERFLOW` if the buffer is too small, or `FD_BINCODE_ERR_ENCODING` if the data is not a valid boolean encoding.


---
### fd\_bincode\_bool\_decode\_unsafe<!-- {{#callable:fd_bincode_bool_decode_unsafe}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L126>)

Calls `fd_bincode_uint8_decode_unsafe` to decode a boolean value from a buffer without safety checks.
- **Inputs**:
    - ``self``: A pointer to an `uchar` where the decoded boolean value will be stored.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that provides the current position and end of the data buffer for decoding.
- **Logic and Control Flow**:
    - Calls the function `fd_bincode_uint8_decode_unsafe` with `self` and `ctx` as arguments.
- **Output**: No return value; the function modifies the data at the location pointed to by `self`.


---
### fd\_bincode\_bool\_encode<!-- {{#callable:fd_bincode_bool_encode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L132>)

Encodes a boolean value into a binary format and updates the encoding context.
- **Inputs**:
    - `self`: The boolean value to encode, represented as an `uchar`.
    - `ctx`: A pointer to the `fd_bincode_encode_ctx_t` structure, which contains the current position in the data buffer and the end of the buffer.
- **Logic and Control Flow**:
    - Cast `ctx->data` to an `uchar` pointer and assign it to `ptr`.
    - Check if writing one byte to `ptr` would exceed `ctx->dataend`. If true, return `FD_BINCODE_ERR_OVERFLOW`.
    - Convert `self` to a boolean (0 or 1) and store it at the location pointed to by `ptr`.
    - Advance `ctx->data` by one byte.
    - Return `FD_BINCODE_SUCCESS`.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` on success or `FD_BINCODE_ERR_OVERFLOW` if there is not enough space in the buffer.


---
### fd\_bincode\_bytes\_decode<!-- {{#callable:fd_bincode_bytes_decode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L146>)

Decodes a sequence of bytes from a buffer into a destination array, updating the context to reflect the new position.
- **Inputs**:
    - ``self``: A pointer to the destination array where the decoded bytes will be stored.
    - ``len``: The number of bytes to decode from the buffer.
    - ``ctx``: A pointer to the `fd_bincode_decode_ctx_t` structure, which contains the current position and end of the data buffer.
- **Logic and Control Flow**:
    - Initialize a pointer `ptr` to the current position in the data buffer from `ctx->data`.
    - Check if the remaining bytes in the buffer (`ctx->dataend - ptr`) are less than `len`. If true, return `FD_BINCODE_ERR_UNDERFLOW` to indicate an error due to insufficient data.
    - Copy `len` bytes from the buffer starting at `ptr` to the destination array `self` using `fd_memcpy`.
    - Update the context's data pointer `ctx->data` to point to the new position after the copied bytes.
    - Return `FD_BINCODE_SUCCESS` to indicate successful decoding.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` on success or `FD_BINCODE_ERR_UNDERFLOW` if there is not enough data to decode.


---
### fd\_bincode\_bytes\_decode\_footprint<!-- {{#callable:fd_bincode_bytes_decode_footprint}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L160>)

Calculates the footprint of a byte sequence in a decoding context and updates the context's data pointer.
- **Inputs**:
    - ``len``: The length of the byte sequence to decode.
    - ``ctx``: A pointer to the `fd_bincode_decode_ctx_t` structure, which contains the current position and end of the data buffer.
- **Logic and Control Flow**:
    - Convert `ctx->data` to a `uchar` pointer `ptr`.
    - Check if the remaining buffer size (`ctx->dataend - ptr`) is less than `len`.
    - If the buffer size is insufficient, return `FD_BINCODE_ERR_UNDERFLOW`.
    - If sufficient, update `ctx->data` to point to the next position after the byte sequence.
    - Return `FD_BINCODE_SUCCESS`.
- **Output**: Returns `FD_BINCODE_SUCCESS` if the buffer has enough space for the byte sequence, otherwise returns `FD_BINCODE_ERR_UNDERFLOW`.


---
### fd\_bincode\_bytes\_decode\_unsafe<!-- {{#callable:fd_bincode_bytes_decode_unsafe}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L173>)

Copies a specified number of bytes from a source buffer to a destination buffer without safety checks.
- **Inputs**:
    - ``self``: A pointer to the destination buffer where the bytes will be copied.
    - ``len``: The number of bytes to copy from the source buffer to the destination buffer.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position in the source data buffer.
- **Logic and Control Flow**:
    - Initialize a pointer `ptr` to the current position in the source data buffer from `ctx->data`.
    - Use `fd_memcpy` to copy `len` bytes from `ptr` to `self`.
    - Update `ctx->data` to point to the new position in the source buffer after the copied bytes.
- **Output**: No return value; the function modifies the destination buffer and updates the context's data pointer.


---
### fd\_bincode\_bytes\_encode<!-- {{#callable:fd_bincode_bytes_encode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L182>)

Encodes a byte array into a buffer, updating the context to reflect the new position.
- **Inputs**:
    - ``self``: A pointer to the byte array to encode.
    - ``len``: The length of the byte array to encode.
    - ``ctx``: A pointer to the encoding context, which contains the current position and end of the buffer.
- **Logic and Control Flow**:
    - Checks the memory safety of the input byte array using `fd_msan_check`.
    - Calculates the new position in the buffer by adding `len` to the current position `ctx->data`.
    - Checks if the new position exceeds the buffer's end (`ctx->dataend`).
    - If the new position exceeds the buffer's end, returns `FD_BINCODE_ERR_OVERFLOW`.
    - Copies the byte array from `self` to the current position in the buffer using `fd_memcpy`.
    - Updates the context's current position to the new position after the copy.
    - Returns `FD_BINCODE_SUCCESS` to indicate successful encoding.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` on success or `FD_BINCODE_ERR_OVERFLOW` if the buffer is too small.


---
### fd\_bincode\_compact\_u16\_decode<!-- {{#callable:fd_bincode_compact_u16_decode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L200>)

Decodes a compactly encoded 16-bit unsigned integer from a data buffer.
- **Inputs**:
    - ``self``: A pointer to a `ushort` where the decoded value will be stored.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position and end of the data buffer.
- **Logic and Control Flow**:
    - Check if `ctx->data` is `NULL`; if so, return `FD_BINCODE_ERR_UNDERFLOW`.
    - Check if there is at least one byte available and the most significant bit of the first byte is 0; if so, decode the value from one byte, update `ctx->data`, and return `FD_BINCODE_SUCCESS`.
    - Check if there are at least two bytes available and the most significant bit of the second byte is 0; if so, check for non-minimal encoding, decode the value from two bytes, update `ctx->data`, and return `FD_BINCODE_SUCCESS`.
    - Check if there are at least three bytes available and the most significant bits of the third byte are 0; if so, check for non-minimal encoding, decode the value from three bytes, update `ctx->data`, and return `FD_BINCODE_SUCCESS`.
    - If none of the above conditions are met, return `FD_BINCODE_ERR_UNDERFLOW`.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` on success, `FD_BINCODE_ERR_UNDERFLOW` if there is not enough data, or `FD_BINCODE_ERR_ENCODING` if the encoding is invalid.


---
### fd\_bincode\_compact\_u16\_decode\_unsafe<!-- {{#callable:fd_bincode_compact_u16_decode_unsafe}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L233>)

Decodes a compactly encoded 16-bit unsigned integer from a buffer without safety checks.
- **Inputs**:
    - ``self``: A pointer to a `ushort` where the decoded value will be stored.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position in the data buffer.
- **Logic and Control Flow**:
    - Cast `ctx->data` to a `const uchar*` and assign it to `ptr`.
    - Check if the most significant bit of `ptr[0]` is not set; if true, assign `ptr[0]` to `*self` and advance `ctx->data` by 1 byte.
    - If the most significant bit of `ptr[0]` is set, check if the most significant bit of `ptr[1]` is not set; if true, decode the value using `ptr[0]` and `ptr[1]`, assign it to `*self`, and advance `ctx->data` by 2 bytes.
    - If the most significant bits of both `ptr[0]` and `ptr[1]` are set, decode the value using `ptr[0]`, `ptr[1]`, and `ptr[2]`, assign it to `*self`, and advance `ctx->data` by 3 bytes.
- **Output**: The function does not return a value; it updates the `*self` with the decoded `ushort` value and advances the `ctx->data` pointer.


---
### fd\_bincode\_compact\_u16\_encode<!-- {{#callable:fd_bincode_compact_u16_encode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L254>)

Encodes a 16-bit unsigned integer into a compact binary format using 1 to 3 bytes.
- **Inputs**:
    - ``self``: Pointer to the 16-bit unsigned integer to encode.
    - ``ctx``: Pointer to the `fd_bincode_encode_ctx_t` structure, which contains the current position and end of the data buffer.
- **Logic and Control Flow**:
    - Convert the value pointed to by `self` to an `ulong` named `val`.
    - If `val` is less than 0x80, check if there is space for 1 byte in the buffer; if so, write `val` as a single byte and update the buffer position.
    - If `val` is less than 0x4000, check if there is space for 2 bytes in the buffer; if so, write `val` using two bytes with the first byte's most significant bit set and update the buffer position.
    - Otherwise, check if there is space for 3 bytes in the buffer; if so, write `val` using three bytes with the first two bytes' most significant bits set and update the buffer position.
    - Return `FD_BINCODE_ERR_OVERFLOW` if there is not enough space in the buffer for the required number of bytes.
- **Output**: Returns `FD_BINCODE_SUCCESS` on successful encoding, or `FD_BINCODE_ERR_OVERFLOW` if the buffer does not have enough space.


---
### fd\_bincode\_compact\_u16\_size<!-- {{#callable:fd_bincode_compact_u16_size}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L288>)

Determines the number of bytes needed to encode a `ushort` value in a compact format.
- **Inputs**:
    - `self`: A pointer to a `ushort` value that needs to be evaluated for its compact encoding size.
- **Logic and Control Flow**:
    - Retrieve the value pointed to by `self` and store it in `val`.
    - Check if `val` is less than `0x80UL`; if true, return 1.
    - If the above condition is false, check if `val` is less than `0x4000UL`; if true, return 2.
    - If neither condition is met, return 3.
- **Output**: Returns an `ulong` representing the number of bytes required to encode the `ushort` value in a compact format.


---
### fd\_bincode\_varint\_decode<!-- {{#callable:fd_bincode_varint_decode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L310>)

Decodes a variable-length integer from a byte stream using the `serde_varint` algorithm.
- **Inputs**:
    - ``self``: A pointer to an `ulong` where the decoded integer will be stored.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position and end of the data buffer.
- **Logic and Control Flow**:
    - Initialize `out` to 0 and `shift` to 0.
    - Enter a loop that continues while `shift` is less than 64.
    - Check if the current data position in `ctx` is at or beyond `dataend`; if so, return `FD_BINCODE_ERR_UNDERFLOW`.
    - Read a byte from the current data position in `ctx` and advance the data pointer.
    - Combine the byte with `out` using bitwise operations, shifting it by `shift` bits.
    - Check if the most significant bit of the byte is 0; if so, verify the encoding and return `FD_BINCODE_SUCCESS` if valid, otherwise return `FD_BINCODE_ERR_ENCODING`.
    - Increment `shift` by 7 to prepare for the next byte.
- **Output**: Returns `FD_BINCODE_SUCCESS` on successful decoding, `FD_BINCODE_ERR_UNDERFLOW` if the data buffer is exhausted, or `FD_BINCODE_ERR_ENCODING` if the encoding is invalid.


---
### fd\_bincode\_varint\_decode\_footprint<!-- {{#callable:fd_bincode_varint_decode_footprint}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L341>)

Calculates the footprint of a variable-length integer encoded using the `serde_varint` algorithm without modifying the output variable.
- **Inputs**:
    - `ctx`: A pointer to `fd_bincode_decode_ctx_t`, which contains the current position and end of the data buffer for decoding.
- **Logic and Control Flow**:
    - Initialize `out` to 0 and `shift` to 0.
    - Enter a loop that continues while `shift` is less than 64.
    - Check if the current data position in `ctx` is at or beyond `dataend`; if so, return `FD_BINCODE_ERR_UNDERFLOW`.
    - Read a byte from the current data position and increment the data pointer.
    - Update `out` by OR-ing it with the byte value (masked with 0x7F) shifted left by `shift`.
    - Check if the most significant bit of the byte is 0; if so, perform additional checks:
    - - Verify that the shifted `out` value matches the byte; if not, return `FD_BINCODE_ERR_ENCODING`.
    - - Check for invalid zero byte encoding; if found, return `FD_BINCODE_ERR_ENCODING`.
    - If all checks pass, return `FD_BINCODE_SUCCESS`.
    - Increment `shift` by 7 and continue the loop.
    - If the loop exits without returning, return `FD_BINCODE_ERR_ENCODING`.
- **Output**: Returns an integer status code: `FD_BINCODE_SUCCESS` on success, `FD_BINCODE_ERR_UNDERFLOW` if data is insufficient, or `FD_BINCODE_ERR_ENCODING` if encoding is invalid.


---
### fd\_bincode\_varint\_decode\_unsafe<!-- {{#callable:fd_bincode_varint_decode_unsafe}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L370>)

Decodes a variable-length integer from a byte stream using the `serde_varint` algorithm without safety checks.
- **Inputs**:
    - ``self``: A pointer to an `ulong` where the decoded integer will be stored.
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position in the data buffer.
- **Logic and Control Flow**:
    - Initialize `out` to 0 and `shift` to 0.
    - Enter an infinite loop to process each byte from the data buffer.
    - Read a byte from the current position in the data buffer and increment the data pointer.
    - Combine the lower 7 bits of the byte with `out`, shifted by `shift` bits.
    - Check if the most significant bit of the byte is 0; if so, store `out` in `self` and return.
    - Increment `shift` by 7 to prepare for the next byte.
- **Output**: The function does not return a value but updates the `self` pointer with the decoded integer.


---
### fd\_bincode\_varint\_encode<!-- {{#callable:fd_bincode_varint_encode}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L390>)

Encodes an unsigned long integer into a variable-length format and writes it to a buffer, ensuring it does not exceed the buffer's end.
- **Inputs**:
    - `val`: The unsigned long integer to encode.
    - `ctx`: A pointer to the `fd_bincode_encode_ctx_t` structure, which contains the current position in the data buffer and the end of the buffer.
- **Logic and Control Flow**:
    - Cast `ctx->data` to a `uchar` pointer `ptr` to start writing the encoded value.
    - Enter a loop to encode the value `val` into a variable-length format.
    - Check if writing another byte would exceed the buffer's end (`ctx->dataend`). If so, return `FD_BINCODE_ERR_OVERFLOW`.
    - If `val` is less than `0x80UL`, write it directly to `ptr`, update `ctx->data`, and return `FD_BINCODE_SUCCESS`.
    - Otherwise, write the lower 7 bits of `val` ORed with `0x80UL` to `ptr`, shift `val` right by 7 bits, and continue the loop.
- **Output**: Returns `FD_BINCODE_SUCCESS` on successful encoding, or `FD_BINCODE_ERR_OVERFLOW` if the buffer is exceeded.


---
### fd\_bincode\_varint\_size<!-- {{#callable:fd_bincode_varint_size}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L407>)

Calculates the number of bytes needed to encode a given unsigned long integer using a variable-length encoding scheme.
- **Inputs**:
    - `val`: An unsigned long integer to determine the encoded size for.
- **Logic and Control Flow**:
    - Initialize `sz` to 0 to keep track of the number of bytes needed.
    - Enter an infinite loop to process the value `val`.
    - Check if `val` is less than 0x80UL; if true, return `sz + 1` as the size, since the value fits in one byte.
    - If `val` is not less than 0x80UL, increment `sz` by 1 and right-shift `val` by 7 bits to process the next 7 bits in the next iteration.
- **Output**: Returns the number of bytes required to encode the input value `val` using the variable-length encoding.


---
### fd\_archive\_encode\_setup\_length<!-- {{#callable:fd_archive_encode_setup_length}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L451>)

Prepares the encoding context by reserving space for a length field and updating the data pointer.
- **Inputs**:
    - `ctx`: A pointer to an `fd_bincode_encode_ctx_t` structure, which contains the current position and end of the data buffer.
    - `offset_out`: A pointer to a `void*` where the function will store the current data pointer position, which is the start of the reserved space for the length field.
- **Logic and Control Flow**:
    - Cast the `ctx->data` pointer to an `uchar*` and store it in `ptr`.
    - Check if adding the size of a `uint` to `ptr` exceeds `ctx->dataend`. If true, return `FD_BINCODE_ERR_OVERFLOW`.
    - Store the current `ptr` value in `*offset_out` to mark the start of the reserved space for the length field.
    - Advance `ctx->data` by the size of a `uint` to skip over the reserved space.
    - Return `FD_BINCODE_SUCCESS` to indicate successful setup.
- **Output**: Returns `FD_BINCODE_SUCCESS` on success or `FD_BINCODE_ERR_OVERFLOW` if there is not enough space in the buffer.


---
### fd\_archive\_encode\_set\_length<!-- {{#callable:fd_archive_encode_set_length}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L461>)

Calculates and sets the length of encoded data in a buffer.
- **Inputs**:
    - ``ctx``: A pointer to `fd_bincode_encode_ctx_t`, which contains the current position in the data buffer.
    - ``offset``: A pointer to a memory location where the length of the encoded data will be stored.
- **Logic and Control Flow**:
    - Calculate the length of the encoded data by subtracting the sum of `offset` and the size of `uint` from the current position in the data buffer (`ctx->data`).
    - Store the calculated length at the memory location pointed to by `offset`.
- **Output**: Returns `FD_BINCODE_SUCCESS` to indicate successful execution.


---
### fd\_archive\_decode\_setup\_length<!-- {{#callable:fd_archive_decode_setup_length}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L466>)

Sets up the decoding of a length-prefixed data segment by updating the context and storing the current data pointer.
- **Inputs**:
    - `ctx`: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position and end of the data buffer.
    - `offset_out`: A pointer to a `void*` where the function will store the current data pointer for later use.
- **Logic and Control Flow**:
    - Cast the `ctx->data` pointer to an `uchar*` and store it in `ptr`.
    - Check if the data buffer has enough space to read a `uint` by comparing `ptr + sizeof(uint)` with `ctx->dataend`.
    - If there is not enough space, return `FD_BINCODE_ERR_UNDERFLOW`.
    - Store the current data pointer in `offset_out`.
    - Advance the `ctx->data` pointer by `sizeof(uint)` bytes.
    - Return `FD_BINCODE_SUCCESS`.
- **Output**: Returns `FD_BINCODE_SUCCESS` if the setup is successful, otherwise returns `FD_BINCODE_ERR_UNDERFLOW` if there is not enough data to read a `uint`.


---
### fd\_archive\_decode\_check\_length<!-- {{#callable:fd_archive_decode_check_length}} -->
[View Source →](<../../../../../src/flamenco/types/fd_bincode.h#L476>)

Validates that the length of the decoded data matches the expected length.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_bincode_decode_ctx_t` structure that contains the current position and end of the data buffer.
    - ``offset``: A pointer to a memory location where the expected length of the data is stored.
- **Logic and Control Flow**:
    - Retrieve the expected length from the memory location pointed to by `offset`.
    - Calculate the actual length of the data by subtracting the sum of `offset` and the size of a `uint` from the current position in the data buffer (`ctx->data`).
    - Compare the expected length with the actual length.
    - If they are not equal, return `FD_BINCODE_ERR_ENCODING`.
    - If they are equal, return `FD_BINCODE_SUCCESS`.
- **Output**: Returns `FD_BINCODE_SUCCESS` if the lengths match, otherwise returns `FD_BINCODE_ERR_ENCODING`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)