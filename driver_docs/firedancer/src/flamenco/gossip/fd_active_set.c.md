<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements functions for managing an active set with bloom filters and peer rotation in a gossip protocol.

# Purpose
The code defines a set of functions for managing an "active set" data structure, which is used to handle a collection of network peers. The primary components include functions for creating, joining, and manipulating the active set. The [`fd_active_set_new`](<#fd_active_set_new>) function initializes a new active set in shared memory, aligning it properly and setting up bloom filters for each peer. The [`fd_active_set_join`](<#fd_active_set_join>) function allows a process to join an existing active set, verifying its integrity through a magic number check. The [`fd_active_set_nodes`](<#fd_active_set_nodes>) function retrieves a list of nodes from the active set based on certain criteria, while [`fd_active_set_node_pubkey`](<#fd_active_set_node_pubkey>) returns the public key of a specific peer. The [`fd_active_set_prune`](<#fd_active_set_prune>) function updates the bloom filters to reflect changes in peer connectivity, and [`fd_active_set_rotate`](<#fd_active_set_rotate>) manages the rotation of peers within the active set, ensuring that the set remains up-to-date with the current network state.

The code is structured to provide a narrow functionality focused on managing network peers using bloom filters for efficient membership testing. It includes both public and private headers, indicating that it is part of a larger library or system. The functions defined in this file are intended to be used by other parts of the system to manage peer connectivity and state, with a focus on memory alignment and efficient data handling. The use of bloom filters suggests that the system is designed to handle a large number of peers with minimal memory overhead.
# Imports and Dependencies

---
- `fd_active_set.h`
- `fd_active_set_private.h`


# Functions

---
### fd\_active\_set\_align<!-- {{#callable:fd_active_set_align}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L4>)

Returns the alignment requirement for an active set.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the value of the macro `FD_ACTIVE_SET_ALIGN`.
- **Output**: The alignment requirement for an active set as defined by `FD_ACTIVE_SET_ALIGN`.


---
### fd\_active\_set\_footprint<!-- {{#callable:fd_active_set_footprint}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L9>)

Calculates the memory footprint required for an active set structure with associated Bloom filters.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT`.
    - Append the size of `fd_active_set_t` to `l` with alignment `FD_ACTIVE_SET_ALIGN`.
    - Append the size of 25 sets of 12 Bloom filters to `l` with alignment `FD_BLOOM_ALIGN`, using [`fd_bloom_footprint`](<fd_bloom.c.md#fd_bloom_footprint>) to calculate the size of each Bloom filter with parameters 0.1 and 32768.
    - Finalize the layout `l` with alignment `FD_ACTIVE_SET_ALIGN` and return the result.
- **Output**: Returns the total memory footprint as an `ulong` value.
- **Functions Called**:
    - [`fd_bloom_footprint`](<fd_bloom.c.md#fd_bloom_footprint>)


---
### fd\_active\_set\_new<!-- {{#callable:fd_active_set_new}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L18>)

Initializes a new active set structure in shared memory with bloom filters for peer nodes.
- **Inputs**:
    - ``shmem``: Pointer to shared memory where the active set will be initialized.
    - ``rng``: Pointer to a random number generator used for initializing bloom filters.
- **Logic and Control Flow**:
    - Check if `shmem` is NULL; if so, log a warning and return NULL.
    - Check if `shmem` is aligned according to [`fd_active_set_align`](<#fd_active_set_align>); if not, log a warning and return NULL.
    - Calculate the bloom filter footprint using [`fd_bloom_footprint`](<fd_bloom.c.md#fd_bloom_footprint>) with parameters 0.1 and 32768.
    - Initialize scratch allocation with `FD_SCRATCH_ALLOC_INIT` using `shmem`.
    - Allocate memory for `fd_active_set_t` and bloom filters using `FD_SCRATCH_ALLOC_APPEND`.
    - Verify the final allocation size with `FD_SCRATCH_ALLOC_FINI` to ensure it matches the expected footprint.
    - Assign the random number generator `rng` to the active set structure.
    - Iterate over 25 entries, initializing each entry's `nodes_idx` and `nodes_len` to 0.
    - For each entry, iterate over 12 nodes, creating and joining a bloom filter for each node.
    - If bloom filter creation fails, log a warning and return NULL.
    - Update the bloom filter pointer `_blooms` by the bloom footprint size after each node initialization.
    - Use memory fences `FD_COMPILER_MFENCE` to ensure memory operations are complete before setting the magic number.
    - Set the magic number of the active set to `FD_ACTIVE_SET_MAGIC` using `FD_VOLATILE`.
    - Return the pointer to the initialized active set structure.
- **Output**: Returns a pointer to the newly initialized `fd_active_set_t` structure, or NULL if an error occurs.
- **Functions Called**:
    - [`fd_active_set_align`](<#fd_active_set_align>)
    - [`fd_bloom_footprint`](<fd_bloom.c.md#fd_bloom_footprint>)
    - [`fd_active_set_footprint`](<#fd_active_set_footprint>)
    - [`fd_bloom_join`](<fd_bloom.c.md#fd_bloom_join>)
    - [`fd_bloom_new`](<fd_bloom.c.md#fd_bloom_new>)


---
### fd\_active\_set\_join<!-- {{#callable:fd_active_set_join}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L62>)

Validates and returns a pointer to an `fd_active_set_t` structure if the input is correctly aligned and initialized.
- **Inputs**:
    - `shas`: A pointer to a memory location that is expected to contain an `fd_active_set_t` structure.
- **Logic and Control Flow**:
    - Check if `shas` is NULL; if true, log a warning and return NULL.
    - Check if `shas` is aligned according to [`fd_active_set_align`](<#fd_active_set_align>); if not, log a warning and return NULL.
    - Cast `shas` to an `fd_active_set_t` pointer and store it in `as`.
    - Check if the `magic` field of `as` equals `FD_ACTIVE_SET_MAGIC`; if not, log a warning and return NULL.
    - Return the `as` pointer.
- **Output**: A pointer to an `fd_active_set_t` structure if all checks pass, otherwise NULL.
- **Functions Called**:
    - [`fd_active_set_align`](<#fd_active_set_align>)


---
### fd\_active\_set\_nodes<!-- {{#callable:fd_active_set_nodes}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L84>)

Identifies and returns active nodes from an active set based on identity and origin stakes, while considering bloom filter membership and specific conditions.
- **Inputs**:
    - ``active_set``: A pointer to the `fd_active_set_t` structure representing the active set of nodes.
    - ``identity_pubkey``: A pointer to a 32-byte array representing the public key of the identity.
    - ``identity_stake``: An unsigned long integer representing the stake associated with the identity.
    - ``origin``: A pointer to a 32-byte array representing the origin's public key.
    - ``origin_stake``: An unsigned long integer representing the stake associated with the origin.
    - ``ignore_prunes_if_peer_is_origin``: An integer flag indicating whether to ignore prunes if the peer is the origin.
    - ``out_nodes``: An array of unsigned long integers with a static size of 12, used to store the indices of active nodes.
- **Logic and Control Flow**:
    - Calculate the `stake_bucket` using the minimum of `identity_stake` and `origin_stake` and retrieve the corresponding entry from `active_set`.
    - Determine if `identity_pubkey` is equal to `origin` by comparing the two arrays.
    - Initialize `out_idx` to zero to track the number of active nodes identified.
    - Iterate over the nodes in the entry, using a modulo operation to wrap around the node index.
    - For each node, check if it should be pushed to `out_nodes` based on bloom filter membership and specific conditions (`must_push_if_peer_is_origin` and `must_push_own_values`).
    - If the node meets the criteria, add its index to `out_nodes` and increment `out_idx`.
- **Output**: Returns the number of active nodes identified, stored in `out_idx`.
- **Functions Called**:
    - [`fd_active_set_stake_bucket`](<fd_active_set_private.h.md#fd_active_set_stake_bucket>)
    - [`fd_bloom_contains`](<fd_bloom.c.md#fd_bloom_contains>)


---
### fd\_active\_set\_node\_pubkey<!-- {{#callable:fd_active_set_node_pubkey}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L109>)

Retrieves the public key of a node from an active set based on a given peer index.
- **Inputs**:
    - `active_set`: A pointer to an `fd_active_set_t` structure representing the active set from which to retrieve the node's public key.
    - `peer_idx`: An unsigned long integer representing the index of the peer whose public key is to be retrieved.
- **Logic and Control Flow**:
    - Calculate `bucket` as the integer division of `peer_idx` by `FD_ACTIVE_SET_PEERS_PER_ENTRY`.
    - Calculate `idx` as the remainder of `peer_idx` divided by `FD_ACTIVE_SET_PEERS_PER_ENTRY`.
    - Check if `bucket` is greater than or equal to `FD_ACTIVE_SET_STAKE_ENTRIES`; if true, log an error and exit.
    - Check if `idx` is greater than or equal to the number of nodes in the specified bucket; if true, log an error and exit.
    - Return the public key of the node at the calculated `bucket` and `idx`.
- **Output**: A constant pointer to an unsigned character array representing the public key of the specified node.


---
### fd\_active\_set\_prune<!-- {{#callable:fd_active_set_prune}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L124>)

Prunes an active set by inserting the origin into the bloom filter of a node if the node's public key matches the push destination.
- **Inputs**:
    - ``active_set``: A pointer to the `fd_active_set_t` structure representing the active set.
    - ``push_dest``: A pointer to a 32-byte array representing the destination public key to check against nodes in the active set.
    - ``origin``: A pointer to a 32-byte array representing the origin public key to insert into the bloom filter if conditions are met.
    - ``origin_stake``: An unsigned long representing the stake associated with the origin.
    - ``identity_pubkey``: A pointer to a 32-byte array representing the identity public key to compare with the origin.
    - ``identity_stake``: An unsigned long representing the stake associated with the identity.
- **Logic and Control Flow**:
    - Check if `identity_pubkey` is equal to `origin` using `memcmp`; if true, return immediately.
    - Calculate the stake bucket using [`fd_active_set_stake_bucket`](<fd_active_set_private.h.md#fd_active_set_stake_bucket>) with the minimum of `identity_stake` and `origin_stake`.
    - Iterate over the nodes in the calculated bucket (up to 12 nodes).
    - For each node, check if the node's public key matches `push_dest` using `memcmp`.
    - If a match is found, insert `origin` into the node's bloom filter using [`fd_bloom_insert`](<fd_bloom.c.md#fd_bloom_insert>) and return.
- **Output**: No output is returned; the function modifies the bloom filter of a node in the active set if conditions are met.
- **Functions Called**:
    - [`fd_active_set_stake_bucket`](<fd_active_set_private.h.md#fd_active_set_stake_bucket>)
    - [`fd_bloom_insert`](<fd_bloom.c.md#fd_bloom_insert>)


---
### fd\_active\_set\_rotate<!-- {{#callable:fd_active_set_rotate}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_active_set.c#L142>)

Replaces a peer in a randomly selected bucket of the active set with a new peer from the CRDS, updating the bloom filter and public key.
- **Inputs**:
    - ``active_set``: A pointer to the `fd_active_set_t` structure, which contains the active set of peers.
    - ``crds``: A pointer to the `fd_crds_t` structure, which contains the CRDS (Contact Record Directory Service) data.
- **Logic and Control Flow**:
    - Calculate the number of bloom filter items using the maximum of the peer count from `crds` and 512.
    - Select a random bucket from the active set using the random number generator in `active_set`.
    - Retrieve the entry corresponding to the selected bucket.
    - If the entry's `nodes_len` is 12, set `replace_idx` to `nodes_idx`, increment `nodes_idx`, and add the public key of the node at `replace_idx` to the CRDS bucket.
    - If the entry's `nodes_len` is less than 12, set `replace_idx` to `nodes_len`.
    - Retrieve the peer to replace using `replace_idx`.
    - Sample and remove a new peer from the CRDS bucket; if no peer is available, return `ULONG_MAX`.
    - Initialize the bloom filter for the replacement peer with the calculated number of items.
    - Insert the new peer's public key into the bloom filter and copy the public key to the replacement peer.
    - Update the entry's `nodes_len` to the minimum of `nodes_len + 1` and 12.
    - Return the calculated index based on the bucket and `replace_idx`.
- **Output**: Returns the index of the replaced peer in the format `bucket*12 + replace_idx`, or `ULONG_MAX` if no new peer is available.
- **Functions Called**:
    - [`fd_crds_peer_count`](<crds/fd_crds.c.md#fd_crds_peer_count>)
    - [`fd_crds_bucket_add`](<crds/fd_crds.c.md#fd_crds_bucket_add>)
    - [`fd_crds_bucket_sample_and_remove`](<crds/fd_crds.c.md#fd_crds_bucket_sample_and_remove>)
    - [`fd_bloom_initialize`](<fd_bloom.c.md#fd_bloom_initialize>)
    - [`fd_bloom_insert`](<fd_bloom.c.md#fd_bloom_insert>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)