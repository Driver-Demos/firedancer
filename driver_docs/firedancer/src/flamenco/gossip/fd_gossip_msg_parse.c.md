<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Parses various types of gossip messages, including CRDS values, pull requests, and ping/pong messages.

# Purpose
The code is a C source file that implements parsing functions for a gossip protocol. It is designed to handle various types of gossip messages, such as pull requests, pull responses, push messages, prune messages, ping, and pong messages. The file includes several parsing functions that extract and validate data from a payload, which is a byte array representing a serialized message. The parsing functions use macros and utility functions to check conditions, manage offsets, and ensure data integrity during the parsing process.

The file defines several structures and functions to parse different types of gossip messages, each associated with a specific tag. The main function, [`fd_gossip_msg_parse`](<#fd_gossip_msg_parse>), determines the type of message based on its tag and delegates the parsing to the appropriate function. Each parsing function extracts specific fields from the payload, such as public keys, wallclock times, and other message-specific data, while performing checks to ensure the data is valid and within expected bounds. The code also includes utility functions for decoding variable-length integers and bit vectors, which are used in the parsing process. The file is intended to be part of a larger system that processes gossip messages, likely in a distributed network context.
# Imports and Dependencies

---
- `fd_gossip_private.h`
- `../../ballet/txn/fd_compact_u16.h`
- `../../util/tmpl/fd_set.c`


# Global Variables

---
### value
- **Type**: `ulong`
- **Description**: `value` is a global variable of type `ulong` initialized to 0UL. It is used to accumulate the decoded value from a variable-length integer in the `decode_u64_varint` function.
- **Use**: Accumulates the decoded value from a variable-length integer in the `decode_u64_varint` function.


---
### shift
- **Type**: `ulong`
- **Description**: `shift` is a variable of type `ulong` initialized to 0U. It is used in the `decode_u64_varint` function to track the bit position for shifting operations.
- **Use**: Used to accumulate the bit shift amount when decoding a variable-length integer from the payload.


# Data Structures

---
### slot\_hash\_pair
- **Type**: ``struct``
- **Members**:
    - ``slot``: An unsigned long integer representing a slot.
    - ``hash``: An array of 32 unsigned characters representing a hash.
- **Description**: A `slot_hash_pair` is a packed structure that contains a `slot` and a `hash`. The `slot` is an unsigned long integer that typically represents a position or index, while the `hash` is a fixed-size array of 32 bytes used to store a hash value. This structure is used to associate a specific slot with its corresponding hash value, which can be useful in contexts such as verifying data integrity or tracking changes over time.


---
### slot\_hash\_pair\_t
- **Type**: ``struct``
- **Members**:
    - ``slot``: An unsigned long integer representing a slot.
    - ``hash``: An array of 32 unsigned characters representing a hash.
- **Description**: A `slot_hash_pair_t` is a packed structure that contains a `slot` and a `hash`. The `slot` is an unsigned long integer, and the `hash` is a 32-byte array of unsigned characters. This structure is used to associate a specific slot with its corresponding hash value, which is useful in contexts where both the slot and its hash need to be stored or transmitted together.


---
### ipv6\_addr
- **Type**: ``struct``
- **Members**:
    - ``hi``: Stores the high-order 64 bits of the IPv6 address.
    - ``lo``: Stores the low-order 64 bits of the IPv6 address.
- **Description**: Represents an IPv6 address using two `ulong` fields, `hi` and `lo`, to store the high-order and low-order 64 bits of the address, respectively. This structure allows for efficient manipulation and storage of IPv6 addresses in a compact form.


---
### ipv6\_addr\_t
- **Type**: ``struct``
- **Members**:
    - ``hi``: The upper 64 bits of the IPv6 address.
    - ``lo``: The lower 64 bits of the IPv6 address.
- **Description**: Represents an IPv6 address using two 64-bit unsigned long integers to store the high and low parts of the address. This structure allows for efficient storage and manipulation of IPv6 addresses in a compact form.


# Functions

---
### decode\_bitvec\_impl<!-- {{#callable:decode_bitvec_impl}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L85>)

Decodes a bit vector from a payload and updates output parameters with the bit vector's offset, capacity, and count.
- **Inputs**:
    - ``payload``: Pointer to the input data buffer containing the bit vector.
    - ``payload_sz``: Size of the input data buffer.
    - ``start_offset``: Starting offset in the payload from where to begin decoding.
    - ``out_bits_offset``: Pointer to store the offset of the bit vector within the payload.
    - ``out_bits_cap``: Pointer to store the capacity of the bit vector.
    - ``out_bits_cnt``: Pointer to store the count of bits in the bit vector.
    - ``bits_per_element``: Number of bits per element in the bit vector.
- **Logic and Control Flow**:
    - Initialize the decoding process with `CHECK_INIT` macro to set up the payload and offset variables.
    - Check if there is at least one byte left in the payload using `CHECK_LEFT(1U)` and load the `has_bits` flag from the payload.
    - If `has_bits` is zero, set `out_bits_offset`, `out_bits_cap`, and `out_bits_cnt` to zero and return the number of bytes consumed.
    - Calculate the element size in bytes as `bits_per_element/8U`.
    - Check if there are at least 8 bytes left in the payload, load the `bits_cap` from the payload, and increment the cursor by 8 bytes.
    - Ensure that `bits_cap` does not cause an overflow when multiplied by `elem_sz`.
    - Check if there are enough bytes left for the bit vector data, calculate `bits_offset`, and increment the cursor by `bits_cap*elem_sz`.
    - Check if there are at least 8 bytes left, load the `bits_cnt` from the payload, and increment the cursor by 8 bytes.
    - Ensure that `bits_cnt` is less than or equal to `bits_cap*bits_per_element`.
    - Update the output pointers with the calculated `bits_offset`, `bits_cap`, and `bits_cnt`.
    - Return the number of bytes consumed from the payload.
- **Output**: Returns the number of bytes consumed from the payload if the bit vector is valid, otherwise returns 0.


---
### decode\_bitvec\_u64<!-- {{#callable:decode_bitvec_u64}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L122>)

Calls [`decode_bitvec_impl`](<#decode_bitvec_impl>) to decode a bit vector from a payload with 64 bits per element.
- **Inputs**:
    - ``payload``: A pointer to the input data buffer containing the bit vector.
    - ``payload_sz``: The size of the input data buffer in bytes.
    - ``start_offset``: The starting offset in the payload from where to begin decoding.
    - ``out_bits_offset``: A pointer to store the offset of the decoded bits in the payload.
    - ``out_bits_cap``: A pointer to store the capacity of the decoded bit vector.
    - ``out_bits_cnt``: A pointer to store the count of bits in the decoded bit vector.
- **Logic and Control Flow**:
    - Calls [`decode_bitvec_impl`](<#decode_bitvec_impl>) with the provided arguments and a fixed `bits_per_element` value of 64.
    - Returns the result of the [`decode_bitvec_impl`](<#decode_bitvec_impl>) function call.
- **Output**: Returns the number of bytes consumed from the payload if the bit vector is valid, or 0 if it is not.
- **Functions Called**:
    - [`decode_bitvec_impl`](<#decode_bitvec_impl>)


---
### decode\_bitvec\_u8<!-- {{#callable:decode_bitvec_u8}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L132>)

Calls [`decode_bitvec_impl`](<#decode_bitvec_impl>) to decode a bit vector from a payload with 8 bits per element.
- **Inputs**:
    - ``payload``: Pointer to the input data buffer containing the bit vector.
    - ``payload_sz``: Size of the input data buffer in bytes.
    - ``start_offset``: Offset in the buffer where the bit vector starts.
    - ``out_bits_offset``: Pointer to store the offset of the decoded bits in the buffer.
    - ``out_bits_cap``: Pointer to store the capacity of the decoded bit vector.
    - ``out_bits_cnt``: Pointer to store the count of bits in the decoded bit vector.
- **Logic and Control Flow**:
    - Calls [`decode_bitvec_impl`](<#decode_bitvec_impl>) with the provided arguments and a fixed `bits_per_element` value of 8.
    - Returns the result of [`decode_bitvec_impl`](<#decode_bitvec_impl>), which is the number of bytes consumed if successful, or 0 if there is an error.
- **Output**: Returns the number of bytes consumed from the payload if the bit vector is valid, or 0 if there is an error.
- **Functions Called**:
    - [`decode_bitvec_impl`](<#decode_bitvec_impl>)


---
### fd\_gossip\_msg\_crds\_legacy\_contact\_info\_parse<!-- {{#callable:fd_gossip_msg_crds_legacy_contact_info_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L142>)

Parses a legacy contact information message from a payload and updates the CRDS value structure.
- **Inputs**:
    - `crds_val`: A pointer to a `fd_gossip_view_crds_value_t` structure where parsed data will be stored.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data.
    - `start_offset`: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Check if there are at least 32 bytes left in the payload and set `crds_val->pubkey_off` to the current offset, then increment the offset by 32 bytes.
    - Iterate 10 times to parse IP addresses and ports, checking if each address is IPv6 or IPv4 and incrementing the offset accordingly.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
    - Increment the offset by 2 bytes for the shred version.
    - Return the number of bytes consumed during parsing.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### fd\_gossip\_msg\_crds\_vote\_parse<!-- {{#callable:fd_gossip_msg_crds_vote_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L163>)

Parses a CRDS vote message from a payload and updates the `crds_val` structure with the parsed data.
- **Inputs**:
    - `crds_val`: A pointer to an `fd_gossip_view_crds_value_t` structure where the parsed vote data will be stored.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data.
    - `start_offset`: The starting offset in the payload from where to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Check if there is at least 1 byte left in the payload and load the vote index into `crds_val->vote->index`, then increment the cursor by 1.
    - Verify that the vote index is less than `FD_GOSSIP_VOTE_IDX_MAX`.
    - Check if there are at least 32 bytes left and set `crds_val->pubkey_off` to the current offset, then increment the cursor by 32.
    - Parse the transaction size using `fd_txn_parse_core` and store the transaction offset and size in `crds_val->vote->txn_off` and `crds_val->vote->txn_sz`, respectively, then increment the cursor by the transaction size.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### fd\_gossip\_msg\_crds\_lowest\_slot\_parse<!-- {{#callable:fd_gossip_msg_crds_lowest_slot_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L182>)

Parses a gossip message payload to extract and validate the lowest slot information from a CRDS value.
- **Inputs**:
    - `crds_val`: A pointer to an `fd_gossip_view_crds_value_t` structure where the parsed CRDS value will be stored.
    - `payload`: A pointer to the payload data to be parsed.
    - `payload_sz`: The size of the payload data in bytes.
    - `start_offset`: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up the payload, size, and offset.
    - Check if there is at least 1 byte left in the payload and load the first byte into `ix`, then increment the offset by 1.
    - Ensure `ix` is zero, indicating a valid start of the message.
    - Check if there are at least 32 bytes left, set `crds_val->pubkey_off` to the current offset, and increment the offset by 32.
    - Check if there are at least 8 bytes left, load the next byte into `root`, and increment the offset by 8.
    - Ensure `root` is zero, indicating a valid root value.
    - Check if there are at least 8 bytes left, load the next 8 bytes into `crds_val->lowest_slot`, and increment the offset by 8.
    - Ensure `crds_val->lowest_slot` is less than `MAX_SLOT`.
    - Check if there are at least 8 bytes left, load the next 8 bytes into `slots_len`, and increment the offset by 8.
    - Ensure `slots_len` is zero, indicating no slots set.
    - Skip over the deprecated slots set by incrementing the offset by `slots_len*8U`.
    - Check if there are at least 8 bytes left, load the next 8 bytes into `stash_len`, and increment the offset by 8.
    - Ensure `stash_len` is zero, indicating no entries in the deprecated stash vector.
    - Load the wallclock time into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
- **Output**: Returns the number of bytes consumed from the payload if parsing is successful, or 0 if there is a parsing error.


---
### fd\_gossip\_msg\_crds\_account\_hashes\_parse<!-- {{#callable:fd_gossip_msg_crds_account_hashes_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L218>)

Parses a CRDS account hashes message from a payload and updates the CRDS value structure with the parsed data.
- **Inputs**:
    - `crds_val`: A pointer to an `fd_gossip_view_crds_value_t` structure where the parsed data will be stored.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data.
    - `start_offset`: The starting offset in the payload from where to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Check if there are at least 32 bytes left in the payload and set `crds_val->pubkey_off` to the current offset, then increment the offset by 32 bytes.
    - Check if there are at least 8 bytes left in the payload, load the `hashes_len` from the current cursor position, and increment the offset by 8 bytes.
    - Cast the current cursor position to a `slot_hash_pair_t` pointer named `hashes`.
    - Ensure `hashes_len` does not cause an overflow when multiplied by 40 and increment the offset by `hashes_len * 40` bytes.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
    - Iterate over each hash in `hashes` and check that each `slot` is less than `MAX_SLOT`.
- **Output**: Returns the number of bytes consumed from the payload if successful, or 0 if a parsing error occurs.


---
### fd\_gossip\_msg\_crds\_epoch\_slots\_parse<!-- {{#callable:fd_gossip_msg_crds_epoch_slots_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L238>)

Parses epoch slots data from a payload into a CRDS value structure.
- **Inputs**:
    - ``crds_val``: A pointer to an `fd_gossip_view_crds_value_t` structure where parsed data will be stored.
    - ``payload``: A pointer to the payload data to parse.
    - ``payload_sz``: The size of the payload data.
    - ``start_offset``: The starting offset in the payload from which to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up payload and offset variables.
    - Check if there is enough data left in the payload for the epoch slots index and load it into `crds_val->epoch_slots->index`.
    - Verify that the index is less than `FD_GOSSIP_EPOCH_SLOTS_IDX_MAX`.
    - Load the public key offset into `crds_val->pubkey_off` and increment the cursor by 32 bytes.
    - Load the number of slots (`slots_len`) and increment the cursor by 8 bytes.
    - Iterate over each slot in `slots_len`.
    - For each slot, check if it is uncompressed by loading a 4-byte value `is_uncompressed`.
    - If `is_uncompressed` is true, load `first_slot` and `num`, then decode a bit vector using [`decode_bitvec_u8`](<#decode_bitvec_u8>).
    - Verify constraints on `first_slot`, `num`, and the decoded bit vector's bit count.
    - If `is_uncompressed` is false, load `first_slot`, `num`, and `compressed_len`, then increment the cursor by `compressed_len`.
    - Load the wallclock time into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
- **Output**: Returns the number of bytes consumed from the payload during parsing.
- **Functions Called**:
    - [`decode_bitvec_u8`](<#decode_bitvec_u8>)


---
### fd\_gossip\_msg\_crds\_legacy\_version\_parse<!-- {{#callable:fd_gossip_msg_crds_legacy_version_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L282>)

Parses a legacy version CRDS message from a payload and updates the CRDS value structure with parsed data.
- **Inputs**:
    - `crds_val`: A pointer to a `fd_gossip_view_crds_value_t` structure where parsed data will be stored.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data.
    - `start_offset`: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Check if there are at least 32 bytes left in the payload and set `crds_val->pubkey_off` to the current offset, then increment the offset by 32 bytes.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
    - Increment the offset by 6 bytes to account for major, minor, and patch version numbers, each stored as a 16-bit unsigned integer.
    - Check if there is at least 1 byte left in the payload to determine if a commit hash is present, and increment the offset by 1 byte.
    - If a commit hash is present, increment the offset by 4 additional bytes.
    - Return the number of bytes consumed during parsing.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### fd\_gossip\_msg\_crds\_version\_parse<!-- {{#callable:fd_gossip_msg_crds_version_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L299>)

Parses a CRDS version message from a payload, updating the CRDS value and returning the number of bytes consumed.
- **Inputs**:
    - `crds_val`: A pointer to a `fd_gossip_view_crds_value_t` structure where the parsed CRDS value will be stored.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data in bytes.
    - `start_offset`: The starting offset in the payload from which to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing by setting up local variables with `CHECK_INIT` macro.
    - Call [`fd_gossip_msg_crds_legacy_version_parse`](<#fd_gossip_msg_crds_legacy_version_parse>) to parse the legacy version part of the CRDS message and increment the offset by the number of bytes consumed.
    - Increment the offset by 4 bytes to account for the feature set.
    - Return the total number of bytes consumed from the start offset.
- **Output**: Returns the number of bytes consumed from the payload during parsing.
- **Functions Called**:
    - [`fd_gossip_msg_crds_legacy_version_parse`](<#fd_gossip_msg_crds_legacy_version_parse>)


---
### fd\_gossip\_msg\_crds\_node\_instance\_parse<!-- {{#callable:fd_gossip_msg_crds_node_instance_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L310>)

Parses a CRDS node instance message from a payload and updates the `crds_val` structure with the parsed data.
- **Inputs**:
    - `crds_val`: A pointer to an `fd_gossip_view_crds_value_t` structure where the parsed data will be stored.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data.
    - `start_offset`: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Check if there are at least 32 bytes left in the payload using `CHECK_LEFT(32U)` and set `crds_val->pubkey_off` to the current offset, then increment the offset by 32 bytes.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
    - Increment the offset by 8 bytes for an unused timestamp using `CHECKED_INC(8U)`.
    - Check if there are at least 8 bytes left in the payload using `CHECK_LEFT(8U)` and load the node instance token into `crds_val->node_instance->token`, then increment the offset by 8 bytes.
    - Return the number of bytes consumed from the payload.
- **Output**: Returns the number of bytes consumed from the payload.


---
### fd\_gossip\_msg\_crds\_duplicate\_shred\_parse<!-- {{#callable:fd_gossip_msg_crds_duplicate_shred_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L323>)

Parses a duplicate shred message from a gossip payload and updates the CRDS value structure with parsed data.
- **Inputs**:
    - ``crds_val``: A pointer to a `fd_gossip_view_crds_value_t` structure where parsed data will be stored.
    - ``payload``: A pointer to the payload data to parse.
    - ``payload_sz``: The size of the payload data.
    - ``start_offset``: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Load and store a 2-byte index into `ds->index` and increment the cursor by 2 bytes.
    - Check if `ds->index` is less than `FD_GOSSIP_DUPLICATE_SHRED_IDX_MAX`.
    - Load and store a 32-byte public key offset into `crds_val->pubkey_off` and increment the cursor by 32 bytes.
    - Load and store an 8-byte slot into `ds->slot` and increment the cursor by 8 bytes.
    - Skip 5 bytes (4 unused + 1 shred type) using `CHECKED_INC`.
    - Load and store a 1-byte number of chunks into `ds->num_chunks` and increment the cursor by 1 byte.
    - Load and store a 1-byte chunk index into `ds->chunk_index` and increment the cursor by 1 byte.
    - Check if `ds->chunk_index` is less than `ds->num_chunks`.
    - Load and store an 8-byte chunk length into `ds->chunk_len` and increment the cursor by 8 bytes.
    - Store the current cursor offset into `ds->chunk_off` and increment the cursor by `ds->chunk_len` bytes.
    - Return the number of bytes consumed during parsing.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### fd\_gossip\_msg\_crds\_snapshot\_hashes\_parse<!-- {{#callable:fd_gossip_msg_crds_snapshot_hashes_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L348>)

Parses a CRDS snapshot hashes message from a payload and updates the CRDS value structure with offsets and lengths.
- **Inputs**:
    - ``crds_val``: A pointer to a `fd_gossip_view_crds_value_t` structure where parsed data will be stored.
    - ``payload``: A pointer to the payload data to parse.
    - ``payload_sz``: The size of the payload data.
    - ``start_offset``: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Check if there are at least 32 bytes left in the payload, set `crds_val->pubkey_off` to the current offset, and increment the offset by 32 bytes.
    - Check if there are at least 40 bytes left, set `crds_val->snapshot_hashes->full_off` to the current offset, and increment the offset by 40 bytes.
    - Load an `ulong` value from the current cursor position into `incremental_len`, check if it is less than `(ULONG_MAX-39U)/40U` to prevent overflow, and increment the offset by 8 bytes.
    - Check if there are `incremental_len*40U` bytes left, set `crds_val->snapshot_hashes->inc_off` to the current offset, and increment the offset by `incremental_len*40U`.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
    - Set `crds_val->snapshot_hashes->inc_len` to `incremental_len`.
    - Cast the payload at `crds_val->snapshot_hashes->full_off` to a `slot_hash_pair_t` pointer and check if the `slot` is less than `MAX_SLOT`.
    - Cast the payload at `crds_val->snapshot_hashes->inc_off` to a `slot_hash_pair_t` pointer and iterate over `incremental_len` to check if each `slot` is greater than `full_slot` and less than `MAX_SLOT`.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### version\_parse<!-- {{#callable:version_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L376>)

Parses version information from a payload and updates the `fd_contact_info_t` structure with the extracted version details.
- **Inputs**:
    - `ci`: A pointer to an `fd_contact_info_t` structure where the parsed version information will be stored.
    - `payload`: A pointer to the payload data from which the version information will be extracted.
    - `payload_sz`: The size of the payload data in bytes.
    - `start_offset`: The starting offset in the payload from where the parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up local variables and validate initial conditions.
    - Use `READ_CHECKED_COMPACT_U16` macro to read and decode the major version number from the payload, updating the `ci->version.major` field and incrementing the offset by the decoded size.
    - Repeat the above step to read and decode the minor and patch version numbers, updating `ci->version.minor` and `ci->version.patch` fields respectively.
    - Check if there are at least 4 bytes left in the payload using `CHECK_LEFT` before reading the commit hash, then load it into `ci->version.commit` and increment the offset by 4 bytes.
    - Check again for at least 4 bytes left before reading the feature set, load it into `ci->version.feature_set`, and increment the offset by 4 bytes.
    - Read and decode the client version number using `READ_CHECKED_COMPACT_U16`, updating `ci->version.client` and incrementing the offset by the decoded size.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### ipv6\_hash<!-- {{#callable:ipv6_hash}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L425>)

Computes a hash value for an IPv6 address using its high and low parts.
- **Inputs**:
    - ``addr``: A pointer to an `ipv6_addr_t` structure containing the high and low parts of the IPv6 address.
- **Logic and Control Flow**:
    - Compute the hash of the low part of the IPv6 address using `fd_ulong_hash`.
    - XOR the result with the high part of the IPv6 address.
    - Compute the hash of the XOR result using `fd_ulong_hash`.
- **Output**: Returns an unsigned long integer representing the hash value of the IPv6 address.


---
### fd\_gossip\_msg\_crds\_contact\_info\_parse<!-- {{#callable:fd_gossip_msg_crds_contact_info_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L439>)

Parses a CRDS contact info message from a payload and updates the `crds_val` structure with the parsed data.
- **Inputs**:
    - ``crds_val``: A pointer to an `fd_gossip_view_crds_value_t` structure where the parsed contact info will be stored.
    - ``payload``: A pointer to the byte array containing the CRDS contact info message.
    - ``payload_sz``: The size of the `payload` in bytes.
    - ``start_offset``: The starting offset in the `payload` from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up the payload, size, and offset variables.
    - Check if there are at least 32 bytes left in the payload and set `crds_val->pubkey_off` to the current offset, then increment the offset by 32 bytes.
    - Decode a variable-length 64-bit integer from the payload to get the wallclock time, check its validity, and convert it to nanoseconds to store in `crds_val->wallclock_nanos`.
    - Copy the public key from the payload to `ci->pubkey.uc` and set `ci->wallclock_nanos` to the parsed wallclock nanoseconds.
    - Parse and store the instance creation wallclock time and shred version from the payload into `ci`.
    - Call [`version_parse`](<#version_parse>) to parse the version information from the payload and update `ci`.
    - Read and check the number of addresses (`addrs_len`) from the payload, ensuring it does not exceed the maximum allowed addresses.
    - Initialize sets for tracking seen IPv4 and IPv6 addresses, and parse each address from the payload, updating the sets and storing IPv4 addresses in `ip4_addrs`.
    - Read and check the number of sockets (`sockets_len`) from the payload, ensuring it does not exceed the maximum allowed sockets.
    - Initialize sets for tracking socket tags and address indices, and parse each socket from the payload, updating the sets and storing valid sockets in `ci->sockets`.
    - Check that all addresses are referenced at least once across all sockets.
    - Read and skip over any unused extensions in the payload.
    - Return the total number of bytes consumed during parsing.
- **Output**: Returns the number of bytes consumed from the payload if parsing is successful, or 0 if there is a parsing error.
- **Functions Called**:
    - [`version_parse`](<#version_parse>)
    - [`ipv6_hash`](<#ipv6_hash>)


---
### fd\_gossip\_msg\_crds\_last\_voted\_fork\_slots\_parse<!-- {{#callable:fd_gossip_msg_crds_last_voted_fork_slots_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L534>)

Parses a gossip message payload to extract the last voted fork slots information and updates the `crds_val` structure accordingly.
- **Inputs**:
    - ``crds_val``: A pointer to an `fd_gossip_view_crds_value_t` structure where the parsed data will be stored.
    - ``payload``: A pointer to the byte array containing the gossip message payload.
    - ``payload_sz``: The size of the `payload` in bytes.
    - ``start_offset``: The starting offset in the `payload` from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up local variables for payload and offset management.
    - Check if there are at least 32 bytes left in the payload and set `crds_val->pubkey_off` to the current offset, then increment the offset by 32 bytes.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using the `CHECKED_WALLCLOCK_LOAD` macro.
    - Check if there are at least 4 bytes left and load a `uint` value to determine if raw offsets are used, then increment the offset by 4 bytes.
    - If `is_rawoffsets` is false, load the length of slots (`slots_len`) and increment the offset by 8 bytes, then increment the offset by `slots_len * 4` bytes for RunLengthEncoding.
    - If `is_rawoffsets` is true, decode a bit vector using [`decode_bitvec_u8`](<#decode_bitvec_u8>) and increment the offset by the number of bytes consumed.
    - Increment the offset by 42 bytes to account for the last voted slot, last voted hash, and shred version.
    - Return the total number of bytes consumed during parsing.
- **Output**: Returns the number of bytes consumed from the `payload` during parsing.
- **Functions Called**:
    - [`decode_bitvec_u8`](<#decode_bitvec_u8>)


---
### fd\_gossip\_msg\_crds\_restart\_heaviest\_fork\_parse<!-- {{#callable:fd_gossip_msg_crds_restart_heaviest_fork_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L556>)

Parses a gossip message payload to extract and update the CRDS value for the restart of the heaviest fork.
- **Inputs**:
    - ``crds_val``: A pointer to `fd_gossip_view_crds_value_t` where the parsed CRDS value will be stored.
    - ``payload``: A constant pointer to the payload data to be parsed.
    - ``payload_sz``: The size of the payload data in bytes.
    - ``start_offset``: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT`, setting up local variables for payload and offset management.
    - Ensure there are at least 32 bytes left in the payload for the public key offset using `CHECK_LEFT` and update `crds_val->pubkey_off` with the current offset.
    - Increment the offset by 32 bytes using `INC(32U)`.
    - Load the wallclock time in nanoseconds into `crds_val->wallclock_nanos` using `CHECKED_WALLCLOCK_LOAD`.
    - Increment the offset by 50 bytes using `CHECKED_INC(8U+32U+8U+2U)` to account for the last slot, last slot hash, observed stake, and shred version.
    - Return the number of bytes consumed from the payload using `BYTES_CONSUMED`.
- **Output**: Returns the number of bytes consumed from the payload, or 0 if there is a parsing error.


---
### fd\_gossip\_msg\_crds\_data\_parse<!-- {{#callable:fd_gossip_msg_crds_data_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L569>)

Parses a CRDS data message based on the tag in the `crds_val` structure and delegates to the appropriate parsing function.
- **Inputs**:
    - ``crds_val``: A pointer to a `fd_gossip_view_crds_value_t` structure that contains the CRDS value to parse.
    - ``payload``: A pointer to the payload data to parse.
    - ``payload_sz``: The size of the payload data.
    - ``start_offset``: The starting offset in the payload from which to begin parsing.
- **Logic and Control Flow**:
    - Check the `tag` field of the `crds_val` structure to determine the type of CRDS value.
    - Use a `switch` statement to select the appropriate parsing function based on the `tag`.
    - Call the selected parsing function with the provided arguments (`crds_val`, `payload`, `payload_sz`, `start_offset`).
    - If the `tag` is unknown, log a warning and return 0.
- **Output**: Returns the number of bytes consumed during parsing, or 0 if the tag is unknown.
- **Functions Called**:
    - [`fd_gossip_msg_crds_legacy_contact_info_parse`](<#fd_gossip_msg_crds_legacy_contact_info_parse>)
    - [`fd_gossip_msg_crds_vote_parse`](<#fd_gossip_msg_crds_vote_parse>)
    - [`fd_gossip_msg_crds_lowest_slot_parse`](<#fd_gossip_msg_crds_lowest_slot_parse>)
    - [`fd_gossip_msg_crds_account_hashes_parse`](<#fd_gossip_msg_crds_account_hashes_parse>)
    - [`fd_gossip_msg_crds_epoch_slots_parse`](<#fd_gossip_msg_crds_epoch_slots_parse>)
    - [`fd_gossip_msg_crds_legacy_version_parse`](<#fd_gossip_msg_crds_legacy_version_parse>)
    - [`fd_gossip_msg_crds_version_parse`](<#fd_gossip_msg_crds_version_parse>)
    - [`fd_gossip_msg_crds_node_instance_parse`](<#fd_gossip_msg_crds_node_instance_parse>)
    - [`fd_gossip_msg_crds_duplicate_shred_parse`](<#fd_gossip_msg_crds_duplicate_shred_parse>)
    - [`fd_gossip_msg_crds_snapshot_hashes_parse`](<#fd_gossip_msg_crds_snapshot_hashes_parse>)
    - [`fd_gossip_msg_crds_contact_info_parse`](<#fd_gossip_msg_crds_contact_info_parse>)
    - [`fd_gossip_msg_crds_last_voted_fork_slots_parse`](<#fd_gossip_msg_crds_last_voted_fork_slots_parse>)
    - [`fd_gossip_msg_crds_restart_heaviest_fork_parse`](<#fd_gossip_msg_crds_restart_heaviest_fork_parse>)


---
### fd\_gossip\_msg\_crds\_vals\_parse<!-- {{#callable:fd_gossip_msg_crds_vals_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L610>)

Parses an array of CRDS values from a payload starting at a given offset.
- **Inputs**:
    - `crds_values`: An array of `fd_gossip_view_crds_value_t` structures to store parsed CRDS values.
    - `crds_values_len`: The number of CRDS values to parse.
    - `payload`: A pointer to the payload data to parse.
    - `payload_sz`: The size of the payload data.
    - `start_offset`: The starting offset in the payload from which to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro using `payload`, `payload_sz`, and `start_offset`.
    - Iterate over each CRDS value up to `crds_values_len`.
    - For each CRDS value, set `signature_off` to the current offset and increment by 64 bytes.
    - Set the `tag` field by loading 4 bytes from the current cursor position and increment the offset by 4 bytes.
    - Call [`fd_gossip_msg_crds_data_parse`](<#fd_gossip_msg_crds_data_parse>) to parse the CRDS data and store the size of the parsed data.
    - Calculate the total length of the CRDS value as the sum of the parsed data size, 64 bytes for the signature, and 4 bytes for the tag.
    - Increment the current offset by the size of the parsed CRDS data.
- **Output**: Returns the total number of bytes consumed during parsing.
- **Functions Called**:
    - [`fd_gossip_msg_crds_data_parse`](<#fd_gossip_msg_crds_data_parse>)


---
### fd\_gossip\_msg\_ping\_pong\_parse<!-- {{#callable:fd_gossip_msg_ping_pong_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L628>)

Parses a ping or pong message from a gossip protocol payload and updates the view with the offset of the ping/pong data.
- **Inputs**:
    - ``view``: A pointer to an `fd_gossip_view_t` structure where the parsed ping/pong offset will be stored.
    - ``payload``: A constant pointer to the payload data from which the ping/pong message will be parsed.
    - ``payload_sz``: The size of the payload data in bytes.
    - ``start_offset``: The starting offset in the payload from which to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT`, setting up local variables for payload, size, and offset.
    - Assert that the size of `fd_gossip_view_ping_t` is equal to `fd_gossip_view_pong_t` using `FD_STATIC_ASSERT`, ensuring compatibility.
    - Check that there is enough data left in the payload to read a ping/pong message using `CHECK_LEFT`.
    - Set the `ping_pong_off` field of the `view` to the current offset (`CUR_OFFSET`).
    - Increment the current offset by the size of `fd_gossip_view_ping_t` using `INC`.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### fd\_gossip\_pull\_req\_parse<!-- {{#callable:fd_gossip_pull_req_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L643>)

Parses a gossip pull request message from a payload and updates the view with the parsed data.
- **Inputs**:
    - ``view``: A pointer to an `fd_gossip_view_t` structure where the parsed pull request data will be stored.
    - ``payload``: A pointer to the payload data to be parsed.
    - ``payload_sz``: The size of the payload data in bytes.
    - ``start_offset``: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up the payload, size, and offset.
    - Load and store the length of bloom keys from the payload into `pr->bloom_keys_len` and increment the cursor by 8 bytes.
    - Check if `bloom_keys_len` is within a valid range to prevent overflow.
    - Load the bloom keys offset and increment the cursor by the size of the bloom keys.
    - Decode the bloom filter bit vector using [`decode_bitvec_u64`](<#decode_bitvec_u64>) and update `pr->bloom_bits_offset`, `pr->bloom_len`, and `pr->bloom_bits_cnt`.
    - Ensure the bloom filter has at least one element to avoid division by zero errors.
    - Load and store the number of bits set in the bloom filter, the mask, and the mask bits from the payload, incrementing the cursor accordingly.
    - Parse the contact information using [`fd_gossip_msg_crds_vals_parse`](<#fd_gossip_msg_crds_vals_parse>) and update the cursor.
    - Return the total number of bytes consumed during parsing.
- **Output**: Returns the number of bytes consumed from the payload during parsing.
- **Functions Called**:
    - [`decode_bitvec_u64`](<#decode_bitvec_u64>)
    - [`fd_gossip_msg_crds_vals_parse`](<#fd_gossip_msg_crds_vals_parse>)


---
### fd\_gossip\_msg\_crds\_container\_parse<!-- {{#callable:fd_gossip_msg_crds_container_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L675>)

Parses a CRDS container from a gossip message payload and updates the view with the parsed data.
- **Inputs**:
    - ``view``: A pointer to an `fd_gossip_view_t` structure that will be updated with the parsed CRDS container data.
    - ``payload``: A pointer to the payload data to parse.
    - ``payload_sz``: The size of the payload data in bytes.
    - ``start_offset``: The starting offset in the payload from which to begin parsing.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up local variables for payload, size, and offset.
    - Determine the CRDS container type based on the `view->tag` and assign the appropriate container (`view->push` or `view->pull_response`).
    - Check if there are at least 32 bytes left in the payload and set `container->from_off` to the current offset, then increment the offset by 32 bytes.
    - Check if there are at least 8 bytes left in the payload, load the CRDS values length into `container->crds_values_len`, and increment the offset by 8 bytes.
    - Ensure `container->crds_values_len` does not exceed `FD_GOSSIP_MSG_MAX_CRDS`.
    - Call [`fd_gossip_msg_crds_vals_parse`](<#fd_gossip_msg_crds_vals_parse>) to parse the CRDS values and increment the offset by the number of bytes consumed.
    - Return the total number of bytes consumed from the payload.
- **Output**: Returns the number of bytes consumed from the payload if successful, or 0 if there is a parsing error.
- **Functions Called**:
    - [`fd_gossip_msg_crds_vals_parse`](<#fd_gossip_msg_crds_vals_parse>)


---
### fd\_gossip\_msg\_prune\_parse<!-- {{#callable:fd_gossip_msg_prune_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L695>)

Parses a gossip message of type 'prune' from a payload and updates the view with parsed data.
- **Inputs**:
    - ``view``: A pointer to an `fd_gossip_view_t` structure where the parsed prune message data will be stored.
    - ``payload``: A pointer to the payload data from which the prune message will be parsed.
    - ``payload_sz``: The size of the payload data in bytes.
    - ``start_offset``: The starting offset in the payload from where parsing should begin.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro to set up the payload, size, and offset.
    - Check if there are at least 32 bytes left in the payload, then set `outer` to the current cursor position and increment the cursor by 32 bytes.
    - Check if there are at least 32 bytes left, set `prune->pubkey_off` to the current offset, and increment the cursor by 32 bytes.
    - Verify that the 32-byte segment at `outer` matches the segment at `payload + prune->pubkey_off`.
    - Check if there are at least 8 bytes left, load `prune->origins_len` from the cursor, and increment the cursor by 8 bytes.
    - Ensure `prune->origins_len` does not exceed the maximum allowed value to prevent overflow.
    - Check if there are enough bytes left for `prune->origins_len * 32`, set `prune->origins_off` to the current offset, and increment the cursor accordingly.
    - Check if there are at least 64 bytes left, set `prune->signature_off` to the current offset, and increment the cursor by 64 bytes.
    - Check if there are at least 32 bytes left, set `prune->destination_off` to the current offset, and increment the cursor by 32 bytes.
    - Check if there are at least 8 bytes left, load `prune->wallclock` from the cursor, and increment the cursor by 8 bytes.
    - Ensure `prune->wallclock` is less than `WALLCLOCK_MAX_MILLIS`.
    - Convert `prune->wallclock` from milliseconds to nanoseconds and store it in `prune->wallclock_nanos`.
- **Output**: Returns the number of bytes consumed from the payload during parsing.


---
### fd\_gossip\_msg\_parse<!-- {{#callable:fd_gossip_msg_parse}} -->
[View Source →](<../../../../../src/flamenco/gossip/fd_gossip_msg_parse.c#L720>)

Parses a gossip message from a payload and updates the view with the message details.
- **Inputs**:
    - ``view``: A pointer to an `fd_gossip_view_t` structure where the parsed message details will be stored.
    - ``payload``: A pointer to the payload data to be parsed.
    - ``payload_sz``: The size of the payload data in bytes.
- **Logic and Control Flow**:
    - Initialize parsing with `CHECK_INIT` macro, setting up the payload and offset variables.
    - Verify that `payload_sz` does not exceed `FD_GOSSIP_MTU`.
    - Extract the message tag from the first 4 bytes of the payload and increment the cursor.
    - Check if the extracted tag is valid by comparing it to `FD_GOSSIP_MESSAGE_LAST`.
    - Store the tag in the `view->tag` field.
    - Use a switch statement to handle different message types based on the tag:
    - - For `FD_GOSSIP_MESSAGE_PULL_REQUEST`, call [`fd_gossip_pull_req_parse`](<#fd_gossip_pull_req_parse>).
    - - For `FD_GOSSIP_MESSAGE_PULL_RESPONSE` and `FD_GOSSIP_MESSAGE_PUSH`, call [`fd_gossip_msg_crds_container_parse`](<#fd_gossip_msg_crds_container_parse>).
    - - For `FD_GOSSIP_MESSAGE_PRUNE`, call [`fd_gossip_msg_prune_parse`](<#fd_gossip_msg_prune_parse>).
    - - For `FD_GOSSIP_MESSAGE_PING` and `FD_GOSSIP_MESSAGE_PONG`, call [`fd_gossip_msg_ping_pong_parse`](<#fd_gossip_msg_ping_pong_parse>).
    - If the tag is unknown, log a warning and return 0.
    - Ensure that the entire payload has been consumed by checking `payload_sz` against `CUR_OFFSET`.
- **Output**: Returns the number of bytes consumed from the payload if successful, or 0 if there is an error.
- **Functions Called**:
    - [`fd_gossip_pull_req_parse`](<#fd_gossip_pull_req_parse>)
    - [`fd_gossip_msg_crds_container_parse`](<#fd_gossip_msg_crds_container_parse>)
    - [`fd_gossip_msg_prune_parse`](<#fd_gossip_msg_prune_parse>)
    - [`fd_gossip_msg_ping_pong_parse`](<#fd_gossip_msg_ping_pong_parse>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)