<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Test cases for arithmetic and bitwise operations on 32-bit and 64-bit registers with immediate and register operands.

# Purpose
The content is a test suite for verifying the behavior of arithmetic and bitwise operations in a software system, likely an emulator or a virtual machine. Each line represents a test case for a specific operation, such as addition (`add32`, `add64`), subtraction (`sub32`, `sub64`), multiplication (`mul32`, `mul64`), division (`div32`, `div64`), modulus (`mod32`, `mod64`), and byte order conversion (`be{16,32,64}`, `le{16,32,64}`). The test cases specify the operation code (`op`), destination register (`dst`), source register (`src`), offset (`off`), initial register values, immediate values (`imm`), and expected results. The comments indicate the expected outcome, such as overflow, underflow, sign extension, or validation errors (`vfy`) for invalid operations. This file is crucial for ensuring the correctness and reliability of arithmetic and bitwise operations within the system.
# Content Summary
The provided content is a series of test cases for a set of operations on registers, likely for a virtual machine or a low-level programming environment. Each line represents a test case for a specific operation, detailing the operation code, destination and source registers, offsets, initial register values, immediate values, and the expected result after the operation. The operations include addition, subtraction, multiplication, division, and modulus, both with immediate values and between registers. Additionally, there are operations for byte order conversion (big-endian and little-endian).

Key technical details include:

1. **Operation Codes**: Each operation is identified by a unique code (e.g., `op=04` for `add32 reg, imm`). These codes specify the type of arithmetic or logical operation to perform.

2. **Registers**: The operations involve destination (`dst`) and source (`src`) registers, which are specified by numbers (e.g., `dst=0`, `src=1`). The initial values of these registers are provided, and the expected result is shown after the operation.

3. **Immediate Values**: Some operations use immediate values (`imm`) as operands, which are constants used in the operation.

4. **Offsets**: Each operation includes an offset (`off`), which may be used for addressing or other purposes in the context of the operation.

5. **Results and Annotations**: The expected result of each operation is provided, along with annotations indicating specific conditions such as overflow, underflow, sign extension, truncation, and invalid operations.

6. **Validation and Errors**: Some operations are marked with `vfy` or `err`, indicating verification failures or errors, such as invalid source or destination registers, or divide-by-zero errors.

7. **Byte Order Operations**: The `be{16,32,64}` and `le{16,32,64}` operations convert register values to big-endian or little-endian format, with specific immediate values indicating the size of the conversion. Invalid immediate values are flagged with `vfy`.

This file is essential for developers to understand the behavior of arithmetic and logical operations in the system, including edge cases and error handling. It serves as a reference for expected outcomes and validation of operations within the system.

---
Made with ❤️ by [Driver](https://www.driver.ai/)