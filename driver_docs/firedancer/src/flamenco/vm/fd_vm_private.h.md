<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines private constants, structures, and functions for virtual memory management and SBPF instruction handling in the Firedancer VM.

# Purpose
The code is a C header file that defines private components and functionalities for a virtual machine (VM) implementation. It includes various macros, data structures, and inline functions that are used to manage memory alignment, instruction handling, and error logging within the VM. The file is intended to be included in other C source files that require access to these private VM functionalities.

Key components of the code include definitions for memory alignment constants (`FD_VM_ALIGN_RUST_{}`) that ensure compatibility with Rust data types, and a packed structure `fd_vm_vec` that represents a vector descriptor in memory. The file also defines several macros for handling errors and logging within the VM context, such as `FD_VM_ERR_FOR_LOG_EBPF` and `FD_VM_ERR_FOR_LOG_SYSCALL`. Additionally, the code provides inline functions for constructing and deconstructing SBPF (Solana Berkeley Packet Filter) instructions, as well as functions for memory address translation and access violation handling. These components are crucial for the VM's operation, particularly in managing memory and executing instructions efficiently.
# Imports and Dependencies

---
- `fd_vm.h`
- `../../ballet/sbpf/fd_sbpf_instr.h`
- `../../ballet/sbpf/fd_sbpf_opcodes.h`
- `../../ballet/murmur3/fd_murmur3.h`
- `../runtime/context/fd_exec_txn_ctx.h`
- `../runtime/fd_runtime_const.h`
- `../features/fd_features.h`
- `fd_vm_base.h`


# Data Structures

---
### fd\_vm\_vec
- **Type**: ``struct``
- **Members**:
    - ``addr``: Stores the starting address of the vector.
    - ``len``: Stores the length of the vector.
- **Description**: Represents a packed vector descriptor with an address and length, similar in layout to a Rust slice header and various vector types in the C version of the syscall API.


---
### fd\_vm\_vec\_t
- **Type**: ``struct``
- **Members**:
    - ``addr``: Stores the virtual address of the vector.
    - ``len``: Stores the length of the vector.
- **Description**: Represents an in-memory vector descriptor, equivalent in layout to a Rust slice header and various vector types in the C version of the syscall API. It contains two members: `addr`, which holds the virtual address, and `len`, which holds the length of the vector. The structure is packed and has a fixed size of 16 bytes, aligning with the Rust slice header alignment.


# Functions

---
### fd\_vm\_instr<!-- {{#callable:fd_vm_instr}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L176>)

Constructs an SBPF instruction word from given opcode, destination register, source register, offset, and immediate value.
- **Inputs**:
    - `opcode`: The operation code, assumed to be valid.
    - `dst`: The destination register, assumed to be in the range [0, FD_VM_REG_CNT).
    - `src`: The source register, assumed to be in the range [0, FD_VM_REG_CNT).
    - `offset`: A short integer representing the offset.
    - `imm`: An unsigned integer representing the immediate value.
- **Logic and Control Flow**:
    - Combine `opcode` with `dst` shifted left by 8 bits.
    - Combine the result with `src` shifted left by 12 bits.
    - Combine the result with `offset` (cast to `ushort` and then `ulong`) shifted left by 16 bits.
    - Combine the result with `imm` (cast to `ulong`) shifted left by 32 bits.
    - Return the final combined value as the SBPF instruction word.
- **Output**: Returns an `ulong` representing the constructed SBPF instruction word.


---
### fd\_vm\_instr\_opcode<!-- {{#callable:fd_vm_instr_opcode}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L189>)

Extracts the opcode from a given SBPF instruction word.
- **Inputs**:
    - `instr`: The SBPF instruction word from which to extract the opcode.
- **Logic and Control Flow**:
    - Perform a bitwise AND operation between `instr` and `255UL` to isolate the least significant 8 bits of the instruction word.
- **Output**: Returns the opcode as an unsigned long integer, which is a value in the range [0, 256).


---
### fd\_vm\_instr\_dst<!-- {{#callable:fd_vm_instr_dst}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L190>)

Extracts the destination register field from a given SBPF instruction word.
- **Inputs**:
    - `instr`: An unsigned long integer representing the SBPF instruction word from which to extract the destination register field.
- **Logic and Control Flow**:
    - Shift the `instr` value right by 8 bits.
    - Apply a bitwise AND operation with `15UL` to isolate the 4-bit destination register field.
- **Output**: Returns an unsigned long integer representing the destination register field, which is in the range [0, 16).


---
### fd\_vm\_instr\_src<!-- {{#callable:fd_vm_instr_src}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L191>)

Extracts the source register field from a given SBPF instruction word.
- **Inputs**:
    - `instr`: An unsigned long integer representing the SBPF instruction word from which to extract the source register field.
- **Logic and Control Flow**:
    - Shift the `instr` value 12 bits to the right to align the source register field with the least significant bits.
    - Apply a bitwise AND operation with `15UL` to isolate the 4-bit source register field.
- **Output**: Returns an unsigned long integer representing the source register field, which is in the range [0, 16).


---
### fd\_vm\_instr\_offset<!-- {{#callable:fd_vm_instr_offset}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L192>)

Extracts the offset field from a 64-bit SBPF instruction word.
- **Inputs**:
    - `instr`: A 64-bit unsigned long integer representing the SBPF instruction word.
- **Logic and Control Flow**:
    - Right shifts the `instr` by 16 bits to isolate the offset field.
    - Casts the result to an unsigned short to ensure it fits within 16 bits.
    - Casts the unsigned short to a signed short to handle potential negative values.
    - Casts the signed short to a signed long to extend the sign bit.
    - Casts the signed long to an unsigned long to return the final offset value.
- **Output**: Returns the offset field as an unsigned long integer.


---
### fd\_vm\_instr\_imm<!-- {{#callable:fd_vm_instr_imm}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L193>)

Extracts the immediate value from a 64-bit SBPF instruction word by shifting it right by 32 bits and casting it to a 32-bit unsigned integer.
- **Inputs**:
    - `instr`: A 64-bit unsigned long integer representing an SBPF instruction word.
- **Logic and Control Flow**:
    - Shift the input `instr` right by 32 bits to isolate the immediate value.
    - Cast the result to a 32-bit unsigned integer.
- **Output**: Returns the immediate value as a 32-bit unsigned integer.


---
### fd\_vm\_instr\_opclass<!-- {{#callable:fd_vm_instr_opclass}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L195>)

Extracts the operation class from a given instruction by applying a bitwise AND operation with 7.
- **Inputs**:
    - `instr`: An unsigned long integer representing the instruction from which to extract the operation class.
- **Logic and Control Flow**:
    - Perform a bitwise AND operation between `instr` and `7UL` to isolate the least significant 3 bits of `instr`.
- **Output**: Returns an unsigned long integer representing the operation class, which is a value in the range [0, 8).


---
### fd\_vm\_instr\_normal\_opsrc<!-- {{#callable:fd_vm_instr_normal_opsrc}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L196>)

Extracts the source operand bit from a given instruction.
- **Inputs**:
    - `instr`: An unsigned long integer representing the instruction from which to extract the source operand bit.
- **Logic and Control Flow**:
    - Shift the `instr` value right by 3 bits.
    - Perform a bitwise AND operation with `1UL` to isolate the source operand bit.
- **Output**: Returns an unsigned long integer representing the source operand bit, which is either 0 or 1.


---
### fd\_vm\_instr\_normal\_opmode<!-- {{#callable:fd_vm_instr_normal_opmode}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L197>)

Extracts the normal operation mode from a given instruction by shifting and masking.
- **Inputs**:
    - `instr`: An unsigned long integer representing the instruction from which to extract the normal operation mode.
- **Logic and Control Flow**:
    - Shift the input `instr` right by 4 bits.
    - Apply a bitwise AND operation with 15UL to isolate the relevant bits.
- **Output**: Returns an unsigned long integer representing the normal operation mode, which is in the range [0, 16).


---
### fd\_vm\_instr\_mem\_opsize<!-- {{#callable:fd_vm_instr_mem_opsize}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L198>)

Extracts the memory operation size from a given instruction by shifting and masking the instruction value.
- **Inputs**:
    - `instr`: An unsigned long integer representing the instruction from which to extract the memory operation size.
- **Logic and Control Flow**:
    - Shift the `instr` value right by 3 bits to align the memory operation size bits to the least significant bits.
    - Apply a bitwise AND operation with `3UL` to isolate the 2 bits representing the memory operation size.
- **Output**: Returns an unsigned long integer representing the memory operation size, which is a value in the range [0, 4).


---
### fd\_vm\_instr\_mem\_opaddrmode<!-- {{#callable:fd_vm_instr_mem_opaddrmode}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L199>)

Extracts the memory operand address mode from a given instruction.
- **Inputs**:
    - `instr`: An unsigned long integer representing the instruction from which to extract the memory operand address mode.
- **Logic and Control Flow**:
    - Shift the `instr` value right by 5 bits.
    - Apply a bitwise AND operation with `7UL` to isolate the relevant bits for the memory operand address mode.
- **Output**: Returns an unsigned long integer representing the memory operand address mode, which is in the range [0, 8).


---
### fd\_vm\_mem\_cfg<!-- {{#callable:fd_vm_mem_cfg}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L214>)

Configures the memory regions of a virtual machine (`vm`) by setting host addresses and load/store sizes for different memory regions.
- **Inputs**:
    - ``vm``: A pointer to a `fd_vm_t` structure representing the virtual machine to configure.
- **Logic and Control Flow**:
    - Set the host address and load/store sizes for region 0 to zero.
    - Set the host address for the program region to `vm->rodata`, load size to `vm->rodata_sz`, and store size to zero.
    - Set the host address for the stack region to `vm->stack`, load and store sizes to `FD_VM_STACK_MAX`.
    - Set the host address for the heap region to `vm->heap`, load and store sizes to `vm->heap_max`.
    - Set the host address and load/store sizes for region 5 to zero.
    - Check if `vm->direct_mapping` is true or `vm->input_mem_regions_cnt` is zero; if so, set the host address and load/store sizes for the input region to zero.
    - If the above condition is false, set the host address for the input region to the first input memory region's host address, and both load and store sizes to the first input memory region's size.
    - Return the configured `vm` pointer.
- **Output**: Returns the configured `fd_vm_t` pointer.


---
### fd\_vm\_generate\_access\_violation<!-- {{#callable:fd_vm_generate_access_violation}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L243>)

Determines the type of access violation based on the virtual address and SBPF version.
- **Inputs**:
    - `vaddr`: The virtual address to check for access violations.
    - `sbpf_version`: The SBPF version to determine if dynamic stack frames are enabled.
- **Logic and Control Flow**:
    - Calculate `rel_offset` as the difference between `vaddr` and `FD_VM_MEM_MAP_STACK_REGION_START`.
    - Calculate `stack_frame` by dividing `rel_offset` by `FD_VM_STACK_FRAME_SZ`.
    - Check if dynamic stack frames are not enabled and `stack_frame` is between -1 and `FD_VM_MAX_CALL_DEPTH`.
    - If the above condition is true, return `FD_VM_ERR_EBPF_STACK_ACCESS_VIOLATION`.
    - If the condition is false, return `FD_VM_ERR_EBPF_ACCESS_VIOLATION`.
- **Output**: Returns an integer indicating the type of access violation: `FD_VM_ERR_EBPF_STACK_ACCESS_VIOLATION` or `FD_VM_ERR_EBPF_ACCESS_VIOLATION`.


---
### fd\_vm\_get\_input\_mem\_region\_idx<!-- {{#callable:fd_vm_get_input_mem_region_idx}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L295>)

Finds the index of the input memory region with the largest offset that is less than or equal to a given offset.
- **Inputs**:
    - ``vm``: A pointer to a constant `fd_vm_t` structure, which contains information about the virtual machine, including the input memory regions.
    - ``offset``: An unsigned long integer representing the offset to search for within the input memory regions.
- **Logic and Control Flow**:
    - Initialize `left` to 0 and `right` to the count of input memory regions minus one.
    - Enter a while loop that continues as long as `left` is less than `right`.
    - Calculate `mid` as the average of `left` and `right`.
    - Check if `offset` is greater than or equal to the sum of `vaddr_offset` and `address_space_reserved` of the memory region at index `mid`.
    - If true, set `left` to `mid + 1`; otherwise, set `right` to `mid`.
    - Exit the loop when `left` is no longer less than `right`.
    - Return `left` as the index of the input memory region.
- **Output**: Returns an unsigned long integer representing the index of the input memory region.


---
### fd\_vm\_handle\_input\_mem\_region\_oob<!-- {{#callable:fd_vm_handle_input_mem_region_oob}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L317>)

Handles out-of-bounds memory access for input memory regions in a virtual machine, potentially resizing the region if necessary.
- **Inputs**:
    - ``vm``: A pointer to a constant `fd_vm_t` structure representing the virtual machine context.
    - ``offset``: An unsigned long integer representing the offset within the memory region.
    - ``sz``: An unsigned long integer representing the size of the memory access.
    - ``region_idx``: An unsigned long integer representing the index of the memory region in the virtual machine's input memory regions array.
    - ``write``: An unsigned char indicating whether the access is a write operation (non-zero value) or not (zero value).
- **Logic and Control Flow**:
    - Check if `stricter_abi_and_runtime_constraints` is enabled in the virtual machine; if not, return immediately.
    - Check if the access is a write operation; if not, return immediately.
    - Retrieve the memory region at `region_idx` from the virtual machine's input memory regions.
    - Check if the memory region is writable; if not, return immediately.
    - Calculate the `requested_len` by adding `offset` and `sz`, then subtracting `region->vaddr_offset`.
    - Check if `requested_len` exceeds `region->address_space_reserved`; if so, return immediately.
    - Calculate `remaining_allowed_growth` by subtracting `vm->instr_ctx->txn_ctx->accounts_resize_delta` from `FD_MAX_ACCOUNT_DATA_GROWTH_PER_TRANSACTION`.
    - If `requested_len` exceeds `region->region_sz`, calculate `new_region_sz` as the minimum of `region->address_space_reserved`, `FD_RUNTIME_ACC_SZ_MAX`, and the sum of `region->region_sz` and `remaining_allowed_growth`.
    - If `new_region_sz` exceeds `region->region_sz`, update `vm->instr_ctx->txn_ctx->accounts_resize_delta`, resize the account using `fd_txn_account_resize`, and update `region->region_sz`.
- **Output**: No return value; the function modifies the virtual machine's memory region and transaction context as needed.


---
### fd\_vm\_find\_input\_mem\_region<!-- {{#callable:fd_vm_find_input_mem_region}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L384>)

Finds the host address corresponding to a given offset in the input memory region, handling out-of-bounds access and illegal writes.
- **Inputs**:
    - ``vm``: A pointer to a `fd_vm_t` structure representing the virtual machine context.
    - ``offset``: An unsigned long integer representing the offset into the input memory region.
    - ``sz``: An unsigned long integer representing the size of the memory access.
    - ``write``: An unsigned char indicating if the access is a write operation (non-zero) or a read operation (zero).
    - ``sentinel``: An unsigned long integer representing the sentinel value to return in case of an error or invalid access.
- **Logic and Control Flow**:
    - Check if the input memory regions count is zero; if so, return the sentinel value.
    - Use a binary search to find the index of the memory region corresponding to the given offset.
    - If the region index is out of bounds, return the sentinel value.
    - Calculate the number of bytes available in the found region.
    - If the requested size exceeds the available bytes, call [`fd_vm_handle_input_mem_region_oob`](<#fd_vm_handle_input_mem_region_oob>) to handle out-of-bounds access, potentially resizing the region.
    - Recalculate the available bytes after potential resizing and check again if the requested size exceeds the available bytes; if so, return the sentinel value.
    - Check if the access is a write and the region is not writable; if so, return the sentinel value.
    - Calculate the adjusted host address by adding the offset to the host address of the start region and return it.
- **Output**: Returns the host address corresponding to the given offset in the input memory region, or the sentinel value if the access is invalid.
- **Functions Called**:
    - [`fd_vm_get_input_mem_region_idx`](<#fd_vm_get_input_mem_region_idx>)
    - [`fd_vm_handle_input_mem_region_oob`](<#fd_vm_handle_input_mem_region_oob>)


---
### fd\_vm\_mem\_haddr<!-- {{#callable:fd_vm_mem_haddr}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L429>)

Translates a virtual memory address range to a host memory address range, handling special cases for stack and input regions.
- **Inputs**:
    - ``vm``: A pointer to the `fd_vm_t` structure representing the virtual machine context.
    - ``vaddr``: The starting virtual address to translate.
    - ``sz``: The size of the memory range to translate.
    - ``vm_region_haddr``: An array of host addresses corresponding to virtual memory regions, indexed from 0 to 5.
    - ``vm_region_sz``: An array of sizes for each virtual memory region, indexed from 0 to 5.
    - ``write``: A flag indicating if the access is a write (1) or a read (0).
    - ``sentinel``: A value to return if the translation fails.
- **Logic and Control Flow**:
    - Determine the memory region from the virtual address using `FD_VADDR_TO_REGION` and calculate the offset using `FD_VM_OFFSET_MASK`.
    - Check if the region is a stack region and dynamic stack frames are not enabled; if so, handle potential access violations due to gaps.
    - Adjust the offset for stack regions to account for gaps in the virtual address space.
    - Calculate the maximum size of the region and check if the requested size exceeds this maximum.
    - If the region is an input region, call [`fd_vm_find_input_mem_region`](<#fd_vm_find_input_mem_region>) to handle potential resizing and access violations.
    - If memory tracing is enabled and the size is within bounds, log the memory access event.
    - Return the translated host address if the size is within bounds, otherwise return the sentinel value.
- **Output**: Returns the translated host address if successful, or the sentinel value if the translation fails.
- **Functions Called**:
    - [`fd_vm_find_input_mem_region`](<#fd_vm_find_input_mem_region>)
    - [`fd_vm_trace_event_mem`](<fd_vm_base.h.md#fd_vm_trace_event_mem>)


---
### fd\_vm\_mem\_haddr\_fast<!-- {{#callable:fd_vm_mem_haddr_fast}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L479>)

Translates a virtual address to a host address quickly when the virtual address region is already known to have a valid mapping.
- **Inputs**:
    - ``vm``: A pointer to a `fd_vm_t` structure representing the virtual machine context.
    - ``vaddr``: The virtual address to be translated.
    - ``vm_region_haddr``: An array of host addresses indexed by region, used for address translation.
- **Logic and Control Flow**:
    - Determine the region of the virtual address using `FD_VADDR_TO_REGION` macro.
    - Calculate the offset within the region by applying `FD_VM_OFFSET_MASK` to the virtual address.
    - Check if the region is the input region (`FD_VM_INPUT_REGION`).
    - If the region is the input region, call [`fd_vm_find_input_mem_region`](<#fd_vm_find_input_mem_region>) to find the host address for the input region.
    - If the region is not the input region, add the offset to the base host address of the region from `vm_region_haddr` and return the result.
- **Output**: Returns the translated host address corresponding to the given virtual address.
- **Functions Called**:
    - [`fd_vm_find_input_mem_region`](<#fd_vm_find_input_mem_region>)


---
### fd\_vm\_mem\_ld\_1<!-- {{#callable:fd_vm_mem_ld_1}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L491>)

Loads a single byte from a given host address and returns it as an unsigned long.
- **Inputs**:
    - `haddr`: The host address from which to load a single byte.
- **Logic and Control Flow**:
    - Casts the input `haddr` to a pointer of type `uchar const *`.
    - Dereferences the pointer to obtain the byte at the specified address.
    - Casts the byte to an `ulong` and returns it.
- **Output**: An `ulong` representing the byte loaded from the specified host address.


---
### fd\_vm\_mem\_ld\_2<!-- {{#callable:fd_vm_mem_ld_2}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L495>)

Loads a 2-byte unsigned short from a given host address and returns it as an unsigned long.
- **Inputs**:
    - `haddr`: A host address from which to load a 2-byte unsigned short.
- **Logic and Control Flow**:
    - Declare a variable `t` of type `ushort`.
    - Use `memcpy` to copy 2 bytes from the address `haddr` into `t`.
    - Return the value of `t` cast to `ulong`.
- **Output**: An unsigned long representing the 2-byte value loaded from the specified host address.


---
### fd\_vm\_mem\_ld\_4<!-- {{#callable:fd_vm_mem_ld_4}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L501>)

Loads a 4-byte unsigned integer from a specified memory address and returns it as an unsigned long integer.
- **Inputs**:
    - `haddr`: The host memory address from which to load the 4-byte unsigned integer.
- **Logic and Control Flow**:
    - Declare a variable `t` of type `uint` to store the loaded value.
    - Use `memcpy` to copy 4 bytes from the memory address `haddr` into `t`.
    - Cast the value of `t` to `ulong` and return it.
- **Output**: Returns the 4-byte unsigned integer loaded from the specified memory address, cast to an `ulong`.


---
### fd\_vm\_mem\_ld\_8<!-- {{#callable:fd_vm_mem_ld_8}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L507>)

Loads an 8-byte unsigned long value from a specified memory address.
- **Inputs**:
    - `haddr`: The host memory address from which to load the 8-byte unsigned long value.
- **Logic and Control Flow**:
    - Declare a variable `t` of type `ulong` to store the loaded value.
    - Use `memcpy` to copy 8 bytes from the memory address `haddr` into `t`.
    - Return the value stored in `t`.
- **Output**: Returns the 8-byte unsigned long value loaded from the specified memory address.


---
### fd\_vm\_mem\_st\_1<!-- {{#callable:fd_vm_mem_st_1}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L513>)

Stores a single byte value at a specified memory address.
- **Inputs**:
    - `haddr`: The host address where the byte will be stored, represented as an unsigned long integer.
    - `val`: The byte value to store at the specified address, represented as an unsigned char.
- **Logic and Control Flow**:
    - Casts the `haddr` to a pointer of type `uchar *`.
    - Dereferences the pointer to store the `val` at the specified memory location.
- **Output**: No return value; the function performs a side effect by modifying memory at the specified address.


---
### fd\_vm\_mem\_st\_2<!-- {{#callable:fd_vm_mem_st_2}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L517>)

Stores a 2-byte unsigned short value at a specified memory address.
- **Inputs**:
    - ``haddr``: The host memory address where the 2-byte value will be stored.
    - ``val``: The 2-byte unsigned short value to store at the specified memory address.
- **Logic and Control Flow**:
    - Uses the `memcpy` function to copy the 2-byte value from `val` to the memory location pointed to by `haddr`.
- **Output**: No return value; the function performs an in-place memory operation.


---
### fd\_vm\_mem\_st\_4<!-- {{#callable:fd_vm_mem_st_4}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L522>)

Copies a 4-byte unsigned integer value to a specified memory address.
- **Inputs**:
    - ``haddr``: The host memory address where the 4-byte value will be stored.
    - ``val``: The 4-byte unsigned integer value to store at the specified memory address.
- **Logic and Control Flow**:
    - Uses the `memcpy` function to copy the 4-byte value from the address of `val` to the memory location specified by `haddr`.
- **Output**: No return value; the function performs a memory store operation.


---
### fd\_vm\_mem\_st\_8<!-- {{#callable:fd_vm_mem_st_8}} -->
[View Source →](<../../../../../src/flamenco/vm/fd_vm_private.h#L527>)

Stores an 8-byte unsigned long value at a specified memory address.
- **Inputs**:
    - `haddr`: The host memory address where the 8-byte value will be stored.
    - `val`: The 8-byte unsigned long value to store at the specified memory address.
- **Logic and Control Flow**:
    - Uses the `memcpy` function to copy the 8-byte value from `val` to the memory location pointed to by `haddr`.
- **Output**: No return value; the function performs a memory store operation.



---
Made with ❤️ by [Driver](https://www.driver.ai/)