<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for a virtual machine interpreter, including arithmetic, bitwise, and syscall operations.

# Purpose
The code is a C program designed to test and validate a virtual machine (VM) that executes eBPF (extended Berkeley Packet Filter) instructions. It includes several components that facilitate the testing of the VM's functionality, such as arithmetic and bitwise operations, memory operations, and system calls. The program defines a static syscall [`accumulator_syscall`](<#accumulator_syscall>) that sums five arguments and returns the result. It also includes functions to generate random ALU (Arithmetic Logic Unit) and ALU64 instructions, which are used to test the VM's handling of these operations.

The main function initializes the VM and registers the [`accumulator_syscall`](<#accumulator_syscall>). It then runs a series of test cases using the `TEST_PROGRAM_SUCCESS` macro, which executes eBPF programs with predefined instructions and checks if the VM produces the expected results. The test cases cover a wide range of operations, including arithmetic, bitwise, memory access, and control flow instructions. The program also includes a test to ensure the VM exits correctly when the compute unit (CU) count reaches zero. Additionally, the code verifies the integrity of a static list of syscalls by comparing their hash values. The program concludes by running performance benchmarks with randomly generated instructions and validating the static syscall list.
# Imports and Dependencies

---
- `fd_vm.h`
- `fd_vm_base.h`
- `fd_vm_private.h`
- `test_vm_util.h`
- `stdlib.h`


# Global Variables

---
### FD\_VM\_SBPF\_STATIC\_SYSCALLS\_LIST
- **Type**: ``static const uint[]``
- **Description**: Contains a list of 32-bit unsigned integers representing static syscall identifiers for a virtual machine. Each element corresponds to a specific syscall, with the first element being zero and subsequent elements being hash values of syscall names.
- **Use**: Used to map syscall names to their corresponding hash values for identification in the virtual machine.


---
### \_syscalls
- **Type**: `fd_sbpf_syscalls_t[]`
- **Description**: An array of `fd_sbpf_syscalls_t` structures, where each element represents a slot for storing system call information. The size of the array is determined by the constant `FD_SBPF_SYSCALLS_SLOT_CNT`.
- **Use**: Used to store and manage system call information for the virtual machine.


# Functions

---
### accumulator\_syscall<!-- {{#callable:accumulator_syscall}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L7>)

Calculates the sum of five unsigned long integers and stores the result in a provided memory location.
- **Inputs**:
    - `_vm`: Unused parameter, typically a pointer to a virtual machine context.
    - `arg0`: First unsigned long integer to add.
    - `arg1`: Second unsigned long integer to add.
    - `arg2`: Third unsigned long integer to add.
    - `arg3`: Fourth unsigned long integer to add.
    - `arg4`: Fifth unsigned long integer to add.
    - `ret`: Pointer to an unsigned long where the result of the addition will be stored.
- **Logic and Control Flow**:
    - Add `arg0`, `arg1`, `arg2`, `arg3`, and `arg4` together.
    - Store the result of the addition in the memory location pointed to by `ret`.
    - Return 0 to indicate successful execution.
- **Output**: Returns 0 to indicate success.


---
### test\_program\_success<!-- {{#callable:test_program_success}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L19>)

Executes a virtual machine program and verifies its result against an expected outcome, logging execution time and errors if the result is incorrect.
- **Inputs**:
    - ``test_case_name``: A string representing the name of the test case.
    - ``expected_result``: An unsigned long integer representing the expected result of the program execution.
    - ``text``: A pointer to an array of unsigned long integers representing the program instructions to be executed.
    - ``text_cnt``: An unsigned long integer representing the number of instructions in the `text` array.
    - ``syscalls``: A pointer to a `fd_sbpf_syscalls_t` structure containing system call information for the virtual machine.
    - ``instr_ctx``: A pointer to a `fd_exec_instr_ctx_t` structure containing execution context information for the virtual machine.
- **Logic and Control Flow**:
    - Initialize a SHA-256 context and a virtual machine instance.
    - Join the SHA-256 and virtual machine instances to their respective contexts.
    - Initialize the virtual machine with the provided instruction context, text, and system calls.
    - Set the program counter, instruction counter, compute unit, frame count, and heap size for the virtual machine.
    - Configure the virtual machine memory settings.
    - Validate the virtual machine setup; log an error and exit if validation fails.
    - Measure the execution time of the virtual machine program by logging the wall clock time before and after execution.
    - Execute the virtual machine program and check if the result in register 0 matches the expected result.
    - Log warnings if the result does not match the expected result, including the error code, return value, program counter, and instruction counter.
    - Log the execution time of the test case.
- **Output**: No return value; the function logs execution details and errors.
- **Functions Called**:
    - [`fd_vm_join`](<fd_vm.c.md#fd_vm_join>)
    - [`fd_vm_new`](<fd_vm.c.md#fd_vm_new>)
    - [`fd_vm_init`](<fd_vm.c.md#fd_vm_init>)
    - [`fd_vm_mem_cfg`](<fd_vm_private.h.md#fd_vm_mem_cfg>)
    - [`fd_vm_validate`](<fd_vm.c.md#fd_vm_validate>)
    - [`fd_vm_strerror`](<fd_vm.c.md#fd_vm_strerror>)
    - [`fd_vm_exec`](<fd_vm.h.md#fd_vm_exec>)


---
### generate\_random\_alu\_instrs<!-- {{#callable:generate_random_alu_instrs}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L90>)

Generates a sequence of random ALU instructions and stores them in the provided text array.
- **Inputs**:
    - ``rng``: A pointer to a random number generator of type `fd_rng_t` used to generate random values.
    - ``text``: A pointer to an array of `ulong` where the generated instructions will be stored.
    - ``text_cnt``: The number of instructions to generate and store in the `text` array.
- **Logic and Control Flow**:
    - Check if `text_cnt` is zero; if so, return immediately without generating instructions.
    - Define a static array `opcodes` containing 25 possible ALU operation codes.
    - Iterate over the range from 0 to `text_cnt-1`, generating a random instruction for each index.
    - For each instruction, randomly select an opcode from `opcodes`, and set random values for `dst_reg`, `src_reg`, and `imm` fields using the random number generator `rng`.
    - Set the `offset` field of each instruction to zero.
    - Apply specific constraints to the `imm` field for certain opcodes to ensure valid instruction behavior (e.g., non-zero divisors, valid shift amounts).
    - Convert each instruction to a `ulong` using `fd_sbpf_ulong` and store it in the `text` array.
    - Set the last instruction in the `text` array to an `EXIT` operation.
- **Output**: The function does not return a value; it modifies the `text` array in place.


---
### generate\_random\_alu64\_instrs<!-- {{#callable:generate_random_alu64_instrs}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L148>)

Generates a sequence of random 64-bit ALU instructions and stores them in the provided text array.
- **Inputs**:
    - ``rng``: A pointer to a random number generator of type `fd_rng_t` used to generate random values.
    - ``text``: A pointer to an array of type `ulong` where the generated instructions will be stored.
    - ``text_cnt``: The number of instructions to generate, including the final exit instruction.
- **Logic and Control Flow**:
    - Check if `text_cnt` is zero; if so, return immediately.
    - Initialize a static array `opcodes` with 25 different 64-bit ALU operation codes.
    - Iterate over the range from 0 to `text_cnt-1`, generating a random instruction for each index.
    - For each instruction, randomly select an opcode from `opcodes`, and set random destination and source registers.
    - Set the instruction's immediate value to a random number between 0 and 1024*1024.
    - Adjust the immediate value for specific opcodes to ensure valid operations (e.g., non-zero divisors).
    - Convert the instruction to a `ulong` and store it in the `text` array.
    - After the loop, set the last instruction in `text` to an exit operation.
- **Output**: The function does not return a value; it modifies the `text` array in place to contain the generated instructions.


---
### test\_0cu\_exit<!-- {{#callable:test_0cu_exit}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L210>)

Tests the virtual machine's behavior when the compute unit (CU) count reaches zero after executing instructions, ensuring it exits successfully or fails if CUs are exhausted.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initialize a SHA-256 context and a virtual machine (VM) context.
    - Define a set of instructions (`text`) that includes two XOR operations and an EXIT operation.
    - Initialize instruction and transaction contexts using [`test_vm_minimal_exec_instr_ctx`](<test_vm_util.c.md#test_vm_minimal_exec_instr_ctx>).
    - Test the VM's successful exit by initializing it with a CU count equal to the number of instructions, validating, executing, and checking that the CU count is zero after execution.
    - Test the VM's failure to exit by initializing it with a CU count less than the number of instructions, validating, executing, and expecting an error indicating exceeded maximum instructions.
    - Clean up by deleting the VM and SHA-256 contexts.
- **Output**: No output is returned; the function performs tests and asserts conditions internally.
- **Functions Called**:
    - [`fd_vm_join`](<fd_vm.c.md#fd_vm_join>)
    - [`fd_vm_new`](<fd_vm.c.md#fd_vm_new>)
    - [`fd_vm_instr`](<fd_vm_private.h.md#fd_vm_instr>)
    - [`test_vm_minimal_exec_instr_ctx`](<test_vm_util.c.md#test_vm_minimal_exec_instr_ctx>)
    - [`fd_vm_init`](<fd_vm.c.md#fd_vm_init>)
    - [`fd_vm_validate`](<fd_vm.c.md#fd_vm_validate>)
    - [`fd_vm_exec`](<fd_vm.h.md#fd_vm_exec>)
    - [`fd_vm_delete`](<fd_vm.c.md#fd_vm_delete>)
    - [`fd_vm_leave`](<fd_vm.c.md#fd_vm_leave>)


---
### test\_static\_syscalls\_list<!-- {{#callable:test_static_syscalls_list}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L388>)

Validates that the static syscall list in `FD_VM_SBPF_STATIC_SYSCALLS_LIST` matches the expected hash values for each syscall name.
- **Inputs**: None
- **Logic and Control Flow**:
    - Initializes an array `static_syscalls_from_simd` with a list of syscall names.
    - Checks that the first element of `FD_VM_SBPF_STATIC_SYSCALLS_LIST` is zero using `FD_TEST`.
    - Iterates over the `static_syscalls_from_simd` array starting from the second element.
    - For each syscall name, calculates a hash key using `fd_murmur3_32`.
    - Verifies that the hash key matches the corresponding element in `FD_VM_SBPF_STATIC_SYSCALLS_LIST` using `FD_TEST`.
- **Output**: No output is returned; the function performs validation checks using assertions.


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_interp.c#L444>)

Initializes and tests a virtual machine environment with various SBPF instructions and syscalls.
- **Inputs**:
    - `argc`: The number of command-line arguments.
    - `argv`: An array of command-line argument strings.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with command-line arguments.
    - Creates and joins a random number generator using `fd_rng_new` and `fd_rng_join`.
    - Initializes and joins SBPF syscalls using `fd_sbpf_syscalls_new` and `fd_sbpf_syscalls_join`.
    - Registers the `accumulator_syscall` with the syscalls.
    - Defines a macro `TEST_PROGRAM_SUCCESS` to test SBPF programs with expected results.
    - Executes multiple test cases using the `TEST_PROGRAM_SUCCESS` macro with various SBPF instructions.
    - Allocates memory for instruction text using `malloc`.
    - Generates random ALU and ALU64 instructions using [`generate_random_alu_instrs`](<#generate_random_alu_instrs>) and [`generate_random_alu64_instrs`](<#generate_random_alu64_instrs>).
    - Tests the generated instructions with [`test_program_success`](<#test_program_success>).
    - Calls [`test_0cu_exit`](<#test_0cu_exit>) to ensure VM exits correctly when compute units reach zero.
    - Frees allocated memory for instruction text.
    - Deletes and leaves the SBPF syscalls and random number generator.
    - Calls [`test_static_syscalls_list`](<#test_static_syscalls_list>) to verify static syscall list.
    - Logs a notice message indicating successful execution.
    - Calls `fd_halt` to terminate the program.
- **Output**: Returns 0 to indicate successful execution.
- **Functions Called**:
    - [`test_vm_minimal_exec_instr_ctx`](<test_vm_util.c.md#test_vm_minimal_exec_instr_ctx>)
    - [`fd_vm_syscall_register`](<syscall/fd_vm_syscall.c.md#fd_vm_syscall_register>)
    - [`generate_random_alu_instrs`](<#generate_random_alu_instrs>)
    - [`test_program_success`](<#test_program_success>)
    - [`generate_random_alu64_instrs`](<#generate_random_alu64_instrs>)
    - [`test_0cu_exit`](<#test_0cu_exit>)
    - [`test_static_syscalls_list`](<#test_static_syscalls_list>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)