<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Executes and validates text-based instruction tests for a virtual machine, logging results and errors.

# Purpose
The code is a C program designed to execute and validate text-based instruction tests for a virtual machine (VM) located in the `src/flamenco/vm` directory. It includes a parser that interprets a minimal text-based grammar to define test instructions and expected outcomes. The program reads test files, parses the instructions, and executes them on a VM instance. It then compares the actual execution results with the expected results to determine if the tests pass or fail.

The program is structured into several components: parsing, execution, and test handling. The parsing component reads and interprets the test instructions, converting them into a format suitable for execution. The execution component runs the parsed instructions on a VM, using functions like [`run_input`](<#run_input>) and [`run_input2`](<#run_input2>) to manage the VM's state and validate the execution. The test handling component, including functions like [`handle_file`](<#handle_file>) and [`run_fixture`](<#run_fixture>), manages the reading of test files and the comparison of actual versus expected results. The program can execute tests specified in command-line arguments or default test paths if no arguments are provided. It logs the results of the tests, indicating whether they pass or fail.
# Imports and Dependencies

---
- `fd_vm.h`
- `fd_vm_base.h`
- `fd_vm_private.h`
- `test_vm_util.h`
- `assert.h`
- `ctype.h`
- `errno.h`
- `fcntl.h`
- `stdlib.h`
- `sys/stat.h`
- `unistd.h`


# Data Structures

---
### test\_input
- **Type**: ``struct``
- **Members**:
    - ``input``: Pointer to a heap-allocated array of unsigned characters.
    - ``input_sz``: Size of the input array.
    - ``op``: Operation code as an unsigned character.
    - ``dst``: Destination register index, using 4 bits.
    - ``src``: Source register index, using 4 bits.
    - ``off``: Offset value as an unsigned short.
    - ``imm``: Immediate value as an unsigned long.
    - ``reg``: Array of registers, each an unsigned long, with a size defined by `REG_CNT`.
    - ``region_boundary``: Array of unsigned integers representing region boundaries, with a fixed size of 16.
    - ``region_boundary_cnt``: Count of region boundaries used.
- **Description**: Represents the input data for a test, including operation codes, register indices, and memory regions, used in a virtual machine instruction test environment.


---
### test\_input\_t
- **Type**: ``struct``
- **Members**:
    - ``input``: Pointer to a heap-allocated array of unsigned characters.
    - ``input_sz``: Size of the input array.
    - ``op``: Operation code as an unsigned character.
    - ``dst``: Destination register index, using 4 bits.
    - ``src``: Source register index, using 4 bits.
    - ``off``: Offset value as an unsigned short.
    - ``imm``: Immediate value as an unsigned long.
    - ``reg``: Array of 12 unsigned long integers representing registers.
    - ``region_boundary``: Array of 16 unsigned integers for region boundaries.
    - ``region_boundary_cnt``: Count of region boundaries as an unsigned integer.
- **Description**: Defines the structure for test input data used in executing text-based instruction tests. It includes fields for input data, operation codes, register indices, offsets, immediate values, and region boundaries, which are essential for setting up and executing virtual machine instructions.


---
### test\_effects
- **Type**: ``struct``
- **Members**:
    - `status`: Stores the status of the test effects.
    - `force_exec`: Indicates if execution should be forced despite verification failure.
    - `reg`: An array of registers with a size defined by `REG_CNT`.
- **Description**: Holds the effects of a test execution, including the status, a flag to force execution, and an array of register values.


---
### test\_effects\_t
- **Type**: ``struct``
- **Members**:
    - `status`: Stores the status of the test execution.
    - `force_exec`: Indicates if the execution should be forced despite validation failures.
    - `reg`: An array of registers used during the test execution.
- **Description**: `test_effects_t` is a structure that holds the results of a test execution, including the status, a flag to force execution, and an array of register values.


---
### test\_fixture
- **Type**: ``struct``
- **Members**:
    - ``line``: Stores the line number associated with the test fixture.
    - ``input``: Holds the input data for the test, defined by `test_input_t`.
    - ``effects``: Contains the expected effects or outcomes of the test, defined by `test_effects_t`.
- **Description**: Represents a test fixture that includes a line number, input data, and expected effects for executing text-based instruction tests. The `line` member helps track the location of the test in the source file, while `input` and `effects` provide the necessary data and expected results for the test execution.


---
### test\_fixture\_t
- **Type**: ``struct``
- **Members**:
    - ``line``: Stores the line number in the test file where the fixture is defined.
    - ``input``: Holds the input data for the test, encapsulated in a `test_input_t` structure.
    - ``effects``: Contains the expected effects of the test, encapsulated in a `test_effects_t` structure.
- **Description**: Encapsulates a test case for a virtual machine instruction, including the input data and the expected effects or results of executing the instruction.


---
### test\_parser
- **Type**: ``struct``
- **Members**:
    - ``path``: Pointer to a constant character string representing the file path.
    - ``cur``: Pointer to the current position in the input buffer.
    - ``end``: Pointer to the end of the input buffer.
    - ``line``: Current line number in the input being parsed.
    - ``test_line``: Line number where the current test started.
    - ``state``: Current state of the parser, indicating whether it is parsing input or assertions.
    - ``input``: Structure holding the input data for the test.
    - ``effects``: Structure holding the expected effects or results of the test.
- **Description**: Represents a parser for test instructions, maintaining the current parsing state, input data, and expected effects. It tracks the current position and line number in the input buffer, and manages transitions between parsing input and assertions. The `input` and `effects` members store the data and expected outcomes for the test being parsed.


---
### test\_parser\_t
- **Type**: ``struct``
- **Members**:
    - ``path``: Pointer to the file path being parsed.
    - ``cur``: Pointer to the current position in the input buffer.
    - ``end``: Pointer to the end of the input buffer.
    - ``line``: Current line number in the input file.
    - ``test_line``: Line number where the current test started.
    - ``state``: Current state of the parser, either input or assert.
    - ``input``: Holds the current test input data.
    - ``effects``: Holds the expected effects of the test execution.
- **Description**: `test_parser_t` is a structure used to parse and manage the state of text-based instruction tests. It maintains pointers to the input buffer and tracks the current parsing position and line numbers. The structure also holds the current state of the parser, which can be either input or assert, and stores the current test input and expected effects for validation.


# Functions

---
### test\_status\_str<!-- {{#callable:test_status_str}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L27>)

Maps an integer status code to its corresponding string representation.
- **Inputs**:
    - `status`: An integer representing the status code to be converted to a string.
- **Logic and Control Flow**:
    - Uses a switch statement to check the value of `status`.
    - If `status` is `STATUS_OK`, returns the string "Ok".
    - If `status` is `STATUS_FAULT`, returns the string "Fault".
    - If `status` is `STATUS_VERIFY_FAIL`, returns the string "VerifyFail".
    - For any other value of `status`, returns the string "unknown (!!!)".
- **Output**: A constant character pointer to the string representation of the status code.


---
### parse\_advance<!-- {{#callable:parse_advance}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L86>)

Advances the current position in the parser by a specified number of characters and updates the line count if newline characters are encountered.
- **Inputs**:
    - `p`: A pointer to a `test_parser_t` structure, which contains the current state of the parser.
    - `n`: The number of characters to advance the current position in the parser.
- **Logic and Control Flow**:
    - Assert that advancing `n` characters does not exceed the end of the input buffer.
    - Iterate over each character from the current position up to `n` characters.
    - If a newline character is encountered, increment the line count in the parser.
    - Advance the current position in the parser by `n` characters.
- **Output**: No return value; the function modifies the state of the `test_parser_t` structure pointed to by `p`.


---
### parse\_assign\_sep<!-- {{#callable:parse_assign_sep}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L101>)

Advances the parser's current position to the next '=' character, removing any surrounding whitespace.
- **Inputs**:
    - `p`: A pointer to a `test_parser_t` structure, which contains the current state of the parser, including the current position, end position, and other parsing metadata.
- **Logic and Control Flow**:
    - While the current position is not at the end and the current character is a whitespace, call [`parse_advance`](<#parse_advance>) to move forward by one character.
    - If the current position is at the end or the current character is not '=', log an error indicating that '=' was expected at the current path and line.
    - Call [`parse_advance`](<#parse_advance>) to move past the '=' character.
    - While the current position is not at the end and the current character is a whitespace, call [`parse_advance`](<#parse_advance>) to move forward by one character.
- **Output**: No return value; the function modifies the parser state in place.
- **Functions Called**:
    - [`parse_advance`](<#parse_advance>)


---
### parse\_hex\_buf<!-- {{#callable:parse_hex_buf}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L118>)

Converts a hexadecimal string from the parser's current position into a binary buffer and returns it.
- **Inputs**:
    - `p`: A pointer to a `test_parser_t` structure, which contains the current parsing state, including the current position and end of the input buffer.
    - `psz`: A pointer to an `ulong` where the function will store the size of the parsed binary buffer.
- **Logic and Control Flow**:
    - Initialize `sz` to 0 to count the number of hexadecimal character pairs.
    - Set `peek` to the current position in the parser's input buffer.
    - Iterate over the input buffer in pairs of characters, checking if both characters are hexadecimal digits using `fd_isxdigit`.
    - If a pair of characters is not hexadecimal, break the loop; otherwise, increment `peek` by 2 and `sz` by 1.
    - Allocate memory for the binary buffer `buf` with size `sz` and assert that the allocation is successful.
    - Set `cur` to point to the start of `buf`.
    - Iterate over the input buffer again, converting each pair of hexadecimal characters to a byte and storing it in `buf`.
    - For each pair, calculate the high and low nibbles using `fd_isdigit` and `tolower`, then combine them into a byte and store it in `buf`.
    - Advance the parser's current position by 2 characters using [`parse_advance`](<#parse_advance>).
    - Store the size of the parsed buffer in `*psz`.
- **Output**: Returns a pointer to the allocated binary buffer containing the parsed data.
- **Functions Called**:
    - [`parse_advance`](<#parse_advance>)


---
### parse\_hex\_int<!-- {{#callable:parse_hex_int}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L157>)

Parses a hexadecimal string from the current position in the parser and returns its unsigned long integer value.
- **Inputs**:
    - `p`: A pointer to a `test_parser_t` structure that contains the current parsing state, including the current position and end of the input buffer.
- **Logic and Control Flow**:
    - Initialize `val` to 0 and `empty` to 1 to track if any valid hexadecimal digits are found.
    - Enter a loop that continues as long as the current position `p->cur` is not at the end `p->end` of the input buffer.
    - Retrieve the current character `c` from the input buffer.
    - Check if `c` is a valid hexadecimal digit using `fd_isxdigit`; if not, exit the loop.
    - Determine the numeric value of `c` as a hexadecimal digit, using `fd_isdigit` to differentiate between numeric and alphabetic digits.
    - Shift `val` left by 4 bits to make room for the new digit and add the digit's value to `val`.
    - Set `empty` to 0 to indicate that at least one valid digit has been processed.
    - Advance the parser's current position by 1 using [`parse_advance`](<#parse_advance>).
    - After the loop, if no valid digits were found (`empty` is still 1), log an error indicating that a hexadecimal integer was expected at the current file path and line number.
    - Return the parsed unsigned long integer value `val`.
- **Output**: Returns the parsed unsigned long integer value from the hexadecimal string.
- **Functions Called**:
    - [`parse_advance`](<#parse_advance>)


---
### parse\_token<!-- {{#callable:parse_token}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L186>)

Parses the next token from the input stream and updates the parser state or returns a completed test fixture if ready.
- **Inputs**:
    - ``p``: A pointer to a `test_parser_t` structure that holds the current state of the parser.
    - ``out``: A pointer to a `test_fixture_t` structure where the function stores the parsed test fixture if it is complete.
- **Logic and Control Flow**:
    - Skip whitespace characters in the input stream.
    - Check if the end of the input stream is reached; if so, handle the end-of-file condition based on the current parser state.
    - Switch on the current character to handle different token types: '$' for new input, '#' for comments, and ':' for assertions.
    - For '$', update the parser state and return a completed test fixture if the previous state was an assertion.
    - For '#', skip the comment until a newline is encountered.
    - For ':', set the parser state to assertion and copy input registers to effects registers.
    - If none of the above, read a word and handle specific keywords like 'input', 'region_boundary', 'op', 'dst', 'src', 'off', 'imm', 'ok', 'err', 'vfy', 'vfyub', or register assignments.
    - Log an error if an unexpected token is encountered.
    - Return `NULL` if no complete test fixture is ready.
- **Output**: Returns a pointer to a `test_fixture_t` if a new test fixture is ready; otherwise, returns `NULL`.
- **Functions Called**:
    - [`parse_advance`](<#parse_advance>)
    - [`parse_assign_sep`](<#parse_assign_sep>)
    - [`parse_hex_buf`](<#parse_hex_buf>)
    - [`parse_hex_int`](<#parse_hex_int>)


---
### parse\_next<!-- {{#callable:parse_next}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L342>)

Iterates through tokens in a parser and returns the next complete test fixture if available.
- **Inputs**:
    - ``p``: A pointer to a `test_parser_t` structure that contains the current state of the parser.
    - ``out``: A pointer to a `test_fixture_t` structure where the function will store the parsed test fixture if one is complete.
- **Logic and Control Flow**:
    - Calls [`parse_token`](<#parse_token>) in a loop to read the next token from the parser `p` and attempts to parse it into the `out` structure.
    - If [`parse_token`](<#parse_token>) returns a non-NULL value, indicating a complete test fixture is ready, the function returns this value.
    - Continues parsing tokens until the end of the input is reached (`p->cur != p->end`).
    - If no complete test fixture is found by the end of the input, returns `NULL`.
- **Output**: Returns a pointer to a `test_fixture_t` structure if a complete test fixture is parsed, otherwise returns `NULL`.
- **Functions Called**:
    - [`parse_token`](<#parse_token>)


---
### run\_input2<!-- {{#callable:run_input2}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L354>)

Validates and executes a virtual machine (VM) and updates the status and register values in the output structure based on the execution result.
- **Inputs**:
    - ``out``: A pointer to a `test_effects_t` structure where the function will store the execution results, including status and register values.
    - ``vm``: A pointer to an `fd_vm_t` structure representing the virtual machine to be validated and executed.
    - ``force_exec``: An integer flag indicating whether to force execution even if validation fails.
- **Logic and Control Flow**:
    - Check if the VM is valid using [`fd_vm_validate`](<fd_vm.c.md#fd_vm_validate>); if not, set `out->status` to `STATUS_VERIFY_FAIL`.
    - If validation fails and `force_exec` is true, attempt to execute the VM using [`fd_vm_exec_notrace`](<fd_vm_interp.c.md#fd_vm_exec_notrace>); if successful, a TODO comment suggests marking these tests as 'vfyub'.
    - If the VM execution fails, set `out->status` to `STATUS_FAULT`.
    - If the VM execution is successful, set `out->status` to `STATUS_OK` and copy the first 12 register values from the VM to `out->reg`.
- **Output**: Updates the `out` structure with the execution status and register values based on the VM's execution result.
- **Functions Called**:
    - [`fd_vm_validate`](<fd_vm.c.md#fd_vm_validate>)
    - [`fd_vm_exec_notrace`](<fd_vm_interp.c.md#fd_vm_exec_notrace>)


---
### run\_input<!-- {{#callable:run_input}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L382>)

Executes a test input on a virtual machine (VM) by assembling instructions, setting up the VM, and running the input through the VM.
- **Inputs**:
    - ``input``: A pointer to a `test_input_t` structure containing the test input data, including operation code, destination and source registers, offset, immediate value, and memory regions.
    - ``out``: A pointer to a `test_effects_t` structure where the function will store the results of the test execution.
    - ``vm``: A pointer to an `fd_vm_t` structure representing the virtual machine on which the test input will be executed.
    - ``sbpf_version``: An unsigned long integer representing the version of the SBPF (Solana Berkeley Packet Filter) to use during execution.
    - ``force_exec``: An integer flag indicating whether to force execution even if validation fails.
- **Logic and Control Flow**:
    - Initialize an array `text` to store the assembled instructions and a counter `text_cnt` to track the number of instructions.
    - Assemble the first instruction using [`fd_vm_instr`](<fd_vm_private.h.md#fd_vm_instr>) with parameters from `input` and store it in `text`.
    - If the operation code is `FD_SBPF_OP_LDDW`, assemble a second instruction for the high 32 bits of the immediate value and store it in `text`.
    - Assemble an exit instruction and store it in `text`.
    - Allocate memory for `input_copy` and copy the input data from `input` to `input_copy`.
    - Initialize an array `input_region` to define memory regions for the VM.
    - If `input->region_boundary_cnt` is zero, define a single memory region for the entire input; otherwise, define multiple regions based on `input->region_boundary`.
    - Create and join `fd_sbpf_calldests_t` and `fd_sbpf_syscalls_t` structures for call destinations and syscalls, respectively.
    - Initialize instruction and transaction contexts using [`test_vm_minimal_exec_instr_ctx`](<test_vm_util.c.md#test_vm_minimal_exec_instr_ctx>).
    - Initialize the VM using [`fd_vm_init`](<fd_vm.c.md#fd_vm_init>) with the assembled instructions, memory regions, and other parameters.
    - Copy register values from `input` to the VM's registers.
    - Call [`run_input2`](<#run_input2>) to execute the input on the VM and store the results in `out`.
    - Free allocated resources for syscalls, call destinations, and `input_copy`.
- **Output**: No direct output is returned, but the function modifies the `out` parameter to store the results of the test execution.
- **Functions Called**:
    - [`fd_vm_instr`](<fd_vm_private.h.md#fd_vm_instr>)
    - [`test_vm_minimal_exec_instr_ctx`](<test_vm_util.c.md#test_vm_minimal_exec_instr_ctx>)
    - [`fd_vm_init`](<fd_vm.c.md#fd_vm_init>)
    - [`run_input2`](<#run_input2>)


---
### run\_fixture<!-- {{#callable:run_fixture}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L494>)

Executes a test fixture and compares the actual execution results with the expected results, logging any discrepancies.
- **Inputs**:
    - ``f``: A pointer to a `test_fixture_t` structure containing the test input and expected effects.
    - ``src_file``: A string representing the source file name where the test is defined.
    - ``vm``: A pointer to an `fd_vm_t` structure representing the virtual machine instance to execute the test.
    - ``sbpf_version``: An unsigned long integer representing the version of the SBPF to use during execution.
- **Logic and Control Flow**:
    - Initialize the `fail` variable to 0.
    - Retrieve the expected effects from the test fixture `f`.
    - Initialize an `actual` effects structure to store the results of the test execution.
    - Call [`run_input`](<#run_input>) to execute the test input and populate the `actual` effects structure.
    - Compare the `status` field of the expected and actual effects; log a warning and set `fail` to 1 if they differ.
    - If either the expected or actual status is not `STATUS_OK`, return the `fail` value.
    - Iterate over each register (0 to `REG_CNT-1`) and compare the expected and actual register values; log a warning and set `fail` to 1 if they differ.
    - Return the `fail` value.
- **Output**: Returns an integer indicating whether the test execution matched the expected results (0 for match, 1 for mismatch).
- **Functions Called**:
    - [`run_input`](<#run_input>)
    - [`test_status_str`](<#test_status_str>)


---
### handle\_file<!-- {{#callable:handle_file}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L534>)

Processes a file containing test instructions, executes them using a virtual machine, and returns the number of failed tests.
- **Inputs**:
    - ``file_path``: A constant character pointer to the path of the file to be processed.
    - ``vm``: A pointer to an `fd_vm_t` structure representing the virtual machine to execute the tests.
    - ``sbpf_version``: An unsigned long integer representing the version of the SBPF (Solana Berkeley Packet Filter) to use.
- **Logic and Control Flow**:
    - Opens the file specified by `file_path` in read-only mode and checks for errors.
    - Retrieves the file's metadata using `fstat` and checks for errors.
    - Allocates a buffer to read the file's contents and checks for successful allocation.
    - Reads the file's contents into the buffer and checks for read errors.
    - Initializes a `test_parser_t` structure to parse the file's contents.
    - Enters a loop to parse and execute each test fixture in the file using [`parse_next`](<#parse_next>) and [`run_fixture`](<#run_fixture>).
    - Accumulates the number of failed tests in the `fail` variable.
    - Closes the file and checks for errors.
    - Frees the allocated memory for the input and buffer.
    - Returns the total number of failed tests.
- **Output**: Returns an integer representing the number of test fixtures that failed during execution.
- **Functions Called**:
    - [`parse_next`](<#parse_next>)
    - [`run_fixture`](<#run_fixture>)


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/flamenco/vm/test_vm_instr.c#L584>)

Initializes the environment, processes command-line arguments, executes specified instruction tests, and logs the results.
- **Inputs**:
    - `argc`: The number of command-line arguments.
    - `argv`: An array of strings representing the command-line arguments.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with command-line arguments.
    - Determines the CPU index using `fd_tile_cpu_id` and `fd_tile_idx`, and adjusts it if necessary.
    - Extracts command-line options for page size, page count, and NUMA index using `fd_env_strip_cmdline_cstr` and `fd_env_strip_cmdline_ulong`.
    - Initializes a virtual machine instance using [`fd_vm_join`](<fd_vm.c.md#fd_vm_join>) and [`fd_vm_new`](<fd_vm.c.md#fd_vm_new>).
    - Iterates over command-line arguments to execute files that do not start with '--', using [`handle_file`](<#handle_file>).
    - If no files are executed, runs default instruction test paths for versions 0 and 2.
    - Logs the results of the tests using `FD_LOG_NOTICE` or `FD_LOG_WARNING`.
    - Calls `fd_halt` to clean up and exits with the number of failed tests.
- **Output**: Returns an integer representing the number of failed tests.
- **Functions Called**:
    - [`fd_vm_join`](<fd_vm.c.md#fd_vm_join>)
    - [`fd_vm_new`](<fd_vm.c.md#fd_vm_new>)
    - [`handle_file`](<#handle_file>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)