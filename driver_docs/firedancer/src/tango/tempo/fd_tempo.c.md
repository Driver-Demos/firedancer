<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Models and measures wallclock and tickcount performance, and calculates asynchronous minimum intervals.

# Purpose
The code provides functionality for modeling and measuring the performance of time-related operations in a system. It includes functions to model the overhead and jitter of wallclock and tickcount operations, which are essential for understanding the timing characteristics of an application. The functions [`fd_tempo_wallclock_model`](<#fd_tempo_wallclock_model>) and [`fd_tempo_tickcount_model`](<#fd_tempo_tickcount_model>) estimate the time taken for these operations using a robust statistical approach, which helps in identifying the minimal overhead and jitter. These models are useful for applications that require precise timing measurements and need to account for system-induced delays.

Additionally, the code includes functions to set and retrieve the number of ticks per nanosecond, which is crucial for converting between different time units in performance-sensitive applications. The function [`fd_tempo_set_tick_per_ns`](<#fd_tempo_set_tick_per_ns>) allows explicit setting of this conversion factor, while `fd_tempo_tick_per_ns` calculates it based on observed data if not set explicitly. The [`fd_tempo_observe_pair`](<#fd_tempo_observe_pair>) function provides a mechanism to obtain synchronized observations of wallclock and tickcount values, which is important for accurate timing analysis. The [`fd_tempo_async_min`](<#fd_tempo_async_min>) function calculates the minimum asynchronous interval based on given parameters, ensuring that the interval is within a reasonable range. This collection of functions is designed to be used in environments where precise timing and performance measurements are critical.
# Imports and Dependencies

---
- `../fd_tango.h`
- `../../util/math/fd_stat.h`


# Global Variables

---
### mu
- **Type**: ``double``
- **Description**: Represents the average number of ticks per nanosecond, used in timing calculations.
- **Use**: Used to store the average tick rate per nanosecond, which is set by the `fd_tempo_set_tick_per_ns` function and used in the `fd_tempo_tick_per_ns` function.


---
### sigma
- **Type**: ``double``
- **Description**: Represents the standard deviation of the tick per nanosecond measurement. It is used in conjunction with the mean (`mu`) to model the distribution of tick per nanosecond values.
- **Use**: Used to store the standard deviation of tick per nanosecond measurements, which is calculated or set explicitly in the `fd_tempo_set_tick_per_ns` function.


---
### explicit\_set
- **Type**: ``int``
- **Description**: A static integer variable that indicates whether the tick per nanosecond value has been explicitly set by the user.
- **Use**: Used to determine if the tick per nanosecond value should be sampled or if it has already been set explicitly.


# Functions

---
### fd\_tempo\_wallclock\_model<!-- {{#callable:fd_tempo_wallclock_model}} -->
[View Source →](<../../../../../src/tango/tempo/fd_tempo.c#L6>)

Models the overhead and jitter of the `fd_log_wallclock()` function call using a robust estimator for a shifted exponential random variable.
- **Inputs**:
    - `opt_tau`: A pointer to a double where the function will store the estimated jitter parameter `tau` if it is not NULL.
- **Logic and Control Flow**:
    - Initialize static variables `t0` and `tau` to store the model parameters.
    - Use `FD_ONCE_BEGIN` to ensure the initialization block runs only once.
    - Enter an infinite loop to perform the modeling process.
    - Define constants `TRIAL_CNT` and `TRIM_CNT` for the number of trials and trimming count.
    - Create an array `trial` to store the time differences between consecutive `fd_log_wallclock()` calls.
    - Perform `TRIAL_CNT` measurements of the time taken for `fd_log_wallclock()` calls and store the results in `trial`.
    - Trim the first and last `TRIM_CNT` samples from `trial` to form `sample`.
    - Calculate `sample_cnt` as the number of samples after trimming and `thresh` as half of `sample_cnt`.
    - Use `fd_stat_robust_exp_fit_double` to fit a robust exponential model to `sample` and update `t0` and `tau`.
    - Break the loop if the fit is successful and `t0` is positive, otherwise increment `iter`.
    - Log a warning and set fallback values for `t0` and `tau` if the loop iterates three times without success.
    - End the `FD_ONCE_BEGIN` block.
    - If `opt_tau` is not NULL, store `tau` in the location pointed to by `opt_tau`.
- **Output**: Returns the estimated minimal overhead `t0` of the `fd_log_wallclock()` function call.


---
### fd\_tempo\_tickcount\_model<!-- {{#callable:fd_tempo_tickcount_model}} -->
[View Source →](<../../../../../src/tango/tempo/fd_tempo.c#L61>)

Models the performance of the `fd_tickcount()` function by estimating the minimal overhead and jitter using a robust exponential fit.
- **Inputs**:
    - `opt_tau`: A pointer to a double where the function can store the estimated jitter (tau). If NULL, the function does not store the jitter.
- **Logic and Control Flow**:
    - Initializes static variables `t0` and `tau` to store the model parameters.
    - Uses a loop to repeatedly measure the time difference between consecutive calls to `fd_tickcount()` to gather samples.
    - Defines `TRIAL_CNT` as 512 and `TRIM_CNT` as 64 to control the number of samples and trimming for robust estimation.
    - Stores the time differences in an array `trial` and trims the first and last `TRIM_CNT` samples to form the `sample` array.
    - Calculates the number of samples `sample_cnt` and a threshold `thresh` for robust fitting.
    - Uses `fd_stat_robust_exp_fit_double` to fit the samples to a shifted exponential model, updating `t0` and `tau`.
    - Breaks the loop if the fit is successful and `t0` is positive, otherwise retries up to 3 times.
    - Logs a warning and uses fallback values for `t0` and `tau` if the model cannot be fitted after 3 iterations.
    - Stores the estimated jitter `tau` in `opt_tau` if it is not NULL.
- **Output**: Returns the estimated minimal overhead `t0` for the `fd_tickcount()` function.


---
### fd\_tempo\_set\_tick\_per\_ns<!-- {{#callable:fd_tempo_set_tick_per_ns}} -->
[View Source →](<../../../../../src/tango/tempo/fd_tempo.c#L108>)

Sets the global variables `mu` and `sigma` to the provided values and marks them as explicitly set.
- **Inputs**:
    - `_mu`: The mean value to set for the global variable `mu`.
    - `_sigma`: The standard deviation value to set for the global variable `sigma`.
- **Logic and Control Flow**:
    - Set the global variable `explicit_set` to 1 to indicate that the values have been explicitly set.
    - Assign the input `_mu` to the global variable `mu`.
    - Assign the input `_sigma` to the global variable `sigma`.
- **Output**: No output is returned as the function is of type `void`.


---
### fd\_tempo\_observe\_pair<!-- {{#callable:fd_tempo_observe_pair}} -->
[View Source →](<../../../../../src/tango/tempo/fd_tempo.c#L169>)

Performs a series of alternating tickcount and wallclock observations to determine the wallclock observation with the smallest elapsed ticks between adjacent tickcount observations.
- **Inputs**:
    - `opt_now`: A pointer to a long where the function will store the best wallclock observation, if not NULL.
    - `opt_tic`: A pointer to a long where the function will store the best tickcount observation adjusted by the midpoint of the joint time, if not NULL.
- **Logic and Control Flow**:
    - Initialize variables `best_wc`, `best_tc`, and `best_jt` to store the best wallclock, tickcount, and joint time observations respectively.
    - Define `TRIAL_CNT` as 4 to perform 1 warmup and 3 real reads.
    - Perform a series of alternating tickcount and wallclock observations, storing results in arrays `wc` and `tc`.
    - Initialize `best_wc`, `best_tc`, and `best_jt` with the first real observation results.
    - Iterate over the observations to find the wallclock observation with the smallest elapsed ticks between adjacent tickcount observations, updating `best_wc`, `best_tc`, and `best_jt` accordingly.
    - Check if `best_jt` is negative, log a warning if so, and set `best_jt` to 0.
    - If `opt_now` is not NULL, store `best_wc` in `opt_now`.
    - If `opt_tic` is not NULL, store the adjusted `best_tc` in `opt_tic`.
- **Output**: Returns the best joint time (`best_jt`), which is the smallest elapsed ticks between adjacent tickcount observations.


---
### fd\_tempo\_async\_min<!-- {{#callable:fd_tempo_async_min}} -->
[View Source →](<../../../../../src/tango/tempo/fd_tempo.c#L254>)

Calculates the minimum asynchronous interval based on input parameters, ensuring it is a power of two within a specified range.
- **Inputs**:
    - `lazy`: A long integer that should be in the range [1, 2^31).
    - `event_cnt`: An unsigned long integer that should be in the range [1, 2^31).
    - `tick_per_ns`: A float representing ticks per nanosecond, which should be in the range (0, ~1.5e29).
- **Logic and Control Flow**:
    - Check if `lazy` is within the valid range [1, 2^31); if not, log a warning and return 0.
    - Check if `event_cnt` is within the valid range [1, 2^31); if not, log a warning and return 0.
    - Calculate `tick_per_ns_max` as `FLT_MAX / (1L<<31)` and check if `tick_per_ns` is within the range (0, `tick_per_ns_max`); if not, log a warning and return 0.
    - Convert `lazy` and `event_cnt` to floats `_lazy` and `_event_cnt`, respectively, and calculate `_async_target` as `(tick_per_ns * _lazy) / _event_cnt`.
    - Check if `_async_target` is at least 1; if not, log a warning and return 0.
    - Check if `_async_target` is less than 2^32; if not, log a warning and return 0.
    - Convert `_async_target` to an unsigned long `async_target`.
    - Return `1UL << fd_ulong_find_msb(async_target)`, ensuring the result is a power of two within [1, 2^31].
- **Output**: An unsigned long integer representing the minimum asynchronous interval, which is a power of two within the range [1, 2^31].



---
Made with ❤️ by [Driver](https://www.driver.ai/)