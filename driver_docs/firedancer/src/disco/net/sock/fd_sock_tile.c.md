<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements socket management and data transmission for a network tile, including UDP socket creation and packet handling.

# Purpose
The code is a C source file that implements a network socket management module for a system called Firedancer. It is designed to handle both the creation and management of UDP sockets and the transmission and reception of network packets. The module is part of a larger system that appears to be focused on high-performance networking, as indicated by the use of functions like `recvmmsg` and `sendmmsg` for batch processing of messages. The code includes functionality for configuring socket options, binding sockets to specific addresses and ports, and managing ancillary data for packet transmission.

The module defines several static functions that handle different aspects of socket management, such as [`create_udp_socket`](<#create_udp_socket>) for creating and configuring UDP sockets, [`poll_rx_socket`](<#poll_rx_socket>) for receiving packets, and [`flush_tx_batch`](<#flush_tx_batch>) for sending packets. It also includes functions for initializing the module in both privileged and unprivileged modes, which suggests that it is designed to operate in environments with varying levels of access control. The code makes extensive use of macros and constants to manage configuration parameters, such as `STEM_BURST` for batch sizes and `RX_SOCK_FD_MIN` for socket file descriptor ranges. Additionally, the module integrates with a larger system through callback functions and metrics reporting, indicating that it is part of a modular and extensible architecture.
# Imports and Dependencies

---
- `fd_sock_tile_private.h`
- `../fd_net_common.h`
- `../../topo/fd_topo.h`
- `../../../util/net/fd_eth.h`
- `../../../util/net/fd_ip4.h`
- `../../../util/net/fd_udp.h`
- `assert.h`
- `stdalign.h`
- `errno.h`
- `fcntl.h`
- `unistd.h`
- `netinet/in.h`
- `sys/socket.h`
- `../../metrics/fd_metrics.h`
- `generated/fd_sock_tile_seccomp.h`
- `../../stem/fd_stem.c`


# Global Variables

---
### before\_frag
- **Type**: `function`
- **Description**: Implements early filtering logic for incoming fragments in a socket tile. It checks the protocol of the fragment and determines if processing should continue.
- **Use**: Used to filter incoming fragments based on their protocol before further processing.


---
### fd\_tile\_sock
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a structure of type `fd_topo_run_tile_t` that represents a configuration for a network socket tile. It includes function pointers and parameters necessary for initializing and running the tile.
- **Use**: Used to configure and manage the lifecycle of a network socket tile in a topology.


# Functions

---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L37>)

Populates a seccomp filter policy for a socket tile and returns the instruction count.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the tile configuration.
    - ``out_cnt``: An unsigned long integer representing the count of output filters.
    - ``out``: A pointer to a `struct sock_filter` array where the seccomp filter policy will be populated.
- **Logic and Control Flow**:
    - Initialize scratch memory allocation with `FD_SCRATCH_ALLOC_INIT` using the local address of the tile object from the topology.
    - Allocate memory for a `fd_sock_tile_t` context using `FD_SCRATCH_ALLOC_APPEND`.
    - Call [`populate_sock_filter_policy_fd_sock_tile`](<generated/fd_sock_tile_seccomp.h.md#populate_sock_filter_policy_fd_sock_tile>) with the provided parameters to populate the seccomp filter policy.
    - Return the instruction count from `sock_filter_policy_fd_sock_tile_instr_cnt`.
- **Output**: Returns an unsigned long integer representing the instruction count of the seccomp filter policy.
- **Functions Called**:
    - [`populate_sock_filter_policy_fd_sock_tile`](<generated/fd_sock_tile_seccomp.h.md#populate_sock_filter_policy_fd_sock_tile>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L49>)

Populates an array with file descriptors that are allowed for a given tile in a network topology.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the specific tile in the topology.
    - ``out_fds_cnt``: An unsigned long integer representing the maximum number of file descriptors that can be stored in the `out_fds` array.
    - ``out_fds``: A pointer to an integer array where the allowed file descriptors will be stored.
- **Logic and Control Flow**:
    - Allocate scratch memory for the tile object using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_INIT`.
    - Append a `fd_sock_tile_t` context to the scratch memory using `FD_SCRATCH_ALLOC_APPEND`.
    - Retrieve the socket count from the context (`ctx->sock_cnt`).
    - Check if `out_fds_cnt` is less than the required number of file descriptors (`sock_cnt + 3`). If true, log an error using `FD_LOG_ERR`.
    - Initialize `out_cnt` to 0 and populate `out_fds` with the file descriptor for `stderr` (2).
    - If the log file descriptor is valid, add it to `out_fds`.
    - Add the transmit socket file descriptor (`ctx->tx_sock`) to `out_fds`.
    - Iterate over each socket in `ctx->pollfd` and add its file descriptor to `out_fds`.
    - Return the total count of file descriptors added to `out_fds`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array as an unsigned long integer.


---
### tx\_scratch\_footprint<!-- {{#callable:tx_scratch_footprint}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L76>)

Calculates the memory footprint required for a transmission scratch buffer.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `fd_ulong_align_up` with `FD_NET_MTU` and `FD_CHUNK_ALIGN` to align the maximum transmission unit size to the chunk alignment.
    - Multiplies the result by `STEM_BURST` to determine the total memory footprint.
- **Output**: Returns an `ulong` representing the calculated memory footprint.


---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L81>)

Returns a constant alignment value of 4096 bytes.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the constant value `4096UL`.
- **Output**: A constant unsigned long integer value of 4096.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L86>)

Calculates the memory footprint required for a scratch space based on various data structures and alignment requirements.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure, which is not used in this function.
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT`.
    - Append the size and alignment of `fd_sock_tile_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the size and alignment of an array of `struct iovec` with `STEM_BURST` elements to `l`.
    - Append the size and alignment of an array of `struct cmsghdr` with `STEM_BURST * FD_SOCK_CMSG_MAX` elements to `l`.
    - Append the size and alignment of an array of `struct sockaddr_in` with `STEM_BURST` elements to `l`.
    - Append the size and alignment of an array of `struct mmsghdr` with `STEM_BURST` elements to `l`.
    - Append the size and alignment of the result from `tx_scratch_footprint()` to `l`.
    - Finalize the layout with `FD_LAYOUT_FINI` using `scratch_align()` and return the result.
- **Output**: Returns an `ulong` representing the total memory footprint required.
- **Functions Called**:
    - [`tx_scratch_footprint`](<#tx_scratch_footprint>)
    - [`scratch_align`](<#scratch_align>)


---
### create\_udp\_socket<!-- {{#callable:create_udp_socket}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L101>)

Creates and configures a UDP socket with specified options and binds it to a given address and port.
- **Inputs**:
    - `sock_fd`: The file descriptor for the socket to be created.
    - `bind_addr`: The IP address to bind the socket to, in network byte order.
    - `udp_port`: The UDP port number to bind the socket to, in host byte order.
    - `so_rcvbuf`: The size of the receive buffer for the socket.
- **Logic and Control Flow**:
    - Checks if the file descriptor `sock_fd` is already in use; logs an error if it is.
    - Creates a new UDP socket using `socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)` and logs an error if it fails.
    - Sets the `SO_REUSEPORT` option on the socket to allow multiple sockets to bind to the same address and port.
    - Enables the `IP_PKTINFO` option to receive packet information.
    - Sets the receive buffer size using `setsockopt` with `SO_RCVBUF`.
    - Initializes a `sockaddr_in` structure with the specified `bind_addr` and `udp_port`, and binds the socket to this address.
    - Duplicates the original socket file descriptor to `sock_fd` using `dup3` or `dup2` depending on the platform.
    - Closes the original socket file descriptor `orig_fd`.
- **Output**: No return value; the function configures the socket and logs errors if any operation fails.


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L156>)

Initializes socket-related resources and configurations for a network tile in a topology.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the specific tile within the topology.
- **Logic and Control Flow**:
    - Allocate scratch memory for socket-related structures using `FD_SCRATCH_ALLOC_INIT` and `FD_SCRATCH_ALLOC_APPEND` macros.
    - Initialize memory for various socket-related structures such as `fd_sock_tile_t`, `struct iovec`, `struct cmsghdr`, `struct sockaddr_in`, and `struct mmsghdr` using `fd_memset`.
    - Set up the context (`ctx`) with initial values and pointers to allocated memory regions.
    - Iterate over potential UDP port candidates to create and configure receive sockets, checking for valid ports and assigning them to file descriptors starting from `RX_SOCK_FD_MIN`.
    - Validate specific socket indices for repair intake and serve ports using `FD_TEST`.
    - Map UDP ports to their respective links and protocols, and create UDP sockets using [`create_udp_socket`](<#create_udp_socket>) function.
    - Configure the `pollfd` structure for each socket to listen for incoming data (`POLLIN` events).
    - Create a transmit socket using `socket` function with `SOCK_RAW` and `SOCK_CLOEXEC` flags, and configure its send buffer size using `setsockopt`.
    - Assign the transmit socket and bind address to the context (`ctx`).
- **Output**: No return value; the function operates by side effects on the provided `topo` and `tile` structures.
- **Functions Called**:
    - [`tx_scratch_footprint`](<#tx_scratch_footprint>)
    - [`create_udp_socket`](<#create_udp_socket>)


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L266>)

Initializes the unprivileged context for a socket tile by setting up receive and transmit links based on the topology and tile configuration.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to the `fd_topo_tile_t` structure representing the specific tile configuration.
- **Logic and Control Flow**:
    - Retrieve the local address of the socket tile context using `fd_topo_obj_laddr` with `topo` and `tile->tile_obj_id`.
    - Check if the number of outgoing links (`tile->out_cnt`) exceeds `MAX_NET_OUTS` and log an error if true.
    - Iterate over each outgoing link (`tile->out_cnt`) and verify that the link name starts with "net_"; log an error if not.
    - For each valid outgoing link, set up the receive link context (`ctx->link_rx`) with base, chunk0, and watermark values using `fd_dcache_compact_chunk0` and `fd_dcache_compact_wmark`.
    - Check if the burst size of each link is less than `STEM_BURST` and log an error if true.
    - Iterate over each incoming link (`tile->in_cnt`) and verify that the link name contains "_net"; log an error if not.
    - For each valid incoming link, set up the transmit link context (`ctx->link_tx`) with base, chunk0, and watermark values using `fd_dcache_compact_chunk0` and `fd_dcache_compact_wmark`.
- **Output**: No return value; the function initializes the context in place.


---
### poll\_rx\_socket<!-- {{#callable:poll_rx_socket}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L310>)

Receives and processes a batch of UDP packets from a socket, updating metrics and preparing data for further processing.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_sock_tile_t` structure, which contains context and state information for the socket operations.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing data and managing state.
    - ``sock_idx``: An unsigned integer representing the index of the socket being polled.
    - ``sock_fd``: An integer file descriptor for the socket from which packets are received.
    - ``proto``: A `ushort` representing the protocol identifier for the packets being processed.
- **Logic and Control Flow**:
    - Calculate header size and maximum payload size based on network MTU and header structures.
    - Determine the receive link and destination port for the socket index from the context.
    - Prepare a batch of message headers and I/O vectors for receiving packets, speculatively setting up chunk indexes for data storage.
    - Call `recvmmsg` to receive a batch of messages from the socket, handling errors and updating metrics.
    - For each received message, validate and process the packet, updating metrics and preparing headers for further processing.
    - Determine the destination address from control messages and update the Ethernet, IP, and UDP headers accordingly.
    - Publish the processed packet data using `fd_stem_publish`, routing repair ping messages to a specific link if necessary.
    - Update the chunk index to the next free index for future packet reception.
    - Return the number of messages successfully received.
- **Output**: Returns the number of packets successfully received and processed as an `ulong`.


---
### poll\_rx<!-- {{#callable:poll_rx}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L438>)

Polls sockets for incoming data and processes received packets.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_sock_tile_t` structure that contains context information for socket operations.
    - ``stem``: A pointer to a `fd_stem_context_t` structure used for processing received packets.
- **Logic and Control Flow**:
    - Initialize `pkt_cnt` to 0 to count the number of packets processed.
    - Check if `ctx->batch_cnt` is non-zero, indicating an unclean batch, and log an error if true.
    - Reset `ctx->tx_idle_cnt` to 0 to restart TX polling.
    - Call `fd_syscall_poll` to poll the file descriptors in `ctx->pollfd` for events, logging an error if the call fails.
    - Iterate over each socket in `ctx->pollfd` using a loop from 0 to `ctx->sock_cnt`.
    - For each socket, check if `revents` indicates `POLLIN` or `POLLERR`.
    - If a socket has events, call [`poll_rx_socket`](<#poll_rx_socket>) to process incoming packets and add the result to `pkt_cnt`.
    - Reset `revents` for each socket to 0 after processing.
    - Return the total packet count `pkt_cnt`.
- **Output**: Returns the total number of packets processed as an unsigned long integer.
- **Functions Called**:
    - [`poll_rx_socket`](<#poll_rx_socket>)


---
### flush\_tx\_batch<!-- {{#callable:flush_tx_batch}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L466>)

Sends a batch of messages from a socket and updates metrics based on the success or failure of the send operation.
- **Inputs**:
    - `ctx`: A pointer to a `fd_sock_tile_t` structure that contains the context for the socket operations, including the batch of messages to send and metrics to update.
- **Logic and Control Flow**:
    - Retrieve the number of messages in the batch from `ctx->batch_cnt`.
    - Iterate over the batch of messages, attempting to send them using `sendmmsg`.
    - If `sendmmsg` sends messages successfully, increment the no-error metric counter.
    - If `sendmmsg` sends fewer messages than requested, increment the drop count and handle errors based on `errno`.
    - For specific errors like `EAGAIN`, `ENOBUFS`, `EPERM`, `ENETUNREACH`, `EHOSTUNREACH`, `ENONET`, `ENETDOWN`, and `EHOSTDOWN`, increment the corresponding error metric counter.
    - Log a notice if an unknown error occurs during `sendmmsg`.
    - Adjust the loop index `j` based on the number of messages sent or failed.
    - If all messages are sent successfully, update the packet count metric and exit the loop.
    - Reset `ctx->tx_ptr` and `ctx->batch_cnt` after processing the batch.
- **Output**: No direct output is returned, but the function updates the metrics in the `ctx` structure and resets the batch count and pointer.


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L542>)

Processes a network fragment by validating, preparing, and copying it into a send buffer for transmission.
- **Inputs**:
    - ``ctx``: Pointer to the `fd_sock_tile_t` context structure containing socket and transmission information.
    - ``in_idx``: Index of the input link in the context's transmission array.
    - ``seq``: Sequence number of the fragment, marked as unused.
    - ``sig``: Signature of the fragment used to determine header size.
    - ``chunk``: Chunk index of the fragment in the transmission buffer.
    - ``sz``: Size of the fragment in bytes.
    - ``ctl``: Control parameter, marked as unused.
- **Logic and Control Flow**:
    - Check if the `chunk` is within the valid range and if `sz` is less than or equal to `FD_NET_MTU`; log an error if not.
    - Calculate the minimum header size and check if `sz` is less than this minimum; log an error if true.
    - Convert the `chunk` to a local address and calculate the header size using `sig`.
    - Verify that the header size is within valid bounds; log an error if not.
    - Extract the IP and UDP headers from the frame and payload, respectively.
    - Check if the IP version is 4 and the protocol is UDP; log an error if not.
    - Calculate the message size and prepare the `mmsghdr`, `sockaddr_in`, `iovec`, and `cmsghdr` structures for the message.
    - Copy the UDP header and payload into the transmission buffer.
    - Update the total transmitted bytes in the context's metrics.
- **Output**: No return value; the function updates the context's transmission buffer and metrics.


---
### after\_frag<!-- {{#callable:after_frag}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L620>)

Commits a packet to the transmission buffer and flushes the buffer if it reaches a predefined batch size.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_sock_tile_t` structure, which holds the context for socket operations.
    - ``in_idx``: An unused parameter, presumably intended to represent the index of the input.
    - ``seq``: An unused parameter, presumably intended to represent the sequence number of the packet.
    - ``sig``: An unused parameter, presumably intended to represent the signature of the packet.
    - ``sz``: The size of the packet being processed.
    - ``tsorig``: An unused parameter, presumably intended to represent the original timestamp of the packet.
    - ``tspub``: An unused parameter, presumably intended to represent the publication timestamp of the packet.
    - ``stem``: An unused parameter, presumably intended to represent the context for stem operations.
- **Logic and Control Flow**:
    - Set `ctx->tx_idle_cnt` to 0 to indicate activity in the transmission buffer.
    - Increment `ctx->batch_cnt` to track the number of packets in the current batch.
    - Align the `sz` value to `FD_CHUNK_ALIGN` and add it to `ctx->tx_ptr` to update the transmission pointer.
    - Check if `ctx->batch_cnt` is greater than or equal to `STEM_BURST`.
    - If the batch count reaches `STEM_BURST`, call `flush_tx_batch(ctx)` to send the batch of packets.
- **Output**: No return value; the function operates by modifying the state of the `ctx` structure.
- **Functions Called**:
    - [`flush_tx_batch`](<#flush_tx_batch>)


---
### after\_credit<!-- {{#callable:after_credit}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L647>)

Manages transmission and reception of network packets, flushing transmission batches and polling for received packets when idle.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_sock_tile_t` structure that holds the context for socket operations.
    - ``stem``: A pointer to a `fd_stem_context_t` structure used for managing the stem context.
    - ``poll_in``: An unused integer pointer parameter, marked with `FD_PARAM_UNUSED`.
    - ``charge_busy``: A pointer to an integer that indicates if the function detected any received packets.
- **Logic and Control Flow**:
    - Check if `ctx->tx_idle_cnt` is greater than 512.
    - If `ctx->batch_cnt` is non-zero, call `flush_tx_batch(ctx)` to flush the transmission batch.
    - Call `poll_rx(ctx, stem)` to poll for received packets and store the result in `pkt_cnt`.
    - Set `*charge_busy` to true if `pkt_cnt` is not zero, indicating packets were received.
    - Increment `ctx->tx_idle_cnt`.
- **Output**: No direct return value; modifies `*charge_busy` to indicate if packets were received.
- **Functions Called**:
    - [`flush_tx_batch`](<#flush_tx_batch>)
    - [`poll_rx`](<#poll_rx>)


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L662>)

Updates various socket-related metrics in the context structure.
- **Inputs**:
    - `ctx`: A pointer to a `fd_sock_tile_t` structure that contains the metrics to update.
- **Logic and Control Flow**:
    - Set the `sys_recvmmsg_cnt` metric using `FD_MCNT_SET` macro.
    - Copy the `sys_sendmmsg_cnt` metric using `FD_MCNT_ENUM_COPY` macro.
    - Set the `rx_pkt_cnt` metric using `FD_MCNT_SET` macro.
    - Set the `tx_pkt_cnt` metric using `FD_MCNT_SET` macro.
    - Set the `tx_drop_cnt` metric using `FD_MCNT_SET` macro.
    - Set the `tx_bytes_total` metric using `FD_MCNT_SET` macro.
    - Set the `rx_bytes_total` metric using `FD_MCNT_SET` macro.
- **Output**: No return value; the function updates metrics in the provided context.


---
### rlimit\_file\_cnt<!-- {{#callable:rlimit_file_cnt}} -->
[View Source →](<../../../../../../src/disco/net/sock/fd_sock_tile.c#L673>)

Calculates the total number of file descriptors required for socket operations in a given tile.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology configuration.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the specific tile configuration.
- **Logic and Control Flow**:
    - Retrieve the local address of the tile object using `fd_topo_obj_laddr` with `topo` and `tile->tile_obj_id` as arguments.
    - Access the `sock_cnt` field from the `fd_sock_tile_t` structure pointed to by the retrieved local address.
    - Add the constant `RX_SOCK_FD_MIN` to the `sock_cnt` to calculate the total number of file descriptors.
- **Output**: Returns an `ulong` representing the total number of file descriptors needed for the tile's socket operations.



---
Made with ❤️ by [Driver](https://www.driver.ai/)