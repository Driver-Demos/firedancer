<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Translates between AF_XDP and fd_tango traffic, sets up XDP and XSK socket configuration, and manages network packet processing and routing.

# Purpose
The code is a C source file that implements a network tile for handling traffic between AF_XDP sockets and a custom protocol called `fd_tango`. The primary function of this code is to set up and manage XDP (eXpress Data Path) and XSK (AF_XDP socket) configurations, enabling efficient packet processing and transmission. The code includes definitions for various data structures and functions that facilitate the management of network traffic, including the setup of socket configurations, handling of incoming and outgoing packets, and maintenance of network metrics.

Key components of the code include structures like `fd_net_ctx_t`, which holds the context for network operations, and `fd_net_flusher_t`, which manages the pacing of packet transmissions. The code also defines several functions for handling packet transmission ([`net_tx_ready`](<#net_tx_ready>), [`net_tx_wakeup`](<#net_tx_wakeup>)), reception ([`net_rx_event`](<#net_rx_event>), [`net_rx_packet`](<#net_rx_packet>)), and routing ([`net_tx_route`](<#net_tx_route>)). Additionally, the code includes mechanisms for managing network device tables and handling GRE (Generic Routing Encapsulation) packets. The file is part of a larger system, likely a network application or service, and is designed to be integrated with other components, as indicated by the inclusion of various headers and the use of external interfaces.
# Imports and Dependencies

---
- `errno.h`
- `fcntl.h`
- `net/if.h`
- `netinet/in.h`
- `sys/socket.h`
- `linux/if_xdp.h`
- `../fd_net_common.h`
- `../../metrics/fd_metrics.h`
- `../../netlink/fd_netlink_tile.h`
- `../../topo/fd_topo.h`
- `../../../waltz/ip/fd_fib4.h`
- `../../../waltz/neigh/fd_neigh4_map.h`
- `../../../waltz/mib/fd_netdev_tbl.h`
- `../../../waltz/mib/fd_dbl_buf.h`
- `../../../waltz/xdp/fd_xdp_redirect_user.h`
- `../../../waltz/xdp/fd_xsk.h`
- `../../../util/log/fd_dtrace.h`
- `../../../util/net/fd_eth.h`
- `../../../util/net/fd_ip4.h`
- `../../../util/net/fd_gre.h`
- `unistd.h`
- `linux/if.h`
- `sys/ioctl.h`
- `linux/unistd.h`
- `linux/if_arp.h`
- `generated/fd_xdp_tile_seccomp.h`
- `../../stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_net
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Represents a network tile configuration for the XDP tile, which translates between AF_XDP and `fd_tango` traffic. It is responsible for setting up the XDP and XSK socket configuration.
- **Use**: Used to define the network tile's behavior and configuration in the system.


# Data Structures

---
### fd\_net\_in\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``mem``: Pointer to a `fd_wksp_t` structure, representing the memory workspace.
    - ``chunk0``: Unsigned long integer indicating the starting chunk index.
    - ``wmark``: Unsigned long integer representing the watermark or upper limit for chunks.
- **Description**: `fd_net_in_ctx_t` is a structure that holds consumer information for an incoming tango link, used as part of the TX path in a network tile. It contains a pointer to a memory workspace, a starting chunk index, and a watermark to manage the data flow.


---
### fd\_net\_out\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``mcache``: Pointer to a `fd_frag_meta_t` structure for managing metadata cache.
    - ``sync``: Pointer to an `ulong` for synchronization purposes.
    - ``depth``: An `ulong` representing the depth of the metadata cache.
    - ``seq``: An `ulong` representing the sequence number for the metadata cache.
- **Description**: Contains publisher information for a link to a downstream application tile, used as part of the RX path.


---
### fd\_net\_flusher
- **Type**: ``struct``
- **Members**:
    - ``pending_cnt``: Counts packets enqueued after the last `sendto()` wakeup.
    - ``pending_wmark``: Threshold for pending packets to trigger a wakeup.
    - ``next_tail_flush_ticks``: Time ticks for the next tail flush after a `sendto()` wakeup.
    - ``tail_flush_backoff``: Backoff ticks for tail flush if packets remain unacknowledged.
- **Description**: Controls the pacing of XDP `sendto()` calls for flushing TX batches, ensuring efficient packet transmission by managing wakeup triggers based on packet rate and unacknowledged packets.


---
### fd\_net\_flusher\_t
- **Type**: ``struct``
- **Members**:
    - `pending_cnt`: Counts packets enqueued after the last `sendto()` wakeup.
    - `pending_wmark`: Threshold for pending packets to trigger a wakeup.
    - `next_tail_flush_ticks`: Time ticks for the next tail flush after a `sendto()` wakeup.
    - `tail_flush_backoff`: Backoff time in ticks before issuing another wakeup if packets remain unacknowledged.
- **Description**: Controls the pacing of XDP `sendto()` calls for flushing TX batches, ensuring efficient packet transmission by balancing wakeup frequency to avoid context switches and packet delays.


---
### fd\_net\_free\_ring\_t
- **Type**: ``struct``
- **Members**:
    - ``prod``: The producer index of the queue.
    - ``cons``: The consumer index of the queue.
    - ``depth``: The maximum number of elements the queue can hold.
    - ``queue``: A pointer to an array of `ulong` that stores the queue elements.
- **Description**: A FIFO queue that stores pointers to free XDP TX frames, used to manage the availability of transmission buffers in a network context. The `prod` and `cons` indices track the positions for producing and consuming elements, respectively, while `depth` defines the queue's capacity. The `queue` array holds the actual pointers to the free frames.


---
### fd\_net\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``xsk_cnt``: Stores the count of AF_XDP sockets.
    - ``xsk``: An array of AF_XDP sockets.
    - ``prog_link_fds``: File descriptors for program links.
    - ``umem_frame0``: Pointer to the first UMEM frame.
    - ``umem_sz``: Size of usable UMEM starting at `umem_frame0`.
    - ``umem_chunk0``: Lowest allowed chunk number in UMEM.
    - ``umem_wmark``: Highest allowed chunk number in UMEM.
    - ``net_tile_id``: Index of the current network interface.
    - ``net_tile_cnt``: Total number of network interfaces.
    - ``tx_op``: Details of an inflight send operation.
    - ``rr_idx``: Index for round-robin cycle service operations.
    - ``free_tx``: Ring tracking free packet buffers.
    - ``src_mac_addr``: Source MAC address.
    - ``default_address``: Default IP address.
    - ``bind_address``: IP address to bind to.
    - ``shred_listen_port``: Port for listening to shred transactions.
    - ``quic_transaction_listen_port``: Port for listening to QUIC transactions.
    - ``legacy_transaction_listen_port``: Port for listening to legacy transactions.
    - ``gossip_listen_port``: Port for listening to gossip messages.
    - ``repair_intake_listen_port``: Port for listening to repair intake.
    - ``repair_serve_listen_port``: Port for serving repair requests.
    - ``send_src_port``: Source port for sending.
    - ``in_cnt``: Count of incoming network contexts.
    - ``in``: Array of incoming network contexts.
    - ``quic_out``: Outgoing context for QUIC.
    - ``shred_out``: Outgoing context for shred.
    - ``gossvf_out``: Outgoing context for gossip.
    - ``repair_out``: Outgoing context for repair.
    - ``send_out``: Outgoing context for send operations.
    - ``xdp_stats_interval_ticks``: Interval for XDP stats refresh in ticks.
    - ``next_xdp_stats_refresh``: Next scheduled time for XDP stats refresh.
    - ``tx_flusher``: Array of TX flusher structures, one per XSK.
    - ``fib_local``: Pointer to the local route table.
    - ``fib_main``: Pointer to the main route table.
    - ``neigh4``: Array of neighbor tables.
    - ``neigh4_solicit``: Array of neighbor solicit links.
    - ``netdev_dbl_buf``: Pointer to the remote copy of the device table.
    - ``netdev_buf``: Pointer to the local copy of the device table.
    - ``netdev_buf_sz``: Size of the local device table buffer.
    - ``netdev_tbl``: Join to the local copy of the device table.
    - ``has_gre_interface``: Flag to enable GRE support.
    - ``metrics``: Structure containing various network metrics.
- **Description**: `fd_net_ctx_t` is a complex data structure that manages network context for AF_XDP sockets, including UMEM management, network interface handling, and packet transmission operations. It contains fields for socket management, UMEM frame and chunk tracking, network interface identifiers, and various operational details for transmitting and receiving packets. The structure also includes metrics for monitoring network performance and supports GRE encapsulation. It is designed to handle multiple network interfaces and manage the flow of packets through a series of incoming and outgoing contexts.


---
### xdp\_statistics\_v0
- **Type**: ``struct``
- **Members**:
    - ``rx_dropped``: Counts packets dropped for unspecified reasons.
    - ``rx_invalid_descs``: Counts packets dropped due to invalid descriptors in the receive path.
    - ``tx_invalid_descs``: Counts packets dropped due to invalid descriptors in the transmit path.
- **Description**: The `xdp_statistics_v0` structure is used to track statistics related to packet drops in an XDP (eXpress Data Path) environment. It contains three fields that count the number of packets dropped for various reasons, including general drops, and drops due to invalid descriptors in both the receive and transmit paths. This structure helps in monitoring and diagnosing issues related to packet handling in XDP applications.


---
### xdp\_statistics\_v1
- **Type**: ``struct``
- **Members**:
    - ``rx_dropped``: Counts packets dropped for unspecified reasons.
    - ``rx_invalid_descs``: Counts packets dropped due to invalid descriptors in the receive path.
    - ``tx_invalid_descs``: Counts packets dropped due to invalid descriptors in the transmit path.
    - ``rx_ring_full``: Counts packets dropped because the receive ring is full.
    - ``rx_fill_ring_empty_descs``: Counts failures to retrieve items from the fill ring.
    - ``tx_ring_empty_descs``: Counts failures to retrieve items from the transmit ring.
- **Description**: The `xdp_statistics_v1` structure collects various statistics related to packet processing in an XDP (eXpress Data Path) environment. It tracks the number of packets dropped for different reasons, such as invalid descriptors or full rings, in both the receive and transmit paths. This structure helps in monitoring and diagnosing issues in the packet processing pipeline.


# Functions

---
### fd\_net\_flusher\_inc<!-- {{#callable:fd_net_flusher_inc}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L104>)

Marks a new packet as enqueued and updates the next tail flush time.
- **Inputs**:
    - ``flusher``: A pointer to an `fd_net_flusher_t` structure that controls the pacing of XDP sendto calls for flushing TX batches.
    - ``now``: A long integer representing the current time in ticks.
- **Logic and Control Flow**:
    - Increment the `pending_cnt` field of the `flusher` structure to indicate a new packet is enqueued.
    - Calculate `next_flush` as the sum of `now` and `flusher->tail_flush_backoff`.
    - Update `flusher->next_tail_flush_ticks` to the minimum of its current value and `next_flush`.
- **Output**: No return value; the function updates the state of the `flusher` structure.


---
### fd\_net\_flusher\_check<!-- {{#callable:fd_net_flusher_check}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L121>)

Determines if a sendto() wakeup should be issued based on pending packet count and timeout conditions.
- **Inputs**:
    - `flusher`: A pointer to an `fd_net_flusher_t` structure that controls the pacing of XDP sendto calls.
    - `now`: A long integer representing the current time in ticks.
    - `tx_ring_empty`: An integer indicating if the TX ring is empty (non-zero if empty, zero if not).
- **Logic and Control Flow**:
    - Calculate `flush_level` as true if `flusher->pending_cnt` is greater than or equal to `flusher->pending_wmark`.
    - Calculate `flush_timeout` as true if `now` is greater than or equal to `flusher->next_tail_flush_ticks`.
    - Determine `flush` as true if either `flush_level` or `flush_timeout` is true.
    - If `flush` is false, return 0.
    - If `flush` is true and `tx_ring_empty` is true, reset `flusher->pending_cnt` to 0 and `flusher->next_tail_flush_ticks` to `LONG_MAX`, then return 0.
    - If `flush` is true and `tx_ring_empty` is false, return 1.
- **Output**: Returns 1 if a sendto() wakeup should be issued, otherwise returns 0.


---
### fd\_net\_flusher\_wakeup<!-- {{#callable:fd_net_flusher_wakeup}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L141>)

Resets the `pending_cnt` to zero and updates the `next_tail_flush_ticks` based on the current time and `tail_flush_backoff`.
- **Inputs**:
    - ``flusher``: A pointer to an `fd_net_flusher_t` structure that controls the pacing of XDP sendto calls.
    - ``now``: A long integer representing the current time, typically obtained from a recent `fd_tickcount()` call.
- **Logic and Control Flow**:
    - Set `flusher->pending_cnt` to 0UL, indicating no packets are pending.
    - Calculate the next tail flush time by adding `flusher->tail_flush_backoff` to `now`.
    - Assign the calculated value to `flusher->next_tail_flush_ticks`.
- **Output**: No return value; the function modifies the `flusher` structure in place.


---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L272>)

Returns a constant value of 4096UL.
- **Inputs**: None
- **Logic and Control Flow**:
    - The function is defined as `static inline`, indicating it is intended for use within the same translation unit and suggests inlining for performance.
    - The function is marked with `FD_FN_CONST`, indicating it has no side effects and its return value depends only on its parameters, which in this case are none.
- **Output**: The function returns an unsigned long integer with the value 4096UL.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L277>)

Calculates the memory footprint required for a scratch space based on the alignment and size of various components.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure that contains configuration details, including `xdp.free_ring_depth`.
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT`.
    - Append the size and alignment of `fd_net_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the size and alignment of an array of `ulong` with length `tile->xdp.free_ring_depth` to `l`.
    - Append the size and alignment of a network device table footprint to `l` using `fd_netdev_tbl_footprint` and `fd_netdev_tbl_align`.
    - Finalize the layout with `FD_LAYOUT_FINI` using [`scratch_align`](<#scratch_align>) to determine the final alignment.
- **Output**: Returns an `ulong` representing the total memory footprint required for the scratch space.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L286>)

Updates network metrics by setting various counters and gauges based on the `ctx` structure's metrics data.
- **Inputs**:
    - `ctx`: A pointer to a `fd_net_ctx_t` structure containing network metrics to update.
- **Logic and Control Flow**:
    - Set multiple network receive (RX) metrics using `FD_MCNT_SET`, including packet count, total bytes, undersized packet count, fill blocked count, and backpressure count.
    - Set RX busy and idle counts using `FD_MGAUGE_SET`, ensuring values are non-negative by using `fd_long_max`.
    - Set multiple network transmit (TX) metrics using `FD_MCNT_SET`, including submit count, complete count, total bytes, route fail count, neighbor fail count, and full fail count.
    - Set TX busy and idle counts using `FD_MGAUGE_SET`, ensuring values are non-negative by using `fd_long_max`.
    - Set XSK (AF_XDP socket) wakeup counts for both TX and RX using `FD_MCNT_SET`.
    - Set GRE (Generic Routing Encapsulation) related metrics using `FD_MCNT_SET`, including GRE packet count, invalid packet count, ignored packet count, and route fail count.
- **Output**: No return value; the function updates metrics in the provided `ctx` structure.


---
### poll\_xdp\_statistics<!-- {{#callable:poll_xdp_statistics}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L330>)

Aggregates XDP statistics from multiple AF_XDP sockets and updates the metrics.
- **Inputs**:
    - ``ctx``: A pointer to `fd_net_ctx_t` structure, which contains context information for the network operations, including the number of XDP sockets and their file descriptors.
- **Logic and Control Flow**:
    - Initialize a `struct xdp_statistics_v1` named `stats` to zero.
    - Retrieve the count of XDP sockets from `ctx->xsk_cnt`.
    - Iterate over each XDP socket using a loop from 0 to `xsk_cnt`.
    - For each socket, initialize a `struct xdp_statistics_v1` named `sub_stats` and set `optlen` to the size of `struct xdp_statistics_v1`.
    - Call `getsockopt` to retrieve XDP statistics for the current socket and store them in `sub_stats`.
    - If `getsockopt` fails, log an error message and continue to the next socket.
    - Check if `optlen` matches the expected sizes of `struct xdp_statistics_v0` or `struct xdp_statistics_v1`; if not, log an error message.
    - Accumulate the statistics from `sub_stats` into `stats`.
    - After the loop, update the metrics using `FD_MCNT_SET` with the accumulated statistics in `stats`.
- **Output**: No return value; the function updates metrics based on the aggregated statistics.


---
### net\_is\_fatal\_xdp\_error<!-- {{#callable:net_is_fatal_xdp_error}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L364>)

Determines if a given error code from an XDP API call is a non-recoverable error.
- **Inputs**:
    - `err`: An integer representing the error code returned by an XDP API call.
- **Logic and Control Flow**:
    - Checks if the error code `err` is equal to `ESOCKTNOSUPPORT`, `EOPNOTSUPP`, `EINVAL`, or `EPERM`.
    - Returns 1 if any of these conditions are true, indicating a fatal error.
    - Returns 0 if none of these conditions are met, indicating a non-fatal error.
- **Output**: Returns 1 if the error is fatal and non-recoverable, otherwise returns 0.


---
### net\_load\_netdev\_tbl<!-- {{#callable:net_load_netdev_tbl}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L372>)

Loads the network device table into the local buffer and attempts to join it to the local context.
- **Inputs**:
    - `ctx`: A pointer to `fd_net_ctx_t`, which is the network context containing buffers and tables for network operations.
- **Logic and Control Flow**:
    - Attempts to read the network device table from the netlink tile using `fd_dbl_buf_read` into `ctx->netdev_buf`.
    - If the read operation fails, the function returns immediately without further processing.
    - If the read operation is successful, it attempts to join the local copy of the network device table using `fd_netdev_tbl_join`.
    - If the join operation fails, it logs an error message indicating the failure.
- **Output**: No explicit output is returned; the function modifies the network context `ctx` in place.


---
### net\_query\_netdev\_tbl<!-- {{#callable:net_query_netdev_tbl}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L385>)

Queries the network device table to return a pointer to the network device associated with a given interface index.
- **Inputs**:
    - `ctx`: A pointer to a `fd_net_ctx_t` structure, which contains the network context including the network device table.
    - `if_idx`: An unsigned integer representing the interface index to query in the network device table.
- **Logic and Control Flow**:
    - Checks if the provided `if_idx` is greater than the number of devices in the network device table (`ctx->netdev_tbl.hdr->dev_cnt`).
    - If `if_idx` is greater, returns `NULL` indicating an invalid index.
    - If `if_idx` is valid, returns a pointer to the network device at the specified index in the `dev_tbl` array.
- **Output**: Returns a pointer to the `fd_netdev_t` structure representing the network device at the specified interface index, or `NULL` if the index is invalid.


---
### net\_check\_gre\_interface\_exists<!-- {{#callable:net_check_gre_interface_exists}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L396>)

Checks if a GRE interface exists in the network device table.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_net_ctx_t` structure, which contains the network context including the network device table.
- **Logic and Control Flow**:
    - Retrieve the device table from the `ctx` structure.
    - Get the device count from the device table header.
    - Iterate over each device in the device table.
    - Check if the device type is `ARPHRD_IPGRE`.
    - If a device with type `ARPHRD_IPGRE` is found, return 1.
    - If no such device is found after iterating through the table, return 0.
- **Output**: Returns 1 if a GRE interface exists, otherwise returns 0.


---
### net\_tx\_ready<!-- {{#callable:net_tx_ready}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L414>)

Checks if the current XSK is ready to submit a TX send job by verifying available TX buffers and ring capacity.
- **Inputs**:
    - `ctx`: A pointer to `fd_net_ctx_t`, which contains the network context including XSK and free ring information.
    - `xsk_idx`: An unsigned integer representing the index of the XSK to check within the context.
- **Logic and Control Flow**:
    - Retrieve the XSK and TX ring from the context using `xsk_idx`.
    - Check if the free TX buffer ring is empty by comparing `prod` and `cons` indices; return 0 if empty.
    - Check if the TX ring is full by comparing the difference between `prod` and `cons` with the ring's depth; return 0 if full.
    - Return 1 if both checks pass, indicating readiness for TX.
- **Output**: Returns 1 if the XSK is ready for a TX send job, otherwise returns 0.


---
### net\_rx\_wakeup<!-- {{#callable:net_rx_wakeup}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L428>)

Triggers the `xsk_recvmsg` function in the kernel to receive packets and updates metrics.
- **Inputs**:
    - ``ctx``: A pointer to `fd_net_ctx_t`, which contains the network context and metrics.
    - ``xsk``: A pointer to `fd_xsk_t`, representing the AF_XDP socket context.
    - ``charge_busy``: A pointer to an integer that indicates if the function should mark the context as busy.
- **Logic and Control Flow**:
    - Checks if the `xsk` needs a wakeup using `fd_xsk_rx_need_wakeup`; if not, the function returns immediately.
    - Sets `*charge_busy` to 1 to indicate the context is busy.
    - Initializes a `struct msghdr` array `_ignored` to zero.
    - Attempts to call `recvmsg` on `xsk->xsk_fd` with `MSG_DONTWAIT` flag to trigger the kernel's `xsk_recvmsg`.
    - If `recvmsg` returns -1, checks if the error is a fatal XDP error using [`net_is_fatal_xdp_error`](<#net_is_fatal_xdp_error>); logs an error if true.
    - If the error is not `EAGAIN`, logs a warning if the current timestamp exceeds `xsk->log_suppress_until_ns`, and updates `log_suppress_until_ns`.
    - Increments the `xsk_rx_wakeup_cnt` metric in the `ctx` structure.
- **Output**: No return value; the function updates the `ctx` metrics and may log errors or warnings.
- **Functions Called**:
    - [`net_is_fatal_xdp_error`](<#net_is_fatal_xdp_error>)


---
### net\_tx\_wakeup<!-- {{#callable:net_tx_wakeup}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L453>)

Triggers the `xsk_sendmsg` function in the kernel to transmit packets if necessary.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains network context and metrics.
    - ``xsk``: A pointer to the `fd_xsk_t` structure, representing an AF_XDP socket.
    - ``charge_busy``: A pointer to an integer that indicates if the function should mark the context as busy.
- **Logic and Control Flow**:
    - Check if the `xsk` requires a wakeup using `fd_xsk_tx_need_wakeup`; if not, return immediately.
    - Compare the producer and consumer indices of the `xsk`'s TX ring; if they are equal, return immediately.
    - Set `*charge_busy` to 1 to indicate that the context is busy.
    - Attempt to call `sendto` on the `xsk`'s file descriptor with non-blocking mode; if it fails, check for fatal XDP errors.
    - If a fatal error is detected, log an error message and return.
    - If the error is not `EAGAIN`, log a warning message if the current time exceeds the suppression threshold.
    - Increment the `xsk_tx_wakeup_cnt` metric in the `ctx` structure.
- **Output**: No return value; the function modifies the `charge_busy` flag and updates metrics in the `ctx` structure.
- **Functions Called**:
    - [`net_is_fatal_xdp_error`](<#net_is_fatal_xdp_error>)


---
### net\_tx\_periodic\_wakeup<!-- {{#callable:net_tx_periodic_wakeup}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L477>)

Performs a periodic wakeup for transmitting packets using an AF_XDP socket.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains the context for network operations.
    - ``xsk_idx``: An unsigned integer representing the index of the AF_XDP socket in the context.
    - ``now``: A long integer representing the current time in ticks.
    - ``charge_busy``: A pointer to an integer that indicates if the function should charge the system as busy.
- **Logic and Control Flow**:
    - Retrieve the current producer and consumer indices of the TX ring for the specified AF_XDP socket using `FD_VOLATILE_CONST` to ensure memory consistency.
    - Check if the TX ring is empty by comparing the producer and consumer indices.
    - Call [`fd_net_flusher_check`](<#fd_net_flusher_check>) to determine if a wakeup is needed based on the current time and whether the TX ring is empty.
    - If a wakeup is needed, call [`net_tx_wakeup`](<#net_tx_wakeup>) to trigger the kernel to process the TX ring and set `charge_busy` if necessary.
    - Call [`fd_net_flusher_wakeup`](<#fd_net_flusher_wakeup>) to update the flusher state with the current time.
- **Output**: Returns 0, indicating successful execution without errors.
- **Functions Called**:
    - [`fd_net_flusher_check`](<#fd_net_flusher_check>)
    - [`net_tx_wakeup`](<#net_tx_wakeup>)
    - [`fd_net_flusher_wakeup`](<#fd_net_flusher_wakeup>)


---
### during\_housekeeping<!-- {{#callable:during_housekeeping}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L492>)

Performs housekeeping tasks for a network context, including updating metrics and refreshing network device and socket information.
- **Inputs**:
    - `ctx`: A pointer to a `fd_net_ctx_t` structure representing the network context to be updated.
- **Logic and Control Flow**:
    - Get the current tick count using `fd_tickcount()` and store it in `now`.
    - Call `net_load_netdev_tbl(ctx)` to load the network device table into the context.
    - Check for the existence of a GRE interface using `net_check_gre_interface_exists(ctx)` and update `ctx->has_gre_interface`.
    - Reset the receive and transmit busy and idle counters in `ctx->metrics`.
    - Iterate over each XSK socket in `ctx->xsk`, refreshing cached consumer and producer sequence numbers for each ring (frame, receive, transmit, and completion).
    - Update the receive and transmit busy and idle counters based on the difference between cached producer and consumer sequence numbers.
    - If the current time `now` exceeds `ctx->next_xdp_stats_refresh`, update `ctx->next_xdp_stats_refresh` and call `poll_xdp_statistics(ctx)` to refresh XDP statistics.
- **Output**: No return value; updates the `ctx` structure in place.
- **Functions Called**:
    - [`net_load_netdev_tbl`](<#net_load_netdev_tbl>)
    - [`net_check_gre_interface_exists`](<#net_check_gre_interface_exists>)
    - [`poll_xdp_statistics`](<#poll_xdp_statistics>)


---
### net\_tx\_route<!-- {{#callable:net_tx_route}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L535>)

Resolves the network transmission route by determining the appropriate interface, source IP, and MAC addresses for a given destination IP, and checks if the destination belongs to a GRE interface.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains network context and configuration data.
    - ``dst_ip``: The destination IP address for which the route is being resolved.
    - ``is_gre_inf``: A pointer to a `uint` that will be set to 1 if the destination IP belongs to a GRE interface, otherwise set to 0.
- **Logic and Control Flow**:
    - Perform a route lookup using `fd_fib4_lookup` on both local and main FIB tables to find the next hop.
    - Determine the route type (`rtype`), interface index (`if_idx`), and source IP (`ip4_src`) from the next hop.
    - If the route type is `FD_FIB4_RTYPE_LOCAL`, change it to `FD_FIB4_RTYPE_UNICAST` and set `if_idx` to 1.
    - If the route type is not `FD_FIB4_RTYPE_UNICAST`, increment the `tx_route_fail_cnt` metric and return 0.
    - Query the network device table using [`net_query_netdev_tbl`](<#net_query_netdev_tbl>) with `if_idx`. If the device is not found, increment the `tx_route_fail_cnt` metric and return 0.
    - Set the source IP in `ctx->tx_op.src_ip` using `fd_uint_if` to choose between the bind address and the IP from the next hop.
    - Check if the network device type is `ARPHRD_LOOPBACK` or `ARPHRD_IPGRE` and handle accordingly, setting `is_gre_inf` and other parameters as needed.
    - If the device type is not `ARPHRD_ETHER`, return 0.
    - Check if the interface index matches `ctx->xsk[XSK_IDX_MAIN].if_idx`. If not, increment the `tx_no_xdp_cnt` metric and return 0.
    - Resolve the neighbor using `fd_neigh4_hmap_query_try`. If not found, solicit the neighbor and increment the `tx_neigh_fail_cnt` metric, then return 0.
    - Check the neighbor state. If not active, increment the `tx_neigh_fail_cnt` metric and return 0.
    - Set the source IP and MAC addresses in `ctx->tx_op` using the neighbor and network device information.
    - Return 1 to indicate successful route resolution.
- **Output**: Returns 1 on successful route resolution, setting the necessary transmission parameters in `ctx->tx_op`, or 0 on failure, updating relevant metrics.
- **Functions Called**:
    - [`net_query_netdev_tbl`](<#net_query_netdev_tbl>)


---
### before\_frag<!-- {{#callable:before_frag}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L631>)

Determines if a network tile is responsible for a transmission job and prepares the transmission operation if so.
- **Inputs**:
    - `ctx`: A pointer to the `fd_net_ctx_t` structure, which contains the network context and state information.
    - `in_idx`: An unsigned long integer representing the index of the incoming packet.
    - `seq`: An unsigned long integer representing the sequence number of the packet.
    - `sig`: An unsigned long integer representing the signature of the packet, used to determine protocol and routing information.
- **Logic and Control Flow**:
    - Ignore `in_idx` and `seq` as they are not used in the function logic.
    - Retrieve the protocol from the packet signature using `fd_disco_netmux_sig_proto` and check if it is `DST_PROTO_OUTGOING`. If not, return 1 to indicate the packet is not for outgoing transmission.
    - Calculate the target network tile index using a hash of the packet signature and the total number of network tiles.
    - Initialize GRE (Generic Routing Encapsulation) related fields in the transmission operation to zero.
    - Call [`net_tx_route`](<#net_tx_route>) to determine the route for the packet. If it fails, return 1.
    - Check if the packet requires GRE encapsulation. If so, perform additional routing checks and set GRE-related fields accordingly.
    - Verify that the packet routes to a valid XDP interface. If not, increment the `tx_no_xdp_cnt` metric and return 1.
    - Adjust the target index for loopback packets to always target tile 0.
    - Check if the current network tile is responsible for the packet. If not, return 1 to ignore the packet.
    - Check if the transmission is ready using [`net_tx_ready`](<#net_tx_ready>). If not, increment the `tx_full_fail_cnt` metric and return 1.
    - Allocate a buffer for the packet from the free transmission ring and update the `tx_op.frame` with the allocated buffer.
    - Return 0 to indicate the packet is ready for further processing.
- **Output**: Returns 0 if the packet is ready for transmission by this network tile, otherwise returns 1 to indicate the packet should be ignored or cannot be processed.
- **Functions Called**:
    - [`net_tx_route`](<#net_tx_route>)
    - [`net_tx_ready`](<#net_tx_ready>)


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L720>)

Validates and processes a network packet fragment for transmission, ensuring it meets size and boundary conditions, and copies it into a transmission buffer.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains the network context and operational parameters.
    - ``in_idx``: An index indicating which input context in `ctx->in` to use for processing the packet.
    - ``seq``: An unused parameter, marked with `FD_PARAM_UNUSED`, likely intended for sequence tracking.
    - ``sig``: An unused parameter, marked with `FD_PARAM_UNUSED`, likely intended for signaling or identification.
    - ``chunk``: The chunk number of the packet fragment to be processed.
    - ``sz``: The size of the packet fragment in bytes.
    - ``ctl``: An unused parameter, marked with `FD_PARAM_UNUSED`, likely intended for control information.
- **Logic and Control Flow**:
    - Check if `chunk` is within the valid range defined by `ctx->in[in_idx].chunk0` and `ctx->in[in_idx].wmark`, and if `sz` is less than or equal to `FD_NET_MTU`; log an error if not.
    - Check if `sz` is smaller than the combined size of an Ethernet and IPv4 header; log an error if true.
    - Check if `sz` exceeds `FD_ETH_PAYLOAD_MAX`; log an error if true.
    - Verify that the `frame` pointer in `ctx->tx_op` is within the bounds of `ctx->umem_frame0` and `ctx->umem_sz`; log an error if out of bounds.
    - Convert the `chunk` to a local address using `fd_chunk_to_laddr_const`.
    - If `ctx->tx_op.use_gre` is true, copy the packet data excluding the Ethernet header to the transmission buffer, offset by the size of the GRE header; otherwise, copy the entire packet data to the transmission buffer.
- **Output**: No return value; the function logs errors and performs memory operations as side effects.


---
### after\_frag<!-- {{#callable:after_frag}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L759>)

Handles the final steps of preparing and submitting a network packet for transmission, including setting Ethernet and IP headers, handling GRE encapsulation, and updating transmission metrics.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains the context for network operations.
    - ``in_idx``: An unsigned long integer representing the index of the input.
    - ``seq``: An unsigned long integer representing the sequence number of the packet.
    - ``sig``: An unsigned long integer representing the signal associated with the packet.
    - ``sz``: An unsigned long integer representing the size of the packet.
    - ``tsorig``: An unsigned long integer representing the original timestamp of the packet.
    - ``tspub``: An unsigned long integer representing the publication timestamp of the packet.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is not used in this function.
- **Logic and Control Flow**:
    - Initialize local variables `frame` and `xsk_idx` from `ctx->tx_op`.
    - Copy Ethernet addresses from `ctx->tx_op.mac_addrs` to the `frame`.
    - Check if GRE encapsulation is required by evaluating `ctx->tx_op.use_gre`.
    - If GRE is used, construct the outer IP header and GRE header, update `iphdr` to point to the inner IP header, and adjust `sz` and `xsk_idx`.
    - Construct the inner IP header by checking and updating the source IP address and recalculating the checksum if necessary.
    - Submit the packet to the TX ring by updating the `xsk->ring_tx.packet_ring` with the packet's address and length.
    - Clear the `tx_op.frame` to indicate the frame is now owned by the kernel.
    - Update transmission metrics, including incrementing the packet submission count and total bytes transmitted.
    - If GRE was used, increment the GRE transmission count.
    - Call [`fd_net_flusher_inc`](<#fd_net_flusher_inc>) to update the flusher state for the given `xsk_idx`.
- **Output**: No return value; the function operates by side effects on the `ctx` and network transmission state.
- **Functions Called**:
    - [`fd_net_flusher_inc`](<#fd_net_flusher_inc>)


---
### net\_rx\_packet<!-- {{#callable:net_rx_packet}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L883>)

Processes incoming Ethernet frames, filters for UDP/IPv4 packets, and routes them to the appropriate downstream tile.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure containing network context and configuration.
    - ``umem_off``: An unsigned long representing the offset in the UMEM where the packet data starts.
    - ``sz``: An unsigned long representing the size of the packet.
    - ``freed_chunk``: A pointer to an unsigned integer where the function stores the index of the freed UMEM chunk.
- **Logic and Control Flow**:
    - Check if the packet size is less than the minimum required for Ethernet, IPv4, and UDP headers; if so, increment the undersized packet counter and return.
    - Calculate the packet's starting and ending addresses using `umem_off` and `sz`.
    - Verify if the packet is an IPv4 packet by checking the Ethernet type; if not, return.
    - Check if the packet is a GRE packet; if so, handle GRE-specific processing, including checking for GRE interface availability and adjusting the packet size and offset.
    - Translate the packet to a UMEM frame index and control information.
    - Filter for UDP/IPv4 packets by checking the IP version and protocol; if not UDP/IPv4, return.
    - Calculate the start of the UDP header using the IP header length and verify its validity.
    - Extract the source IP address and UDP source and destination ports from the packet.
    - Log the packet reception using a trace probe.
    - Determine the appropriate downstream tile based on the UDP destination port and route the packet accordingly.
    - Calculate a signature for the packet using source IP, source port, and protocol information.
    - Retrieve the metadata line for the current sequence and store the chunk index in `freed_chunk`.
    - Publish the new frame metadata to the downstream tile's mcache.
    - Increment the sequence number for the next packet.
    - Update GRE and packet metrics.
- **Output**: No direct output; modifies `freed_chunk` to store the index of the freed UMEM chunk and updates metrics in the `ctx` structure.


---
### net\_comp\_event<!-- {{#callable:net_comp_event}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1018>)

Handles the completion of an XDP TX frame by freeing the frame and updating metrics.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains the network context and state information.
    - ``xsk``: A pointer to the `fd_xsk_t` structure, representing the AF_XDP socket.
    - ``comp_seq``: An unsigned integer representing the sequence number of the completed frame.
- **Logic and Control Flow**:
    - Retrieve the completion ring from the `xsk` structure and calculate the mask for indexing.
    - Locate the frame in the completion ring using the `comp_seq` and mask.
    - Check if the frame address plus the maximum transmission unit (`FD_NET_MTU`) exceeds the usable memory size (`ctx->umem_sz`).
    - If the bounds check fails, log an error and terminate the function.
    - Retrieve the free ring from the `ctx` structure and calculate the mask for indexing.
    - Calculate the difference between the producer and consumer indices of the free ring to determine available space.
    - If the free ring is full, terminate the function without freeing the frame.
    - Store the frame address in the free ring and increment the producer index.
    - Update the consumer index of the completion ring to prepare for the next iteration.
    - Increment the `tx_complete_cnt` metric in the `ctx` structure.
- **Output**: No return value; the function updates the network context and metrics.


---
### net\_rx\_event<!-- {{#callable:net_rx_event}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1057>)

Handles an incoming XDP RX frame, processes it, and returns the frame to the kernel via the fill ring.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains the network context and state information.
    - ``xsk``: A pointer to the `fd_xsk_t` structure, representing the AF_XDP socket context.
    - ``rx_seq``: An unsigned integer representing the sequence number of the received frame in the RX ring.
- **Logic and Control Flow**:
    - Locate the incoming frame in the RX ring using the `rx_seq` and `rx_mask` to index into the `packet_ring` array.
    - Check if the frame length exceeds the maximum transmission unit (`FD_NET_MTU`). If it does, log an error and terminate the function.
    - Check if there is space in the fill ring to return the frame. If the fill ring is full, increment the `rx_fill_blocked_cnt` metric and return.
    - Calculate the `freed_chunk` from the frame address and pass the frame to the [`net_rx_packet`](<#net_rx_packet>) function for further processing.
    - Update the RX ring consumer index to reflect the processed frame.
    - Check for mcache corruption by verifying the `freed_chunk` is within valid bounds. Log a critical error if corruption is detected.
    - Calculate the offset for the freed frame and update the fill ring with this offset, then increment the fill ring producer index.
- **Output**: No return value; the function operates by side effects on the provided context and socket structures.
- **Functions Called**:
    - [`net_rx_packet`](<#net_rx_packet>)


---
### before\_credit<!-- {{#callable:before_credit}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1109>)

Manages the state of network transmission buffers and processes incoming and outgoing packets in a round-robin manner.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_net_ctx_t` structure, which contains the network context and state information.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is not used in this function.
    - ``charge_busy``: A pointer to an integer that indicates if the function has performed any operations that should be considered as 'busy' work.
- **Logic and Control Flow**:
    - If `ctx->tx_op.frame` is not NULL, set `*charge_busy` to 1, return the frame to the free list, and set `ctx->tx_op.frame` to NULL.
    - Retrieve the current round-robin index `rr_idx` and the corresponding socket `rr_xsk`.
    - Call [`net_tx_periodic_wakeup`](<#net_tx_periodic_wakeup>) to handle periodic transmission wakeups.
    - Check if there are new packets available by comparing `rx_cons` and `rx_prod`. If they differ, set `*charge_busy` to 1, update `cached_prod`, and call [`net_rx_event`](<#net_rx_event>).
    - If no new packets are available, call [`net_rx_wakeup`](<#net_rx_wakeup>) and update the round-robin index `ctx->rr_idx`.
    - Check if there are completed transmission frames by comparing `comp_cons` and `comp_prod`. If they differ, set `*charge_busy` to 1, update `cached_prod`, and call [`net_comp_event`](<#net_comp_event>).
- **Output**: No return value; the function modifies the state of the network context and updates the `charge_busy` flag.
- **Functions Called**:
    - [`net_tx_periodic_wakeup`](<#net_tx_periodic_wakeup>)
    - [`net_rx_event`](<#net_rx_event>)
    - [`net_rx_wakeup`](<#net_rx_wakeup>)
    - [`net_comp_event`](<#net_comp_event>)


---
### net\_xsk\_bootstrap<!-- {{#callable:net_xsk_bootstrap}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1159>)

Assigns UMEM frames to the FILL ring of a specified XSK (AF_XDP socket) in the network context.
- **Inputs**:
    - `ctx`: A pointer to `fd_net_ctx_t`, which is the network context containing the XSKs and other network configurations.
    - `xsk_idx`: An unsigned integer representing the index of the XSK in the context's XSK array to which the frames will be assigned.
    - `frame_off`: An unsigned long representing the starting offset of the frame in the UMEM region.
- **Logic and Control Flow**:
    - Retrieve the XSK from the context using the provided `xsk_idx`.
    - Calculate the frame size as `FD_NET_MTU` and the fill ring depth as half of the XSK's fill ring depth.
    - Iterate over the fill ring depth, assigning `frame_off` to each position in the fill ring's frame array and incrementing `frame_off` by the frame size each time.
    - Update the fill ring's producer index to reflect the new frames added, using a volatile store to ensure memory visibility.
- **Output**: Returns the updated `frame_off` after assigning frames to the fill ring.


---
### interface\_addrs<!-- {{#callable:interface_addrs}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1181>)

Retrieves the MAC and IPv4 address of a specified network interface.
- **Inputs**:
    - `interface`: A string representing the name of the network interface to query.
    - `mac`: A pointer to an array of unsigned characters where the function will store the MAC address of the interface.
    - `ip4_addr`: A pointer to an unsigned integer where the function will store the IPv4 address of the interface.
- **Logic and Control Flow**:
    - Create a socket using `AF_INET` and `SOCK_DGRAM` to perform network operations.
    - Initialize a `struct ifreq` and set its address family to `AF_INET`.
    - Copy the interface name into `ifr.ifr_name` using `strncpy`.
    - Use `ioctl` with `SIOCGIFHWADDR` to get the MAC address of the interface and store it in `mac`.
    - Use `ioctl` with `SIOCGIFADDR` to get the IPv4 address of the interface and store it in `ip4_addr`.
    - Close the socket and handle any errors that occur during these operations.
- **Output**: No return value; the function outputs the MAC and IPv4 address through the provided pointers.


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1222>)

Initializes network tile resources, including AF_XDP sockets, UMEM regions, and network interface configurations.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology configuration.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the specific network tile configuration.
- **Logic and Control Flow**:
    - Allocate scratch memory for network context and free transaction queue using `FD_SCRATCH_ALLOC_INIT` and `FD_SCRATCH_ALLOC_APPEND`.
    - Initialize the network context (`ctx`) and set its memory to zero using `fd_memset`.
    - Retrieve the network interface index using `if_nametoindex` and log an error if it fails.
    - Obtain the MAC and IP address of the interface using [`interface_addrs`](<#interface_addrs>).
    - Load the UMEM dcache and calculate the aligned UMEM frame size and size using `fd_dcache_join`, `fd_dcache_data_sz`, and alignment functions.
    - Calculate UMEM chunk bounds and validate them, logging errors if they are invalid.
    - Set up the free transaction queue and its depth in the network context.
    - Create and configure the first XSK (AF_XDP socket) using `fd_xsk_init` and `fd_xsk_activate`, logging errors if these operations fail.
    - Check if the process is single-threaded and conditionally close the `xsk_map_fd`.
    - If the tile is the main network tile (index 0), bind to the loopback interface and configure a second XSK for it.
    - Calculate the XDP statistics interval ticks using `fd_tempo_tick_per_ns`.
    - Finalize scratch memory allocation with `FD_SCRATCH_ALLOC_FINI` and check for overflow, logging an error if it occurs.
- **Output**: No return value; the function performs initialization tasks and logs errors if any issues occur.
- **Functions Called**:
    - [`interface_addrs`](<#interface_addrs>)
    - [`scratch_footprint`](<#scratch_footprint>)


---
### init\_device\_table<!-- {{#callable:init_device_table}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1361>)

Initializes the device table by joining a remote double buffer and creating a temporary empty device table.
- **Inputs**:
    - ``ctx``: A pointer to `fd_net_ctx_t`, which is the network context structure that holds network-related data and state.
    - ``netdev_dbl_buf``: A pointer to a double buffer that contains device table updates.
- **Logic and Control Flow**:
    - Join the remote double buffer containing device table updates using `fd_dbl_buf_join` and assign it to `ctx->netdev_dbl_buf`.
    - Check if the join operation was successful; if not, log an error using `FD_LOG_ERR`.
    - Calculate the size of the network device buffer using `fd_netdev_tbl_footprint` and assign it to `ctx->netdev_buf_sz`.
    - Create a temporary empty device table during startup by calling `fd_netdev_tbl_new` and `fd_netdev_tbl_join`.
- **Output**: No return value; the function modifies the `ctx` structure in place.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1375>)

Initializes network context for a tile in a topology, setting up memory, ports, and network links.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the specific tile to initialize.
- **Logic and Control Flow**:
    - Allocate scratch memory for the network context and initialize it.
    - Check that the `xsk_cnt` and `free_tx.queue` are valid.
    - Allocate memory for the free ring and network device buffer.
    - Set network tile ID and count based on the topology and tile name.
    - Assign network ports from the tile's configuration to the context.
    - Validate input link count and ensure it does not exceed `MAX_NET_INS`.
    - For each input link, validate MTU and set memory, chunk, and watermark in the context.
    - For each output link, match link names to set up multicast cache and sequence in the context.
    - Check that all configured listen ports have corresponding output links.
    - Initialize transmit flusher parameters for each XSK.
    - Join FIB and neighbor tables using topology object addresses.
    - Initialize the device table using the topology object address.
    - Initialize the TX free ring with frame offsets.
    - Initialize RX mcache chunks for each output link.
    - Bootstrap XSKs and wake up RX and TX for each XSK.
    - Check if the frame offset exceeds the UMEM size and log an error if so.
- **Output**: No return value; the function initializes the network context in place.
- **Functions Called**:
    - [`init_device_table`](<#init_device_table>)
    - [`net_xsk_bootstrap`](<#net_xsk_bootstrap>)
    - [`net_rx_wakeup`](<#net_rx_wakeup>)
    - [`net_tx_wakeup`](<#net_tx_wakeup>)


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1530>)

Initializes and configures seccomp filters for a network tile based on its context and topology.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the specific tile in the topology.
    - ``out_cnt``: An unsigned long integer representing the count of output filters.
    - ``out``: A pointer to a `struct sock_filter` array where the function will store the seccomp filters.
- **Logic and Control Flow**:
    - Allocates scratch memory for the network context using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_INIT`.
    - Appends a `fd_net_ctx_t` structure to the scratch memory using `FD_SCRATCH_ALLOC_APPEND`.
    - Determines the file descriptor for the second allow FD (`allow_fd2`) based on the number of XSKs in the context.
    - Checks that the file descriptors for the XSKs are valid using `FD_TEST`.
    - Calls [`populate_sock_filter_policy_fd_xdp_tile`](<generated/fd_xdp_tile_seccomp.h.md#populate_sock_filter_policy_fd_xdp_tile>) to populate the seccomp filters with the determined file descriptors.
    - Returns the instruction count from `sock_filter_policy_fd_xdp_tile_instr_cnt`.
- **Output**: Returns an unsigned long integer representing the number of instructions in the seccomp filter policy.
- **Functions Called**:
    - [`populate_sock_filter_policy_fd_xdp_tile`](<generated/fd_xdp_tile_seccomp.h.md#populate_sock_filter_policy_fd_xdp_tile>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../../src/disco/net/xdp/fd_xdp_tile.c#L1548>)

Populates an array with file descriptors that are allowed for a specific network tile.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the specific tile in the topology.
    - `out_fds_cnt`: An unsigned long integer representing the maximum number of file descriptors that can be stored in the `out_fds` array.
    - `out_fds`: A pointer to an integer array where the allowed file descriptors will be stored.
- **Logic and Control Flow**:
    - Allocate scratch memory and initialize a network context `ctx` using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_APPEND`.
    - Check if `out_fds_cnt` is less than 6; if so, log an error using `FD_LOG_ERR`.
    - Initialize `out_cnt` to 0.
    - Add the file descriptor for `stderr` (2) to `out_fds` and increment `out_cnt`.
    - If the log file descriptor is valid, add it to `out_fds` and increment `out_cnt`.
    - Add the file descriptor for the first XSK socket (`ctx->xsk[0].xsk_fd`) to `out_fds` and increment `out_cnt`.
    - Add the file descriptor for the first program link (`ctx->prog_link_fds[0]`) to `out_fds` and increment `out_cnt`.
    - If there is more than one XSK socket, add the file descriptor for the second XSK socket (`ctx->xsk[1].xsk_fd`) to `out_fds` and increment `out_cnt`.
    - If there is more than one XSK socket, add the file descriptor for the second program link (`ctx->prog_link_fds[1]`) to `out_fds` and increment `out_cnt`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array as an unsigned long integer.



---
Made with ❤️ by [Driver](https://www.driver.ai/)