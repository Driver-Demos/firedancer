<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a TPU server tile for handling transactions over TPU/UDP and TPU/QUIC protocols.

# Purpose
The code defines a module for a Transaction Processing Unit (TPU) server tile that handles incoming transactions using the QUIC protocol. It is part of a larger system that processes transactions for inclusion in blocks, supporting both TPU/UDP and TPU/QUIC protocols. The module acts as a producer in a data processing pipeline, defragmenting multi-packet TPU streams from QUIC into complete transactions. It relies on network tiles for packet transmission and reception, allowing multiple QUIC tiles to operate concurrently, with each UDP flow assigned to a specific QUIC tile.

Key components of the module include functions for setting QUIC limits, handling incoming transactions, and managing metrics. The [`quic_limits`](<#quic_limits>) function configures connection and handshake limits, while [`legacy_stream_notify`](<#legacy_stream_notify>) processes transactions sent via TPU/UDP. The module also includes functions for handling QUIC connections and streams, such as [`quic_conn_final`](<#quic_conn_final>) and [`quic_stream_rx`](<#quic_stream_rx>), which manage connection finalization and stream reception, respectively. Additionally, the module provides initialization functions for both privileged and unprivileged contexts, setting up necessary resources and configurations for the QUIC tile. The module defines a public API through the `fd_tile_quic` structure, which includes function pointers for initialization, running, and configuring security policies.
# Imports and Dependencies

---
- `fd_quic_tile.h`
- `../metrics/fd_metrics.h`
- `../stem/fd_stem.h`
- `../topo/fd_topo.h`
- `fd_tpu.h`
- `../../waltz/quic/fd_quic_private.h`
- `generated/quic_seccomp.h`
- `../../util/io/fd_io.h`
- `../../util/net/fd_eth.h`
- `errno.h`
- `fcntl.h`
- `linux/unistd.h`
- `sys/random.h`
- `../stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_quic
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a QUIC tile configuration for a TPU server tile. This configuration includes function pointers for initialization, security, and execution of the tile.
- **Use**: Used to configure and manage a QUIC tile in a network topology for handling transactions.


# Functions

---
### quic\_limits<!-- {{#callable:quic_limits}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L36>)

Calculates and returns the QUIC limits based on the given tile configuration.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure containing the QUIC configuration parameters.
- **Logic and Control Flow**:
    - Initialize a `fd_quic_limits_t` structure `limits` with values from the `tile` parameter, including `conn_cnt`, `handshake_cnt`, `conn_id_cnt`, `inflight_frame_cnt`, and `min_inflight_frame_cnt_conn`.
    - Set `conn_id_cnt` to `FD_QUIC_MIN_CONN_ID_CNT` and calculate `inflight_frame_cnt` as 64 times the `max_concurrent_connections` from `tile`.
    - Check if the `fd_quic_footprint` function returns false for the `limits` structure, and if so, log an error message indicating invalid QUIC limits.
    - Return the `limits` structure.
- **Output**: Returns a `fd_quic_limits_t` structure containing the calculated QUIC limits.


---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L55>)

Calculates the maximum alignment requirement between `fd_quic_ctx_t` and the result of `fd_quic_align()`.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `fd_ulong_max` with `alignof(fd_quic_ctx_t)` and `fd_quic_align()` as arguments.
    - Returns the result of `fd_ulong_max`, which is the maximum of the two values.
- **Output**: Returns an `ulong` representing the maximum alignment requirement.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L60>)

Calculates the memory footprint required for a QUIC tile's scratch space based on its configuration.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure that contains configuration details for the QUIC tile, including `out_depth` and `reasm_cnt`.
- **Logic and Control Flow**:
    - Retrieve `out_depth` and `reasm_max` from the `tile` structure.
    - Call [`quic_limits`](<#quic_limits>) to get the QUIC limits based on the `tile` configuration, which may log an error if invalid.
    - Initialize a layout variable `l` with `FD_LAYOUT_INIT`.
    - Append the size and alignment of `fd_quic_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the footprint and alignment of QUIC limits to `l` using `FD_LAYOUT_APPEND`.
    - Append the footprint and alignment of TPU reassembly to `l` using `FD_LAYOUT_APPEND`.
    - Finalize the layout with `FD_LAYOUT_FINI` using the alignment from [`scratch_align`](<#scratch_align>) and return the result.
- **Output**: Returns an `ulong` representing the calculated memory footprint for the QUIC tile's scratch space.
- **Functions Called**:
    - [`quic_limits`](<#quic_limits>)
    - [`fd_tpu_reasm_align`](<fd_tpu_reasm.c.md#fd_tpu_reasm_align>)
    - [`fd_tpu_reasm_footprint`](<fd_tpu_reasm.c.md#fd_tpu_reasm_footprint>)
    - [`scratch_align`](<#scratch_align>)


---
### legacy\_stream\_notify<!-- {{#callable:legacy_stream_notify}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L80>)

Handles transactions sent via TPU/UDP by publishing them and updating metrics if successful.
- **Inputs**:
    - ``ctx``: A pointer to `fd_quic_ctx_t` structure containing context information for the QUIC tile.
    - ``packet``: A pointer to the packet data received via TPU/UDP.
    - ``packet_sz``: The size of the packet in bytes.
    - ``ipv4``: An unsigned integer representing the IPv4 address associated with the packet.
- **Logic and Control Flow**:
    - Retrieve the current timestamp from `ctx->now` and store it in `tspub`.
    - Access the reassembly context from `ctx->reasm` and store it in `reasm`.
    - Access the stem context from `ctx->stem` and store it in `stem`.
    - Retrieve the first element of the `mcaches` array from `stem` and store it in `mcache`.
    - Retrieve the memory location for verification output from `ctx->verify_out_mem` and store it in `base`.
    - Retrieve the first sequence number from `stem->seqs` and store it in `seq`.
    - Call [`fd_tpu_reasm_publish_fast`](<fd_tpu_reasm.c.md#fd_tpu_reasm_publish_fast>) with the reassembly context, packet data, packet size, metadata cache, base memory, sequence number, timestamp, IPv4 address, and source type `FD_TXN_M_TPU_SOURCE_UDP`.
    - If the call to [`fd_tpu_reasm_publish_fast`](<fd_tpu_reasm.c.md#fd_tpu_reasm_publish_fast>) returns `FD_TPU_REASM_SUCCESS`, call `fd_stem_advance` with the stem context and zero to advance the stem sequence.
    - Increment the `txns_received_udp` metric in `ctx->metrics`.
- **Output**: No return value; the function updates the context and metrics based on the success of the packet publication.
- **Functions Called**:
    - [`fd_tpu_reasm_publish_fast`](<fd_tpu_reasm.c.md#fd_tpu_reasm_publish_fast>)


---
### before\_credit<!-- {{#callable:before_credit}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L106>)

Updates the QUIC context with the current time and processes QUIC service tasks, setting the busy charge status.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_ctx_t` structure representing the QUIC context.
    - ``stem``: A pointer to the `fd_stem_context_t` structure representing the stem context.
    - ``charge_busy``: A pointer to an integer where the function stores the busy charge status after processing.
- **Logic and Control Flow**:
    - Assigns the `stem` pointer to the `stem` member of the `ctx` structure.
    - Retrieves the current time using `fd_clock_now` and assigns it to the `now` member of the `ctx` structure.
    - Calls `fd_quic_service` with the `quic` member of `ctx` and the current time, storing the result in `charge_busy`.
- **Output**: The function does not return a value but updates the `ctx` structure and the `charge_busy` integer.


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L118>)

Writes various QUIC-related metrics from the `fd_quic_ctx_t` context to the appropriate metric counters and gauges.
- **Inputs**:
    - `ctx`: A pointer to an `fd_quic_ctx_t` structure containing the metrics to be written.
- **Logic and Control Flow**:
    - Uses `FD_MCNT_SET` to update counters for various transaction and fragment metrics such as `TXNS_RECEIVED_UDP`, `FRAGS_OK`, and `TXNS_OVERRUN` from the `ctx->metrics` structure.
    - Uses `FD_MGAUGE_SET` to update gauge metrics like `TXN_REASMS_ACTIVE` using the maximum of `ctx->metrics.reasm_active` and 0.
    - Updates network-related metrics such as `RECEIVED_PACKETS` and `SENT_BYTES` using `FD_MCNT_SET` with values from `ctx->quic->metrics`.
    - Copies enumerated metrics like `CONNECTIONS_STATE` and `RECEIVED_FRAMES` using `FD_MGAUGE_ENUM_COPY` and `FD_MCNT_ENUM_COPY`.
    - Copies histogram metrics like `SERVICE_DURATION_SECONDS` using `FD_MHIST_COPY`.
- **Output**: No return value; the function operates by side-effect, updating metrics.


---
### before\_frag<!-- {{#callable:before_frag}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L181>)

Checks if a given signature is valid for processing based on protocol and round-robin criteria.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_ctx_t` context structure, which contains configuration and state information for the QUIC tile.
    - ``in_idx``: An unsigned long integer representing the input index, which is not used in the function.
    - ``seq``: An unsigned long integer representing the sequence number, which is not used in the function.
    - ``sig``: An unsigned long integer representing the signature to be checked.
- **Logic and Control Flow**:
    - Retrieve the protocol from the signature using `fd_disco_netmux_sig_proto` function.
    - Check if the protocol is neither `DST_PROTO_TPU_UDP` nor `DST_PROTO_TPU_QUIC`; if so, return 1 indicating an invalid signature.
    - Retrieve the hash from the signature using `fd_disco_netmux_sig_hash` function.
    - Check if the hash modulo the round-robin count does not equal the round-robin ID in the context; if so, return 1 indicating an invalid signature.
    - Return 0 if both checks pass, indicating a valid signature.
- **Output**: Returns an integer: 0 if the signature is valid for processing, or 1 if it is not.


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L198>)

Copies a fragment of network data into a buffer within the QUIC context.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_ctx_t` structure, which contains the context for the QUIC operation.
    - ``in_idx``: An index indicating the position within the `net_in_bounds` array of the `ctx` structure.
    - ``seq``: An unused parameter, marked with `FD_PARAM_UNUSED`, indicating a sequence number.
    - ``sig``: An unused parameter, marked with `FD_PARAM_UNUSED`, indicating a signal or signature.
    - ``chunk``: A value representing the chunk of data to be processed.
    - ``sz``: The size of the data fragment to be copied.
    - ``ctl``: A control parameter used in the translation of the network fragment.
- **Logic and Control Flow**:
    - Calls `fd_net_rx_translate_frag` to translate the network fragment using the provided `in_idx`, `chunk`, `ctl`, and `sz` parameters.
    - Stores the result of the translation in the `src` pointer.
    - Copies the data from `src` to the `buffer` in the `ctx` structure using `fd_memcpy`.
- **Output**: No return value; the function operates by side effect, modifying the `buffer` in the `ctx` structure.


---
### after\_frag<!-- {{#callable:after_frag}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L212>)

Processes network packets based on their protocol type, either QUIC or UDP, and handles them accordingly.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_quic_ctx_t` structure, which contains context information for QUIC processing.
    - ``in_idx``: An unsigned long integer representing the input index, which is not used in the function.
    - ``seq``: An unsigned long integer representing the sequence number, which is not used in the function.
    - ``sig``: An unsigned long integer representing the signal, used to determine the protocol type.
    - ``sz``: An unsigned long integer representing the size of the packet.
    - ``tsorig``: An unsigned long integer representing the original timestamp, which is not used in the function.
    - ``tspub``: An unsigned long integer representing the publication timestamp, which is not used in the function.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is not used in the function.
- **Logic and Control Flow**:
    - Determine the protocol type from the `sig` using `fd_disco_netmux_sig_proto` function.
    - If the protocol is QUIC (`DST_PROTO_TPU_QUIC`), check if the packet size is smaller than the size of an Ethernet header; if so, log an error.
    - If the packet size is valid, extract the IP packet from the buffer and process it using `fd_quic_process_packet`.
    - If the protocol is UDP (`DST_PROTO_TPU_UDP`), calculate the network header size using `fd_disco_netmux_sig_hdr_sz`.
    - Check if the packet size is less than or equal to the network header size; if so, increment the `udp_pkt_too_small` metric and return.
    - Calculate the data size by subtracting the network header size from the total size.
    - Check if the data size is smaller than the minimum serialized transaction size (`FD_TXN_MIN_SERIALIZED_SZ`); if so, increment the `udp_pkt_too_small` metric and return.
    - Check if the data size exceeds the maximum transaction MTU (`FD_TPU_MTU`); if so, increment the `udp_pkt_too_large` metric and return.
    - If the data size is valid, call [`legacy_stream_notify`](<#legacy_stream_notify>) to handle the UDP packet.
- **Output**: No return value; the function processes packets and updates metrics or logs errors as needed.
- **Functions Called**:
    - [`legacy_stream_notify`](<#legacy_stream_notify>)


---
### quic\_conn\_final<!-- {{#callable:quic_conn_final}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L264>)

Updates the QUIC connection metrics by adjusting the active and abandoned reassembly counts based on the number of active receive streams.
- **Inputs**:
    - ``conn``: A pointer to an `fd_quic_conn_t` structure representing the QUIC connection.
    - ``quic_ctx``: A pointer to a context object, specifically an `fd_quic_ctx_t` structure, associated with the QUIC connection.
- **Logic and Control Flow**:
    - Retrieve the QUIC context from the `quic_ctx` pointer.
    - Calculate the number of streams to abandon using `fd_long_max` on `conn->srx->rx_streams_active` and 0.
    - Subtract the calculated abandon count from `ctx->metrics.reasm_active`.
    - Add the calculated abandon count to `ctx->metrics.reasm_abandoned`.
- **Output**: No return value; the function updates the metrics in the provided context.


---
### quic\_stream\_rx<!-- {{#callable:quic_stream_rx}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L273>)

Processes incoming QUIC stream data for reassembly and publication, handling both complete and fragmented transactions.
- **Inputs**:
    - ``conn``: A pointer to the `fd_quic_conn_t` structure representing the QUIC connection.
    - ``stream_id``: The identifier for the QUIC stream.
    - ``offset``: The offset in the stream where the data starts.
    - ``data``: A pointer to the data buffer containing the stream data.
    - ``data_sz``: The size of the data buffer.
    - ``fin``: An integer flag indicating if this is the final piece of data for the stream (1 if true, 0 if false).
- **Logic and Control Flow**:
    - Initialize local variables and retrieve context and state information from the connection.
    - Check if the data is oversized by comparing `offset + data_sz` to `FD_TPU_MTU`.
    - If `offset` is 0 and `fin` is true, handle the data as a complete transaction using a fast path, checking for minimum size and oversize conditions.
    - If `data_sz` is 0 and `fin` is false, return success as a no-operation.
    - Query the reassembly slot for the given `conn_uid` and `stream_id`.
    - If no slot is found, start a new reassembly, handling conditions for offset, empty data, and oversize.
    - Check if the evicted reassembly buffer was busy and update metrics accordingly.
    - Prepare a new reassembly slot and update metrics for reassembly start and active streams.
    - If a slot is found but not busy, increment duplicate fragment count and return success.
    - Attempt to reassemble the fragment, updating metrics for gaps and oversize errors, and return appropriate status.
    - If `fin` is true, check the size of the reassembled data, publish it, update metrics, and advance the stem.
- **Output**: Returns `FD_QUIC_SUCCESS` on successful processing or `FD_QUIC_FAILED` if a gap is detected during reassembly.
- **Functions Called**:
    - [`fd_tpu_reasm_publish_fast`](<fd_tpu_reasm.c.md#fd_tpu_reasm_publish_fast>)
    - [`fd_tpu_reasm_query`](<fd_tpu_reasm.c.md#fd_tpu_reasm_query>)
    - [`fd_tpu_reasm_prepare`](<fd_tpu_reasm.c.md#fd_tpu_reasm_prepare>)
    - [`fd_tpu_reasm_frag`](<fd_tpu_reasm.c.md#fd_tpu_reasm_frag>)
    - [`fd_tpu_reasm_publish`](<fd_tpu_reasm.c.md#fd_tpu_reasm_publish>)


---
### quic\_tx\_aio\_send<!-- {{#callable:quic_tx_aio_send}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L381>)

Sends a batch of packets over a network interface, updating the context's chunk index and optionally setting the batch index.
- **Inputs**:
    - `_ctx`: A pointer to the QUIC context (`fd_quic_ctx_t`) used for network operations.
    - `batch`: A pointer to an array of `fd_aio_pkt_info_t` structures, each containing information about a packet to send.
    - `batch_cnt`: The number of packets in the `batch` array.
    - `opt_batch_idx`: An optional pointer to a `ulong` where the function will store the number of packets processed if not NULL.
    - `flush`: An integer flag indicating whether to flush the operation, though it is not used in this function.
- **Logic and Control Flow**:
    - Iterates over each packet in the `batch` array up to `batch_cnt`.
    - Checks if the packet size is less than `FD_NETMUX_SIG_MIN_HDR_SZ`; if so, skips processing that packet.
    - Loads the destination IP address from the packet buffer.
    - Calculates the L2 and L3 addresses for the packet in the network output memory.
    - Initializes the Ethernet header and copies the packet data to the L3 address.
    - Calculates the total size of the L2 packet.
    - Generates a signature for the packet using the destination IP and other parameters.
    - Publishes the packet using `fd_stem_publish` with the calculated signature, chunk, size, and control information.
    - Updates the context's `net_out_chunk` to the next available chunk using `fd_dcache_compact_next`.
    - If `opt_batch_idx` is not NULL, sets it to `batch_cnt`.
- **Output**: Returns `FD_AIO_SUCCESS` to indicate successful processing of the batch.


---
### quic\_tls\_keylog<!-- {{#callable:quic_tls_keylog}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L420>)

Logs a given line to a buffered output stream, ensuring the stream has enough space and flushing it if necessary.
- **Inputs**:
    - `_ctx`: A pointer to the context, specifically of type `fd_quic_ctx_t`, which contains the buffered output stream for key logging.
    - `line`: A constant character pointer to the line of text that needs to be logged.
- **Logic and Control Flow**:
    - Retrieve the `fd_quic_ctx_t` context from `_ctx` and access the `keylog_stream` from it.
    - Calculate the size of the `line` including the null terminator.
    - Check if the buffered output stream has enough space to accommodate the `line`.
    - If the stream does not have enough space, flush the stream to free up space.
    - If flushing fails, log an error message with the error code and description.
    - Check again if the stream has enough space after flushing; if not, log an error indicating the buffer is too small.
    - Append the `line` to the stream, followed by a newline character.
    - Update the stream's position to reflect the newly added line.
- **Output**: No return value; the function logs the line to the output stream or logs an error if it fails.


---
### during\_housekeeping<!-- {{#callable:during_housekeeping}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L447>)

Performs periodic housekeeping tasks for a QUIC context, including recalibrating the clock and flushing the keylog stream if necessary.
- **Inputs**:
    - `ctx`: A pointer to a `fd_quic_ctx_t` structure representing the QUIC context.
- **Logic and Control Flow**:
    - Check if the current time (`ctx->now`) is greater than or equal to the next recalibration time (`ctx->recal_next`).
    - If recalibration is needed, update `ctx->recal_next` with the result of `fd_clock_default_recal`.
    - Check if the keylog stream buffer (`ctx->keylog_stream.wbuf`) is non-null, indicating that key logging is active.
    - If key logging is active, update the current time (`ctx->now`) and check if it is greater than the next keylog flush time (`ctx->keylog_next_flush`).
    - If a keylog flush is needed, call `fd_io_buffered_ostream_flush` to flush the keylog stream.
    - If the flush operation fails, log an error message.
    - Update `ctx->keylog_next_flush` to the current time plus the keylog flush interval (`FD_QUIC_KEYLOG_FLUSH_INTERVAL_NS`).
- **Output**: No return value; the function modifies the `ctx` structure in place.


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L465>)

Initializes a QUIC context for a tile, setting up key logging and ensuring necessary resources are available.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology configuration.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the specific tile configuration.
- **Logic and Control Flow**:
    - Retrieve the QUIC context pointer `ctx` using `fd_topo_obj_laddr` with `topo` and `tile->tile_obj_id`.
    - Check if the footprint of the tile object is sufficient using [`scratch_footprint`](<#scratch_footprint>); log an error if insufficient.
    - Initialize the memory of `ctx` to zero using `fd_memset`.
    - Set `ctx->keylog_fd` to -1, indicating no key log file is open initially.
    - Check if `tile->quic.key_log_path` is not an empty string; if so, open the file at this path for writing, creating, and appending.
    - If the file open operation fails, log an error with details.
    - Initialize a buffered output stream for key logging using `fd_io_buffered_ostream_init`.
    - Log a warning indicating that QUIC encryption keys are being logged to the specified path.
    - Call `fd_log_wallclock` to ensure the vDSO virtual call is initialized, which is necessary for the QUIC implementation.
- **Output**: No return value; the function performs initialization tasks and logs errors or warnings as needed.
- **Functions Called**:
    - [`scratch_footprint`](<#scratch_footprint>)


---
### quic\_tls\_cv\_sign<!-- {{#callable:quic_tls_cv_sign}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L497>)

Signs a given payload using Ed25519 and SHA-512 with the provided context's keys.
- **Inputs**:
    - `signer_ctx`: A pointer to the context (`fd_quic_ctx_t`) containing the necessary cryptographic keys and SHA-512 state.
    - `signature`: An array of 64 unsigned characters where the function will store the generated signature.
    - `payload`: A constant array of 130 unsigned characters representing the data to be signed.
- **Logic and Control Flow**:
    - Retrieve the SHA-512 state from the context using `fd_sha512_join`.
    - Call `fd_ed25519_sign` to sign the `payload` using the context's public and private keys, storing the result in `signature`.
    - Release the SHA-512 state using `fd_sha512_leave`.
- **Output**: The function does not return a value; it outputs the signature directly into the `signature` array.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L507>)

Initializes the unprivileged components of a QUIC tile in a network topology.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the specific tile to initialize.
- **Logic and Control Flow**:
    - Retrieve the local address of the tile object using `fd_topo_obj_laddr` and store it in `scratch`.
    - Check if the tile has no input links or too many input links, and log an error if either condition is true.
    - Verify that the tile has exactly two output links named 'quic_verify' and 'quic_net', logging an error if not.
    - Check if the output depth of the tile matches the depth of the 'quic_verify' link, logging an error if not.
    - Ensure the presence of an output dcache, logging an error if it is missing.
    - Initialize scratch memory allocation and allocate space for a `fd_quic_ctx_t` context structure.
    - Iterate over each input link, checking that each is named 'net_quic', and initialize network receive bounds for each link.
    - Initialize the clock and set the recalibration and current time values in the context.
    - Generate a random private key for TLS and derive the corresponding public key using SHA-512.
    - Create and join a new asynchronous I/O context for QUIC transmission.
    - Determine QUIC limits based on the tile configuration and create a new QUIC context, logging an error if creation fails.
    - Allocate and join a new TPU reassembly context, logging an error if creation fails.
    - Validate the `ack_delay_millis` and `idle_timeout_millis` configuration values, logging errors for invalid settings.
    - Configure the QUIC context with server role, timeouts, maximum stream data, retry settings, and public key.
    - Set up QUIC callbacks for connection finalization, stream reception, and TLS key logging if enabled.
    - Initialize the QUIC context for network transmission and log an error if initialization fails.
    - Set up memory and chunk management for network output and verification output.
    - Configure round-robin settings for the tile and validate the configuration, logging an error if invalid.
    - Finalize scratch memory allocation and check for overflow, logging an error if detected.
    - Join and initialize histograms for service and receive durations.
- **Output**: No return value; the function initializes the tile's unprivileged components and logs errors if any issues occur.
- **Functions Called**:
    - [`quic_limits`](<#quic_limits>)
    - [`fd_tpu_reasm_align`](<fd_tpu_reasm.c.md#fd_tpu_reasm_align>)
    - [`fd_tpu_reasm_footprint`](<fd_tpu_reasm.c.md#fd_tpu_reasm_footprint>)
    - [`fd_tpu_reasm_join`](<fd_tpu_reasm.c.md#fd_tpu_reasm_join>)
    - [`fd_tpu_reasm_new`](<fd_tpu_reasm.c.md#fd_tpu_reasm_new>)
    - [`scratch_footprint`](<#scratch_footprint>)


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L629>)

Populates a seccomp filter policy for a QUIC context and returns the instruction count.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the tile configuration.
    - `out_cnt`: An unsigned long integer representing the count of output filters.
    - `out`: A pointer to an array of `struct sock_filter` where the seccomp filter policy will be populated.
- **Logic and Control Flow**:
    - Retrieve the QUIC context using `fd_topo_obj_laddr` with `topo` and `tile->tile_obj_id`.
    - Call [`populate_sock_filter_policy_quic`](<generated/quic_seccomp.h.md#populate_sock_filter_policy_quic>) with `out_cnt`, `out`, the log file descriptor, and the keylog file descriptor from the QUIC context.
    - Return `sock_filter_policy_quic_instr_cnt`.
- **Output**: Returns the number of instructions in the seccomp filter policy as an unsigned long integer.
- **Functions Called**:
    - [`populate_sock_filter_policy_quic`](<generated/quic_seccomp.h.md#populate_sock_filter_policy_quic>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../src/disco/quic/fd_quic_tile.c#L639>)

Populates an array with file descriptors that are allowed for use, including standard error, a log file, and a keylog file if available.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the tile configuration.
    - ``out_fds_cnt``: An unsigned long integer representing the maximum number of file descriptors that can be stored in `out_fds`.
    - ``out_fds``: A pointer to an integer array where the function will store the allowed file descriptors.
- **Logic and Control Flow**:
    - Retrieve the context `ctx` using `fd_topo_obj_laddr` with `topo` and `tile->tile_obj_id`.
    - Check if `out_fds_cnt` is less than 3; if so, log an error and terminate.
    - Initialize `out_cnt` to 0 and set `out_fds[out_cnt++]` to 2, representing the standard error file descriptor.
    - Check if the log file descriptor is valid using `fd_log_private_logfile_fd`; if valid, add it to `out_fds`.
    - Check if `ctx->keylog_fd` is not -1; if valid, add it to `out_fds`.
    - Return the count of file descriptors added to `out_fds`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array as an unsigned long integer.



---
Made with ❤️ by [Driver](https://www.driver.ai/)