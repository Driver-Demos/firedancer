<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines a seccomp filter policy for archiver playback with architecture-specific syscall checks.

# Purpose
The code is a C header file that defines a seccomp (secure computing mode) filter policy for a playback archiver. It is generated automatically and should not be edited manually. The file includes several Linux headers related to auditing, capabilities, filtering, and seccomp, as well as a utility header from the project's source. The code defines architecture-specific constants to ensure compatibility with the target architecture, such as `AUDIT_ARCH_I386` for i386, `AUDIT_ARCH_X86_64` for x86_64, and `AUDIT_ARCH_AARCH64` for aarch64. If the architecture is unsupported, it triggers a compilation error.

The main functionality is provided by the [`populate_sock_filter_policy_archiver_playback`](<#populate_sock_filter_policy_archiver_playback>) function, which initializes a seccomp filter with 17 instructions. This filter is designed to restrict system calls to a predefined set, specifically allowing `SYS_write`, `SYS_read`, and `SYS_fsync` under certain conditions. The filter checks the architecture and syscall numbers, and it uses conditional jumps to either allow or kill the process based on the syscall arguments. The function uses `fd_memcpy` to copy the filter instructions into the provided output buffer. The seccomp filter is intended to enhance security by limiting the system calls that the playback archiver can execute.
# Imports and Dependencies

---
- `../../../../src/util/fd_util_base.h`
- `linux/audit.h`
- `linux/capability.h`
- `linux/filter.h`
- `linux/seccomp.h`
- `linux/bpf.h`
- `sys/syscall.h`
- `signal.h`
- `stddef.h`


# Global Variables

---
### sock\_filter\_policy\_archiver\_playback\_instr\_cnt
- **Type**: ``unsigned int``
- **Description**: Defines the number of instructions in the socket filter policy for archiver playback.
- **Use**: Used to verify that the output buffer can hold the required number of filter instructions.


# Functions

---
### populate\_sock\_filter\_policy\_archiver\_playback<!-- {{#callable:populate_sock_filter_policy_archiver_playback}} -->
[View Source →](<../../../../../../src/disco/archiver/generated/archiver_playback_seccomp.h#L26>)

Populates a socket filter policy for seccomp to control system call permissions based on architecture and file descriptors.
- **Inputs**:
    - `out_cnt`: The number of filter instructions expected in the output, must be at least 17.
    - `out`: A pointer to a `sock_filter` array where the filter policy will be stored.
    - `logfile_fd`: The file descriptor for the log file, used to allow specific system calls.
    - `archive_fd`: The file descriptor for the archive, used to allow specific system calls.
- **Logic and Control Flow**:
    - Check if `out_cnt` is at least 17 using `FD_TEST` macro.
    - Define a `sock_filter` array with 17 instructions to implement the seccomp policy.
    - Load the architecture from `seccomp_data` and compare it with `ARCH_NR`; if not equal, jump to `RET_KILL_PROCESS`.
    - Load the syscall number and check if it matches `SYS_write`, `SYS_read`, or `SYS_fsync`.
    - For `SYS_write`, check if the first argument is 2 or matches `logfile_fd`; allow or kill process accordingly.
    - For `SYS_read`, check if the first argument matches `archive_fd`; allow or kill process accordingly.
    - For `SYS_fsync`, check if the first argument matches `logfile_fd`; allow or kill process accordingly.
    - If none of the conditions match, jump to `RET_KILL_PROCESS`.
    - Copy the filter array to the output using `fd_memcpy`.
- **Output**: The function does not return a value; it populates the `out` array with the seccomp filter policy.



---
Made with ❤️ by [Driver](https://www.driver.ai/)