<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements network topology management and monitoring using Netlink, including route and neighbor updates.

# Purpose
The code is a C source file that defines functions and structures for managing network topology using Netlink sockets. It is part of a larger system that deals with network configuration and monitoring. The primary function, [`fd_netlink_topo_create`](<#fd_netlink_topo_create>), initializes various network topology objects, such as double buffers for network devices, route tables, and neighbor hashmaps. It configures these objects with parameters like maximum routes and neighbors, and seeds for random number generation. The function also sets up shared memory usage modes for these objects.

The file includes several functions for initializing and managing network topology tiles, such as [`fd_netlink_topo_join`](<#fd_netlink_topo_join>), [`privileged_init`](<#privileged_init>), and [`unprivileged_init`](<#unprivileged_init>). These functions handle the setup of network interfaces, Netlink socket connections, and data structures for network device tables and neighbor hashmaps. The code also defines callback functions for handling network events, such as link, route, and neighbor updates, using Netlink messages. The file concludes with the definition of a `fd_topo_run_tile_t` structure, which encapsulates the functionality of the network topology tile, including its initialization and execution methods.
# Imports and Dependencies

---
- `fd_netlink_tile_private.h`
- `../topo/fd_topo.h`
- `../topo/fd_topob.h`
- `../metrics/fd_metrics.h`
- `../../waltz/ip/fd_fib4_netlink.h`
- `../../waltz/mib/fd_netdev_netlink.h`
- `../../waltz/neigh/fd_neigh4_netlink.h`
- `../../util/pod/fd_pod_format.h`
- `../../util/log/fd_dtrace.h`
- `fd_netlink_tile.h`
- `errno.h`
- `net/if.h`
- `netinet/in.h`
- `sys/socket.h`
- `sys/random.h`
- `sys/time.h`
- `linux/rtnetlink.h`
- `generated/netlink_seccomp.h`
- `../stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_netlnk
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a `fd_topo_run_tile_t` structure named `fd_tile_netlnk` that configures a network link tile. It includes function pointers for initialization, security policy population, and execution of the tile.
- **Use**: Used to manage and execute network link operations within a topology.


# Functions

---
### fd\_netlink\_topo\_create<!-- {{#callable:fd_netlink_topo_create}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L23>)

Initializes and configures network topology objects for a netlink tile, including route tables and neighbor hashmaps.
- **Inputs**:
    - ``netlink_tile``: Pointer to `fd_topo_tile_t` structure representing the netlink tile to configure.
    - ``topo``: Pointer to `fd_topo_t` structure representing the network topology.
    - ``netlnk_max_routes``: Maximum number of routes for the netlink.
    - ``netlnk_max_peer_routes``: Maximum number of peer routes for the netlink.
    - ``netlnk_max_neighbors``: Maximum number of neighbors for the netlink.
    - ``bind_interface``: Name of the network interface to bind to, as a constant character string.
- **Logic and Control Flow**:
    - Retrieve topology objects for double buffer, main and local FIB4, and neighbor hashmap using `fd_topob_obj` function.
    - Set the netlink tile to use these topology objects with read-write permissions using `fd_topob_tile_uses`.
    - Calculate the MTU for the netdev double buffer and insert it into the topology properties using `fd_pod_insertf_ulong`.
    - Configure the route table by inserting maximum routes and peer routes into the topology properties.
    - Generate a random seed for the FIB4 route peer and insert it into the topology properties.
    - Calculate parameters for the neighbor hashmap, including maximum elements, alignment, and footprint, and insert them into the topology properties.
    - Generate a random seed for the neighbor hashmap and insert it into the topology properties.
    - Assign object IDs to the `netlink_tile` structure and copy the `bind_interface` into the `netlink_tile` structure.
- **Output**: No return value; the function modifies the `netlink_tile` and `topo` structures in place.


---
### fd\_netlink\_topo\_join<!-- {{#callable:fd_netlink_topo_join}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L80>)

Associates a `join_tile` with specific network objects in a topology for read-only access.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the network topology.
    - ``netlink_tile``: A pointer to an `fd_topo_tile_t` structure representing the netlink tile containing network object identifiers.
    - ``join_tile``: A pointer to an `fd_topo_tile_t` structure representing the tile to be joined with the network objects.
- **Logic and Control Flow**:
    - Calls `fd_topob_tile_uses` to associate `join_tile` with the network object identified by `netlink_tile->netlink.neigh4_obj_id` in read-only mode.
    - Calls `fd_topob_tile_uses` to associate `join_tile` with the network object identified by `netlink_tile->netlink.neigh4_ele_obj_id` in read-only mode.
    - Calls `fd_topob_tile_uses` to associate `join_tile` with the network object identified by `netlink_tile->netlink.fib4_main_obj_id` in read-only mode.
    - Calls `fd_topob_tile_uses` to associate `join_tile` with the network object identified by `netlink_tile->netlink.fib4_local_obj_id` in read-only mode.
- **Output**: No return value; the function operates by side effects on the `join_tile` and `topo` structures.


---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L92>)

Calculates the maximum alignment requirement between `fd_netlink_tile_ctx_t` and `FD_NETDEV_TBL_ALIGN`.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls `fd_ulong_max` to determine the maximum value between `alignof(fd_netlink_tile_ctx_t)` and `FD_NETDEV_TBL_ALIGN`.
- **Output**: Returns the maximum alignment requirement as an `ulong`.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L97>)

Calculates the memory footprint required for a scratch space based on alignment and size requirements of network link tile context and network device table.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure, which is not used in the function.
- **Logic and Control Flow**:
    - Initialize a variable `l` with `FD_LAYOUT_INIT` to start the layout calculation.
    - Append the alignment and size of `fd_netlink_tile_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the alignment and footprint of the network device table to `l` using `FD_LAYOUT_APPEND`, with parameters `NETDEV_MAX` and `BOND_MASTER_MAX`.
    - Finalize the layout calculation with `FD_LAYOUT_FINI`, using `scratch_align()` to determine the final alignment.
- **Output**: Returns an `ulong` representing the calculated memory footprint for the scratch space.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L106>)

Populates a seccomp filter with allowed network operations for a specific tile in a topology.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the specific tile in the topology.
    - ``out_cnt``: An unsigned long integer representing the count of output filters to populate.
    - ``out``: A pointer to a `struct sock_filter` array where the function will store the populated seccomp filters.
- **Logic and Control Flow**:
    - Retrieve the local address of the tile object using `fd_topo_obj_laddr` and store it in `ctx`.
    - Verify that the `magic` field of `ctx` matches `FD_NETLINK_TILE_CTX_MAGIC`.
    - Call [`populate_sock_filter_policy_netlink`](<generated/netlink_seccomp.h.md#populate_sock_filter_policy_netlink>) to populate the seccomp filter with network operation policies, using file descriptors from `ctx` and the log file.
    - Return the count of instructions in the seccomp filter, `sock_filter_policy_netlink_instr_cnt`.
- **Output**: Returns the number of instructions in the populated seccomp filter as an unsigned long integer.
- **Functions Called**:
    - [`populate_sock_filter_policy_netlink`](<generated/netlink_seccomp.h.md#populate_sock_filter_policy_netlink>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L117>)

Populates an array with file descriptors related to network link monitoring and logging.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the tile in the topology.
    - ``out_fds_cnt``: An unsigned long integer specifying the maximum number of file descriptors that can be stored in `out_fds`.
    - ``out_fds``: A pointer to an integer array where the function will store the file descriptors.
- **Logic and Control Flow**:
    - Retrieve the context `ctx` for the tile using `fd_topo_obj_laddr` and verify its magic number.
    - Check if `out_fds_cnt` is less than 5; if so, log an error and terminate.
    - Initialize `out_cnt` to 0 and add the file descriptor for `stderr` to `out_fds`.
    - If the log file descriptor is valid, add it to `out_fds`.
    - Add the file descriptors for `nl_monitor`, `nl_req`, and `prober` from `ctx` to `out_fds`.
    - Return the count of file descriptors added to `out_fds`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array as an unsigned long integer.


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L137>)

Initializes a privileged network link tile context for a topology.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the network link tile to initialize.
- **Logic and Control Flow**:
    - Checks if the `tile` kind ID is not zero and logs an error if true.
    - Retrieves the network interface index for the neighbor interface name in `tile->netlink.neigh_if` using `if_nametoindex` and logs an error if it fails.
    - Obtains a pointer to the network link tile context using `fd_topo_obj_laddr` and initializes it with zeroes using `fd_memset`.
    - Sets the `magic` field of the context to `FD_NETLINK_TILE_CTX_MAGIC` and assigns the neighbor interface index to `ctx->neigh4_ifidx`.
    - Initializes two netlink connections for monitoring and requests using `fd_netlink_init` and logs an error if either fails.
    - Sets up a `sockaddr_nl` structure for netlink communication and binds it to the monitor socket, logging an error if binding fails.
    - Initializes a neighbor prober with specific parameters using `fd_neigh4_prober_init`.
    - Configures the socket option `SO_RCVTIMEO` for the monitor socket to set a 2ms timeout for blocking reads, logging an error if it fails.
- **Output**: No return value; the function initializes the network link tile context and logs errors if any operation fails.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L183>)

Initializes an unprivileged network tile context by allocating memory, setting up network device tables, and preparing for network updates.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the network topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the network tile to initialize.
- **Logic and Control Flow**:
    - Initialize scratch memory allocation with the local address of the tile object.
    - Allocate memory for `fd_netlink_tile_ctx_t` and verify its magic number.
    - Calculate and allocate memory for the network device table size and alignment.
    - Verify the presence of necessary object IDs in the `tile` structure.
    - Create and join a new network device table using the allocated memory.
    - Join the double buffer for network devices using the object ID from `tile`.
    - Join the neighbor hashmap and FIB4 tables using their respective object IDs from `tile`.
    - Iterate over incoming links to ensure they have an MTU of zero, logging an error if not.
    - Set action flags for link, route, and neighbor updates.
    - Calculate and set the update backoff time to 10 milliseconds.
- **Output**: No direct output; modifies the `ctx` structure within the allocated memory to prepare for network operations.


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L226>)

Updates various network metrics in the context of a netlink tile.
- **Inputs**:
    - `ctx`: A pointer to a `fd_netlink_tile_ctx_t` structure that contains the context for the netlink tile.
- **Logic and Control Flow**:
    - Set the metric for dropped events using `FD_MCNT_SET` with `fd_netlink_enobufs_cnt`.
    - Set the metric for link full syncs using `FD_MCNT_SET` with `ctx->metrics.link_full_syncs`.
    - Set the metric for route full syncs using `FD_MCNT_SET` with `ctx->metrics.route_full_syncs`.
    - Copy the update count metrics using `FD_MCNT_ENUM_COPY` with `ctx->metrics.update_cnt`.
    - Set the gauge for interface count using `FD_MGAUGE_SET` with `ctx->netdev_tbl->hdr->dev_cnt`.
    - Set the gauge for local route count using `FD_MGAUGE_SET` with the result of `fd_fib4_cnt(ctx->fib4_local)`.
    - Set the gauge for main route count using `FD_MGAUGE_SET` with the result of `fd_fib4_cnt(ctx->fib4_main)`.
    - Set the metric for neighbor probes sent using `FD_MCNT_SET` with `ctx->metrics.neigh_solicits_sent`.
    - Set the metric for neighbor probe failures using `FD_MCNT_SET` with `ctx->metrics.neigh_solicits_fails`.
    - Set the metric for host rate-limited neighbor probes using `FD_MCNT_SET` with `ctx->prober->local_rate_limited_cnt`.
    - Set the metric for global rate-limited neighbor probes using `FD_MCNT_SET` with `ctx->prober->global_rate_limited_cnt`.
- **Output**: No return value; the function updates metrics in the provided context.


---
### netlink\_monitor\_read<!-- {{#callable:netlink_monitor_read}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L244>)

Processes netlink messages to update network link, route, or neighbor information and returns a status indicating if a message was read.
- **Inputs**:
    - `ctx`: A pointer to a `fd_netlink_tile_ctx_t` structure that contains context information for the netlink tile.
    - `flags`: An integer representing flags for the `recvfrom` function, such as `MSG_DONTWAIT` for non-blocking operation.
- **Logic and Control Flow**:
    - Allocate a buffer `msg` of size 16384 bytes to store the incoming message.
    - Call `recvfrom` to read a message from the netlink socket specified in `ctx->nl_monitor->fd` into `msg` with the given `flags`.
    - If `recvfrom` returns a non-positive size, check `errno` for specific conditions: return 0 if `errno` is `EAGAIN` or `EINTR`, increment `fd_netlink_enobufs_cnt` and return 0 if `errno` is `ENOBUFS`, or log an error and exit if other errors occur.
    - Cast `msg` to a `struct nlmsghdr` pointer `nlh` to interpret the netlink message header.
    - Log a trace probe with details from the netlink message header using `FD_DTRACE_PROBE_4`.
    - Use a switch statement on `nlh->nlmsg_type` to determine the type of netlink message and update the context `ctx` accordingly:
    - For `RTM_NEWLINK` or `RTM_DELLINK`, set `ctx->action` to include `FD_NET_TILE_ACTION_LINK_UPDATE` and increment the link update count in `ctx->metrics`.
    - For `RTM_NEWROUTE` or `RTM_DELROUTE`, set `ctx->action` to include `FD_NET_TILE_ACTION_ROUTE4_UPDATE` and increment the route update count in `ctx->metrics`.
    - For `RTM_NEWNEIGH` or `RTM_DELNEIGH`, call `fd_neigh4_netlink_ingest_message` to process the neighbor message, and increment the neighbor update count in `ctx->metrics`.
    - For any other message type, log an informational message about the unexpected message type.
    - Return 1 to indicate that a message was successfully read and processed.
- **Output**: Returns 1 if a netlink message was read and processed, or 0 if no message was read due to non-critical errors.


---
### during\_housekeeping<!-- {{#callable:during_housekeeping}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L286>)

Performs housekeeping tasks for network link, route, and neighbor updates based on the current action flags in the context.
- **Inputs**:
    - `ctx`: A pointer to a `fd_netlink_tile_ctx_t` structure that contains the context for network link, route, and neighbor updates.
- **Logic and Control Flow**:
    - Get the current time using `fd_tickcount()` and store it in `now`.
    - Check if the `FD_NET_TILE_ACTION_LINK_UPDATE` flag is set in `ctx->action`.
    - If the current time `now` is less than `ctx->link_update_ts`, return immediately.
    - Clear the `FD_NET_TILE_ACTION_LINK_UPDATE` flag from `ctx->action`.
    - Load the network device table using `fd_netdev_netlink_load_table()` and insert it into the double buffer using `fd_dbl_buf_insert()`.
    - Update `ctx->link_update_ts` with the current time plus `ctx->update_backoff`.
    - Increment the `link_full_syncs` metric in `ctx->metrics`.
    - Check if the `FD_NET_TILE_ACTION_ROUTE4_UPDATE` flag is set in `ctx->action`.
    - If the current time `now` is less than `ctx->route4_update_ts`, return immediately.
    - Clear the `FD_NET_TILE_ACTION_ROUTE4_UPDATE` flag from `ctx->action`.
    - Load the IPv4 route tables using `fd_fib4_netlink_load_table()` for both local and main tables.
    - Update `ctx->route4_update_ts` with the current time plus `ctx->update_backoff`.
    - Increment the `route_full_syncs` metric in `ctx->metrics`.
    - Check if the `FD_NET_TILE_ACTION_NEIGH_UPDATE` flag is set in `ctx->action`.
    - Clear the `FD_NET_TILE_ACTION_NEIGH_UPDATE` flag from `ctx->action`.
    - Request a dump of the neighbor table using `fd_neigh4_netlink_request_dump()`.
    - Initialize a netlink iterator and iterate over the messages, ingesting each message into the neighbor table using `fd_neigh4_netlink_ingest_message()`.
- **Output**: No return value; the function updates the context and metrics in `ctx`.


---
### before\_credit<!-- {{#callable:before_credit}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L320>)

Manages socket buffer clearing and idle count incrementing for network link monitoring, adjusting `charge_busy` based on activity.
- **Inputs**:
    - ``ctx``: A pointer to `fd_netlink_tile_ctx_t`, representing the context for network link monitoring.
    - ``stem``: A pointer to `fd_stem_context_t`, which is unused in this function.
    - ``charge_busy``: A pointer to an integer that indicates whether the system is busy processing network link messages.
- **Logic and Control Flow**:
    - Enters an infinite loop to clear the socket buffer by calling [`netlink_monitor_read`](<#netlink_monitor_read>) with `MSG_DONTWAIT` flag.
    - If [`netlink_monitor_read`](<#netlink_monitor_read>) returns false, exits the loop and sets `*charge_busy` to 1.
    - Increments `ctx->idle_cnt` by 1.
    - Checks if `ctx->idle_cnt` is greater than or equal to 128.
    - If true, sets `*charge_busy` to 0 and calls [`netlink_monitor_read`](<#netlink_monitor_read>) with blocking mode (flag 0).
- **Output**: No return value; modifies `charge_busy` and `ctx->idle_cnt` based on network activity.
- **Functions Called**:
    - [`netlink_monitor_read`](<#netlink_monitor_read>)


---
### after\_poll\_overrun<!-- {{#callable:after_poll_overrun}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L345>)

Sets the `idle_cnt` field of the `fd_netlink_tile_ctx_t` structure to -1, indicating a reset of the idle counter after a poll overrun.
- **Inputs**:
    - `ctx`: A pointer to an `fd_netlink_tile_ctx_t` structure, which represents the context of a netlink tile.
- **Logic and Control Flow**:
    - Accesses the `idle_cnt` field of the `ctx` structure.
    - Sets the `idle_cnt` field to -1L.
- **Output**: No return value; the function modifies the `ctx` structure in place.


---
### after\_frag<!-- {{#callable:after_frag}} -->
[View Source →](<../../../../../src/disco/netlink/fd_netlink_tile.c#L352>)

Handles a neighbor solicit request by parsing the request, checking if the kernel is already processing it, and triggering a neighbor solicit via netlink if necessary.
- **Inputs**:
    - `ctx`: A pointer to `fd_netlink_tile_ctx_t`, which contains the context for the netlink tile.
    - `in_idx`: An unsigned long integer representing the input index, which is not used in the function.
    - `seq`: An unsigned long integer representing the sequence number, which is not used in the function.
    - `sig`: An unsigned long integer containing the request details, including the interface index and IPv4 address.
    - `sz`: An unsigned long integer representing the size of the request, expected to be zero.
    - `tsorig`: An unsigned long integer representing the original timestamp, which is not used in the function.
    - `tspub`: An unsigned long integer representing the publication timestamp, which is not used in the function.
    - `stem`: A pointer to `fd_stem_context_t`, which is not used in the function.
- **Logic and Control Flow**:
    - Set `ctx->idle_cnt` to -1 and get the current tick count.
    - Check if `sz` is not zero and log a warning if it is not.
    - Check if the high bits of `sig` are set and log a warning if they are.
    - Extract `if_idx` and `ip4_addr` from `sig`.
    - Check if `if_idx` matches `ctx->neigh4_ifidx`; if not, increment `ctx->metrics.neigh_solicits_fails` and log an error, then return.
    - Attempt to query the neighbor hashmap with `ip4_addr`; if successful, increment `ctx->metrics.neigh_solicits_fails` and return.
    - Prepare to insert a placeholder in the neighbor hashmap; if unsuccessful, increment `ctx->metrics.neigh_solicits_fails` and return.
    - Set the state of the neighbor entry to `FD_NEIGH4_STATE_INCOMPLETE`, set its `ip4_addr`, and zero its `mac_addr`.
    - Publish the neighbor entry to the hashmap.
    - Trigger a neighbor solicit via netlink and update `ctx->metrics.neigh_solicits_sent` or `ctx->metrics.neigh_solicits_fails` based on the result.
- **Output**: No return value; the function updates the context and metrics within `ctx`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)