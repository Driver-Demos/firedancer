<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for managing and interacting with topological workspaces and objects in shared memory.

# Purpose
The code is a C source file that manages shared memory workspaces and their interactions within a topology. It provides functions to join, leave, create, and fill workspaces, as well as to manage the memory locking and page counting for different types of memory pages (gigantic, huge, and normal). The code is part of a larger system that uses shared memory to manage resources across different components, referred to as tiles, links, and objects. The functions interact with shared memory utilities and workspace management functions to ensure that resources are correctly allocated and deallocated.

Key components include functions like [`fd_topo_join_workspace`](<#fd_topo_join_workspace>), `fd_topo_leave_workspace`, and [`fd_topo_create_workspace`](<#fd_topo_create_workspace>), which handle the joining, leaving, and creation of workspaces, respectively. The code also includes functions to calculate memory requirements, such as [`fd_topo_mlock_max_tile`](<#fd_topo_mlock_max_tile>) and [`fd_topo_gigantic_page_cnt`](<#fd_topo_gigantic_page_cnt>), which determine the maximum memory lock size and the number of gigantic pages required. Additionally, the code provides logging functionality to output the current state of the topology, including summaries of memory usage and workspace details. The file is intended to be part of a larger system, likely imported and used by other components to manage shared memory resources efficiently.
# Imports and Dependencies

---
- `fd_topo.h`
- `../metrics/fd_metrics.h`
- `../../util/pod/fd_pod_format.h`
- `../../util/wksp/fd_wksp_private.h`
- `../../util/shmem/fd_shmem_private.h`
- `stdio.h`
- `errno.h`
- `unistd.h`
- `sys/stat.h`


# Global Variables

---
### fd\_topo\_leave\_workspace
- **Type**: `function`
- **Description**: Detaches a workspace from the topology and resets its properties.
- **Use**: Used to leave a workspace by detaching it and resetting its footprint properties.


---
### fd\_shmem\_private\_base
- **Type**: `char`
- **Description**: An external character array named `fd_shmem_private_base` with a size defined by `FD_SHMEM_PRIVATE_BASE_MAX`. This array is declared as an external variable, indicating it is defined elsewhere and can be accessed by other files that include this declaration.
- **Use**: Used to store or reference a base address or data related to shared memory operations.


# Functions

---
### fd\_topo\_obj\_laddr<!-- {{#callable:fd_topo_obj_laddr}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L13>)

Calculates the local address of an object in a topology based on its ID.
- **Inputs**:
    - ``topo``: A pointer to a constant `fd_topo_t` structure representing the topology.
    - ``obj_id``: An unsigned long integer representing the ID of the object within the topology.
- **Logic and Control Flow**:
    - Retrieve the object from the `topo->objs` array using `obj_id`.
    - Check if `obj_id` is equal to `ULONG_MAX` and log a critical error if true.
    - Check if `obj_id` is greater than or equal to `FD_TOPO_MAX_OBJS` and log a critical error if true.
    - Verify that the object's `id` matches `obj_id` using `FD_TEST`.
    - Verify that the object's `offset` is non-zero using `FD_TEST`.
    - Calculate the local address by adding the object's `offset` to the base address of the workspace identified by `obj->wksp_id`.
- **Output**: Returns a void pointer to the calculated local address of the object.


---
### fd\_topo\_join\_workspace<!-- {{#callable:fd_topo_join_workspace}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L24>)

Joins a workspace to a topology using shared memory and workspace joining functions.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology to which the workspace will be joined.
    - ``wksp``: A pointer to an `fd_topo_wksp_t` structure representing the workspace to be joined.
    - ``mode``: An integer representing the mode in which the shared memory should be joined.
- **Logic and Control Flow**:
    - Declare a character array `name` with a size of `PATH_MAX` to store the workspace name.
    - Use `fd_cstr_printf_check` to format the workspace name as a string combining `topo->app_name` and `wksp->name`, and store it in `name`.
    - Call `fd_shmem_join` with `name` and `mode` to join the shared memory, and pass the result to `fd_wksp_join` to join the workspace.
    - Assign the result of `fd_wksp_join` to `wksp->wksp`.
    - If `wksp->wksp` is `NULL`, log an error message using `FD_LOG_ERR`.
- **Output**: No return value; the function modifies the `wksp` structure by setting its `wksp` member.


---
### tile\_needs\_wksp<!-- {{#callable:tile_needs_wksp}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L35>)

Determines the highest access mode required by a tile for a specific workspace ID.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology, which contains information about objects and workspaces.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the tile, which contains information about the objects it uses.
    - `wksp_id`: An unsigned long integer representing the workspace ID to check against the tile's used objects.
- **Logic and Control Flow**:
    - Initialize `mode` to -1, which indicates that no workspace is needed by default.
    - Iterate over each object used by the tile, as indicated by `tile->uses_obj_cnt`.
    - For each object, check if the workspace ID of the object matches the given `wksp_id`.
    - If a match is found, update `mode` to the maximum of the current `mode` and the object's access mode (`tile->uses_obj_mode[i]`).
    - Return the final value of `mode`, which is the highest access mode required by the tile for the specified workspace ID.
- **Output**: Returns an integer representing the highest access mode required by the tile for the specified workspace ID, or -1 if the workspace is not needed.


---
### fd\_topo\_join\_tile\_workspaces<!-- {{#callable:fd_topo_join_tile_workspaces}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L46>)

Joins the necessary workspaces for a given tile in a topology.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the tile for which workspaces need to be joined.
- **Logic and Control Flow**:
    - Iterates over each workspace in the topology using a loop from 0 to `topo->wksp_cnt`.
    - For each workspace, calls [`tile_needs_wksp`](<#tile_needs_wksp>) to determine if the tile needs the workspace and the mode required.
    - If [`tile_needs_wksp`](<#tile_needs_wksp>) returns a mode other than -1, calls [`fd_topo_join_workspace`](<#fd_topo_join_workspace>) to join the workspace with the specified mode.
- **Output**: No return value; the function operates by modifying the state of the topology and tile structures.
- **Functions Called**:
    - [`tile_needs_wksp`](<#tile_needs_wksp>)
    - [`fd_topo_join_workspace`](<#fd_topo_join_workspace>)


---
### fd\_topo\_join\_workspaces<!-- {{#callable:fd_topo_join_workspaces}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L57>)

Joins all workspaces in a topology using a specified mode.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology containing the workspaces to join.
    - ``mode``: An integer specifying the mode to use when joining each workspace.
- **Logic and Control Flow**:
    - Iterates over each workspace in the `topo` structure using a loop that runs from 0 to `topo->wksp_cnt`.
    - For each workspace, calls the [`fd_topo_join_workspace`](<#fd_topo_join_workspace>) function with the current workspace and the specified `mode`.
- **Output**: No return value; the function operates on the workspaces within the `topo` structure.
- **Functions Called**:
    - [`fd_topo_join_workspace`](<#fd_topo_join_workspace>)


---
### fd\_topo\_leave\_workspaces<!-- {{#callable:fd_topo_leave_workspaces}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L76>)

Detaches all workspaces associated with a given topology.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology whose workspaces are to be detached.
- **Logic and Control Flow**:
    - Iterates over each workspace in the `topo` structure using a loop that runs from 0 to `topo->wksp_cnt`.
    - For each workspace, calls the `fd_topo_leave_workspace` function to detach the workspace.
- **Output**: No return value; the function operates directly on the `topo` structure to detach its workspaces.


---
### fd\_topo\_create\_workspace<!-- {{#callable:fd_topo_create_workspace}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L85>)

Creates or updates a shared memory workspace for a given topology and workspace configuration.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology configuration.
    - ``wksp``: A pointer to an `fd_topo_wksp_t` structure representing the workspace configuration.
    - ``update_existing``: An integer flag indicating whether to update an existing workspace (non-zero) or create a new one (zero).
- **Logic and Control Flow**:
    - Constructs a workspace name using the application name from `topo` and the workspace name from `wksp`.
    - Initializes arrays `sub_page_cnt` and `sub_cpu_idx` with the page count and CPU index for the workspace.
    - Checks if `update_existing` is true; if so, calls `fd_shmem_update_multi` to update the existing shared memory, otherwise calls `fd_shmem_create_multi` to create a new shared memory.
    - Handles errors from the shared memory operations, returning -1 if `ENOMEM` is encountered, or logging an error for other failures.
    - Joins the shared memory using `fd_shmem_join` and creates a new workspace memory region with `fd_wksp_new`.
    - Joins the workspace memory with `fd_wksp_join` and allocates memory within the workspace if `wksp->known_footprint` is non-zero.
    - Verifies that the allocated memory offset matches the expected start of the workspace data region.
    - Leaves the workspace and shared memory using `fd_wksp_leave` and `fd_shmem_leave`, respectively.
    - Returns 0 on successful completion.
- **Output**: Returns 0 on success, or -1 if there is an `ENOMEM` error during shared memory operations.
- **Functions Called**:
    - [`fd_topo_workspace_align`](<fd_topo.h.md#fd_topo_workspace_align>)


---
### fd\_topo\_wksp\_new<!-- {{#callable:fd_topo_wksp_new}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L138>)

Initializes new workspace objects in a topology based on provided callbacks.
- **Inputs**:
    - ``topo``: A pointer to a constant `fd_topo_t` structure representing the topology containing objects to be initialized.
    - ``wksp``: A pointer to a constant `fd_topo_wksp_t` structure representing the workspace to be associated with the objects.
    - ``callbacks``: An array of pointers to `fd_topo_obj_callbacks_t` structures, each containing a name and a function pointer for initialization.
- **Logic and Control Flow**:
    - Iterates over each object in the `topo` structure.
    - Checks if the object's workspace ID matches the provided `wksp` ID; if not, continues to the next object.
    - For each matching object, iterates over the `callbacks` array to find a callback with a matching name.
    - If a matching callback is found, records the current wall clock time, calls the `new` function of the callback if it exists, and calculates the elapsed time.
    - Logs a warning if the elapsed time exceeds 100 milliseconds, or an info message if it exceeds 5 milliseconds, then breaks out of the callback loop.
- **Output**: No return value; the function operates through side effects on the provided objects and logs messages.


---
### fd\_topo\_workspace\_fill<!-- {{#callable:fd_topo_workspace_fill}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L159>)

Fills the topology workspace with joined memory caches and data caches for links and metrics and sequence numbers for tiles.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology.
    - ``wksp``: A pointer to an `fd_topo_wksp_t` structure representing the workspace to fill.
- **Logic and Control Flow**:
    - Iterates over each link in the topology using a for loop.
    - Checks if the workspace ID of the link's memory cache object matches the given workspace ID; if not, continues to the next link.
    - Joins the memory cache for the link using `fd_mcache_join` and verifies the join with `FD_TEST`.
    - If the link has a non-zero MTU, checks if the workspace ID of the link's data cache object matches the given workspace ID; if not, continues to the next link.
    - Joins the data cache for the link using `fd_dcache_join` and verifies the join with `FD_TEST`.
    - Iterates over each tile in the topology using a for loop.
    - Checks if the workspace ID of the tile's metrics object matches the given workspace ID; if so, joins the metrics using `fd_metrics_join` and verifies the join with `FD_TEST`.
    - Iterates over each input link sequence number for the tile using a nested for loop.
    - Checks if the workspace ID of the input link's sequence object matches the given workspace ID; if not, continues to the next sequence.
    - Joins the input link sequence using `fd_fseq_join` and verifies the join with `FD_TEST`.
- **Output**: No return value; the function modifies the `topo` structure in place.
- **Functions Called**:
    - [`fd_topo_obj_laddr`](<#fd_topo_obj_laddr>)


---
### fd\_topo\_fill\_tile<!-- {{#callable:fd_topo_fill_tile}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L192>)

Fills the necessary workspaces for a given tile in a topology.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure representing the tile to be filled.
- **Logic and Control Flow**:
    - Iterates over each workspace in the topology using a loop from 0 to `topo->wksp_cnt`.
    - For each workspace, checks if the tile needs the workspace by calling [`tile_needs_wksp`](<#tile_needs_wksp>) with the current index.
    - If the tile needs the workspace (i.e., [`tile_needs_wksp`](<#tile_needs_wksp>) does not return -1), calls [`fd_topo_workspace_fill`](<#fd_topo_workspace_fill>) to fill the workspace.
- **Output**: No return value; the function operates by side effects on the `topo` and `tile` structures.
- **Functions Called**:
    - [`tile_needs_wksp`](<#tile_needs_wksp>)
    - [`fd_topo_workspace_fill`](<#fd_topo_workspace_fill>)


---
### fd\_topo\_fill<!-- {{#callable:fd_topo_fill}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L201>)

Iterates over all workspaces in the topology and fills each one using [`fd_topo_workspace_fill`](<#fd_topo_workspace_fill>).
- **Inputs**:
    - `topo`: A pointer to an `fd_topo_t` structure representing the topology, which contains information about workspaces and other components.
- **Logic and Control Flow**:
    - Iterates over each workspace in the `topo` structure using a for loop with index `i`.
    - Calls [`fd_topo_workspace_fill`](<#fd_topo_workspace_fill>) for each workspace, passing the `topo` structure and the current workspace as arguments.
- **Output**: No return value; the function operates on the `topo` structure to fill its workspaces.
- **Functions Called**:
    - [`fd_topo_workspace_fill`](<#fd_topo_workspace_fill>)


---
### fd\_topo\_tile\_extra\_huge\_pages<!-- {{#callable:fd_topo_tile_extra_huge_pages}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L208>)

Calculates the number of extra huge pages required for a tile's stack.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure, representing the tile for which to calculate extra huge pages.
- **Logic and Control Flow**:
    - Ignores the `tile` input as it is not used in the calculation.
    - Calculates the number of extra huge pages by dividing `FD_TILE_PRIVATE_STACK_SZ` by `FD_SHMEM_HUGE_PAGE_SZ` and adding 2.
- **Output**: Returns an `ulong` representing the number of extra huge pages needed for the tile's stack.


---
### fd\_topo\_tile\_extra\_normal\_pages<!-- {{#callable:fd_topo_tile_extra_normal_pages}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L215>)

Calculates the number of extra normal pages required by a tile, considering key material and shared locks.
- **Inputs**:
    - `tile`: A pointer to a constant `fd_topo_tile_t` structure representing the tile for which to calculate extra normal pages.
- **Logic and Control Flow**:
    - Initialize `key_pages` to 0.
    - Check if `tile->keyswitch_obj_id` is non-zero using `FD_UNLIKELY`.
    - If true, set `key_pages` to 5, indicating the need for normal pages to hold key material.
    - Add 1 to `key_pages` to account for the normal page locked for the `fd_log` shared lock.
    - Return the total number of extra normal pages as `key_pages + 1`.
- **Output**: Returns the total number of extra normal pages as an unsigned long integer.


---
### fd\_topo\_mlock\_max\_tile1<!-- {{#callable:fd_topo_mlock_max_tile1}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L228>)

Calculates the maximum memory lockable by a single tile in a topology.
- **Inputs**:
    - `topo`: A pointer to a constant `fd_topo_t` structure representing the topology.
    - `tile`: A pointer to a constant `fd_topo_tile_t` structure representing the tile.
- **Logic and Control Flow**:
    - Initialize `tile_mem` to 0.
    - Iterate over each workspace in the topology (`topo->wksp_cnt`).
    - For each workspace, check if the tile needs the workspace using [`tile_needs_wksp`](<#tile_needs_wksp>).
    - If the tile needs the workspace, add the workspace's memory size (`page_cnt * page_sz`) to `tile_mem`.
    - Add the extra huge pages required by the tile ([`fd_topo_tile_extra_huge_pages`](<#fd_topo_tile_extra_huge_pages>)) multiplied by `FD_SHMEM_HUGE_PAGE_SZ` to `tile_mem`.
    - Add the extra normal pages required by the tile ([`fd_topo_tile_extra_normal_pages`](<#fd_topo_tile_extra_normal_pages>)) multiplied by `FD_SHMEM_NORMAL_PAGE_SZ` to `tile_mem`.
    - Return the total `tile_mem`.
- **Output**: Returns the total memory size in bytes that can be locked by the tile.
- **Functions Called**:
    - [`tile_needs_wksp`](<#tile_needs_wksp>)
    - [`fd_topo_tile_extra_huge_pages`](<#fd_topo_tile_extra_huge_pages>)
    - [`fd_topo_tile_extra_normal_pages`](<#fd_topo_tile_extra_normal_pages>)


---
### fd\_topo\_mlock\_max\_tile<!-- {{#callable:fd_topo_mlock_max_tile}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L243>)

Finds the maximum memory lock size required by any tile in the topology.
- **Inputs**:
    - ``topo``: A pointer to a constant `fd_topo_t` structure representing the topology.
- **Logic and Control Flow**:
    - Initialize `highest_tile_mem` to 0.
    - Iterate over each tile in the topology using a loop that runs from 0 to `topo->tile_cnt`.
    - For each tile, calculate the maximum memory lock size using [`fd_topo_mlock_max_tile1`](<#fd_topo_mlock_max_tile1>) and update `highest_tile_mem` with the maximum value between the current `highest_tile_mem` and the calculated value.
    - Return `highest_tile_mem` as the result.
- **Output**: Returns the maximum memory lock size (in bytes) required by any tile in the topology as an unsigned long integer.
- **Functions Called**:
    - [`fd_topo_mlock_max_tile1`](<#fd_topo_mlock_max_tile1>)


---
### fd\_topo\_gigantic\_page\_cnt<!-- {{#callable:fd_topo_gigantic_page_cnt}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L254>)

Counts the number of gigantic pages in a given NUMA node within a topology.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology containing workspaces.
    - ``numa_idx``: An unsigned long integer representing the NUMA node index to filter workspaces by.
- **Logic and Control Flow**:
    - Initialize `result` to 0.
    - Iterate over each workspace in `topo->workspaces`.
    - For each workspace, check if its `numa_idx` matches the input `numa_idx`.
    - If the workspace's `page_sz` equals `FD_SHMEM_GIGANTIC_PAGE_SZ`, add its `page_cnt` to `result`.
    - Return `result` as the total count of gigantic pages for the specified NUMA node.
- **Output**: Returns the total number of gigantic pages as an unsigned long integer.


---
### fd\_topo\_huge\_page\_cnt<!-- {{#callable:fd_topo_huge_page_cnt}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L269>)

Calculates the total number of huge pages used by workspaces and tiles in a given topology for a specified NUMA node.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology containing workspaces and tiles.
    - ``numa_idx``: An unsigned long integer representing the NUMA node index to filter workspaces by.
    - ``include_anonymous``: An integer flag indicating whether to include anonymous huge pages, though it is currently unused in the function.
- **Logic and Control Flow**:
    - Initialize `result` to 0.
    - Iterate over each workspace in `topo->workspaces`.
    - For each workspace, check if its `numa_idx` matches the input `numa_idx`.
    - If the workspace's `page_sz` equals `FD_SHMEM_HUGE_PAGE_SZ`, add its `page_cnt` to `result`.
    - Iterate over each tile in `topo->tiles`.
    - Add the result of [`fd_topo_tile_extra_huge_pages`](<#fd_topo_tile_extra_huge_pages>) for each tile to `result`.
    - Ignore the `include_anonymous` parameter as it is not used.
    - Return the accumulated `result`.
- **Output**: Returns the total number of huge pages as an unsigned long integer.
- **Functions Called**:
    - [`fd_topo_tile_extra_huge_pages`](<#fd_topo_tile_extra_huge_pages>)


---
### fd\_topo\_normal\_page\_cnt<!-- {{#callable:fd_topo_normal_page_cnt}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L294>)

Calculates the total number of extra normal pages required by all tiles in a given topology.
- **Inputs**:
    - `topo`: A pointer to an `fd_topo_t` structure representing the topology, which contains information about tiles and their configurations.
- **Logic and Control Flow**:
    - Initialize `result` to 0.
    - Iterate over each tile in the topology using a loop that runs from 0 to `topo->tile_cnt`.
    - For each tile, call [`fd_topo_tile_extra_normal_pages`](<#fd_topo_tile_extra_normal_pages>) to get the number of extra normal pages required by that tile and add it to `result`.
    - Return the accumulated `result` as the total number of extra normal pages.
- **Output**: Returns an `ulong` representing the total number of extra normal pages required by all tiles in the topology.
- **Functions Called**:
    - [`fd_topo_tile_extra_normal_pages`](<#fd_topo_tile_extra_normal_pages>)


---
### fd\_topo\_mlock<!-- {{#callable:fd_topo_mlock}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L303>)

Calculates the total memory size in bytes for all workspaces in a given topology.
- **Inputs**:
    - `topo`: A pointer to a constant `fd_topo_t` structure representing the topology, which contains information about the workspaces.
- **Logic and Control Flow**:
    - Initialize `result` to 0.
    - Iterate over each workspace in the topology using a loop that runs from 0 to `topo->wksp_cnt`.
    - For each workspace, calculate the memory size by multiplying `page_cnt` by `page_sz` and add it to `result`.
    - Return the accumulated `result` as the total memory size.
- **Output**: Returns an `ulong` representing the total memory size in bytes for all workspaces in the topology.


---
### fd\_topo\_mem\_sz\_string<!-- {{#callable:fd_topo_mem_sz_string}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L312>)

Converts a memory size in bytes to a human-readable string format with appropriate units (GiB, MiB, KiB, or B).
- **Inputs**:
    - `sz`: The memory size in bytes to convert.
    - `out`: A character array with a minimum size of 24 to store the resulting formatted string.
- **Logic and Control Flow**:
    - Check if `sz` is greater than or equal to `FD_SHMEM_GIGANTIC_PAGE_SZ`; if true, format `sz` as GiB.
    - If the first condition is false, check if `sz` is greater than or equal to 1048576; if true, format `sz` as MiB.
    - If the second condition is false, check if `sz` is greater than or equal to 1024; if true, format `sz` as KiB.
    - If none of the above conditions are true, format `sz` as bytes (B).
    - Use `fd_cstr_printf_check` to format the string and store it in `out`, ensuring the operation is successful with `FD_TEST`.
- **Output**: A formatted string representing the memory size in the most appropriate unit, stored in the `out` array.


---
### fd\_topo\_print\_log<!-- {{#callable:fd_topo_print_log}} -->
[View Source →](<../../../../../src/disco/topo/fd_topo.c#L325>)

Generates and logs a detailed summary of the topology, including memory usage, page requirements, workspaces, objects, links, and tiles.
- **Inputs**:
    - `stdout`: An integer flag indicating whether to log the output to standard output (non-zero) or to log information (zero).
    - `topo`: A pointer to an `fd_topo_t` structure containing the topology information to be logged.
- **Logic and Control Flow**:
    - Initialize a large character buffer `message` to store the log output.
    - Define a macro `PRINT` to append formatted strings to `message` and handle errors.
    - Calculate `stack_pages` and `private_key_pages` based on the topology's tile count and predefined constants.
    - Compute `total_bytes` as the sum of locked memory, stack pages, and private key pages.
    - Log the total number of tiles and total memory locked in a human-readable format.
    - Calculate the required number of gigantic and huge pages for each NUMA node and log the results.
    - If `topo->agave_affinity_cnt` is greater than zero, format and log the agave affinity information.
    - Iterate over each workspace in `topo->workspaces`, format its details, and append to the log.
    - Iterate over each object in `topo->objs`, format its details, including properties, and append to the log.
    - Iterate over each link in `topo->links`, format its details, and append to the log.
    - Iterate over each tile in `topo->tiles`, format its details, including input and output links, and append to the log.
    - If `stdout` is non-zero, log the `message` to standard output; otherwise, log it as information.
- **Output**: Logs a detailed summary of the topology to either standard output or as log information, depending on the `stdout` flag.
- **Functions Called**:
    - [`fd_topo_mlock`](<#fd_topo_mlock>)
    - [`fd_topo_gigantic_page_cnt`](<#fd_topo_gigantic_page_cnt>)
    - [`fd_topo_huge_page_cnt`](<#fd_topo_huge_page_cnt>)
    - [`fd_topo_normal_page_cnt`](<#fd_topo_normal_page_cnt>)
    - [`fd_topo_mem_sz_string`](<#fd_topo_mem_sz_string>)
    - [`fd_topo_mlock_max_tile1`](<#fd_topo_mlock_max_tile1>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)