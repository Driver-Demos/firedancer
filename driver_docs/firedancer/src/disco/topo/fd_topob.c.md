<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Functions for creating and managing a topology of workspaces, objects, links, and tiles with validation and automatic layout.

# Purpose
The code defines a set of functions for managing and configuring a topology of computational resources, such as tiles, workspaces, objects, and links. The primary data structure used is `fd_topo_t`, which represents the topology and contains arrays for tiles, workspaces, objects, and links. The functions provided allow for the creation and configuration of these components, including setting up new topologies ([`fd_topob_new`](<#fd_topob_new>)), adding workspaces ([`fd_topob_wksp`](<#fd_topob_wksp>)), objects ([`fd_topob_obj`](<#fd_topob_obj>)), links ([`fd_topob_link`](<#fd_topob_link>)), and tiles ([`fd_topob_tile`](<#fd_topob_tile>)). The code also includes functions for managing the relationships between these components, such as linking tiles to input and output links ([`fd_topob_tile_in`](<#fd_topob_tile_in>), [`fd_topob_tile_out`](<#fd_topob_tile_out>)) and assigning resources to NUMA nodes ([`initialize_numa_assignments`](<#initialize_numa_assignments>)).

The code is structured to ensure that the topology is valid and consistent. It includes validation checks to prevent errors such as duplicate names, invalid workspace IDs, and incorrect link assignments. The [`validate`](<#validate>) function performs these checks, ensuring that each component is correctly configured and that the topology adheres to expected constraints. Additionally, the code provides an automatic layout system ([`fd_topob_auto_layout`](<#fd_topob_auto_layout>)) to assign tiles to CPU cores based on NUMA node order, with special handling for critical tiles that require specific CPU assignments. The [`fd_topob_finish`](<#fd_topob_finish>) function finalizes the topology setup, calculating memory footprints and aligning resources as needed. Overall, the code provides a comprehensive framework for defining and managing a complex topology of computational resources.
# Imports and Dependencies

---
- `fd_topob.h`
- `../../util/pod/fd_pod_format.h`
- `fd_cpu_topo.h`


# Functions

---
### fd\_topob\_new<!-- {{#callable:fd_topob_new}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L6>)

Initializes a `fd_topo_t` structure with given memory and application name, ensuring alignment and setting default properties.
- **Inputs**:
    - `mem`: A pointer to the memory location where the `fd_topo_t` structure will be initialized.
    - `app_name`: A string representing the application name to be stored in the `fd_topo_t` structure.
- **Logic and Control Flow**:
    - Cast `mem` to a `fd_topo_t` pointer and assign it to `topo`.
    - Check if `topo` is NULL; if so, log a warning and return NULL.
    - Check if `topo` is aligned to `fd_topo_t` alignment; if not, log a warning and return NULL.
    - Clear the memory of `topo` using `fd_memset`.
    - Initialize `topo->props` using `fd_pod_new`.
    - Check if `app_name` length exceeds `topo->app_name` size; if so, log an error.
    - Copy `app_name` into `topo->app_name` using `strncpy`.
    - Set `topo->max_page_size` to `FD_SHMEM_GIGANTIC_PAGE_SZ`.
    - Set `topo->gigantic_page_threshold` to four times `FD_SHMEM_HUGE_PAGE_SZ`.
    - Return the initialized `topo` pointer.
- **Output**: Returns a pointer to the initialized `fd_topo_t` structure, or NULL if initialization fails.


---
### fd\_topob\_wksp<!-- {{#callable:fd_topob_wksp}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L34>)

Creates a new workspace in the topology with a specified name and assigns it an ID.
- **Inputs**:
    - `topo`: A pointer to an `fd_topo_t` structure representing the topology where the workspace will be added.
    - `name`: A constant character pointer representing the name of the new workspace.
- **Logic and Control Flow**:
    - Check if `topo` or `name` is NULL or if `name` is an empty string; log an error if any condition is true.
    - Check if the length of `name` is greater than or equal to the maximum allowed length for a workspace name; log an error if true.
    - Check if the current workspace count in `topo` is greater than or equal to the maximum allowed workspaces; log an error if true.
    - Create a pointer `wksp` to the next available workspace in the `topo->workspaces` array.
    - Copy the `name` into the `wksp->name` field, ensuring it does not exceed the maximum length.
    - Assign the current workspace count as the ID of the new workspace.
    - Increment the workspace count in `topo`.
    - Return the pointer to the newly created workspace.
- **Output**: Returns a pointer to the newly created `fd_topo_wksp_t` structure.


---
### fd\_topob\_obj<!-- {{#callable:fd_topob_obj}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L48>)

Creates a new topology object in the specified workspace and assigns it an ID.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology.
    - ``obj_name``: A constant character pointer representing the name of the object to be created.
    - ``wksp_name``: A constant character pointer representing the name of the workspace where the object will be created.
- **Logic and Control Flow**:
    - Check if any of the input arguments `topo`, `obj_name`, or `wksp_name` are NULL and log an error if so.
    - Check if the length of `obj_name` exceeds the maximum allowed size for an object name and log an error if so.
    - Check if the current object count in `topo` has reached the maximum allowed number of objects and log an error if so.
    - Find the workspace ID for `wksp_name` using `fd_topo_find_wksp` and log an error if the workspace is not found.
    - Create a new object in the `objs` array of `topo` at the current object count index.
    - Copy `obj_name` into the `name` field of the new object, set its `id` to the current object count, and set its `wksp_id` to the found workspace ID.
    - Increment the object count in `topo`.
- **Output**: Returns a pointer to the newly created `fd_topo_obj_t` object.


---
### fd\_topob\_link<!-- {{#callable:fd_topob_link}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L68>)

Creates a new link in the topology with specified parameters and updates the topology's properties.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the topology.
    - ``link_name``: A constant character pointer representing the name of the link to be created.
    - ``wksp_name``: A constant character pointer representing the name of the workspace associated with the link.
    - ``depth``: An unsigned long integer representing the depth of the link.
    - ``mtu``: An unsigned long integer representing the maximum transmission unit of the link.
    - ``burst``: An unsigned long integer representing the burst size of the link.
- **Logic and Control Flow**:
    - Checks if `topo`, `link_name`, or `wksp_name` are NULL and logs an error if any are.
    - Checks if the length of `link_name` exceeds the maximum allowed size and logs an error if it does.
    - Checks if the current number of links in `topo` exceeds the maximum allowed and logs an error if it does.
    - Initializes `kind_id` to 0 and iterates over existing links to count how many have the same name as `link_name`.
    - Creates a new link in the `topo->links` array at the current `link_cnt` index.
    - Copies `link_name` to the new link's `name` field and sets its `id`, `kind_id`, `depth`, `mtu`, and `burst` fields.
    - Retrieves an object with the name "mcache" from the workspace and assigns its `id` to the link's `mcache_obj_id`.
    - Inserts the `depth` into the topology's properties using the object's `id`.
    - If `mtu` is non-zero, retrieves an object with the name "dcache" from the workspace, assigns its `id` to the link's `dcache_obj_id`, and inserts `depth`, `burst`, and `mtu` into the topology's properties using the object's `id`.
    - Increments the `link_cnt` of the topology.
- **Output**: Returns a pointer to the newly created `fd_topo_link_t` structure.
- **Functions Called**:
    - [`fd_topob_obj`](<#fd_topob_obj>)


---
### fd\_topob\_tile\_uses<!-- {{#callable:fd_topob_tile_uses}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L108>)

Associates an object with a tile in a topology and records the usage mode.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, representing the topology. It is not used in the function body.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, representing the tile that will use the object.
    - ``obj``: A pointer to a `fd_topo_obj_t` structure, representing the object to be used by the tile.
    - ``mode``: An integer representing the mode in which the tile uses the object.
- **Logic and Control Flow**:
    - Checks if the `uses_obj_cnt` of the `tile` is greater than or equal to `FD_TOPO_MAX_TILE_OBJS` and logs an error if true.
    - Assigns the `id` of `obj` to the `uses_obj_id` array at the index `uses_obj_cnt` of `tile`.
    - Assigns `mode` to the `uses_obj_mode` array at the index `uses_obj_cnt` of `tile`.
    - Increments the `uses_obj_cnt` of `tile` by 1.
- **Output**: No return value; the function modifies the `tile` structure in place.


---
### fd\_topob\_tile<!-- {{#callable:fd_topob_tile}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L122>)

Creates and initializes a new tile in the topology with specified attributes and workspace associations.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the topology.
    - ``tile_name``: A string representing the name of the tile.
    - ``tile_wksp``: A string representing the workspace name for the tile.
    - ``metrics_wksp``: A string representing the workspace name for the metrics.
    - ``cpu_idx``: An unsigned long representing the CPU index for the tile.
    - ``is_agave``: An integer flag indicating if the tile is an Agave tile.
    - ``uses_keyswitch``: An integer flag indicating if the tile uses a keyswitch.
- **Logic and Control Flow**:
    - Checks for null pointers and validates the length of `tile_name` and the number of tiles in `topo`.
    - Calculates `kind_id` by counting existing tiles with the same name.
    - Initializes a new tile in `topo->tiles` with the provided attributes and calculated `kind_id`.
    - Associates the tile with a workspace object for the tile and metrics using [`fd_topob_obj`](<#fd_topob_obj>) and [`fd_topob_tile_uses`](<#fd_topob_tile_uses>).
    - If `uses_keyswitch` is true, associates the tile with a keyswitch object; otherwise, sets `keyswitch_obj_id` to `ULONG_MAX`.
    - Increments the tile count in `topo` and returns a pointer to the newly created tile.
- **Output**: Returns a pointer to the newly created `fd_topo_tile_t` structure.
- **Functions Called**:
    - [`fd_topob_obj`](<#fd_topob_obj>)
    - [`fd_topob_tile_uses`](<#fd_topob_tile_uses>)


---
### fd\_topob\_tile\_in<!-- {{#callable:fd_topob_tile_in}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L170>)

Configures an input link for a specified tile in the topology.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the topology.
    - ``tile_name``: A string representing the name of the tile.
    - ``tile_kind_id``: An unsigned long integer representing the kind ID of the tile.
    - ``fseq_wksp``: A string representing the name of the workspace for the fseq object.
    - ``link_name``: A string representing the name of the link.
    - ``link_kind_id``: An unsigned long integer representing the kind ID of the link.
    - ``reliable``: An integer indicating if the link is reliable (non-zero) or not (zero).
    - ``polled``: An integer indicating if the link is polled (non-zero) or not (zero).
- **Logic and Control Flow**:
    - Checks if any of the input arguments `topo`, `tile_name`, `fseq_wksp`, or `link_name` are NULL and logs an error if so.
    - Finds the tile ID using `fd_topo_find_tile` and logs an error if the tile is not found.
    - Finds the link ID using `fd_topo_find_link` and logs an error if the link is not found.
    - Checks if the tile's input link count exceeds `FD_TOPO_MAX_TILE_IN_LINKS` and logs an error if so.
    - Adds the link ID, reliability, and polling status to the tile's input link arrays.
    - Retrieves the fseq object using [`fd_topob_obj`](<#fd_topob_obj>) and associates it with the tile using [`fd_topob_tile_uses`](<#fd_topob_tile_uses>).
    - Increments the tile's input link count.
    - Associates the link's mcache object with the tile using [`fd_topob_tile_uses`](<#fd_topob_tile_uses>).
    - If the link's MTU is non-zero, associates the link's dcache object with the tile using [`fd_topob_tile_uses`](<#fd_topob_tile_uses>).
- **Output**: No return value; the function modifies the topology structure in place.
- **Functions Called**:
    - [`fd_topob_obj`](<#fd_topob_obj>)
    - [`fd_topob_tile_uses`](<#fd_topob_tile_uses>)


---
### fd\_topob\_tile\_out<!-- {{#callable:fd_topob_tile_out}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L204>)

Adds an outgoing link to a tile in the topology and updates the tile's usage of shared memory objects.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the topology.
    - ``tile_name``: A constant character pointer to the name of the tile.
    - ``tile_kind_id``: An unsigned long representing the kind ID of the tile.
    - ``link_name``: A constant character pointer to the name of the link.
    - ``link_kind_id``: An unsigned long representing the kind ID of the link.
- **Logic and Control Flow**:
    - Finds the tile ID using `fd_topo_find_tile` with `topo`, `tile_name`, and `tile_kind_id` as arguments.
    - Checks if the tile ID is `ULONG_MAX`, logs an error if true, and exits.
    - Retrieves the tile pointer from the `tiles` array in `topo` using the tile ID.
    - Finds the link ID using `fd_topo_find_link` with `topo`, `link_name`, and `link_kind_id` as arguments.
    - Checks if the link ID is `ULONG_MAX`, logs an error if true, and exits.
    - Retrieves the link pointer from the `links` array in `topo` using the link ID.
    - Checks if the tile's outgoing link count exceeds `FD_TOPO_MAX_TILE_OUT_LINKS`, logs an error if true, and exits.
    - Adds the link ID to the tile's `out_link_id` array and increments the `out_cnt`.
    - Calls [`fd_topob_tile_uses`](<#fd_topob_tile_uses>) to update the tile's usage of the link's `mcache_obj_id` in read-write mode.
    - Checks if the link's `mtu` is non-zero, and if so, calls [`fd_topob_tile_uses`](<#fd_topob_tile_uses>) to update the tile's usage of the link's `dcache_obj_id` in read-write mode.
- **Output**: No return value; the function modifies the topology structure in place.
- **Functions Called**:
    - [`fd_topob_tile_uses`](<#fd_topob_tile_uses>)


---
### validate<!-- {{#callable:validate}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L228>)

Validates the integrity and consistency of a topology structure by checking various constraints on objects, tiles, links, and workspaces.
- **Inputs**:
    - `topo`: A pointer to a constant `fd_topo_t` structure representing the topology to validate.
- **Logic and Control Flow**:
    - Iterates over each object in `topo` to ensure its `wksp_id` is within valid bounds.
    - Checks each tile's input links to ensure they are valid and not duplicated.
    - Verifies that each tile's output links are valid, not duplicated, and different from input links, except for specific exceptions.
    - Ensures non-polling input links are not marked as reliable.
    - Confirms that workspace names are unique and each workspace is correctly identified by its ID.
    - Validates that each link has exactly one producer and at least one consumer, unless exceptions are permitted.
- **Output**: No return value; logs errors if validation checks fail.


---
### fd\_topob\_auto\_layout<!-- {{#callable:fd_topob_auto_layout}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L336>)

Assigns CPU cores to tiles in a topology in a NUMA sequential order, with specific handling for floating and critical tiles, and optionally reserves cores for Agave.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure representing the topology of tiles and CPUs.
    - ``reserve_agave_cores``: An integer flag indicating whether to reserve cores for Agave.
- **Logic and Control Flow**:
    - Initialize all tiles' `cpu_idx` to `ULONG_MAX` to indicate unassigned state.
    - Initialize CPU topology and prepare arrays for CPU ordering and assignment tracking.
    - Iterate over NUMA nodes and CPUs to create a sequential CPU ordering, considering hyper-threading pairs.
    - Assign CPUs to tiles based on the `ORDERED` list, ensuring critical tiles do not share hyper-threading pairs.
    - Check that unassigned tiles are in the `FLOATING` list and log a warning if not.
    - If `reserve_agave_cores` is set, reserve remaining online CPUs for Agave.
- **Output**: No return value; modifies the `topo` structure in place to set CPU indices for tiles.
- **Functions Called**:
    - [`fd_topo_cpus_init`](<fd_cpu_topo.c.md#fd_topo_cpus_init>)


---
### initialize\_numa\_assignments<!-- {{#callable:initialize_numa_assignments}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L508>)

Assigns workspaces to NUMA nodes based on the largest object mapped by the first tile.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure that contains information about workspaces, objects, and tiles.
- **Logic and Control Flow**:
    - Iterate over each workspace in `topo` to determine the largest object footprint within that workspace.
    - For each object in the workspace, update `max_footprint` and `max_obj` if the current object has a larger footprint.
    - If no object is found for a workspace, log an error and exit.
    - For each tile, check if it maps the largest object (`max_obj`) and has a valid CPU index; if so, assign the NUMA node index to the workspace and mark it as found.
    - If no strict match is found, iterate over tiles again to find any tile that uses the object and assign the NUMA node index to the workspace.
    - If no tile uses the object, log an error and exit.
- **Output**: The function does not return a value; it modifies the `numa_idx` field of each workspace in the `topo` structure.


---
### fd\_topob\_finish<!-- {{#callable:fd_topob_finish}} -->
[View Source →](<../../../../../src/disco/topo/fd_topob.c#L573>)

Finalizes the topology by updating tile and workspace properties, calculating memory footprints, and validating the configuration.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the topology to finalize.
    - ``callbacks``: An array of pointers to `fd_topo_obj_callbacks_t` structures, providing callback functions for topology objects.
- **Logic and Control Flow**:
    - Iterates over each tile in the topology to count the number of input links that are polled and the number of consumers for each tile's output links.
    - Updates the properties of each tile with the input and consumer counts using `fd_pod_replacef_ulong`.
    - Iterates over each workspace to calculate the total loose size by invoking the `loose` callback for each object in the workspace.
    - Determines the maximum partition size (`part_max`) and calculates the offset for each object in the workspace, aligning it according to the `align` callback.
    - Calculates the footprint for each object using the `footprint` callback and updates the object's offset and footprint properties.
    - Computes the total footprint for the workspace, including alignment and padding, and determines the appropriate page size based on the total footprint.
    - Updates the workspace properties with the calculated partition maximum, known footprint, total footprint, page size, and page count.
    - Calls [`initialize_numa_assignments`](<#initialize_numa_assignments>) to assign NUMA nodes to workspaces based on tile assignments.
    - Calls [`validate`](<#validate>) to ensure the topology configuration is correct.
- **Output**: No return value; the function modifies the `topo` structure in place.
- **Functions Called**:
    - [`initialize_numa_assignments`](<#initialize_numa_assignments>)
    - [`validate`](<#validate>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)