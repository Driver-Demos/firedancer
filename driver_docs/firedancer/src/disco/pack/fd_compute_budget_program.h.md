<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Utility functions for parsing compute budget program instructions from transactions, including state management and fee calculation.

# Purpose
The code is a C header file that provides utility functions for parsing compute budget program instructions from a transaction. It is designed to determine the compute budget limit and the additional reward for including a transaction. The code is intended for high-performance use and performs error checking on data from the transaction. The header defines several constants and flags that are used to track the state of compute budget instructions within a transaction. These instructions can include setting compute unit limits, setting compute unit prices, requesting heap frames, and setting loaded account data sizes.

The file defines a structure, `fd_compute_budget_program_state_t`, which holds the state of the compute budget program as it processes a transaction. This structure includes fields for flags, instruction counts, compute units, loaded account data size, heap size, and micro-lamports per compute unit. The file provides functions to initialize this state, parse individual compute budget instructions, and finalize the state to compute total priority rewards and maximum compute units for a transaction. The constants and functions are critical for maintaining consensus and cannot be changed without coordination. The code is intended to be included in other C files and does not define a public API or external interfaces.
# Imports and Dependencies

---
- `../../ballet/fd_ballet_base.h`
- `../../ballet/txn/fd_txn.h`


# Global Variables

---
### FD\_COMPUTE\_BUDGET\_PROGRAM\_ID
- **Type**: ``uchar[FD_TXN_ACCT_ADDR_SZ]``
- **Description**: An array of unsigned characters that represents the program ID for the compute budget program. This ID is a base58 decoded value of 'ComputeBudget111111111111111111111111111111'.
- **Use**: Used to identify the compute budget program within transactions.


# Data Structures

---
### fd\_compute\_budget\_program\_private\_state
- **Type**: ``struct``
- **Members**:
    - `flags`: Indicates which instructions have been parsed in the transaction.
    - `compute_budget_instr_cnt`: Counts the number of compute budget instructions parsed so far.
    - `compute_units`: Stores the total requested compute units if `SET_CU` is in `flags`; otherwise, 0.
    - `loaded_acct_data_sz`: Stores the maximum data size in bytes that the transaction will load if `SET_LOADED_DATA_SZ` is in `flags`; otherwise, 0.
    - `heap_size`: Stores the size in bytes of the BPF heap if `SET_HEAP` is in `flags`; otherwise, 0.
    - `micro_lamports_per_cu`: Stores the requested prioritization fee in micro-lamports per compute unit if `SET_FEE` is in `flags`; otherwise, 0.
- **Description**: Represents the state of a compute budget program within a transaction, tracking parsed instructions, compute units, data size, heap size, and prioritization fees.


---
### fd\_compute\_budget\_program\_state\_t
- **Type**: ``struct``
- **Members**:
    - ``flags``: Stores flags indicating which compute budget instructions have been parsed in the transaction.
    - ``compute_budget_instr_cnt``: Counts the number of compute budget instructions parsed so far, ranging from 0 to 4.
    - ``compute_units``: Stores the total requested compute units for the transaction if the `SET_CU` flag is set, otherwise 0.
    - ``loaded_acct_data_sz``: Stores the maximum total data size in bytes that the transaction will load from referenced accounts if the `SET_LOADED_DATA_SZ` flag is set, otherwise 0.
    - ``heap_size``: Stores the size in bytes of the BPF heap used for executing the transaction if the `SET_HEAP` flag is set, otherwise 0.
    - ``micro_lamports_per_cu``: Stores the requested prioritization fee in micro-lamports per compute unit if the `SET_FEE` flag is set, otherwise 0.
- **Description**: `fd_compute_budget_program_state_t` is a structure that maintains the state of compute budget program instructions parsed from a transaction. It tracks which instructions have been processed, the number of instructions, and various parameters such as compute units, heap size, and prioritization fees. This state is used to determine the compute budget limits and additional rewards for including the transaction.


# Functions

---
### fd\_compute\_budget\_program\_init<!-- {{#callable:fd_compute_budget_program_init}} -->
[View Source →](<../../../../../src/disco/pack/fd_compute_budget_program.h#L86>)

Initializes a `fd_compute_budget_program_state_t` structure to zero.
- **Inputs**:
    - `state`: A pointer to a `fd_compute_budget_program_state_t` structure that will be initialized.
- **Logic and Control Flow**:
    - Assigns zero to all fields of the `fd_compute_budget_program_state_t` structure pointed to by `state`.
- **Output**: The function does not return a value; it modifies the `state` structure in place.


---
### fd\_compute\_budget\_program\_parse<!-- {{#callable:fd_compute_budget_program_parse}} -->
[View Source →](<../../../../../src/disco/pack/fd_compute_budget_program.h#L95>)

Parses a single ComputeBudgetProgram instruction and updates the state accordingly, returning 0 if the instruction is invalid.
- **Inputs**:
    - `instr_data`: A pointer to the first byte of the instruction data from the transaction.
    - `data_sz`: The length of the instruction data.
    - `state`: A pointer to the `fd_compute_budget_program_state_t` structure that holds the current state of the compute budget program.
- **Logic and Control Flow**:
    - Check if `data_sz` is less than 5; if true, return 0.
    - Switch on the first byte of `instr_data` to determine the instruction type.
    - For case 0, return 0 as it is an invalid instruction.
    - For case 1, check if `data_sz` is less than 5 or if the heap flag is already set; if true, return 0. Load the heap size, check its granularity, update the state, and return 1.
    - For case 2, check if `data_sz` is less than 5 or if the compute unit limit flag is already set; if true, return 0. Load the compute units, apply a limit, update the state, and return 1.
    - For case 3, check if `data_sz` is less than 9 or if the fee flag is already set; if true, return 0. Load the micro lamports per compute unit, update the state, and return 1.
    - For case 4, check if `data_sz` is less than 5 or if the loaded data size flag is already set; if true, return 0. Load the account data size, apply a limit, update the state, and return 1.
    - For any other case, return 0.
- **Output**: Returns 1 if the instruction is valid and the state is updated successfully, otherwise returns 0.


---
### fd\_compute\_budget\_program\_finalize<!-- {{#callable:fd_compute_budget_program_finalize}} -->
[View Source →](<../../../../../src/disco/pack/fd_compute_budget_program.h#L163>)

Calculates the total priority rewards and compute limits for a transaction based on its compute budget program state and instruction counts.
- **Inputs**:
    - `state`: A pointer to a `fd_compute_budget_program_state_t` structure containing the state of the compute budget program.
    - `instr_cnt`: The total number of instructions in the transaction.
    - `builtin_instr_cnt`: The total number of builtin instructions in the transaction.
    - `out_rewards`: A pointer to a `ulong` where the function will store the total priority rewards for the transaction.
    - `out_compute`: A pointer to a `uint` where the function will store the maximum number of compute units the transaction can consume.
    - `out_loaded_account_data_cost`: A pointer to a `ulong` where the function will store the cost of loaded account data.
- **Logic and Control Flow**:
    - Initialize `cu_limit` to 0 and check if the compute unit limit is set in `state->flags`; if not, calculate the default compute limit based on instruction counts.
    - Clamp `cu_limit` to the maximum allowed compute unit limit and store it in `out_compute`.
    - Initialize `loaded_accounts_data_size` to 0 and check if the loaded data size is set in `state->flags`; if not, use the default maximum loaded data size.
    - Calculate `loaded_accounts_data_cost` based on `loaded_accounts_data_size` and store it in `out_loaded_account_data_cost`.
    - Calculate the total fee using a careful arithmetic approach to avoid overflow, considering the compute unit limit and micro lamports per compute unit.
    - Store the calculated total fee in `out_rewards`.
- **Output**: Stores the total priority rewards in `out_rewards`, the maximum compute units in `out_compute`, and the loaded account data cost in `out_loaded_account_data_cost`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)