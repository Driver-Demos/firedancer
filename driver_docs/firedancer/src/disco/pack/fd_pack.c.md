<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a transaction packing system with data structures and functions for managing transaction order, priority, and scheduling in a blockchain environment.

# Purpose
The code is a C module that implements a transaction scheduling system for a blockchain or distributed ledger. It manages transactions, bundles them, and schedules them for execution based on various constraints and priorities. The module is designed to handle transactions efficiently, ensuring that they are processed in a way that maximizes throughput while respecting resource limits and avoiding conflicts.

Key components of the code include:
- **Data Structures**: The code defines several data structures, such as `fd_pack_ord_txn_t`, `fd_pack_expq_t`, and `fd_pack_addr_use_t`, which are used to manage transactions, expiration queues, and account usage, respectively.
- **Transaction Scheduling**: The module uses a combination of treaps (tree-based heaps) and priority queues to manage and schedule transactions. Transactions are prioritized based on their rewards-to-compute ratio, and the system can handle both individual transactions and bundles of transactions.
- **Resource Management**: The code includes mechanisms to track and limit the use of computational resources, data bytes, and account write costs. It ensures that transactions do not exceed predefined limits and that they are scheduled in a way that avoids conflicts with other transactions.
- **Bundle Handling**: The module supports the scheduling of transaction bundles, which are groups of transactions that are processed together. It includes logic to handle initializer bundles, which are special bundles that must be processed before other transactions.
- **Metrics and Verification**: The code includes functions to collect metrics on transaction processing and to verify the integrity of the scheduling system, ensuring that all invariants are maintained.

Overall, the module is designed to be part of a larger system that processes transactions in a blockchain or distributed ledger environment, providing efficient and conflict-free scheduling of transactions.
# Imports and Dependencies

---
- `fd_pack.h`
- `fd_pack_cost.h`
- `fd_pack_bitset.h`
- `fd_pack_unwritable.h`
- `fd_chkdup.h`
- `fd_pack_tip_prog_blacklist.h`
- `math.h`
- `stddef.h`
- `../metrics/fd_metrics.h`
- `../../util/tmpl/fd_pool.c`
- `../../util/tmpl/fd_treap.c`
- `../../util/tmpl/fd_map_chain.c`
- `../../util/tmpl/fd_map_dynamic.c`
- `../../util/tmpl/fd_prq.c`


# Global Variables

---
### null\_addr
- **Type**: ``fd_acct_addr_t``
- **Description**: Represents a constant account address initialized to zero. This is used as a placeholder or null value for account addresses in the system.
- **Use**: Used as a null or default account address in various data structures and operations.


# Data Structures

---
### wrapped\_sig\_t
- **Type**: ``struct``
- **Members**:
    - ``sig``: Holds a signature of type `fd_ed25519_sig_t`.
- **Description**: The `wrapped_sig_t` structure is a simple wrapper around a single `fd_ed25519_sig_t` signature. It is used to encapsulate a signature within a structure, potentially for easier handling or integration with other data structures or systems that require a structured format. This structure contains only one member, `sig`, which stores the signature data.


---
### fd\_pack\_private\_ord\_txn
- **Type**: ``struct``
- **Members**:
    - ``union``: Contains different representations of a transaction, including `fd_txn_p_t`, `fd_txn_e_t`, and a signature structure.
    - ``root``: Indicates which tree the transaction belongs to, using `FD_ORD_TXN_ROOT_*` values.
    - ``sigmap_next``: Next index in the signature map chain.
    - ``sigmap_prev``: Previous index in the signature map chain.
    - ``expires_at``: Expiration time of the transaction.
    - ``expq_idx``: Index in the expiration priority queue.
    - ``noncemap_next``: Next index in the noncemap chain.
    - ``noncemap_prev``: Previous index in the noncemap chain.
    - ``rewards``: Rewards for the transaction, measured in Lamports.
    - ``compute_est``: Estimated compute units required for the transaction.
    - ``left``: Left child index in the treap.
    - ``right``: Right child index in the treap.
    - ``parent``: Parent index in the treap.
    - ``prio``: Priority of the transaction in the treap.
    - ``prev``: Previous transaction index in the treap.
    - ``next``: Next transaction index in the treap.
    - ``skip``: Counter for skipping the transaction under certain conditions.
    - ``rw_bitset``: Bitset for all accounts referenced by the transaction.
    - ``w_bitset``: Bitset for accounts write-locked by the transaction.
- **Description**: The `fd_pack_private_ord_txn` structure is used to manage transactions within a system, allowing them to be organized into various data structures such as trees and maps. It includes fields for handling transaction expiration, priority, and mapping to different chains. The structure also supports operations on transactions, such as skipping and managing compute resources, and it uses bitsets to track account references and locks.


---
### fd\_pack\_ord\_txn\_t
- **Type**: ``struct``
- **Members**:
    - ``txn``: An alias for `txn_e->txnp`, representing the transaction.
    - ``txn_e``: An array of `fd_txn_e_t` elements, representing the transaction elements.
    - ``_txn_e``: A non-array type needed for map_chain operations.
    - ``_sig_cnt``: A count of signatures, used internally.
    - ``sig``: A wrapped signature of type `wrapped_sig_t`.
    - ``root``: An integer indicating which tree the transaction belongs to.
    - ``sigmap_next``: A `ushort` indicating the next element in the sig2txn map_chain.
    - ``sigmap_prev``: A `ushort` indicating the previous element in the sig2txn map_chain.
    - ``expires_at``: A `ulong` indicating the expiration time of the transaction.
    - ``expq_idx``: A `ulong` storing the index in the expiration priority queue.
    - ``noncemap_next``: A `ushort` indicating the next element in the noncemap map_chain.
    - ``noncemap_prev``: A `ushort` indicating the previous element in the noncemap map_chain.
    - ``rewards``: A `uint` representing the rewards in Lamports.
    - ``compute_est``: A `uint` representing the estimated compute units.
    - ``left``: A `ushort` indicating the left child in the treap.
    - ``right``: A `ushort` indicating the right child in the treap.
    - ``parent``: A `ushort` indicating the parent in the treap.
    - ``prio``: A `ushort` representing the priority in the treap.
    - ``prev``: A `ushort` indicating the previous element in the treap.
    - ``next``: A `ushort` indicating the next element in the treap.
    - ``skip``: A `ushort` indicating the number of times to skip the transaction.
    - ``rw_bitset``: A bitset indicating all accounts this transaction references.
    - ``w_bitset``: A bitset indicating accounts this transaction write-locks.
- **Description**: `fd_pack_ord_txn_t` is a data structure that represents a transaction with additional metadata required for ordering by priority. It includes fields for transaction elements, signature counts, expiration times, and various indices for map chains and treaps. The structure is designed to be part of multiple trees, with a `root` field indicating its current tree. It also includes bitsets for tracking account references and write-locks, and fields for managing transaction rewards and compute estimates. The structure is optimized for use in a system that handles transaction scheduling and prioritization.


---
### fd\_pack\_private\_addr\_use\_record
- **Type**: ``struct``
- **Members**:
    - ``key``: Account address.
    - ``_``: Unused placeholder for union.
    - ``in_use_by``: Bitmask indicating which banks are using the address.
    - ``total_cost``: Total cost in cost units (CUs).
    - ``carried_cost``: Cost carried over in cost units.
    - ``ref_cnt``: Reference count in transactions.
    - ``last_use_in``: Last use in transactions.
- **Description**: The `fd_pack_private_addr_use_record` structure is used to track the usage and cost of account addresses in a transaction processing system. It contains a key representing the account address and a union that can store different types of information, such as a bitmask indicating which banks are using the address, the total cost associated with the address, or detailed cost and usage information. This structure helps manage account usage and costs efficiently in a system that processes multiple transactions.


---
### fd\_pack\_addr\_use\_t
- **Type**: ``struct``
- **Members**:
    - ``key``: Account address.
    - ``_``: Union for different purposes: bitmask, total cost, or detailed cost tracking.
- **Description**: `fd_pack_addr_use_t` is a structure used to manage account usage in a transaction processing system. It serves three main purposes: tracking if an address is in use, recording the total cost of transactions writing to an account, and managing write costs for accounts referenced by transactions in a bundle. The structure combines these functionalities to reduce code duplication, as they share a similar shape.


---
### fd\_pack\_expq
- **Type**: ``struct``
- **Members**:
    - ``expires_at``: Stores the expiration time of the transaction.
    - ``txn``: Pointer to a `fd_pack_ord_txn_t` structure representing the transaction.
- **Description**: An element of a priority queue (`fd_prq`) used to sort transactions by their expiration time. The `fd_pack_expq` structure ensures that transactions are processed in order of their expiration, maintaining the invariant that `expires_at` matches the expiration time of the transaction pointed to by `txn`. This structure is part of a larger system that manages transaction scheduling and expiration in a blockchain or distributed ledger context.


---
### fd\_pack\_expq\_t
- **Type**: ``fd_pack_expq_t``
- **Members**:
    - `expires_at`: Stores the expiration time of the transaction.
    - `txn`: Points to the transaction (`fd_pack_ord_txn_t`) associated with this expiration queue element.
- **Description**: An element of an expiration priority queue (`fd_prq`) used to sort transactions by their expiration time. This structure maintains invariants for entries corresponding to pending transactions, ensuring that `expires_at` matches the transaction's expiration time and that the transaction's `exp_prq_idx` is the index of this structure. The priority queue is array-based, meaning the indexes of elements can change, and the `PRQ_TMP_ST` macro is used to keep the invariant up to date.


---
### fd\_pack\_bitset\_acct\_mapping
- **Type**: ``struct``
- **Members**:
    - ``key``: Account address.
    - ``ref_cnt``: Reference count of transactions referencing the account.
    - ``first_instance``: Pointer to the first transaction instance referencing the account.
    - ``first_instance_was_write``: Indicates if the first instance was a write operation.
    - ``bit``: Bit reserved to indicate the account in the bitset.
- **Description**: Maps an account address to the number of transactions referencing it and reserves a bit to indicate it in the bitset, optimizing for accounts referenced a single time.


---
### fd\_pack\_bitset\_acct\_mapping\_t
- **Type**: ``struct``
- **Members**:
    - ``key``: Account address.
    - ``ref_cnt``: Number of transactions referencing the account.
    - ``first_instance``: Pointer to the first transaction instance referencing the account.
    - ``first_instance_was_write``: Indicates if the first instance was a write operation.
    - ``bit``: Bit reserved to indicate the account in the bitset.
- **Description**: Maps an account address to the number of transactions referencing it and reserves a bit in the bitset to indicate the account, optimizing for accounts referenced a single time by not allocating a bit.


---
### noncemap\_extract\_t
- **Type**: ``struct``
- **Members**:
    - ``recent_blockhash``: A pointer to an unsigned character array representing the recent block hash.
    - ``nonce_acct``: A pointer to a `fd_acct_addr_t` structure representing the nonce account address.
    - ``nonce_auth``: A pointer to a `fd_acct_addr_t` structure representing the nonce authority address.
- **Description**: Holds information about a durable nonce transaction, including pointers to the recent block hash, nonce account, and nonce authority. This structure is used to map a tuple of these elements to a durable nonce transaction, ensuring that only one transaction with a given nonce account and recent block hash is in the pool at a time.


---
### fd\_pack\_smallest
- **Type**: ``struct``
- **Members**:
    - `cus`: Stores the smallest compute units (CUs) of a transaction in a treap.
    - `bytes`: Stores the smallest byte size of a transaction in a treap.
- **Description**: Tracks the smallest transaction in each treap by compute units and bytes, allowing the system to skip the heap if the remaining block space is less than the smallest transaction. This helps maintain a conservative estimate of the smallest transaction size, which is useful for efficient scheduling and resource management.


---
### fd\_pack\_smallest\_t
- **Type**: ``struct``
- **Members**:
    - `cus`: Stores the smallest transaction cost in compute units.
    - `bytes`: Stores the smallest transaction size in bytes.
- **Description**: Tracks the smallest transaction in each treap by both compute units and bytes, allowing the system to skip the heap if the remaining block space is insufficient for the smallest transaction. This structure helps maintain a conservative estimate of the smallest transaction, which is useful for optimizing transaction scheduling.


---
### fd\_pack\_penalty\_treap
- **Type**: ``struct``
- **Members**:
    - ``key``: Stores the account address associated with the penalty treap.
    - ``penalty_treap``: An array of one `treap_t` structure that holds transactions writing to the `key` account.
- **Description**: The `fd_pack_penalty_treap` structure represents a penalty treap for a specific account address. It is used to manage transactions that write to a hotly contested account, storing them in a separate treap until they can be moved to the main treap for scheduling. This helps manage contention and ensures that only the most lucrative transactions are moved to the main treap when the account becomes available.


---
### fd\_pack\_penalty\_treap\_t
- **Type**: ``struct``
- **Members**:
    - ``key``: Stores the account address associated with the penalty treap.
    - ``penalty_treap``: Holds a treap of transactions that write to the account specified by `key`.
- **Description**: Manages a penalty treap for a specific account address, where transactions that write to the account are stored. This structure is part of a dynamic map that associates account addresses with their respective penalty treaps, used to manage transactions that contend for hotly contested account addresses.


---
### fd\_pack\_private
- **Type**: ``struct``
- **Members**:
    - ``pack_depth``: Defines the depth of the pack.
    - ``bundle_meta_sz``: Specifies the size of the bundle metadata; if 0, bundles are disabled.
    - ``bank_tile_cnt``: Indicates the number of bank tiles.
    - ``lim``: An array of `fd_pack_limits_t` structures defining the limits for the pack.
    - ``pending_txn_cnt``: Counts the number of pending transactions across all treaps.
    - ``microblock_cnt``: Tracks the number of microblocks generated in the current block.
    - ``data_bytes_consumed``: Measures the amount of data consumed in the current block.
    - ``rng``: A pointer to a random number generator of type `fd_rng_t`.
    - ``cumulative_block_cost``: Accumulates the total cost of the block.
    - ``cumulative_vote_cost``: Accumulates the total cost of votes in the block.
    - ``expire_before``: Defines a threshold time before which transactions are considered expired.
    - ``outstanding_microblock_mask``: A bitmask indicating which banking tiles have outstanding microblocks.
    - ``pool``: A pointer to a pool of ordered transactions.
    - ``pending``: A treap of pending transactions sorted by priority.
    - ``pending_votes``: A treap of pending votes sorted by priority.
    - ``pending_bundles``: A treap of pending bundles sorted by priority.
    - ``penalty_treaps``: A pointer to a map of penalty treaps for hotly contended accounts.
    - ``initializer_bundle_state``: Indicates the current state of the initialization bundle state machine.
    - ``relative_bundle_idx``: Tracks the number of bundles inserted since the last empty pending_bundles.
    - ``pending_smallest``: Stores a conservative estimate of the smallest transaction in the pending treap.
    - ``pending_votes_smallest``: Stores a conservative estimate of the smallest transaction in the pending_votes treap.
    - ``expiration_q``: A pointer to a queue of transactions sorted by expiration time.
    - ``acct_in_use``: A map from account addresses to bitmasks indicating usage by bank tiles.
    - ``bitset_rw_in_use``: A bitset indicating accounts in use for read or write.
    - ``bitset_w_in_use``: A bitset indicating accounts in use for write only.
    - ``writer_costs``: A map from account addresses to the sum of costs of transactions writing to the account.
    - ``written_list``: A list of pointers to account use records that have been written to.
    - ``written_list_cnt``: Counts the number of elements in the written_list.
    - ``written_list_max``: Specifies the maximum number of elements in the written_list.
    - ``noncemap``: A map from nonce-related tuples to transactions.
    - ``signature_map``: Stores pointers into the pool for deleting transactions by signature.
    - ``bundle_temp_map``: A temporary map used during bundle scheduling to track account usage.
    - ``use_by_bank``: An array indicating account usage by bank tiles.
    - ``use_by_bank_cnt``: An array counting the number of accounts used by each bank tile.
    - ``use_by_bank_txn``: An array tracking transactions using accounts for each bank tile.
    - ``txn_per_microblock``: A histogram of transactions per microblock.
    - ``vote_per_microblock``: A histogram of votes per microblock.
    - ``scheduled_cus_per_block``: A histogram of scheduled compute units per block.
    - ``rebated_cus_per_block``: A histogram of rebated compute units per block.
    - ``net_cus_per_block``: A histogram of net compute units per block.
    - ``pct_cus_per_block``: A histogram of the percentage of compute units per block.
    - ``cumulative_rebated_cus``: Accumulates the total rebated compute units.
    - ``compressed_slot_number``: A number that advances each time a new slot is packed.
    - ``bitset_avail``: A stack of available bits for representing account addresses.
    - ``bitset_avail_cnt``: Counts the number of available bits in the bitset_avail stack.
    - ``acct_to_bitset``: A map from account addresses to bitset information.
    - ``chkdup``: Scratch memory for internal processing.
    - ``bundle_meta``: An array parallel to the pool for storing bundle metadata.
- **Description**: The `fd_pack_private` structure is a complex data structure used to manage and track transactions, bundles, and microblocks in a system. It maintains various treaps and maps to handle pending transactions, votes, and bundles, as well as penalty treaps for hotly contended accounts. The structure also includes mechanisms for tracking account usage, transaction expiration, and compute unit scheduling. It supports operations such as inserting, scheduling, and deleting transactions, and provides facilities for managing bundle metadata and handling initialization bundles. The structure is designed to efficiently manage resources and ensure the correct processing of transactions within specified limits.


---
### fd\_pack\_t
- **Type**: ``struct``
- **Members**:
    - `pack_depth`: Defines the depth of the pack.
    - `bundle_meta_sz`: Specifies the size of the bundle metadata.
    - `bank_tile_cnt`: Indicates the number of bank tiles.
    - `lim`: Holds the limits for the pack operations.
    - `pending_txn_cnt`: Tracks the number of pending transactions.
    - `microblock_cnt`: Counts the number of microblocks generated.
    - `data_bytes_consumed`: Records the amount of data consumed in the block.
    - `rng`: Points to the random number generator used.
    - `cumulative_block_cost`: Accumulates the total block cost.
    - `cumulative_vote_cost`: Accumulates the total vote cost.
    - `expire_before`: Sets the expiration threshold for transactions.
    - `outstanding_microblock_mask`: Indicates which banking tiles have outstanding microblocks.
    - `pool`: Points to the pool of ordered transactions.
    - `pending`: Treap of pending transactions sorted by priority.
    - `pending_votes`: Treap of pending votes sorted by priority.
    - `pending_bundles`: Treap of pending bundles sorted by priority.
    - `penalty_treaps`: Maps hotly contended accounts to penalty treaps.
    - `initializer_bundle_state`: Tracks the state of the initialization bundle.
    - `relative_bundle_idx`: Counts the number of bundles inserted since the last empty pending_bundles.
    - `pending_smallest`: Estimates the smallest transaction in the pending treap.
    - `pending_votes_smallest`: Estimates the smallest transaction in the pending votes treap.
    - `expiration_q`: Priority queue for transactions sorted by expiration time.
    - `acct_in_use`: Maps account addresses to their usage status.
    - `bitset_rw_in_use`: Bitset for accounts in use for read or write.
    - `bitset_w_in_use`: Bitset for accounts in use for write only.
    - `writer_costs`: Maps account addresses to the sum of costs of transactions that write to them.
    - `written_list`: Tracks used elements of the writer_costs map.
    - `written_list_cnt`: Counts the number of elements in the written_list.
    - `written_list_max`: Maximum size of the written_list.
    - `noncemap`: Maps nonce-related tuples to transactions.
    - `signature_map`: Stores pointers to transactions by signature for deletion.
    - `bundle_temp_map`: Temporary map for storing account usage in bundles.
    - `use_by_bank`: Tracks account usage by each bank tile.
    - `use_by_bank_cnt`: Counts the number of accounts used by each bank tile.
    - `use_by_bank_txn`: Tracks transactions using accounts for each bank tile.
    - `txn_per_microblock`: Histogram of transactions per microblock.
    - `vote_per_microblock`: Histogram of votes per microblock.
    - `scheduled_cus_per_block`: Histogram of scheduled compute units per block.
    - `rebated_cus_per_block`: Histogram of rebated compute units per block.
    - `net_cus_per_block`: Histogram of net compute units per block.
    - `pct_cus_per_block`: Histogram of percentage of compute units per block.
    - `cumulative_rebated_cus`: Accumulates the total rebated compute units.
    - `compressed_slot_number`: Tracks the compressed slot number for transaction skipping.
    - `bitset_avail`: Stack of available bits for account address representation.
    - `bitset_avail_cnt`: Counts the available bits in the bitset_avail stack.
    - `acct_to_bitset`: Maps account addresses to their bitset representation.
    - `chkdup`: Scratch memory for duplicate checking.
    - `bundle_meta`: Array for storing bundle metadata.
- **Description**: `fd_pack_t` is a complex data structure that manages the state and operations of a transaction pack. It includes various fields to track transaction limits, pending transactions, microblocks, and account usage. The structure uses treaps and maps to efficiently manage and prioritize transactions, handle penalties for hotly contested accounts, and maintain expiration queues. It also supports bundle operations and tracks various metrics related to transaction scheduling and execution. The structure is designed to handle concurrent operations across multiple bank tiles, ensuring efficient transaction processing and resource management.


---
### release\_result\_t
- **Type**: ``struct``
- **Members**:
    - ``clear_rw_bit``: A `ushort` that indicates which read-write bit to clear.
    - ``clear_w_bit``: A `ushort` that indicates which write bit to clear.
- **Description**: The `release_result_t` structure is used to store the results of releasing bit references in a bitset. It contains two members, `clear_rw_bit` and `clear_w_bit`, which specify the bits to clear in the read-write and write bitsets, respectively. This structure is typically used in functions that manage bitset operations, ensuring that the correct bits are cleared when a reference is released.


---
### sched\_return\_t
- **Type**: ``struct``
- **Members**:
    - ``cus_scheduled``: Stores the number of compute units scheduled.
    - ``txns_scheduled``: Stores the number of transactions scheduled.
    - ``bytes_scheduled``: Stores the number of bytes scheduled.
- **Description**: The `sched_return_t` structure is used to track scheduling metrics in a transaction scheduling system. It contains fields to record the number of compute units, transactions, and bytes that have been scheduled. This structure helps in monitoring and managing the resources allocated during the scheduling process.


# Functions

---
### noncemap\_extract<!-- {{#callable:noncemap_extract}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L302>)

Extracts the recent blockhash, nonce account, and nonce authority from a durable nonce transaction.
- **Inputs**:
    - ``k``: A pointer to a `fd_txn_e_t` structure representing a durable nonce transaction.
    - ``out``: A pointer to a `noncemap_extract_t` structure where the extracted data will be stored.
- **Logic and Control Flow**:
    - Retrieve the transaction pointer `txn` from the `k` structure using the `TXN` macro.
    - Extract the recent blockhash from the transaction using `fd_txn_get_recent_blockhash` and store it in `out->recent_blockhash`.
    - Calculate the indices `nonce_idx` and `autho_idx` from the transaction's payload to identify the nonce account and nonce authority.
    - Determine the number of immediate accounts `imm_cnt` using `fd_txn_account_cnt`.
    - Retrieve the account addresses using `fd_txn_get_acct_addrs` and adjust for alternate accounts using `alt_adj`.
    - Set `out->nonce_acct` to the address of the nonce account, using `fd_ptr_if` to choose between immediate and alternate accounts.
    - Set `out->nonce_auth` to the address of the nonce authority, which must be an immediate account.
- **Output**: The function does not return a value; it populates the `noncemap_extract_t` structure pointed to by `out` with the extracted data.


---
### noncemap\_key\_eq\_internal<!-- {{#callable:noncemap_key_eq_internal}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L320>)

Compares two `fd_txn_e_t` keys to determine if they are equal based on their extracted nonce-related fields.
- **Inputs**:
    - `k0`: A pointer to the first `fd_txn_e_t` key to compare.
    - `k1`: A pointer to the second `fd_txn_e_t` key to compare.
- **Logic and Control Flow**:
    - Extracts nonce-related fields from `k0` into `e0` using [`noncemap_extract`](<#noncemap_extract>) function.
    - Extracts nonce-related fields from `k1` into `e1` using [`noncemap_extract`](<#noncemap_extract>) function.
    - Compares the `recent_blockhash` fields of `e0` and `e1` using `memcmp`; returns 0 if they differ.
    - Compares the `nonce_acct` fields of `e0` and `e1` using `memcmp`; returns 0 if they differ.
    - Compares the `nonce_auth` fields of `e0` and `e1` using `memcmp`; returns 0 if they differ.
    - Returns 1 if all compared fields are equal.
- **Output**: Returns 1 if the keys are equal, otherwise returns 0.
- **Functions Called**:
    - [`noncemap_extract`](<#noncemap_extract>)


---
### noncemap\_key\_hash\_internal<!-- {{#callable:noncemap_key_hash_internal}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L333>)

Computes a hash value for a given transaction key using a seed and specific fields extracted from the transaction.
- **Inputs**:
    - ``seed``: An unsigned long integer used as the initial value for the hash computation.
    - ``k``: A pointer to a `fd_txn_e_t` structure representing the transaction key to be hashed.
- **Logic and Control Flow**:
    - Extracts specific fields (`recent_blockhash`, `nonce_acct`, `nonce_auth`) from the transaction key `k` using the [`noncemap_extract`](<#noncemap_extract>) function.
    - Computes three separate hash values using the `fd_hash` function with the `seed` and each extracted field, each with a different offset added to the `seed`.
    - Combines the three hash values using the XOR operation to produce the final hash value.
- **Output**: Returns an unsigned long integer representing the combined hash value of the transaction key.
- **Functions Called**:
    - [`noncemap_extract`](<#noncemap_extract>)


---
### fd\_pack\_footprint<!-- {{#callable:fd_pack_footprint}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L682>)

Calculates the memory footprint required for a pack structure based on various parameters.
- **Inputs**:
    - `pack_depth`: The depth of the pack, representing the maximum number of transactions that can be processed.
    - `bundle_meta_sz`: The size of the metadata associated with each bundle; if zero, bundles are disabled.
    - `bank_tile_cnt`: The number of bank tiles; must be between 1 and `FD_PACK_MAX_BANK_TILES`.
    - `limits`: A pointer to a `fd_pack_limits_t` structure containing various limits for the pack.
- **Logic and Control Flow**:
    - Checks if `bank_tile_cnt` is zero or exceeds `FD_PACK_MAX_BANK_TILES`, returning 0 if true.
    - Checks if `pack_depth` is less than 4, returning 0 if true.
    - Determines if bundles are enabled based on `bundle_meta_sz`.
    - Calculates `extra_depth` based on whether bundles are enabled.
    - Calculates various maximums such as `max_acct_in_treap`, `max_txn_per_mblk`, `max_acct_in_flight`, and `max_txn_in_flight`.
    - Calculates `max_w_per_block` and `written_list_max` based on limits and maximums.
    - Estimates chain counts for signatures and nonces.
    - Calculates log sizes for various tables to ensure they remain sparse.
    - Initializes layout `l` and appends various components to it, calculating their footprints.
    - Returns the final calculated footprint using `FD_LAYOUT_FINI`.
- **Output**: Returns the calculated memory footprint as an unsigned long integer.


---
### fd\_pack\_new<!-- {{#callable:fd_pack_new}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L731>)

Initializes a new `fd_pack_t` structure in the provided memory space with specified parameters for transaction packing.
- **Inputs**:
    - `mem`: Pointer to the memory space where the `fd_pack_t` structure will be initialized.
    - `pack_depth`: The depth of the pack, determining the maximum number of transactions that can be handled.
    - `bundle_meta_sz`: Size of the metadata for each bundle; if zero, bundles are disabled.
    - `bank_tile_cnt`: Number of bank tiles available for transaction processing.
    - `limits`: Pointer to a `fd_pack_limits_t` structure containing various limits for transaction processing.
    - `rng`: Pointer to a random number generator used for seeding and other random operations.
- **Logic and Control Flow**:
    - Determine if bundles are enabled based on `bundle_meta_sz` and calculate `extra_depth` accordingly.
    - Calculate various maximums such as `max_acct_in_treap`, `max_txn_per_mblk`, `max_acct_in_flight`, and `max_txn_in_flight` based on input parameters.
    - Initialize memory allocations for various components like pools, maps, and lists using `FD_SCRATCH_ALLOC_APPEND`.
    - Set initial values for the `fd_pack_t` structure fields, including counters and limits.
    - Initialize data structures such as pools, maps, and treaps using functions like `trp_pool_new`, `penalty_map_new`, and `treap_new`.
    - Set up histograms for tracking transaction and vote counts per microblock.
    - Return the pointer to the initialized memory space.
- **Output**: Returns a pointer to the initialized memory space containing the `fd_pack_t` structure.
- **Functions Called**:
    - [`fd_chkdup_new`](<fd_chkdup.h.md#fd_chkdup_new>)


---
### fd\_pack\_join<!-- {{#callable:fd_pack_join}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L875>)

Initializes and joins various data structures for a `fd_pack_t` object using the provided memory.
- **Inputs**:
    - `mem`: A pointer to the memory location where the `fd_pack_t` object and its associated data structures will be initialized and joined.
- **Logic and Control Flow**:
    - Initialize a scratch allocator with the provided memory `mem`.
    - Allocate and join a `fd_pack_t` object from the scratch allocator.
    - Determine if bundles are enabled based on the `bundle_meta_sz` field of the `fd_pack_t` object.
    - Calculate various parameters such as `pack_depth`, `extra_depth`, `bank_tile_cnt`, and `max_txn_per_microblock` based on the `fd_pack_t` object fields and constants.
    - Join various data structures such as `trp_pool`, `penalty_map`, `expq`, `acct_uses`, `noncemap`, `sig2txn`, `bitset_map`, and others using the scratch allocator and calculated parameters.
    - Set the `PENDING_TRANSACTIONS_HEAP_SIZE` metric to the `pack_depth` of the `fd_pack_t` object.
    - Return the joined `fd_pack_t` object.
- **Output**: A pointer to the joined `fd_pack_t` object.


---
### fd\_pack\_estimate\_rewards\_and\_compute<!-- {{#callable:fd_pack_estimate_rewards_and_compute}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L925>)

Estimates rewards and computes execution costs for a transaction, updating the output structure with these values.
- **Inputs**:
    - ``txne``: A pointer to an `fd_txn_e_t` structure representing the transaction to process.
    - ``out``: A pointer to an `fd_pack_ord_txn_t` structure where the function will store the computed rewards and execution estimates.
- **Logic and Control Flow**:
    - Retrieve the transaction from the `txne` pointer using the `TXN` macro.
    - Calculate the initial signature rewards based on the number of signatures in the transaction.
    - Call [`fd_pack_compute_cost`](<fd_pack_cost.h.md#fd_pack_compute_cost>) to estimate the transaction's execution cost and retrieve additional cost-related metrics.
    - If the cost estimate is zero, return 0 to indicate failure.
    - Adjust the signature rewards by adding precompile signature fees and applying a burn percentage.
    - Calculate the total rewards by adding priority rewards to the adjusted signature rewards, ensuring it does not exceed `UINT_MAX`.
    - Store the computed rewards and cost estimates in the `out` structure.
    - Determine if the transaction is a simple vote and return 1 if true, otherwise return 2.
- **Output**: Returns 0 on failure, 1 if the transaction is a simple vote, and 2 otherwise.
- **Functions Called**:
    - [`fd_pack_compute_cost`](<fd_pack_cost.h.md#fd_pack_compute_cost>)


---
### fd\_pack\_validate\_durable\_nonce<!-- {{#callable:fd_pack_validate_durable_nonce}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L962>)

Validates a transaction to ensure it is a durable nonce transaction with specific conditions.
- **Inputs**:
    - ``txne``: A pointer to a `fd_txn_e_t` structure representing the transaction to validate.
- **Logic and Control Flow**:
    - Retrieve the transaction from the `txne` pointer using the `TXN` macro.
    - Check if the transaction has at least one instruction; if not, return 1.
    - Verify that the first instruction has at least 4 bytes of data; if not, return 1.
    - Ensure the first instruction has at least 3 accounts; if not, return 1.
    - Check if the first 4 bytes of instruction data equal 4 in little-endian format; if not, return 1.
    - Retrieve the account addresses using `fd_txn_get_acct_addrs`.
    - Verify that the program ID of the first instruction matches a static account (`null_addr`); if not, return 1.
    - Check if the nonce authority is a signer; if not, return 0.
    - Return 2 if all checks pass, indicating a valid durable nonce transaction.
- **Output**: Returns 0 if the nonce authority is not a signer, 1 if the transaction is not a valid durable nonce transaction, and 2 if it is valid.


---
### fd\_pack\_can\_fee\_payer\_afford<!-- {{#callable:fd_pack_can_fee_payer_afford}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L992>)

Determines if a fee payer can afford a transaction with a given price, always returning 1.
- **Inputs**:
    - ``acct_addr``: A pointer to a constant `fd_acct_addr_t` structure representing the account address of the fee payer.
    - ``price``: An unsigned long integer representing the price of the transaction in lamports.
- **Logic and Control Flow**:
    - The function takes two parameters: `acct_addr` and `price`, but does not use them in its logic.
    - It casts the parameters to void to avoid compiler warnings about unused variables.
    - The function returns the integer 1, indicating that the fee payer can always afford the transaction.
- **Output**: An integer value of 1, indicating that the fee payer can afford the transaction.


---
### fd\_pack\_insert\_txn\_init<!-- {{#callable:fd_pack_insert_txn_init}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1004>)

Acquires a transaction element from the transaction pool associated with the given pack.
- **Inputs**:
    - `pack`: A pointer to an `fd_pack_t` structure, which contains the transaction pool from which a transaction element is to be acquired.
- **Logic and Control Flow**:
    - Calls `trp_pool_ele_acquire` with `pack->pool` to acquire a transaction element from the pool.
    - Returns the `txn_e` member of the acquired transaction element.
- **Output**: A pointer to an `fd_txn_e_t` structure, representing the acquired transaction element.


---
### fd\_pack\_insert\_txn\_cancel<!-- {{#callable:fd_pack_insert_txn_cancel}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1005>)

Releases a transaction element back to the pool in the `fd_pack_t` structure.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure that manages the transaction pool.
    - ``txn``: A pointer to the `fd_txn_e_t` transaction element to be released back to the pool.
- **Logic and Control Flow**:
    - Calls `trp_pool_ele_release` to release the transaction element `txn` back to the pool managed by `pack->pool`.
- **Output**: No return value.


---
### delete\_worst<!-- {{#callable:delete_worst}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1030>)

Deletes the worst transaction from a transaction pool if its score is below a given threshold.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure representing the transaction pool.
    - ``threshold_score``: A float representing the score threshold below which a transaction is considered for deletion.
    - ``is_vote``: An integer indicating whether the transaction is a vote (non-zero) or not (zero).
- **Logic and Control Flow**:
    - Initialize `worst_score` to `FLT_MAX` and `worst` to `NULL`.
    - Iterate 8 times to sample transactions from the pool.
    - For each sample, check if it is free; if so, find the next non-free transaction.
    - Determine the type of transaction (pending, vote, bundle, or penalty) and set a multiplier based on its type and conditions.
    - Calculate the score of the transaction using the multiplier and compare it to the current `worst_score`.
    - Update `worst` and `worst_score` if the current transaction has a lower score.
    - After sampling, check if `worst` is `NULL` or if `threshold_score` is less than `worst_score`; if so, return 0.
    - If a worst transaction is found, call [`delete_transaction`](<#delete_transaction>) to delete it and return the result.
- **Output**: Returns the number of transactions deleted, or 0 if no transaction was deleted.
- **Functions Called**:
    - [`delete_transaction`](<#delete_transaction>)


---
### validate\_transaction<!-- {{#callable:validate_transaction}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1159>)

Validates a transaction against various criteria to determine if it should be rejected or accepted.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure, which contains the transaction pool and related data.
    - ``ord``: A constant pointer to an `fd_pack_ord_txn_t` structure, representing the ordered transaction to validate.
    - ``txn``: A constant pointer to an `fd_txn_t` structure, representing the transaction to validate.
    - ``accts``: A constant pointer to an `fd_acct_addr_t` structure, representing the account addresses involved in the transaction.
    - ``alt_adj``: A constant pointer to an `fd_acct_addr_t` structure, representing adjusted alternate account addresses.
    - ``check_bundle_blacklist``: An integer flag indicating whether to check the transaction against a bundle blacklist.
- **Logic and Control Flow**:
    - Initialize `writes_to_sysvar` to 0 and iterate over writable accounts in `txn` to check if any are unwritable system variables, updating `writes_to_sysvar` accordingly.
    - If `check_bundle_blacklist` is true, initialize `bundle_blacklist` to 0 and iterate over all accounts in `txn` to check if any violate bundle rules, updating `bundle_blacklist` accordingly.
    - Retrieve alternate accounts and duplicate check structure from `ord` and `pack`, respectively.
    - Check if the fee payer can afford the transaction using [`fd_pack_can_fee_payer_afford`](<#fd_pack_can_fee_payer_afford>); if not, return `FD_PACK_INSERT_REJECT_UNAFFORDABLE`.
    - Check if the transaction's compute estimate exceeds the maximum allowed per block; if so, return `FD_PACK_INSERT_REJECT_TOO_LARGE`.
    - Check if the transaction loads too many accounts; if so, return `FD_PACK_INSERT_REJECT_ACCOUNT_CNT`.
    - Check for duplicate account addresses using [`fd_chkdup_check`](<fd_chkdup.h.md#fd_chkdup_check>); if duplicates exist, return `FD_PACK_INSERT_REJECT_DUPLICATE_ACCT`.
    - Check if the transaction attempts to write to a system variable; if so, return `FD_PACK_INSERT_REJECT_WRITES_SYSVAR`.
    - Check if the transaction uses an account that violates bundle rules; if so, return `FD_PACK_INSERT_REJECT_BUNDLE_BLACKLIST`.
    - If none of the above conditions are met, return 0, indicating the transaction is valid.
- **Output**: Returns an integer indicating the validation result: 0 for valid, or a specific rejection code for invalid transactions.
- **Functions Called**:
    - [`fd_pack_tip_prog_check_blacklist`](<fd_pack_tip_prog_blacklist.h.md#fd_pack_tip_prog_check_blacklist>)
    - [`fd_pack_can_fee_payer_afford`](<#fd_pack_can_fee_payer_afford>)
    - [`fd_chkdup_check`](<fd_chkdup.h.md#fd_chkdup_check>)


---
### populate\_bitsets<!-- {{#callable:populate_bitsets}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1207>)

Populates read-write and write bitsets for a transaction and calculates penalties for account references.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure, which contains the state and data structures for managing transactions.
    - ``ord``: A pointer to an `fd_pack_ord_txn_t` structure, representing the ordered transaction to process.
    - ``penalties``: An array of `ushort` with a size of `FD_TXN_ACCT_ADDR_MAX`, used to store penalty values for account references.
    - ``penalty_idx``: An array of `uchar` with a size of `FD_TXN_ACCT_ADDR_MAX`, used to store indices of accounts that incur penalties.
- **Logic and Control Flow**:
    - Clears the read-write and write bitsets of the transaction in `ord`.
    - Retrieves the transaction and payload from `ord` and gets account addresses.
    - Iterates over writable accounts, querying or inserting them into the bitset map, updating reference counts, and setting bits in the bitsets.
    - Calculates penalties for accounts with reference counts exceeding `PENALTY_TREAP_THRESHOLD` and updates `penalties` and `penalty_idx`.
    - Iterates over readonly accounts, querying or inserting them into the bitset map, updating reference counts, and setting bits in the read-write bitset.
    - Returns the cumulative penalty calculated from the penalties array.
- **Output**: Returns an `ulong` representing the cumulative penalty for the transaction's account references.


---
### fd\_pack\_insert\_txn\_fini<!-- {{#callable:fd_pack_insert_txn_fini}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1284>)

Finalizes the insertion of a transaction into a transaction pack, handling validation, replacement, and insertion logic.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure representing the transaction pack.
    - ``txne``: A pointer to the `fd_txn_e_t` structure representing the transaction to be inserted.
    - ``expires_at``: An unsigned long integer indicating the expiration time of the transaction.
    - ``delete_cnt``: A pointer to an unsigned long integer where the function will store the count of deleted transactions.
- **Logic and Control Flow**:
    - Cast `txne` to `fd_pack_ord_txn_t` and retrieve the transaction and payload pointers.
    - Retrieve account addresses and adjust the ALT expansion pointer.
    - Set the expiration time for the transaction order.
    - Estimate rewards and compute costs using [`fd_pack_estimate_rewards_and_compute`](<#fd_pack_estimate_rewards_and_compute>); reject if estimation fails.
    - Validate the transaction's durable nonce using [`fd_pack_validate_durable_nonce`](<#fd_pack_validate_durable_nonce>); reject if invalid.
    - Validate the transaction using [`validate_transaction`](<#validate_transaction>); reject if validation fails.
    - Check if the transaction has already expired; reject if expired.
    - Initialize `replaces` and `delete_cnt` to zero.
    - If the transaction is a durable nonce, check for duplicates in the noncemap and handle replacements.
    - If the pack is full, delete the worst transaction if the new transaction has a better score; reject if no transaction is deleted.
    - Clear bundle flags and set the skip count for the transaction order.
    - Populate bitsets for account references and determine the appropriate treap for insertion.
    - Insert the transaction into the appropriate treap and update the pending transaction count.
    - Insert the transaction into the signature map and noncemap if applicable.
    - Insert the transaction into the expiration queue.
    - Return a bitwise combination of flags indicating if the transaction is a vote, replaces another transaction, or is a durable nonce.
- **Output**: Returns an integer indicating the status of the insertion, with flags for vote, replacement, and durable nonce status.
- **Functions Called**:
    - [`fd_pack_estimate_rewards_and_compute`](<#fd_pack_estimate_rewards_and_compute>)
    - [`fd_pack_validate_durable_nonce`](<#fd_pack_validate_durable_nonce>)
    - [`validate_transaction`](<#validate_transaction>)
    - [`delete_transaction`](<#delete_transaction>)
    - [`delete_worst`](<#delete_worst>)
    - [`populate_bitsets`](<#populate_bitsets>)


---
### fd\_pack\_insert\_bundle\_init<!-- {{#callable:fd_pack_insert_bundle_init}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1401>)

Initializes a bundle of transactions in a transaction pool for a given pack.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure representing the transaction pack.
    - ``bundle``: A pointer to an array of `fd_txn_e_t` pointers where the initialized transactions will be stored.
    - ``txn_cnt``: The number of transactions to initialize in the bundle.
- **Logic and Control Flow**:
    - Checks if `txn_cnt` is less than or equal to `FD_PACK_MAX_TXN_PER_BUNDLE`.
    - Checks if the number of free elements in the transaction pool is greater than or equal to `txn_cnt`.
    - Iterates over the range from 0 to `txn_cnt`, acquiring a transaction element from the pool for each index and storing it in the `bundle` array.
- **Output**: Returns a pointer to the `bundle` array containing initialized transaction elements.


---
### fd\_pack\_insert\_bundle\_cancel<!-- {{#callable:fd_pack_insert_bundle_cancel}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1411>)

Releases a specified number of transaction elements from a bundle in reverse order.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure, representing the pack from which the bundle elements will be released.
    - ``bundle``: A constant pointer to an array of `fd_txn_e_t` pointers, representing the bundle of transactions to be released.
    - ``txn_cnt``: An unsigned long integer representing the number of transactions in the bundle to be released.
- **Logic and Control Flow**:
    - Iterates over the number of transactions specified by `txn_cnt` in reverse order.
    - For each transaction, calls `trp_pool_ele_release` to release the transaction element from the pool associated with `pack`.
- **Output**: This function does not return a value.


---
### fd\_pack\_insert\_bundle\_fini<!-- {{#callable:fd_pack_insert_bundle_fini}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1426>)

Inserts a bundle of transactions into a pack, ensuring they meet certain conditions and updating the pack's state accordingly.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure representing the pack where the bundle will be inserted.
    - ``bundle``: A pointer to an array of pointers to `fd_txn_e_t` structures, representing the transactions in the bundle.
    - ``txn_cnt``: The number of transactions in the bundle.
    - ``expires_at``: The expiration time for the transactions in the bundle.
    - ``initializer_bundle``: An integer flag indicating if the bundle is an initializer bundle.
    - ``bundle_meta``: A pointer to additional metadata associated with the bundle.
    - ``delete_cnt``: A pointer to a `ulong` where the function will store the number of transactions deleted during the insertion process.
- **Logic and Control Flow**:
    - Initialize error status and set `delete_cnt` to zero.
    - Check if the bundle can be inserted based on the current number of pending bundles and expiration time.
    - Iterate over each transaction in the bundle to validate and compute rewards, checking for durable nonces and updating flags.
    - If any transaction fails validation, cancel the bundle insertion and return the error code.
    - If the bundle is an initializer and there are existing pending bundles, delete the previous initializer bundle if necessary.
    - Ensure the pack has enough space by deleting the worst transactions if needed.
    - If the bundle metadata is provided, copy it to the pack's metadata storage.
    - Check for duplicate nonces within the bundle and cancel the insertion if conflicts are detected.
    - Insert the bundle into the pack's treap, updating the relative bundle index and pack state.
- **Output**: Returns an integer indicating success or a specific error code if the insertion fails.
- **Functions Called**:
    - [`fd_pack_estimate_rewards_and_compute`](<#fd_pack_estimate_rewards_and_compute>)
    - [`fd_pack_validate_durable_nonce`](<#fd_pack_validate_durable_nonce>)
    - [`delete_transaction`](<#delete_transaction>)
    - [`validate_transaction`](<#validate_transaction>)
    - [`fd_pack_insert_bundle_cancel`](<#fd_pack_insert_bundle_cancel>)
    - [`delete_worst`](<#delete_worst>)
    - [`insert_bundle_impl`](<#insert_bundle_impl>)


---
### insert\_bundle\_impl<!-- {{#callable:insert_bundle_impl}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1675>)

Inserts a bundle of transactions into the pending bundles treap, updating their rewards and managing their expiration and nonce status.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure that manages the transaction pool and related data structures.
    - ``bundle_idx``: An unsigned long integer representing the index of the bundle being inserted, used to calculate rewards.
    - ``txn_cnt``: An unsigned long integer indicating the number of transactions in the bundle.
    - ``bundle``: A pointer to an array of `fd_pack_ord_txn_t` pointers, representing the transactions in the bundle.
    - ``expires_at``: An unsigned long integer specifying the expiration time for the transactions in the bundle.
- **Logic and Control Flow**:
    - Calculate `prev_reward` based on `bundle_idx` to determine the initial reward for the last transaction in the bundle.
    - Initialize `prev_cost` to a large constant value (1UL<<32).
    - Iterate over the transactions in the bundle from last to first.
    - For each transaction, calculate its `rewards` based on `prev_reward` and `prev_cost`, and update `prev_reward` and `prev_cost` with the current transaction's values.
    - Set the `root` of each transaction to `FD_ORD_TXN_ROOT_PENDING_BUNDLE`.
    - Call [`populate_bitsets`](<#populate_bitsets>) to update bitsets for the transaction, though penalty information is not used for bundles.
    - Insert each transaction into the `pending_bundles` treap and increment the `pending_txn_cnt`.
    - If a transaction has the `FD_TXN_P_FLAGS_DURABLE_NONCE` flag, insert it into the `noncemap`.
    - Insert each transaction into the `signature_map`.
    - Create a temporary `fd_pack_expq_t` structure for each transaction and insert it into the `expiration_q`.
- **Output**: No return value; the function modifies the state of the `pack` structure and its associated data structures.
- **Functions Called**:
    - [`populate_bitsets`](<#populate_bitsets>)


---
### fd\_pack\_peek\_bundle\_meta<!-- {{#callable:fd_pack_peek_bundle_meta}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1709>)

Returns metadata of the most recent non-initializer bundle if available.
- **Inputs**:
    - ``pack``: A pointer to a constant `fd_pack_t` structure representing the pack from which to retrieve the bundle metadata.
- **Logic and Control Flow**:
    - Retrieve the `initializer_bundle_state` from the `pack` structure.
    - Check if the `initializer_bundle_state` is `FD_PACK_IB_STATE_PENDING` or `FD_PACK_IB_STATE_FAILED`; if so, return `NULL`.
    - Initialize a reverse iterator for the `pending_bundles` treap in the `pack`.
    - Check if the iterator indicates the treap is empty; if so, return `NULL`.
    - Retrieve the current element from the iterator, which is a `fd_pack_ord_txn_t` structure.
    - Check if the transaction has the `FD_TXN_P_FLAGS_INITIALIZER_BUNDLE` flag set; if so, return `NULL`.
    - Calculate the address of the bundle metadata using the `bundle_meta` pointer, the current iterator index, and the `bundle_meta_sz` size.
    - Return the calculated address as a `void const *`.
- **Output**: A pointer to the metadata of the most recent non-initializer bundle, or `NULL` if no such bundle is available.


---
### fd\_pack\_set\_initializer\_bundles\_ready<!-- {{#callable:fd_pack_set_initializer_bundles_ready}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1724>)

Sets the `initializer_bundle_state` of the `fd_pack_t` structure to `FD_PACK_IB_STATE_READY`.
- **Inputs**:
    - `pack`: A pointer to an `fd_pack_t` structure, which represents the pack data structure whose initializer bundle state is to be updated.
- **Logic and Control Flow**:
    - Access the `initializer_bundle_state` field of the `fd_pack_t` structure pointed to by `pack`.
    - Set the `initializer_bundle_state` field to `FD_PACK_IB_STATE_READY`.
- **Output**: No output is returned as the function is of type `void`.


---
### fd\_pack\_metrics\_write<!-- {{#callable:fd_pack_metrics_write}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1729>)

Writes various metrics related to pending transactions in a `fd_pack_t` structure to a monitoring system.
- **Inputs**:
    - ``pack``: A pointer to a `fd_pack_t` structure containing transaction data and metrics to be written.
- **Logic and Control Flow**:
    - Calculate the number of regular pending transactions using `treap_ele_cnt` on `pack->pending`.
    - Calculate the number of pending votes using `treap_ele_cnt` on `pack->pending_votes`.
    - Calculate the number of pending bundles using `treap_ele_cnt` on `pack->pending_bundles`.
    - Calculate the number of conflicting transactions by subtracting the sum of pending votes, pending bundles, and regular pending transactions from `pack->pending_txn_cnt`.
    - Write the total number of available transactions to the metric `AVAILABLE_TRANSACTIONS_ALL`.
    - Write the number of available regular transactions to the metric `AVAILABLE_TRANSACTIONS_REGULAR`.
    - Write the number of available vote transactions to the metric `AVAILABLE_TRANSACTIONS_VOTES`.
    - Write the number of conflicting transactions to the metric `AVAILABLE_TRANSACTIONS_CONFLICTING`.
    - Write the number of available bundle transactions to the metric `AVAILABLE_TRANSACTIONS_BUNDLES`.
    - Write the smallest pending transaction cost units to the metric `SMALLEST_PENDING_TRANSACTION`.
- **Output**: No return value; the function writes metrics to a monitoring system.


---
### release\_bit\_reference<!-- {{#callable:release_bit_reference}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L1748>)

Decrements the reference count for a specific account in a bitset mapping and potentially releases the bit if the reference count reaches zero.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure, which contains the bitset and account mappings.
    - ``acct``: A constant pointer to an `fd_acct_addr_t` structure representing the account address whose reference count is to be decremented.
- **Logic and Control Flow**:
    - Queries the bitset map for the account address to get the corresponding mapping structure `q`.
    - Asserts that `q` is not NULL, as it should not be possible for it to be NULL.
    - Decrements the reference count `q->ref_cnt` for the account.
    - Checks if the reference count has reached zero.
    - If the reference count is zero, retrieves the bit associated with the account and removes the mapping from the bitset map.
    - If the bit is valid (less than `FD_PACK_BITSET_MAX`), adds it back to the available bits stack.
    - Queries the account usage map to check if the account is in use.
    - If the account is in use, updates the usage bitmask to indicate the bit has been cleared and determines if the account was writable, setting the appropriate return values.
- **Output**: Returns a `release_result_t` structure containing the bits to clear for read-write and write-only access, or `FD_PACK_BITSET_MAX` if no bits need clearing.


---
### fd\_pack\_microblock\_complete<!-- {{#callable:fd_pack_microblock_complete}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2092>)

Clears the writable bit for accounts used by a specific banking tile and updates the state of transactions and penalty treaps accordingly.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure representing the current state of the pack.
    - ``bank_tile``: An unsigned long integer representing the index of the banking tile whose microblock is being completed.
- **Logic and Control Flow**:
    - Calculate `clear_mask` to clear the writable bit for the specified banking tile.
    - Check if there are any outstanding microblocks for the specified banking tile; if not, return 0.
    - Copy the current state of `bitset_rw_in_use` and `bitset_w_in_use` to local variables.
    - Iterate over the accounts used by the specified banking tile.
    - For each account, clear the banking tile's bit from `in_use_by` and check if the account is no longer in use.
    - If the account is no longer in use, clear its bit from the bitsets and check for penalty treaps.
    - If a penalty treap exists, move the best transaction from the penalty treap to the main treap.
    - Update the `use_by_bank_cnt` for the specified banking tile and copy the updated bitsets back to the pack.
    - Clear the banking tile's bit from `outstanding_microblock_mask` and return 1.
- **Output**: Returns 1 if the microblock completion was processed, or 0 if there was nothing outstanding for the specified banking tile.


---
### fd\_pack\_try\_schedule\_bundle<!-- {{#callable:fd_pack_try_schedule_bundle}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2209>)

Attempts to schedule a transaction bundle from the pending bundles treap to a specified bank tile, ensuring it fits within resource limits and does not conflict with other transactions.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure representing the current state of the transaction pack.
    - ``bank_tile``: An unsigned long integer representing the bank tile to which the bundle should be scheduled.
    - ``out``: A pointer to an `fd_txn_p_t` structure where the scheduled transactions will be stored.
- **Logic and Control Flow**:
    - Initialize `state` with the current initializer bundle state from `pack`.
    - Check if the initializer bundle state is pending or failed; if so, return `TRY_BUNDLE_NO_READY_BUNDLES`.
    - Initialize `pool` and `bundles` with the transaction pool and pending bundles treap from `pack`.
    - Determine if an initializer bundle is required based on the current state.
    - Initialize a reverse iterator `_cur` for the `bundles` treap.
    - Check if the iterator is done; if so, return `TRY_BUNDLE_NO_READY_BUNDLES`.
    - Retrieve the first transaction and check if it is an initializer bundle; if required but not present, return `TRY_BUNDLE_NO_READY_BUNDLES`.
    - Initialize temporary storage for account usage and limits for compute units, bytes, and microblocks.
    - Iterate over transactions in the bundle, checking if they fit within limits and do not conflict with other transactions.
    - If a transaction does not fit or has conflicts, break the loop and return the appropriate error code.
    - If the bundle is valid, update the `outstanding_microblock_mask` and prepare the transactions for scheduling.
    - Copy transaction data to the `out` structure and update resource consumption metrics.
    - Remove scheduled transactions from the treap and update the pool and maps accordingly.
    - If the scheduled bundle is an initializer bundle, update the initializer bundle state to pending.
    - Return the number of transactions scheduled if successful, or an error code if not.
- **Output**: Returns an integer indicating the result of the scheduling attempt: the number of transactions scheduled if successful, or an error code if no ready bundles, conflicts, or size issues are encountered.
- **Functions Called**:
    - [`release_bit_reference`](<#release_bit_reference>)


---
### fd\_pack\_schedule\_next\_microblock<!-- {{#callable:fd_pack_schedule_next_microblock}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2477>)

Schedules the next microblock of transactions based on available compute units, vote fraction, and scheduling flags.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure that contains the current state and limits for transaction scheduling.
    - ``total_cus``: The total compute units available for scheduling in this microblock.
    - ``vote_fraction``: The fraction of compute units reserved for vote transactions.
    - ``bank_tile``: The index of the bank tile to which the microblock is being scheduled.
    - ``schedule_flags``: Flags indicating which types of transactions to schedule (e.g., votes, bundles, regular transactions).
    - ``out``: A pointer to an array of `fd_txn_p_t` structures where the scheduled transactions will be stored.
- **Logic and Control Flow**:
    - Calculate the maximum compute units (`total_cus`) and vote compute units (`vote_cus`) based on the limits and vote fraction.
    - Check if the microblock count or data bytes consumed exceed their respective limits; if so, return 0.
    - Initialize limits for compute units, transactions, and bytes for non-vote transactions.
    - If `FD_PACK_SCHEDULE_VOTE` flag is set, schedule vote transactions and update limits based on scheduled votes.
    - If `FD_PACK_SCHEDULE_BUNDLE` flag is set and no votes were scheduled, attempt to schedule a bundle; return early if successful or conflicts occur.
    - If `FD_PACK_SCHEDULE_TXN` flag is set, schedule regular transactions with the remaining limits.
    - Update the microblock count, outstanding microblock mask, and data bytes consumed if any transactions were scheduled.
    - Update metrics and return the number of transactions scheduled.
- **Output**: Returns the number of transactions successfully scheduled in the microblock.
- **Functions Called**:
    - [`fd_pack_try_schedule_bundle`](<#fd_pack_try_schedule_bundle>)
    - [`fd_pack_metrics_write`](<#fd_pack_metrics_write>)


---
### fd\_pack\_bank\_tile\_cnt<!-- {{#callable:fd_pack_bank_tile_cnt}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2568>)

Retrieves the `bank_tile_cnt` field from a `fd_pack_t` structure.
- **Inputs**:
    - `pack`: A pointer to a constant `fd_pack_t` structure from which the `bank_tile_cnt` field is retrieved.
- **Logic and Control Flow**:
    - Access the `bank_tile_cnt` field of the `fd_pack_t` structure pointed to by `pack`.
- **Output**: Returns the value of the `bank_tile_cnt` field as an unsigned long integer.


---
### fd\_pack\_current\_block\_cost<!-- {{#callable:fd_pack_current_block_cost}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2569>)

Returns the cumulative block cost from the given `fd_pack_t` structure.
- **Inputs**:
    - `pack`: A pointer to a constant `fd_pack_t` structure from which the cumulative block cost is retrieved.
- **Logic and Control Flow**:
    - Access the `cumulative_block_cost` field of the `fd_pack_t` structure pointed to by `pack`.
    - Return the value of `cumulative_block_cost`.
- **Output**: An unsigned long integer representing the cumulative block cost.


---
### fd\_pack\_set\_block\_limits<!-- {{#callable:fd_pack_set_block_limits}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2572>)

Sets the block limits for a given `fd_pack_t` structure based on the provided `fd_pack_limits_t` values.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure where the block limits will be set.
    - ``limits``: A constant pointer to an `fd_pack_limits_t` structure containing the new block limits to be applied.
- **Logic and Control Flow**:
    - Check if `limits->max_cost_per_block` is greater than or equal to `FD_PACK_MAX_COST_PER_BLOCK_LOWER_BOUND` using `FD_TEST` macro.
    - Check if `limits->max_vote_cost_per_block` is greater than or equal to `FD_PACK_MAX_VOTE_COST_PER_BLOCK_LOWER_BOUND` using `FD_TEST` macro.
    - Check if `limits->max_write_cost_per_acct` is greater than or equal to `FD_PACK_MAX_WRITE_COST_PER_ACCT_LOWER_BOUND` using `FD_TEST` macro.
    - Assign `limits->max_microblocks_per_block` to `pack->lim->max_microblocks_per_block`.
    - Assign `limits->max_data_bytes_per_block` to `pack->lim->max_data_bytes_per_block`.
    - Assign `limits->max_cost_per_block` to `pack->lim->max_cost_per_block`.
    - Assign `limits->max_vote_cost_per_block` to `pack->lim->max_vote_cost_per_block`.
    - Assign `limits->max_write_cost_per_acct` to `pack->lim->max_write_cost_per_acct`.
- **Output**: None (void function).


---
### fd\_pack\_rebate\_cus<!-- {{#callable:fd_pack_rebate_cus}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2585>)

Adjusts the cumulative costs and state of a `fd_pack_t` structure based on a rebate.
- **Inputs**:
    - ``pack``: A pointer to a `fd_pack_t` structure that represents the current state of the pack.
    - ``rebate``: A pointer to a `fd_pack_rebate_t` structure containing rebate details such as cost and vote rebates.
- **Logic and Control Flow**:
    - Checks if the `initializer_bundle_state` is `FD_PACK_IB_STATE_PENDING` and `rebate->ib_result` is not zero; if true, updates `initializer_bundle_state` to `FD_PACK_IB_STATE_READY` or `FD_PACK_IB_STATE_FAILED` based on `rebate->ib_result` value.
    - Subtracts `rebate->total_cost_rebate` from `pack->cumulative_block_cost`.
    - Subtracts `rebate->vote_cost_rebate` from `pack->cumulative_vote_cost`.
    - Subtracts `rebate->data_bytes_rebate` from `pack->data_bytes_consumed`.
    - Adds `rebate->total_cost_rebate` to `pack->cumulative_rebated_cus`.
    - Iterates over `rebate->writer_rebates` to adjust `total_cost` in `pack->writer_costs` for each writer account, logging an error if an account is unknown.
- **Output**: No return value; the function modifies the `pack` structure in place.


---
### fd\_pack\_expire\_before<!-- {{#callable:fd_pack_expire_before}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2620>)

Removes transactions from the expiration queue that expire before a specified time and updates the expiration threshold.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure representing the transaction pack.
    - ``expire_before``: An unsigned long integer representing the expiration threshold time; transactions expiring before this time will be removed.
- **Logic and Control Flow**:
    - Set `expire_before` to the maximum of the input `expire_before` and the current `pack->expire_before`.
    - Initialize `deleted_cnt` to zero to count the number of deleted transactions.
    - Get the expiration queue `prq` from the `pack` structure.
    - While there are transactions in the expiration queue and the earliest transaction expires before `expire_before`, do the following:
    - - Retrieve the transaction `expired` from the expiration queue.
    - - Call [`delete_transaction`](<#delete_transaction>) to remove the transaction from the pack, which also removes it from the heap.
    - - Increment `deleted_cnt` by the number of transactions deleted.
    - Update `pack->expire_before` to the new `expire_before` value.
    - Return the total number of deleted transactions `deleted_cnt`.
- **Output**: Returns the number of transactions deleted from the expiration queue as an unsigned long integer.
- **Functions Called**:
    - [`delete_transaction`](<#delete_transaction>)


---
### fd\_pack\_end\_block<!-- {{#callable:fd_pack_end_block}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2642>)

Resets and clears various metrics and data structures in the `fd_pack_t` structure at the end of a block.
- **Inputs**:
    - `pack`: A pointer to the `fd_pack_t` structure that holds the state and data for the current block.
- **Logic and Control Flow**:
    - Calculate `pct_cus_per_block` as the percentage of cumulative block cost relative to the maximum cost per block, using rounded division.
    - Sample various histograms with the current cumulative costs and percentages.
    - Reset counters and metrics such as `microblock_cnt`, `data_bytes_consumed`, `cumulative_block_cost`, `cumulative_vote_cost`, and `cumulative_rebated_cus` to zero.
    - Clear the `outstanding_microblock_mask` and set `initializer_bundle_state` to `FD_PACK_IB_STATE_NOT_INITIALIZED`.
    - Clear the `acct_in_use` map to remove all account usage records.
    - If `written_list_cnt` is less than `written_list_max-1`, iterate over the `written_list` in reverse order to clear the `writer_costs` map, otherwise clear the entire `writer_costs` map.
    - Reset `written_list_cnt` to zero.
    - Increment `compressed_slot_number` with a maximum value check against `FD_PACK_SKIP_CNT+1`.
    - Clear the `bitset_rw_in_use` and `bitset_w_in_use` bitsets.
    - Reset `use_by_bank_cnt` for each bank tile to zero.
    - Copy various metrics histograms to their respective destinations using `FD_MHIST_COPY`.
- **Output**: None (void function).


---
### release\_tree<!-- {{#callable:release_tree}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2714>)

Releases all elements from a treap and associated maps, marking them as free.
- **Inputs**:
    - ``treap``: Pointer to the treap structure to release elements from.
    - ``signature_map``: Pointer to the signature map used for fast removal of elements by signature.
    - ``noncemap``: Pointer to the nonce map used for fast removal of elements by nonce.
    - ``pool``: Pointer to the pool of transactions where elements are stored.
- **Logic and Control Flow**:
    - Initialize a forward iterator `next` for the treap.
    - Iterate over the treap using a forward iterator `it`.
    - For each element in the treap, set `next` to the next element in the treap.
    - Get the index `idx` of the current element from the iterator.
    - Mark the element at index `idx` in the pool as free by setting its `root` to `FD_ORD_TXN_ROOT_FREE`.
    - Remove the element at index `idx` from the treap using `treap_idx_remove`.
    - Remove the element at index `idx` from the signature map using `sig2txn_idx_remove_fast`.
    - Release the element at index `idx` back to the pool using `trp_pool_idx_release`.
    - If the transaction at index `idx` has the `FD_TXN_P_FLAGS_DURABLE_NONCE` flag, remove it from the nonce map using `noncemap_idx_remove_fast`.
- **Output**: No return value; the function operates by side effects on the provided data structures.


---
### fd\_pack\_clear\_all<!-- {{#callable:fd_pack_clear_all}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2733>)

Clears all transaction data and resets the state of the `fd_pack_t` structure.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure to clear.
- **Logic and Control Flow**:
    - Set `pending_txn_cnt`, `microblock_cnt`, `cumulative_block_cost`, `cumulative_vote_cost`, and `cumulative_rebated_cus` to 0.
    - Set `pending_smallest` and `pending_votes_smallest` transaction sizes to `ULONG_MAX`.
    - Release all transactions from `pending`, `pending_votes`, and `pending_bundles` treaps using [`release_tree`](<#release_tree>).
    - Iterate over the transaction pool and release any penalty treaps associated with non-free transactions.
    - Set `compressed_slot_number` to `FD_PACK_SKIP_CNT+1`.
    - Remove all elements from `expiration_q`.
    - Clear `acct_in_use`, `writer_costs`, and `penalty_treaps`.
    - Clear `bitset_rw_in_use` and `bitset_w_in_use`, reset `bitset_avail`, and set `bitset_avail_cnt` to `FD_PACK_BITSET_MAX`.
    - Set all `use_by_bank_cnt` elements to 0.
- **Output**: None (void function).
- **Functions Called**:
    - [`release_tree`](<#release_tree>)


---
### delete\_transaction<!-- {{#callable:delete_transaction}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2790>)

Deletes a transaction from a specified treap and optionally handles related operations like moving transactions from penalty treaps or deleting full bundles.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure, which contains the transaction pool and related data structures.
    - ``containing``: A pointer to the `fd_pack_ord_txn_t` structure representing the transaction to be deleted.
    - ``delete_full_bundle``: An integer flag indicating whether to delete the entire bundle if the transaction is part of one.
    - ``move_from_penalty_treap``: An integer flag indicating whether to move the best transaction from a penalty treap to the main treap if applicable.
- **Logic and Control Flow**:
    - Retrieve the transaction and account addresses from the `containing` transaction.
    - Determine the root treap based on the transaction's root index and set up penalty treap if applicable.
    - If `delete_full_bundle` is set and the transaction is part of a bundle, iterate through the bundle and delete all transactions in it.
    - If `move_from_penalty_treap` is set and the transaction is in the pending treap, find the best transaction in any conflicting penalty treaps and move it to the main treap.
    - Iterate over all accounts referenced by the transaction, releasing bit references and clearing bits in the bitsets.
    - Remove the transaction from the noncemap, expiration queue, and signature map if applicable.
    - Update the transaction's root to `FD_ORD_TXN_ROOT_FREE` and remove it from the treap and pool.
    - Return the count of deleted transactions.
- **Output**: Returns the number of transactions deleted, including any additional transactions deleted as part of a bundle.
- **Functions Called**:
    - [`delete_transaction`](<#delete_transaction>)
    - [`release_bit_reference`](<#release_bit_reference>)


---
### fd\_pack\_delete\_transaction<!-- {{#callable:fd_pack_delete_transaction}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2916>)

Deletes transactions from a pack based on a given signature.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure representing the transaction pack from which transactions will be deleted.
    - ``sig0``: A pointer to a constant `fd_ed25519_sig_t` structure representing the signature of the transaction(s) to be deleted.
- **Logic and Control Flow**:
    - Initialize `cnt` to 0 and `next` to `ULONG_MAX` to keep track of the number of deleted transactions and the next transaction index, respectively.
    - Use `sig2txn_idx_query_const` to find the index of the first transaction with the given signature in the `signature_map` of the `pack`.
    - Iterate over the transactions with the given signature using a loop, updating `idx` with `next` in each iteration.
    - In each iteration, set `next` to the result of `sig2txn_idx_next_const` to find the next transaction index with the same signature.
    - Call [`delete_transaction`](<#delete_transaction>) to delete the transaction at the current index and increment `cnt` by the number of transactions deleted.
    - Return `cnt`, the total number of transactions deleted.
- **Output**: Returns the number of transactions deleted as an `ulong`.
- **Functions Called**:
    - [`delete_transaction`](<#delete_transaction>)


---
### fd\_pack\_verify<!-- {{#callable:fd_pack_verify}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L2936>)

Verifies the integrity and consistency of the data structures within a `fd_pack_t` instance.
- **Inputs**:
    - ``pack``: A pointer to the `fd_pack_t` structure to verify.
    - ``scratch``: A pointer to a memory area used for temporary data during verification.
- **Logic and Control Flow**:
    - Copy the `acct_to_bitset` map to a scratch area for verification purposes.
    - Initialize bitsets to track processed bits and verify that each bit is in exactly one place.
    - Iterate over the `bitset_avail` array to ensure no duplicate bits are marked as available.
    - Iterate over the `bitset_copy` to verify that each account has a positive reference count and that bits are not used twice.
    - Iterate over all treaps (pending, pending_votes, pending_bundles, and penalty treaps) to verify transaction consistency and count total transactions.
    - For each transaction, verify its presence in the `sig2txn` map and check its expiration consistency with the expiration queue.
    - Verify that all accounts in transactions are correctly mapped in the `bitset_copy` and that reference counts are decremented correctly.
    - Verify that the total number of transactions matches the count in the `sig2txn` map and that the `sig2txn` map is not corrupt.
    - Verify the `noncemap` for consistency with the `sig2txn` map and ensure no phantom transactions exist.
    - Verify that all slots in the pool are accounted for and that no phantom slots exist.
    - Verify that the `acct_in_use` map is consistent with the `use_by_bank` arrays and that no stray uses exist.
    - Ensure that the `bitset_rw_in_use` and `bitset_w_in_use` are consistent with the `acct_in_use` map.
- **Output**: Returns 0 if all verifications pass, or a negative line number if a verification fails.


---
### fd\_pack\_leave<!-- {{#callable:fd_pack_leave}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L3198>)

Ensures memory fence synchronization and returns the input `fd_pack_t` pointer cast to `void *`.
- **Inputs**:
    - ``pack``: A pointer to an `fd_pack_t` structure, representing a pack data structure.
- **Logic and Control Flow**:
    - Calls `FD_COMPILER_MFENCE()` to ensure memory fence synchronization.
    - Casts the `pack` pointer to `void *`.
    - Returns the cast pointer.
- **Output**: Returns the input `fd_pack_t` pointer cast to `void *`.


---
### fd\_pack\_delete<!-- {{#callable:fd_pack_delete}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L3199>)

Ensures memory fence synchronization and returns the input pointer.
- **Inputs**:
    - ``mem``: A pointer to a memory location that the function will return.
- **Logic and Control Flow**:
    - Executes a memory fence operation using `FD_COMPILER_MFENCE()` to ensure memory synchronization.
    - Returns the input pointer `mem`.
- **Output**: Returns the input pointer `mem`.


# Function Declarations (Public API)

---
### delete\_transaction<!-- {{#callable_declaration:delete_transaction}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L679>)

Deletes a transaction from the specified pack.
- **Description**: Use this function to remove a transaction from a pack, optionally deleting the entire bundle if the transaction is part of one. This function can also move the best transaction from a penalty treap to the main treap if the transaction is in the pending treap. Ensure that the pack and transaction are valid and that the transaction is not already free before calling this function.
- **Inputs**:
    - `pack`: A pointer to the `fd_pack_t` structure from which the transaction will be deleted. Must not be null.
    - `containing`: A pointer to the `fd_pack_ord_txn_t` structure representing the transaction to delete. Must not be null and must be part of the specified pack.
    - `delete_full_bundle`: An integer flag indicating whether to delete the entire bundle if the transaction is part of one. Non-zero to delete the full bundle, zero otherwise.
    - `move_from_penalty_treap`: An integer flag indicating whether to move the best transaction from a penalty treap to the main treap if the transaction is in the pending treap. Non-zero to enable this behavior, zero otherwise.
- **Output**: Returns the number of transactions deleted, including any additional transactions if a full bundle is deleted.
- **See Also**: [`delete_transaction`](<#delete_transaction>)  (Implementation)


---
### insert\_bundle\_impl<!-- {{#callable_declaration:insert_bundle_impl}} -->
[View Source →](<../../../../../src/disco/pack/fd_pack.c#L680>)

Inserts a bundle of transactions into a pack.
- **Description**: Use this function to insert a bundle of transactions into a pack, specifying the index of the bundle, the number of transactions, the bundle itself, and the expiration time. This function is typically called when you have a set of transactions that need to be processed together as a bundle. Ensure that the pack is properly initialized before calling this function. The function does not handle penalty information for bundles.
- **Inputs**:
    - `pack`: A pointer to an `fd_pack_t` structure representing the pack where the bundle will be inserted. Must not be null.
    - `bundle_idx`: An unsigned long representing the index of the bundle. Must be a valid index within the pack's capacity.
    - `txn_cnt`: An unsigned long indicating the number of transactions in the bundle. Must be greater than zero and within the pack's transaction capacity.
    - `bundle`: A pointer to an array of `fd_pack_ord_txn_t*` representing the transactions in the bundle. Must not be null and must contain `txn_cnt` valid transaction pointers.
    - `expires_at`: An unsigned long representing the expiration time for the bundle. Transactions in the bundle will expire at this time.
- **Output**: None
- **See Also**: [`insert_bundle_impl`](<#insert_bundle_impl>)  (Implementation)



---
Made with ❤️ by [Driver](https://www.driver.ai/)