<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests for the `fd_store` functionality, including simple, multi-root, map function, and parallel scenarios.

# Purpose
The code is a C program designed to test various functionalities of a data structure referred to as `fd_store`. This program includes several test functions, such as [`test_simple`](<#test_simple>), [`test_mr`](<#test_mr>), [`test_map_function`](<#test_map_function>), and [`test_para`](<#test_para>), each of which exercises different aspects of the `fd_store` operations. The `fd_store` appears to be a structure that manages a collection of elements, possibly for a Merkle tree or similar data structure, given the use of terms like "merkle root" and "hash". The tests involve inserting elements, linking them in a hierarchical manner, querying them, and verifying the integrity of the structure. The program also includes a parallel test ([`test_para`](<#test_para>)) that checks concurrent operations on the `fd_store` using multiple execution tiles, which suggests that the `fd_store` is designed to support concurrent access.

The main function initializes the environment by setting up a workspace (`fd_wksp_t`) and then calls the test functions to validate the `fd_store` operations. The program uses a shared memory workspace, which is created and managed using functions like `fd_wksp_new_anonymous`. The tests involve memory allocation, element insertion, querying, and verification of the data structure's state. The use of `FD_TEST` macros indicates that the program checks for expected conditions and reports failures if any test does not pass. The program concludes by halting the environment with `fd_halt()`. This code is intended to be executed as a standalone program to verify the correctness and performance of the `fd_store` data structure in various scenarios.
# Imports and Dependencies

---
- `fd_store.h`


# Global Variables

---
### tile\_go
- **Type**: `ulong`
- **Description**: `tile_go` is a static global variable of type `ulong`.
- **Use**: It is used as a flag to control the execution flow in the `shred_tile_insert` function, indicating when the tile should start processing.


---
### num\_insert
- **Type**: ``ulong``
- **Description**: `num_insert` is a static global variable of type `ulong` initialized to 10. It represents the number of insert operations to perform in the `shred_tile_insert` function.
- **Use**: Controls the loop iteration count for insert operations in the `shred_tile_insert` function.


---
### store
- **Type**: ``fd_store_t *``
- **Description**: A static pointer to an `fd_store_t` structure, which represents a data store for managing FEC (Forward Error Correction) sets. This variable is used to store and manage data across different slots and tiles in a concurrent environment.
- **Use**: Used to manage and access the FEC sets in the data store across multiple functions and threads.


# Functions

---
### test\_simple<!-- {{#callable:test_simple}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L18>)

Tests the functionality of a simple store with a single FEC set per slot, including insertion, linking, querying, and clearing operations.
- **Inputs**:
    - ``wksp``: A pointer to a `fd_wksp_t` workspace structure used for memory allocation.
- **Logic and Control Flow**:
    - Allocate memory for the store using `fd_wksp_alloc_laddr` with alignment and footprint based on `fec_max`.
    - Create and join a new store with [`fd_store_new`](<fd_store.c.md#fd_store_new>) and [`fd_store_join`](<fd_store.c.md#fd_store_join>).
    - Verify the store and its pool using `FD_TEST` assertions.
    - Insert multiple `fd_hash_t` elements into the store using [`fd_store_insert`](<fd_store.c.md#fd_store_insert>).
    - Query the inserted elements using [`fd_store_query_const`](<fd_store.h.md#fd_store_query_const>) to obtain `fd_store_fec_t` pointers.
    - Link elements in a hierarchical structure using [`fd_store_link`](<fd_store.c.md#fd_store_link>).
    - Verify parent-child relationships using `FD_TEST` with `fd_store_parent` and `fd_store_child`.
    - Publish a specific element using [`fd_store_publish`](<fd_store.c.md#fd_store_publish>) and verify the root of the store.
    - Clear the store using [`fd_store_clear`](<fd_store.c.md#fd_store_clear>) and verify it is empty.
    - Free the allocated memory using `fd_wksp_free_laddr` after deleting and leaving the store.
- **Output**: No return value; the function performs tests and assertions to verify the store's behavior.
- **Functions Called**:
    - [`fd_store_align`](<fd_store.h.md#fd_store_align>)
    - [`fd_store_footprint`](<fd_store.h.md#fd_store_footprint>)
    - [`fd_store_join`](<fd_store.c.md#fd_store_join>)
    - [`fd_store_new`](<fd_store.c.md#fd_store_new>)
    - [`fd_store_pool_t::fd_store_pool`](<fd_store.h.md#fd_store_pool_tfd_store_pool>)
    - [`fd_store_insert`](<fd_store.c.md#fd_store_insert>)
    - [`fd_store_query_const`](<fd_store.h.md#fd_store_query_const>)
    - [`fd_store_link`](<fd_store.c.md#fd_store_link>)
    - [`fd_store_publish`](<fd_store.c.md#fd_store_publish>)
    - [`fd_store_clear`](<fd_store.c.md#fd_store_clear>)
    - [`fd_store_delete`](<fd_store.c.md#fd_store_delete>)
    - [`fd_store_leave`](<fd_store.c.md#fd_store_leave>)


---
### test\_mr<!-- {{#callable:test_mr}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L89>)

Tests the functionality of a store by inserting, querying, linking, and verifying multiple hash entries.
- **Inputs**:
    - ``wksp``: A pointer to a `fd_wksp_t` workspace used for memory allocation.
- **Logic and Control Flow**:
    - Allocate memory for the store using `fd_wksp_alloc_laddr` with alignment and footprint based on `fec_max`.
    - Create and join a new store with [`fd_store_new`](<fd_store.c.md#fd_store_new>) and [`fd_store_join`](<fd_store.c.md#fd_store_join>).
    - Verify the store and its pool using `FD_TEST`.
    - Define multiple `fd_hash_t` variables representing different Merkle roots.
    - Insert each Merkle root into the store and verify insertion with `FD_TEST`.
    - Link the Merkle roots in a specific order using [`fd_store_link`](<fd_store.c.md#fd_store_link>).
    - Print the store's state with [`fd_store_print`](<fd_store.c.md#fd_store_print>).
    - Publish the store with the last Merkle root using [`fd_store_publish`](<fd_store.c.md#fd_store_publish>) and verify the root with `FD_TEST`.
    - Clear the store and verify it is empty with `FD_TEST`.
    - Free the allocated memory using `fd_wksp_free_laddr`.
- **Output**: No return value; the function performs tests and assertions on the store.
- **Functions Called**:
    - [`fd_store_align`](<fd_store.h.md#fd_store_align>)
    - [`fd_store_footprint`](<fd_store.h.md#fd_store_footprint>)
    - [`fd_store_join`](<fd_store.c.md#fd_store_join>)
    - [`fd_store_new`](<fd_store.c.md#fd_store_new>)
    - [`fd_store_pool_t::fd_store_pool`](<fd_store.h.md#fd_store_pool_tfd_store_pool>)
    - [`fd_store_insert`](<fd_store.c.md#fd_store_insert>)
    - [`fd_store_query_const`](<fd_store.h.md#fd_store_query_const>)
    - [`fd_store_link`](<fd_store.c.md#fd_store_link>)
    - [`fd_store_print`](<fd_store.c.md#fd_store_print>)
    - [`fd_store_publish`](<fd_store.c.md#fd_store_publish>)
    - [`fd_store_clear`](<fd_store.c.md#fd_store_clear>)
    - [`fd_store_delete`](<fd_store.c.md#fd_store_delete>)
    - [`fd_store_leave`](<fd_store.c.md#fd_store_leave>)


---
### test\_map\_function<!-- {{#callable:test_map_function}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L184>)

Tests the functionality of a map in a store by inserting keys, checking collisions, and verifying key chains.
- **Inputs**:
    - ``wksp``: A pointer to a `fd_wksp_t` workspace structure used for memory allocation.
- **Logic and Control Flow**:
    - Allocate memory for the store using `fd_wksp_alloc_laddr` with alignment and footprint based on `fec_max`.
    - Create and join a new store with [`fd_store_new`](<fd_store.c.md#fd_store_new>) and [`fd_store_join`](<fd_store.c.md#fd_store_join>).
    - Initialize a pool, fec, and map from the store using [`fd_store_pool`](<fd_store.h.md#fd_store_pool_tfd_store_pool>), `fd_store_fec0`, and `fd_store_map`.
    - Check if the store is valid using `FD_TEST`.
    - Calculate partition size as `fec_max` divided by the store's partition count.
    - Define two keys, `key1` and `key2`, with the same Merkle root but different partitions.
    - Test if the keys are equal using `fd_store_map_key_eq` and check their hash values with `fd_store_map_key_hash`.
    - Insert `key1` and `key2` into the store; insertion of `key2` will fail due to existing Merkle root.
    - Verify that `fd_store_map_ele_query` returns different fec_t pointers for `key1` and `key2`, but `fd_store_query` returns the same fec_t pointer.
    - Create two additional keys, `collide1` and `collide2`, to collide with `key1` and insert them into the store.
    - Verify that `fd_store_map_ele_query_const` returns valid fec_t pointers for `collide1`, `collide2`, and `key1`.
    - Check that all keys belong to the same private chain index using `fd_store_map_private_chain_idx`.
    - Verify that the `next` pointers chain the fec_t structures together correctly.
    - Perform constant and non-constant queries on the store and modify the parent of `collide2`.
    - Re-verify the order and integrity of the fec_t chain using `fd_store_map_ele_query`.
- **Output**: No return value; the function performs tests and assertions to verify map functionality.
- **Functions Called**:
    - [`fd_store_align`](<fd_store.h.md#fd_store_align>)
    - [`fd_store_footprint`](<fd_store.h.md#fd_store_footprint>)
    - [`fd_store_join`](<fd_store.c.md#fd_store_join>)
    - [`fd_store_new`](<fd_store.c.md#fd_store_new>)
    - [`fd_store_pool_t::fd_store_pool`](<fd_store.h.md#fd_store_pool_tfd_store_pool>)
    - [`fd_store_insert`](<fd_store.c.md#fd_store_insert>)
    - [`fd_store_query_const`](<fd_store.h.md#fd_store_query_const>)


---
### shred\_tile\_insert<!-- {{#callable:shred_tile_insert}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L255>)

Inserts hash values into a store for a specific tile index after a synchronization signal is received.
- **Inputs**:
    - `argc`: The number of command-line arguments (unused in this function).
    - `argv`: The array of command-line arguments (unused in this function).
- **Logic and Control Flow**:
    - Logs a notice that the function is called with the current tile index.
    - Waits in a loop until the `tile_go` variable is set to a non-zero value, indicating readiness to proceed.
    - Retrieves the current tile index using `fd_tile_idx()`.
    - Iterates from 1 to `num_insert - 1`, creating a hash value `mr` for each iteration with the current tile index and loop index.
    - Acquires a read lock on the `store` to ensure thread-safe access.
    - Logs a notice about the insertion of the current index at the current tile index.
    - Inserts the hash value `mr` into the `store` at the current tile index.
    - Releases the read lock on the `store`.
- **Output**: Returns 0 to indicate successful execution.
- **Functions Called**:
    - [`fd_store_insert`](<fd_store.c.md#fd_store_insert>)


---
### test\_para<!-- {{#callable:test_para}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L273>)

Tests concurrent acquire and release operations on multiple tiles using a shared store.
- **Inputs**:
    - ``wksp``: A pointer to a `fd_wksp_t` workspace structure used for memory allocation.
- **Logic and Control Flow**:
    - Allocate memory for the store using `fd_wksp_alloc_laddr` with a maximum FEC of 64.
    - Determine the number of available tiles using `fd_tile_cnt` and cap it at the desired maximum.
    - Create a new store with the allocated memory and join it using [`fd_store_join`](<fd_store.c.md#fd_store_join>).
    - Log a notice about testing concurrent operations on the available tiles.
    - Set `tile_go` to 0 and ensure memory fence operations with `FD_COMPILER_MFENCE`.
    - Start execution on each tile (except the first) using `fd_tile_exec_new` with the `shred_tile_insert` function.
    - Pause execution for 0.1 seconds using `fd_log_sleep`.
    - Set `tile_go` to 1 to signal tiles to start processing and ensure memory fence operations again.
    - Delete the execution context for each tile using `fd_tile_exec_delete`.
    - For each tile, verify that all expected entries are present in the store using `fd_store_query`.
    - Verify the integrity of the store using [`fd_store_verify`](<fd_store.c.md#fd_store_verify>).
- **Output**: No return value; the function performs tests and logs results.
- **Functions Called**:
    - [`fd_store_align`](<fd_store.h.md#fd_store_align>)
    - [`fd_store_footprint`](<fd_store.h.md#fd_store_footprint>)
    - [`fd_store_join`](<fd_store.c.md#fd_store_join>)
    - [`fd_store_new`](<fd_store.c.md#fd_store_new>)
    - [`test_para::FD_VOLATILE`](<#test_parafd_volatile>)
    - [`fd_store_verify`](<fd_store.c.md#fd_store_verify>)


---
### FD\_VOLATILE<!-- {{#callable:test_para::FD_VOLATILE}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L287>)

Sets the `tile_go` variable to 0 and enforces a memory fence to ensure memory ordering.
- **Inputs**:
    - `tile_go`: A global variable that is set to 0.
- **Logic and Control Flow**:
    - Set `tile_go` to 0, indicating a reset or initial state.
    - Call `FD_COMPILER_MFENCE()` to enforce a memory fence, ensuring that all previous memory operations are completed before any subsequent operations.
- **Output**: No output is returned as this is a macro operation affecting memory state.


---
### main<!-- {{#callable:main}} -->
[View Source →](<../../../../../src/disco/store/test_store.c#L316>)

Initializes the environment, sets up a workspace, and runs a series of tests on data storage and retrieval functions.
- **Inputs**:
    - `argc`: The number of command-line arguments.
    - `argv`: An array of command-line argument strings.
- **Logic and Control Flow**:
    - Calls `fd_boot` to initialize the environment with command-line arguments.
    - Sets `page_cnt` to 1 and `_page_sz` to "gigantic" for workspace configuration.
    - Retrieves the NUMA index using `fd_shmem_numa_idx` with an argument of 0.
    - Creates a new anonymous workspace `wksp` using `fd_wksp_new_anonymous` with the specified page size, page count, and CPU index.
    - Checks if the workspace `wksp` is successfully created using `FD_TEST`.
    - Runs the [`test_mr`](<#test_mr>), [`test_map_function`](<#test_map_function>), and [`test_para`](<#test_para>) functions with the workspace `wksp` as an argument.
    - Calls `fd_halt` to clean up and terminate the program.
    - Returns 0 to indicate successful execution.
- **Output**: Returns 0 to indicate successful execution.
- **Functions Called**:
    - [`test_mr`](<#test_mr>)
    - [`test_map_function`](<#test_map_function>)
    - [`test_para`](<#test_para>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)