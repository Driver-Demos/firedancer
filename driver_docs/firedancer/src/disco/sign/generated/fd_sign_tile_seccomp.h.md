<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines a seccomp filter policy for syscall control based on architecture and specific syscalls.

# Purpose
The code is a C header file that defines a seccomp (secure computing mode) filter policy for a specific architecture. It is generated automatically and should not be edited manually. The file includes several Linux headers related to auditing, capabilities, filtering, and seccomp, which are necessary for defining and applying the seccomp filter. The code uses conditional compilation to set the `ARCH_NR` macro based on the target architecture, supporting `i386`, `x86_64`, and `aarch64` architectures. If the architecture is unsupported, it generates a compilation error.

The main functionality of the code is encapsulated in the [`populate_sock_filter_policy_fd_sign_tile`](<#populate_sock_filter_policy_fd_sign_tile>) function. This function initializes a `sock_filter` array with 14 instructions that define the seccomp filter policy. The filter checks if the architecture of the executing script matches the runtime architecture and allows or denies specific system calls (`SYS_write` and `SYS_fsync`) based on their arguments. If the conditions are not met, the process is terminated using `SECCOMP_RET_KILL_PROCESS`. The function uses `fd_memcpy` to copy the filter instructions to the output buffer. The code is intended to be used as part of a larger system that requires strict control over system calls for security purposes.
# Imports and Dependencies

---
- `../../../../src/util/fd_util_base.h`
- `linux/audit.h`
- `linux/capability.h`
- `linux/filter.h`
- `linux/seccomp.h`
- `linux/bpf.h`
- `sys/syscall.h`
- `signal.h`
- `stddef.h`


# Global Variables

---
### sock\_filter\_policy\_fd\_sign\_tile\_instr\_cnt
- **Type**: ``unsigned int``
- **Description**: A static constant variable that holds the number of instructions in a socket filter policy.
- **Use**: Used to verify that the output count is sufficient to hold the filter instructions.


# Functions

---
### populate\_sock\_filter\_policy\_fd\_sign\_tile<!-- {{#callable:populate_sock_filter_policy_fd_sign_tile}} -->
[View Source →](<../../../../../../src/disco/sign/generated/fd_sign_tile_seccomp.h#L26>)

Populates a `sock_filter` array with a predefined seccomp filter policy to control system call permissions.
- **Inputs**:
    - `out_cnt`: The number of elements in the `out` array, which must be at least 14.
    - `out`: A pointer to a `sock_filter` array where the filter policy will be copied.
    - `logfile_fd`: The file descriptor to be allowed for certain system calls.
- **Logic and Control Flow**:
    - Check if `out_cnt` is at least 14 using `FD_TEST` macro.
    - Define a `sock_filter` array `filter` with 14 elements to specify the seccomp filter policy.
    - Load the architecture from `seccomp_data` and compare it with `ARCH_NR`; if not equal, jump to `RET_KILL_PROCESS`.
    - Load the syscall number and check if it is `SYS_write` or `SYS_fsync`; if not, jump to `RET_KILL_PROCESS`.
    - For `SYS_write`, check if the first argument is 2 or `logfile_fd`; if not, jump to `RET_KILL_PROCESS`.
    - For `SYS_fsync`, check if the first argument is `logfile_fd`; if not, jump to `RET_KILL_PROCESS`.
    - If none of the conditions are met, execute `RET_KILL_PROCESS`.
    - Copy the `filter` array to the `out` array using `fd_memcpy`.
- **Output**: The function does not return a value; it modifies the `out` array in place.



---
Made with ❤️ by [Driver](https://www.driver.ai/)