<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a circular queue for message storage with functions for creation, manipulation, and verification.

# Purpose
The code defines a circular queue data structure and its associated operations. It provides functionality to manage a circular buffer, which is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. The main components include the `fd_circq_message_private` structure, which holds metadata for each message in the queue, and the `fd_circq_t` structure, which represents the circular queue itself. The code includes functions to create a new circular queue ([`fd_circq_new`](<#fd_circq_new>)), join an existing queue ([`fd_circq_join`](<#fd_circq_join>)), leave a queue ([`fd_circq_leave`](<#fd_circq_leave>)), and delete a queue ([`fd_circq_delete`](<#fd_circq_delete>)). 

The code also provides functions to manipulate the queue, such as [`fd_circq_push_back`](<#fd_circq_push_back>) to add a message to the end of the queue and [`fd_circq_pop_front`](<#fd_circq_pop_front>) to remove a message from the front. The [`verify`](<#fd_fn_unusedverify>) function checks the integrity of the queue, ensuring that the head and tail pointers are within bounds and that the message count is consistent. The [`evict`](<#evict>) function removes messages from the queue when necessary to make space for new messages. The code is intended to be part of a larger system where the circular queue is used for efficient message passing or data buffering.
# Imports and Dependencies

---
- `fd_circq.h`


# Data Structures

---
### fd\_circq\_message\_private
- **Type**: ``struct``
- **Members**:
    - `align`: Specifies the alignment requirement for the message.
    - `footprint`: Indicates the size of the message in the circular buffer.
    - `next`: Stores the offset within the circular buffer where the next message starts.
- **Description**: Defines a private structure for managing messages within a circular queue, ensuring proper alignment and tracking the size and position of each message in the buffer.


---
### fd\_circq\_message\_t
- **Type**: ``struct``
- **Members**:
    - `align`: Specifies the alignment requirement for the message.
    - `footprint`: Indicates the size of the message in the circular queue.
    - `next`: Stores the offset within the circular buffer where the next message starts.
- **Description**: Defines a private structure used in a circular queue to manage messages, including their alignment, size, and the offset to the next message in the buffer.


# Functions

---
### fd\_circq\_align<!-- {{#callable:fd_circq_align}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L16>)

Returns the alignment requirement for a circular queue.
- **Inputs**: None
- **Logic and Control Flow**:
    - Returns the constant `FD_CIRCQ_ALIGN`.
- **Output**: The function returns an `ulong` value representing the alignment requirement for a circular queue.


---
### fd\_circq\_footprint<!-- {{#callable:fd_circq_footprint}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L21>)

Calculates the memory footprint of a circular queue given its size.
- **Inputs**:
    - `sz`: The size of the circular queue in bytes.
- **Logic and Control Flow**:
    - Calculate the total memory footprint by adding the size of the `fd_circq_t` structure to the provided size `sz`.
- **Output**: Returns the total memory footprint in bytes as an unsigned long integer.


---
### fd\_circq\_new<!-- {{#callable:fd_circq_new}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L26>)

Initializes a circular queue structure in shared memory with a specified size.
- **Inputs**:
    - `shmem`: A pointer to the shared memory where the circular queue will be initialized.
    - `sz`: The size of the circular queue to be initialized.
- **Logic and Control Flow**:
    - Cast the `shmem` pointer to a `fd_circq_t` pointer named `circq`.
    - Set the `cnt` field of `circq` to 0, indicating the queue is empty.
    - Set the `head` field of `circq` to 0, indicating the start of the queue.
    - Set the `tail` field of `circq` to 0, indicating the end of the queue.
    - Set the `size` field of `circq` to `sz`, defining the maximum size of the queue.
    - Return the `shmem` pointer.
- **Output**: Returns the pointer to the shared memory (`shmem`) where the circular queue is initialized.


---
### fd\_circq\_join<!-- {{#callable:fd_circq_join}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L37>)

Casts a shared buffer pointer to a `fd_circq_t` pointer.
- **Inputs**:
    - `shbuf`: A pointer to a shared buffer that is to be cast to a `fd_circq_t` pointer.
- **Logic and Control Flow**:
    - Casts the input pointer `shbuf` to a `fd_circq_t` pointer.
    - Returns the casted pointer.
- **Output**: A pointer to `fd_circq_t` that is cast from the input `shbuf`.


---
### fd\_circq\_leave<!-- {{#callable:fd_circq_leave}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L42>)

Returns the pointer to the circular queue buffer.
- **Inputs**:
    - ``buf``: A pointer to the circular queue buffer of type `fd_circq_t`.
- **Logic and Control Flow**:
    - Casts the input `buf` to a `void *` type.
    - Returns the casted pointer.
- **Output**: A `void *` pointer to the circular queue buffer.


---
### fd\_circq\_delete<!-- {{#callable:fd_circq_delete}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L47>)

Returns the input pointer `shbuf` without modification.
- **Inputs**:
    - `shbuf`: A pointer to a shared buffer, which is expected to be of type `void *`.
- **Logic and Control Flow**:
    - Receives a pointer `shbuf` as input.
    - Returns the same pointer `shbuf` without any changes.
- **Output**: The function returns the same pointer `shbuf` that it receives as input.


---
### verify<!-- {{#callable:FD_FN_UNUSED::verify}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L52>)

Validates the internal state of a circular queue (`fd_circq_t`) to ensure consistency and correctness.
- **Inputs**:
    - `circq`: A pointer to the `fd_circq_t` structure representing the circular queue to verify.
- **Logic and Control Flow**:
    - Check that `circq->head` and `circq->tail` are less than `circq->size`.
    - Ensure that if `circq->tail` equals `circq->head`, then `circq->cnt` is less than or equal to 1.
    - If `circq->cnt` is zero, verify that both `circq->head` and `circq->tail` are zero.
    - If `circq->cnt` is one, verify that `circq->head` equals `circq->tail`.
    - Initialize a buffer pointer `buf` to point to the data region of the circular queue.
    - Iterate over each message in the queue using a loop that runs `circq->cnt` times.
    - For each message, calculate the `start` and `end` positions based on alignment and footprint.
    - If the queue has wrapped, ensure that `end` is less than or equal to `circq->head`.
    - Verify that `start` is less than `end` and `end` is less than or equal to `circq->size`.
    - Update `current` to the `next` position of the message and set `wrapped` if `current` is less than `start`.
- **Output**: No output is returned; the function performs internal consistency checks using assertions.


---
### evict<!-- {{#callable:evict}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L80>)

Removes messages from a circular queue that overlap with a specified range.
- **Inputs**:
    - ``circq``: A pointer to the circular queue structure `fd_circq_t`.
    - ``from``: The start of the range to check for overlap.
    - ``to``: The end of the range to check for overlap.
- **Logic and Control Flow**:
    - Convert the `circq` pointer to a buffer pointer `buf` that points to the data region of the circular queue.
    - Enter an infinite loop to process messages in the queue.
    - Check if the queue is empty (`circq->cnt` is zero); if so, exit the function.
    - Retrieve the message at the head of the queue and calculate its start and end positions.
    - Check if the message overlaps with the specified range (`from` to `to`).
    - If there is an overlap, decrement the message count (`circq->cnt`) and increment the drop count (`circq->metrics.drop_cnt`).
    - If the queue becomes empty after removing the message, reset the head and tail pointers to zero; otherwise, update the head pointer to the next message.
    - If there is no overlap, exit the loop.
- **Output**: No output is returned; the function modifies the state of the circular queue `circq` in place.


---
### fd\_circq\_push\_back<!-- {{#callable:fd_circq_push_back}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L105>)

Adds a new message to the back of a circular queue with specified alignment and footprint.
- **Inputs**:
    - `circq`: A pointer to the circular queue structure where the message will be added.
    - `align`: The alignment requirement for the message, which must be a power of 2 and not exceed `FD_CIRCQ_ALIGN`.
    - `footprint`: The size of the message to be added to the circular queue.
- **Logic and Control Flow**:
    - Check if `align` is a power of 2 and does not exceed `FD_CIRCQ_ALIGN`; log a warning and return `NULL` if not.
    - Calculate the total required space for the message, including alignment, and check if it exceeds the circular queue's size; log a warning and return `NULL` if it does.
    - Initialize a buffer pointer to the start of the circular queue's data region.
    - If the queue is not empty, calculate the current position for the new message based on the tail position, alignment, and footprint of the last message.
    - If the calculated position plus required space exceeds the queue's size, evict messages to make space, reset the tail to the start, and update the `next` pointer of the last message if applicable.
    - If there is enough space, evict messages from the current position to the end of the required space, update the tail to the current position, and set the `next` pointer of the last message if applicable.
    - Increment the message count in the queue.
    - Set the alignment and footprint for the new message and return a pointer to the start of the message's data area.
- **Output**: A pointer to the start of the new message's data area in the circular queue, or `NULL` if the operation fails.
- **Functions Called**:
    - [`evict`](<#evict>)


---
### fd\_circq\_pop\_front<!-- {{#callable:fd_circq_pop_front}} -->
[View Source →](<../../../../../src/disco/events/fd_circq.c#L153>)

Removes and returns the front message from a circular queue if it is not empty.
- **Inputs**:
    - `circq`: A pointer to the `fd_circq_t` circular queue structure from which to pop the front message.
- **Logic and Control Flow**:
    - Check if the circular queue `circq` is empty by evaluating `circq->cnt`; if it is empty, return `NULL`.
    - Decrement the message count `circq->cnt` by one.
    - Calculate the address of the front message using `circq->head` and cast it to `fd_circq_message_t *`.
    - If the queue is now empty after popping, set both `circq->head` and `circq->tail` to `0UL`.
    - If the queue is not empty, update `circq->head` to point to the next message using `message->next`.
    - Assert that `circq->head` is within the valid range of the circular queue size using `FD_TEST`.
    - Return a pointer to the message data, which is located immediately after the `fd_circq_message_t` structure.
- **Output**: A pointer to the data of the message that was at the front of the queue, or `NULL` if the queue was empty.



---
Made with ❤️ by [Driver](https://www.driver.ai/)