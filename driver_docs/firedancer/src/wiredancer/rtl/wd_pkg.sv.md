<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Defines parameters, data structures, and modules for signature verification and pipelined operations in a hardware design.

# Purpose
The `wd_sigverify` package defines a set of constants and data structures used for signature verification, particularly focusing on the Ed25519 elliptic curve. The package includes local parameters for cryptographic constants such as the prime number `ED25519_P`, the curve parameter `ED25519_D`, and the base point coordinates `ED25519_Gx`, `ED25519_Gy`, etc. It also defines several packed structures (`pcie_meta_t`, `sv_meta0_t`, `sv_meta1_t`, etc.) that encapsulate metadata and data fields relevant to PCIe transactions and signature verification processes. These structures are likely used to manage and process data packets in a cryptographic context.

The rest of the code consists of various modules that implement pipelined operations and data handling mechanisms. These include modules like `piped_wire`, `piped_pending`, `piped_counter`, and `piped_adder`, which are used to manage data flow and arithmetic operations in a pipelined manner. The `shift_adder_6` and `shift_adder_3` modules perform multi-input addition with shifting, which is useful in cryptographic computations. The `showahead_pkt_fifo` module implements a FIFO buffer with packet handling capabilities, and the `rrb_merge` module manages round-robin merging of input signals. The `var_pipe` module handles variable-length data pipelines, likely for managing data with varying processing times. Overall, the code provides a collection of components for handling data and performing arithmetic operations in a pipelined and efficient manner, suitable for cryptographic and data verification tasks.
# Modules

---
### piped\_adder
Implements a pipelined adder that can handle large bit-width inputs by recursively dividing the addition into smaller parts. The module supports parameterized bit-width, pipeline stages, and optional register stages for output.
- **Constants**:
    - ``W``: Specifies the bit-width of the input and output data.
    - ``C``: Determines the number of pipeline stages.
    - ``M``: Specifies the bit-width of the additional input and output data `m_i` and `m_o`.
    - ``R``: Indicates whether to register the outputs (`R=1`) or not (`R=0`).
- **Ports**:
    - ``clk``: Clock signal for synchronization.
    - ``rst``: Reset signal to initialize the module.
    - ``cin0``: Carry-in input for the addition operation.
    - ``in0``: First input operand for the addition.
    - ``in1``: Second input operand for the addition.
    - ``m_i``: Additional input data for the module.
    - ``m_o``: Additional output data from the module.
    - ``out0``: Result of the addition operation.
    - ``cout0``: Carry-out result from the addition operation.
- **Logic and Control Flow**:
    - Uses a `generate` block to conditionally instantiate logic based on the parameter `C`.
    - If `C` is 0, performs a simple addition of `in0`, `in1`, and `cin0`, and assigns the result to `out0` and `cout0`.
    - If `R` is 1, registers the outputs `out0`, `cout0`, and `m_o` on the rising edge of `clk`.
    - If `C` is greater than 0, divides the input width into two parts and recursively instantiates two smaller `piped_adder` modules.
    - Combines the results of the smaller adders to produce the final output `out0` and `cout0`.


---
### piped\_counter
Implements a piped counter that uses a piped wire to delay input signals and updates a counter based on these signals. The counter can be reset or updated based on the input control signals.
- **Constants**:
    - ``D``: Sets the depth of the piped wire.
    - ``W``: Defines the width of the counter and output logic.
- **Ports**:
    - ``c``: Outputs the current value of the counter.
    - ``p``: Input signal to increment the counter.
    - ``s``: Input signal to store the counter value to the output.
    - ``r``: Input signal to reset the counter.
    - ``clk``: Clock signal for synchronization.
    - ``rst``: Reset signal for the module.
- **Logic and Control Flow**:
    - Uses a `piped_wire` instance to delay the input signals `p`, `s`, and `r` by a depth of `D` cycles.
    - An `always_ff` block updates the counter `cnt` on the rising edge of `clk`. If `rr` is high, the counter resets to zero; otherwise, it increments by `pp`.
    - If `ss` is high, the current counter value is stored in the output `c`.


---
### piped\_pending
Implements a pipelined pending counter that increments or decrements based on input signals. Uses a piped wire to delay input signals and an always block to update the counter.
- **Constants**:
    - ``W``: Defines the width of the output logic `p`.
    - ``D``: Defines the depth of the piped wire instance.
- **Ports**:
    - ``u``: Input signal to increment the counter.
    - ``d``: Input signal to decrement the counter.
    - ``p``: Output logic representing the current counter value.
    - ``clk``: Clock input for synchronization.
    - ``rst``: Reset input to initialize the counter.
- **Logic and Control Flow**:
    - Uses a `piped_wire` instance to delay the input signals `u` and `d` by `D` cycles.
    - An `always_ff` block triggers on the rising edge of `clk` to update the counter `p`.
    - The counter `p` increments if `uu` is high and `dd` is low, decrements if `uu` is low and `dd` is high.
    - Resets the counter `p` to zero when `rst` is high.


---
### piped\_wire
Implements a pipelined wire with configurable width and depth. The module can directly connect input to output or use a pipeline of registers based on the depth parameter.
- **Constants**:
    - ``WIDTH``: Specifies the bit-width of the input and output signals.
    - ``DEPTH``: Determines the number of pipeline stages; a depth of 0 directly connects input to output, while a depth of 1 or more uses registers.
- **Ports**:
    - ``in``: Input signal with a width defined by the `WIDTH` parameter.
    - ``out``: Output signal with a width defined by the `WIDTH` parameter.
    - ``clk``: Clock signal for synchronizing the pipeline stages.
    - ``reset``: Reset signal to initialize the pipeline stages.
- **Logic and Control Flow**:
    - Uses a `generate` block to conditionally instantiate logic based on the `DEPTH` parameter.
    - If `DEPTH` is 0, the module assigns `out` directly from `in`.
    - If `DEPTH` is 1, an `always_ff` block assigns `in` to `out` on the rising edge of `clk`.
    - For `DEPTH` greater than 1, a pipeline of registers is created using a `for` loop and `always_ff` blocks to shift data through the pipeline.


---
### red\_3\_2
Implements a 3-to-2 reduction operation on three input vectors of width `W`. The module can operate in either combinational or sequential mode based on the parameter `R`.
- **Constants**:
    - ``W``: Specifies the width of the input and output vectors.
    - ``R``: Determines if the module operates in combinational (`R=0`) or sequential (`R=1`) mode.
    - ``M``: Specifies the width of the additional input and output vectors `m_i` and `m_o`.
- **Ports**:
    - ``i0``: First input vector of width `W`.
    - ``i1``: Second input vector of width `W`.
    - ``i2``: Third input vector of width `W`.
    - ``s``: Output vector of width `W` representing the sum.
    - ``c``: Output vector of width `W` representing the carry.
    - ``m_i``: Additional input vector of width `M`.
    - ``m_o``: Additional output vector of width `M`.
    - ``clk``: Clock input for sequential operation.
- **Logic and Control Flow**:
    - Uses a `generate` block to iterate over each bit of the input vectors.
    - Calculates the sum of the corresponding bits from `i0`, `i1`, and `i2` and stores it in `ss`.
    - If `R` is 0, assigns the least significant bit of `ss` to `s` and the next bit to `c` directly.
    - If `R` is 1, uses `always_ff` blocks to register the values of `s` and `c` on the rising edge of `clk`.
    - Handles the additional input `m_i` and output `m_o` similarly, either directly assigning or registering based on `R`.


---
### red\_6\_3
Implements a 6-to-3 reduction operation on six input vectors, producing three output vectors. The module can operate in either combinational or sequential mode based on the parameter `R`.
- **Constants**:
    - ``W``: Defines the width of the input and output vectors.
    - ``R``: Determines if the module operates in combinational (`R=0`) or sequential (`R=1`) mode.
    - ``M``: Specifies the width of the additional input and output vector `m_i` and `m_o`.
- **Ports**:
    - ``in0``: First input vector of width `W`.
    - ``in1``: Second input vector of width `W`.
    - ``in2``: Third input vector of width `W`.
    - ``in3``: Fourth input vector of width `W`.
    - ``in4``: Fifth input vector of width `W`.
    - ``in5``: Sixth input vector of width `W`.
    - ``sout``: Output vector representing the sum of the least significant bits of the input vectors.
    - ``cout0``: Output vector representing the sum of the second least significant bits of the input vectors.
    - ``cout1``: Output vector representing the sum of the most significant bits of the input vectors.
    - ``m_i``: Additional input vector of width `M`.
    - ``m_o``: Additional output vector of width `M`.
    - ``clk``: Clock input for sequential operation.
- **Logic and Control Flow**:
    - Uses a `generate` block to iterate over each bit of the input vectors, performing a 6-input addition for each bit position.
    - If `R` is 0, assigns the results directly to the outputs `sout`, `cout0`, and `cout1`.
    - If `R` is 1, uses `always_ff` blocks to register the results on the rising edge of `clk`.
    - Handles the additional input `m_i` and output `m_o` similarly, either directly assigning or registering based on `R`.


---
### rrb\_merge
Implements a round-robin merge mechanism that selects one of the `N` input channels based on a round-robin pointer. The module outputs the selected channel's valid, enable, and data signals.
- **Constants**:
    - ``W``: Specifies the width of the data input and output signals.
    - ``N``: Specifies the number of input channels.
    - ``N_L``: Represents the number of bits needed to address `N` channels, calculated as `$clog2(N)`.
- **Ports**:
    - ``i_r``: Output logic vector indicating the ready status for each input channel.
    - ``i_v``: Input wire vector indicating the valid status for each input channel.
    - ``i_e``: Input wire vector indicating the enable status for each input channel.
    - ``i_m``: Input wire vector carrying data for each input channel.
    - ``o_r``: Input wire indicating the ready status of the output channel.
    - ``o_v``: Output logic indicating the valid status of the output channel.
    - ``o_e``: Output logic indicating the enable status of the output channel.
    - ``o_m``: Output logic carrying data from the selected input channel.
    - ``clk``: Input wire for the clock signal.
    - ``rst``: Input wire for the reset signal.
- **Logic and Control Flow**:
    - The `o_v`, `o_e`, and `o_m` outputs are assigned from the input channel selected by the `rrb` pointer.
    - The `always_comb` block initializes `i_r` to zero and sets the ready status of the selected input channel to `o_r`.
    - The `always_ff` block updates the `rrb` pointer and state `st` based on the current state and the combination of `o_v`, `o_e`, and `o_r`.
    - The `rrb` pointer increments to select the next channel in a round-robin fashion, resetting to zero when it reaches `N`.
    - The state `st` toggles between 0 and 1 based on the conditions of the output signals, controlling the round-robin selection process.
    - The `rst` signal resets the state `st` and the `rrb` pointer to zero.


---
### shift\_adder\_3
Implements a shift and add operation on three input vectors with configurable shifts and parameters. Utilizes submodules `red_3_2` and `piped_adder` to perform reduction and addition operations.
- **Constants**:
    - ``W``: Specifies the width of the input and output vectors.
    - ``S0``: Defines the shift amount for the first input vector.
    - ``S1``: Defines the shift amount for the second input vector.
    - ``S2``: Defines the shift amount for the third input vector.
    - ``C``: Configures the carry chain length in the `piped_adder` submodule.
    - ``M``: Specifies the width of the auxiliary input and output `m_i` and `m_o`.
    - ``R``: Determines the register stage in the `piped_adder` submodule.
    - ``R0``: Determines the register stage in the `red_3_2` submodule.
- **Ports**:
    - ``clk``: Clock signal for synchronous operations.
    - ``rst``: Reset signal to initialize the module.
    - ``cin0``: Carry-in input for the addition operation.
    - ``in0``: First input vector to be shifted and added.
    - ``in1``: Second input vector to be shifted and added.
    - ``in2``: Third input vector to be shifted and added.
    - ``m_i``: Auxiliary input vector for additional data.
    - ``m_o``: Auxiliary output vector for additional data.
    - ``out0``: Output vector resulting from the shift and add operation.
    - ``cout0``: Carry-out output from the addition operation.
- **Logic and Control Flow**:
    - Shifts the input vectors `in0`, `in1`, and `in2` by `S0`, `S1`, and `S2` respectively.
    - Uses the `red_3_2` submodule to reduce the three shifted inputs into a sum `c01_s` and carry `c01_c`.
    - The `piped_adder` submodule adds the reduced sum and carry, along with the carry-in `cin0`, to produce the final output `out0` and carry-out `cout0`.


---
### shift\_adder\_6
Implements a shift and add operation on six input data lines, each shifted by a specified amount, and then reduced using two reduction stages before final addition. The module uses a pipelined architecture to perform these operations efficiently.
- **Constants**:
    - ``W``: Specifies the bit-width of the input and output data lines.
    - ``S0``: Defines the shift amount for the first input data line.
    - ``S1``: Defines the shift amount for the second input data line.
    - ``S2``: Defines the shift amount for the third input data line.
    - ``S3``: Defines the shift amount for the fourth input data line.
    - ``S4``: Defines the shift amount for the fifth input data line.
    - ``S5``: Defines the shift amount for the sixth input data line.
    - ``C``: Specifies the carry bit width for the piped adder.
    - ``M``: Specifies the bit-width of the additional metadata input and output.
    - ``R``: Defines the register stage for the piped adder.
    - ``R0``: Defines the register stage for the first reduction stage.
    - ``R1``: Defines the register stage for the second reduction stage.
- **Ports**:
    - ``clk``: Clock signal for synchronous operations.
    - ``rst``: Reset signal to initialize the module.
    - ``cin0``: Initial carry-in input for the addition process.
    - ``in0``: First input data line to be shifted and added.
    - ``in1``: Second input data line to be shifted and added.
    - ``in2``: Third input data line to be shifted and added.
    - ``in3``: Fourth input data line to be shifted and added.
    - ``in4``: Fifth input data line to be shifted and added.
    - ``in5``: Sixth input data line to be shifted and added.
    - ``m_i``: Metadata input for additional processing.
    - ``m_o``: Metadata output after processing.
    - ``out0``: Final output data after shift and add operations.
    - ``cout0``: Final carry-out after the addition process.
- **Logic and Control Flow**:
    - Shifts each input data line (`in0` to `in5`) by a specified amount (`S0` to `S5`).
    - Uses a `red_6_3` instance to reduce six inputs into three outputs (`c01_s`, `c01_c0`, `c01_c1`).
    - Uses a `red_3_2` instance to further reduce three inputs into two outputs (`c02_s`, `c02_c`).
    - Employs a `piped_adder` to add the final reduced outputs and produce the final result (`out0`, `cout0`).
    - Handles metadata (`m_i`, `m_o`) through the reduction and addition stages.


---
### showahead\_pkt\_fifo
Implements a packet FIFO with show-ahead capability, allowing data to be read before it is fully written. Utilizes two internal `showahead_fifo` instances to manage packet and data storage separately.
- **Constants**:
    - ``WIDTH``: Defines the width of the data bus, defaulting to 32 bits.
    - ``DEPTH``: Specifies the depth of the FIFO, defaulting to 32 entries.
    - ``D_L``: Calculates the number of bits needed to address the depth of the FIFO using the `clog2` function.
    - ``FULL_THRESH``: Sets the threshold for the FIFO to be considered full, defined as `DEPTH-6`.
- **Ports**:
    - ``wr_clk``: Clock signal for write operations.
    - ``wr_req``: Write request signal.
    - ``wr_data``: Data input for write operations, with a width of `WIDTH`.
    - ``wr_eop``: End-of-packet signal for write operations.
    - ``wr_full``: Indicates if the FIFO is full for write operations.
    - ``wr_full_b``: Indicates if the FIFO is not full for write operations.
    - ``wr_count``: Outputs the current count of written data entries.
    - ``wr_count_pkt``: Outputs the current count of written packets.
    - ``rd_clk``: Clock signal for read operations.
    - ``rd_req``: Read request signal.
    - ``rd_data``: Data output for read operations, with a width of `WIDTH`.
    - ``rd_eop``: End-of-packet signal for read operations.
    - ``rd_empty``: Indicates if the FIFO is empty for read operations.
    - ``rd_not_empty``: Indicates if the FIFO is not empty for read operations.
    - ``rd_count``: Outputs the current count of read data entries.
    - ``rd_count_pkt``: Outputs the current count of read packets.
    - ``aclr``: Asynchronous clear signal to reset the FIFO.
- **Logic and Control Flow**:
    - Defines a 2-bit logic vector `rd_not_empty_` to track the non-empty status of the FIFO.
    - Assigns `rd_not_empty` as the logical AND of `rd_not_empty_`, indicating the FIFO is not empty if both bits are set.
    - Assigns `rd_empty` as the logical NOT of `rd_not_empty`, indicating the FIFO is empty if `rd_not_empty` is not set.
    - Instantiates two `showahead_fifo` modules: `f0_inst` for packet counting and `f1_inst` for data storage.
    - `f0_inst` manages packet-level operations, using `wr_eop` and `rd_eop` to track packet boundaries.
    - `f1_inst` handles data-level operations, storing `wr_data` and `wr_eop` together and providing `rd_data` and `rd_eop` on read.


---
### throttle
Implements a throttle mechanism that controls the output `w` based on input signals `i`, `o`, and `f`, and threshold values `ths`. Uses a piped wire to manage threshold values and updates internal counters and gap values based on input conditions.
- **Ports**:
    - ``i``: Input signal that influences the counter and gap logic.
    - ``o``: Output signal that influences the counter logic.
    - ``f``: Input frequency or factor used in the output logic.
    - ``ths``: Array of threshold values used to determine the output `w`.
    - ``w``: Output logic signal controlled by the internal logic and thresholds.
    - ``clk``: Clock signal for synchronizing the module's operations.
    - ``rst``: Reset signal to initialize or reset the module's state.
- **Logic and Control Flow**:
    - Uses a `piped_wire` instance to manage the threshold values `ths` and outputs them to `th0_r`, `th1_r`, and `th2_r`.
    - An `always_comb` block updates `cnt_n` based on the combination of inputs `i` and `o`.
    - An `always_ff` block updates `gap`, `cnt`, and `w` on the rising edge of `clk`.
    - The `gap` is reset to 0 if `i` is high, otherwise it increments if not full.
    - The `cnt` is updated to `cnt_n` on each clock cycle.
    - The output `w` is determined by comparing `cnt_n` and `f` against the threshold values `th0_r`, `th1_r`, and `th2_r`.
    - If `rst` is high, `gap`, `cnt`, and `w` are reset to 0.


---
### var\_pipe
Implements a variable pipeline with a FIFO buffer to manage data flow and timing. Uses a timestamp to control data validity and output readiness.
- **Constants**:
    - ``W_D``: Defines the width of the data input and output ports.
    - ``D``: Specifies the depth of the FIFO buffer used in the module.
- **Ports**:
    - ``i_r``: Output signal indicating readiness to receive data.
    - ``i_v``: Input signal indicating valid data is present.
    - ``i_e``: Input signal for error indication.
    - ``i_w``: Input signal for write enable.
    - ``i_m``: Input data bus with width defined by `W_D`.
    - ``o_v``: Output signal indicating valid data is available.
    - ``o_e``: Output signal for error indication.
    - ``o_m``: Output data bus with width defined by `W_D`.
    - ``clk``: Clock input signal for synchronization.
    - ``rst``: Reset input signal to initialize the module.
- **Logic and Control Flow**:
    - A 64-bit `timestamp` is incremented on each positive clock edge to track time.
    - The `always_comb` block manages the control logic for data flow, setting `i_r` based on `i_w`, and preparing data for the FIFO buffer.
    - The `push_v`, `push_e`, `push_m`, and `push_t` signals are set based on input conditions to control data writing to the FIFO.
    - The `o_v` signal is set to 1 if the data is valid and ready to be output, otherwise it is set to 0.
    - A `showahead_fifo` instance is used to buffer data, with its depth defined by the parameter `D`.



---
Made with ❤️ by [Driver](https://www.driver.ai/)