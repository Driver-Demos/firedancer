<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a simplified N-thread RISC CPU architecture for scheduling the Solana SigVerify algorithm on a Xilinx Virtex UltraScale+ FPGA.

# Purpose
The Verilog code implements a scheduler for the Solana SigVerify algorithm, specifically targeting the Xilinx Virtex UltraScale+ (VU9P) FPGA. It is part of the Firedancer consensus node implementation by Jump Crypto. The design is based on a simplified N-thread RISC CPU architecture with a fixed 256-bit pipeline ALU. This architecture schedules runtime mathematical operations using a fixed instruction stream. The implementation is generic, allowing for a hardware-software co-design process, which optimizes the architecture to balance hardware footprint, mathematical complexity, and runtime latency/throughput.

The code defines a module `shcl_cpu` that manages the scheduling and execution of instructions for the SigVerify algorithm. It uses a set of parallel state machines to handle the instruction pipeline virtually, rather than through a fixed set of stages. The module includes a memory management system with dual-port RAMs for input, constant, and working memory, and a distributed memory for ternary selector input. The design supports multiple logical threads, or "tags," each with its own instruction counter, input hashes, constants, and scratchpad memory. The code also includes a dummy top-level module `schl` for simulation purposes, which interfaces with the `shcl_cpu` module to process input hashes and produce output results.
# Modules

---
### schl
Implements a scheduling mechanism for the Solana SigVerify algorithm using a simplified RISC CPU architecture. Manages input data through a FIFO and processes it using a CPU module to produce hash results.
- **Constants**:
    - ``W_HASH``: Defines the width of the hash input and output, set to 256 bits.
- **Ports**:
    - ``clk``: Clock signal input for synchronization.
    - ``rst``: Reset signal input to initialize the module.
    - ``i_hash``: 256-bit input hash data.
    - ``i_valid``: Indicates if the input hash data is valid.
    - ``i_ready``: Indicates if the module is ready to accept new input data.
    - ``o_hash``: 256-bit output hash data.
    - ``o_valid``: Indicates if the output hash data is valid.
    - ``o_correct``: Indicates if the output hash is correct, always set to '0'.
- **Logic and Control Flow**:
    - Assigns `i_ready` to the negation of `full`, indicating readiness based on FIFO status.
    - Uses a `showahead_fifo` to buffer input data, allowing for asynchronous data handling.
    - Assigns `input_hash` based on the readiness and validity of input data.
    - Increments `ref_cnt` on each clock cycle unless reset, providing a reference counter for input data.
    - Instantiates `shcl_cpu` to process input hash data and produce output hash data.
    - Assigns `o_correct` to '0', indicating no correctness check is performed.


---
### shcl\_cpu
Implements a simplified N-thread RISC CPU architecture for scheduling the runtime of the Solana SigVerify algorithm. Manages instruction fetching, execution, and memory operations using a fixed 256-bit pipeline ALU.
- **Constants**:
    - ``MUL_T``: A constant parameter with a value of `32'h007F_CCC2`.
    - ``MUL_D``: A constant parameter with a value of `15`.
    - ``W_HASH``: A constant parameter with a value of `256`.
    - ``W_IN_MEM``: A constant parameter with a value of `6`.
    - ``W_T``: A constant parameter with a value of `16`.
    - ``MAX_INFLIGHT``: A constant parameter calculated as `(MUL_D+1)+6`.
    - ``NUM_PRIMS``: A local parameter with a value of `11 + 1`.
    - ``W_PRIMS``: A local parameter calculated as `$clog2(NUM_PRIMS)`.
    - ``NUM_TAGS``: A local parameter with a value of `32`.
    - ``W_TAGS``: A local parameter calculated as `$clog2(NUM_TAGS)`.
    - ``NUM_OPS``: A local parameter with a value of `16`.
    - ``W_OPS``: A local parameter calculated as `$clog2(NUM_OPS)`.
    - ``SZ_MEM``: A local parameter with a value of `1024`.
    - ``W_MEM``: A local parameter calculated as `$clog2(SZ_MEM)`.
    - ``NUM_CONSTS``: A local parameter with a value of `12`.
    - ``CONST_MEM``: A parameter array of 12 256-bit constants used for initialization.
    - ``ROM_WIDTH``: A local parameter calculated as `1 + W_OPS + W_IN_MEM + W_IN_MEM + W_IN_MEM + W_IN_MEM`.
    - ``ROM_DEPTH``: A local parameter with a value of `512*4`.
    - ``W_ROM_DEPTH``: A local parameter calculated as `$clog2(ROM_DEPTH)`.
    - ``OP_JMP``: A local parameter with a value of `4'hF`.
    - ``MEM_CNT``: A local parameter with a value of `2`.
    - ``SCRATCH_TAG_OFFSET``: A parameter array defining physical offset addresses for each tag's scratch memory.
- **Ports**:
    - ``clk``: Clock input signal.
    - ``rst``: Reset input signal.
    - ``in_hash_data``: Input hash data signal with a width of `W_HASH`.
    - ``in_hash_valid``: Input signal indicating the validity of the hash data.
    - ``in_hash_ref``: Input reference signal with a width of `W_T`.
    - ``in_hash_ready``: Output signal indicating readiness to accept new hash data.
    - ``out_hash_data``: Output hash data signal with a width of `W_HASH`.
    - ``out_ref``: Output reference signal with a width of `W_T`.
    - ``out_d_addr``: Output data address signal with a width of `W_IN_MEM`.
    - ``out_hash_valid``: Output signal indicating the validity of the hash data.
- **Logic and Control Flow**:
    - Uses a parameterized instruction ROM to fetch instructions for execution.
    - Implements a state machine for each tag to manage instruction execution stages: `ST_INIT`, `ST_IDLE`, `ST_FETCH`, `ST_EXEC0`, `ST_EXEC1`, `ST_BLOCK`, and `ST_JMP`.
    - Handles memory operations using dual-port RAMs for data and ternary bit storage.
    - Manages instruction fetching and execution using combinational and sequential logic blocks.
    - Controls the flow of data through the ALU and manages the output of results.
    - Implements a fairness mechanism to balance instruction requests across tags.
    - Uses a fixed pipeline depth to manage the number of inflight instructions.



---
Made with ❤️ by [Driver](https://www.driver.ai/)