<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a SHA-512 preprocessing module with input/output logic and state management.

# Purpose
The `sha512_pre` module is a hardware description for a preprocessing unit used in the SHA-512 hashing algorithm. It is designed to prepare data blocks for the SHA-512 hash computation by managing input and output signals, handling data alignment, and ensuring the correct block size. The module uses parameters such as `W_BLK`, `W_D`, and `BUFF_SZ` to define the width of the data block and buffer size, which are critical for processing 1024-bit blocks as required by the SHA-512 specification.

The module includes several key components, such as functions `n_blks` and `l_to_b`, which calculate the number of blocks needed and convert data from one format to another, respectively. The state machine within the `always_comb` block manages the flow of data through different states, ensuring that data is correctly padded and formatted before being output. The `self_t` structure holds the current and next states of the module, including metadata and data buffers. The module interfaces with external signals through input and output ports, including clock and reset signals, to synchronize operations. This module is part of a larger system that implements the SHA-512 hashing algorithm, focusing on the preprocessing stage.
# Modules

---
### sha512\_pre
Implements a preprocessing stage for the SHA-512 hashing algorithm. Manages input data and prepares it for further processing in the SHA-512 pipeline.
- **Constants**:
    - ``W_BLK``: Defines the block width for the SHA-512 algorithm, set to 1024 bits.
    - ``W_D``: Defines the data width, set to 512 bits.
    - ``BUFF_SZ``: Defines the buffer size, set to 512 bits.
- **Ports**:
    - ``i_r``: Output logic signal indicating readiness.
    - ``i_w``: Input wire signal for write enable.
    - ``i_v``: Input wire signal for valid data.
    - ``i_e``: Input wire signal for end of data.
    - ``i_m``: Input wire for metadata of type `sv_meta2_t`.
    - ``o_v``: Output logic signal indicating valid output data.
    - ``o_e``: Output logic signal indicating end of output data.
    - ``o_m``: Output logic for metadata of type `sv_meta3_t`.
    - ``clk``: Input wire for clock signal.
    - ``rst``: Input wire for reset signal.
- **Logic and Control Flow**:
    - Defines a function `n_blks` to calculate the number of blocks needed based on input size.
    - Defines a function `l_to_b` to convert logic data to byte format.
    - Uses a packed struct `self_t` to store internal state and data.
    - Assigns input metadata `i_m` to internal variable `i_mm`.
    - Assigns readiness signal `i_r` based on `next.ready`.
    - Assigns output signals `o_v`, `o_e`, and `o_m` based on internal state `self`.
    - Uses an `always_comb` block to update `next` state based on current state `self` and input signals.
    - Implements a state machine with states 0 to 5 to manage data processing and transitions.
    - Uses an `always_ff` block to update `self` state on the rising edge of `clk` and reset on `rst`.


# Functions and Tasks

---
### l\_to\_b
Converts a 1024-bit logic vector from little-endian to big-endian format.
- **Inputs**:
    - `l`: A 1024-bit logic vector in little-endian format.
- **Logic and Control Flow**:
    - Declare an integer `i` for loop iteration.
    - Declare a 2D logic array `b` to store the converted big-endian format.
    - Iterate over the 128 8-bit segments of the input vector `l`.
    - For each segment, reverse the order and store it in `b`.
    - Return the big-endian formatted vector `b`.
- **Output**: A 1024-bit logic vector in big-endian format.


---
### n\_blks
Calculates the number of 16-byte blocks required for a given size.
- **Inputs**:
    - `sz`: An 11-bit logic input representing the size to be processed.
- **Logic and Control Flow**:
    - Declare a logic variable `sz2` with the same bit-width as `sz`.
    - Calculate `sz2` by adding 1 and 16 (128/8) to `sz`.
    - Extract the 4 bits starting from bit 7 of `sz2` and add it to the result of a bitwise OR operation on the first 7 bits of `sz2`.
    - Return the calculated value as the number of blocks.
- **Output**: A 4-bit logic value representing the number of 16-byte blocks required.



---
Made with ❤️ by [Driver](https://www.driver.ai/)