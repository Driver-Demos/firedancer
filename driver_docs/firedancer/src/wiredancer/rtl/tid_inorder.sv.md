<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a module to ensure in-order transaction processing with timestamp-based reordering and RAM storage.

# Purpose
The `tid_inorder` module ensures that transactions belonging to each stream are published to the host in the same order as they were invoked. It uses a 64-bit timestamp for timekeeping, which increments with each clock cycle. Transactions are stored in a RAM based on the least significant bits of their transaction ID, along with the current timestamp. A separate RAM keeps track of the last-seen timestamp for each transaction location, which updates only when a new transaction is detected. The output pointer advances only if a transaction has a timestamp newer than its corresponding last-seen timestamp, ensuring in-order delivery.

The module uses two instances of a `simple_dual_port_ram` to manage transaction data and timestamps. The RAM size is proportional to the reordering span, allowing for efficient management of transaction order. The module interfaces include input and output signals for data, valid flags, and control signals, as well as clock and reset inputs. The logic within the module handles the incrementing of timestamps, updating of RAM addresses, and management of valid and ready signals to ensure correct transaction ordering and flow control.
# Modules

---
### tid\_inorder
Manages transactions to ensure they are published in the same order as invoked, using a timestamp for timekeeping. Utilizes dual-port RAMs to store transaction data and timestamps, advancing output pointers based on timestamp comparisons.
- **Constants**:
    - ``W``: Defines the width of the data input and output ports.
    - ``D``: Specifies the depth of the RAM used for storing transactions.
    - ``D_L``: Calculates the address width for the RAM based on the depth `D`.
    - ``W_L``: Calculates the bit width for the data based on the width `W`.
- **Ports**:
    - ``i_v``: Input valid signal for incoming data.
    - ``i_a``: Input address for writing data to RAM.
    - ``i_d``: Input data to be written to RAM.
    - ``i_f``: Output flag indicating if the input counter `i_c` has reached its maximum.
    - ``i_c``: Output counter for tracking the number of valid inputs.
    - ``o_r``: Input ready signal for outgoing data.
    - ``o_v``: Output valid signal for outgoing data.
    - ``o_d``: Output data read from RAM.
    - ``clk``: Clock input for synchronizing operations.
    - ``rst``: Reset input to initialize or reset the module state.
- **Logic and Control Flow**:
    - Uses a 64-bit `timestamp` to keep track of time, incrementing it on each clock cycle.
    - Stores transactions in a dual-port RAM (`ram_inst`) with the current timestamp and data, using the least significant bits of the transaction ID as the address.
    - Maintains a separate RAM (`ts_ram_inst`) to store the last-seen timestamp for each transaction address, updating it only when a transaction is new.
    - Advances the output pointer if the current transaction's timestamp is newer than the last-seen timestamp.
    - Implements an `always_ff` block to update the `timestamp`, `oo_a`, and output signals `o_v` and `o_d` based on the ready signal `oo_r`.
    - Uses a case statement to increment or decrement the input counter `i_c` based on the valid and ready signals.
    - Resets the module state, including `i_c`, `o_v`, `oo_a`, and `timestamp`, when the reset signal `rst` is active.
    - Includes a display statement to output the current state of various signals when either `i_v` or `o_v` is active.



---
Made with ❤️ by [Driver](https://www.driver.ai/)