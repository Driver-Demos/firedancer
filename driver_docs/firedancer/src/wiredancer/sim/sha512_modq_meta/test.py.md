<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests the SHA-512 modulo Q metadata processing using the cocotb framework.

# Purpose
This code is a test suite for a digital design verification environment using the Cocotb framework. It defines an asynchronous test function [`test`](<#test>) that interacts with a device under test (DUT) through a series of operations. The test initializes the DUT's input and output signals and sets up a clock signal using the `Clock` class from Cocotb. It also uses utility functions from the `wd_cocotil` module to manage reset toggling and random signal toggling, as well as to monitor and generate test transactions.

The test function simulates a sequence of operations on the DUT by generating random transactions and sending them to the DUT's input interface. It uses the `RisingEdge` trigger to synchronize operations with the clock edges. The test also manages backpressure conditions by checking the DUT's input and output readiness signals. The transactions are constructed using random parameters and are stored in a queue for verification purposes. The test continues until all transactions are processed, ensuring that the DUT behaves as expected under various conditions.
# Imports and Dependencies

---
- `random`
- `cocotb`
- `cocotb.clock.Clock`
- `cocotb.triggers.Timer`
- `cocotb.triggers.RisingEdge`
- `cocotb.triggers.ReadOnly`
- `cocotb.binary.BinaryValue`
- `wd_cocotil`


# Functions

---
### test<!-- {{#callable:firedancer/src/wiredancer/sim/sha512_modq_meta/test.test}} -->
[View Source →](<../../../../../../src/wiredancer/sim/sha512_modq_meta/test.py#L11>)

Simulates a testbench for a digital design using the cocotb framework.
- **Decorators**: `@cocotb.test`
- **Inputs**:
    - `dut`: The device under test (DUT) which is an object representing the digital design to be tested.
- **Logic and Control Flow**:
    - Initialize DUT signals `i_v`, `o_r`, and `max_pending` to 0, 0, and 100 respectively.
    - Create empty lists `q_i_sha_modq_meta` and `q_o_sha_modq_meta` to store transaction metadata.
    - Start the clock and various asynchronous processes using `cocotb.start()` to manage reset, random toggling, and monitoring of the DUT.
    - Convert `dut.META_W` to an integer `M` for use in metadata operations.
    - Wait for 2048 clock cycles to allow for post-reset and key-store initialization.
    - Initialize `min_l`, `max_l`, and `mlens` for managing message lengths.
    - Generate a random transaction ID `tid` using `wd_cocotil.random_int(64)`.
    - Iterate over a range of `max_l * 2` to simulate transactions.
    - Check for backpressure by waiting for `dut.i_r` to be '1' when `dut.i_v` is '1'.
    - Introduce random gaps by setting `dut.i_v` to 0 based on a random condition.
    - Select a random message length `mlen` from `mlens`, remove it from the list, and create a transaction `tr`.
    - Append the transaction `tr` to `q_i_sha_modq_meta` and store it in `q_o_sha_modq_meta` with `tid` as the key.
    - Build blocks `blks` from the transaction using `wd_cocotil.build_sha_modq_meta_i(tr)` and iterate over them.
    - For each block, check for backpressure and set DUT input signals `i_v`, `i_f`, `i_l`, `i_c`, `i_t`, `i_m`, and `i_d` accordingly.
    - Continue the simulation until `q_o_sha_modq_meta` is empty, indicating all transactions are processed.
- **Output**: No explicit return value; the function operates as a testbench to simulate and verify the behavior of the DUT.



---
Made with ❤️ by [Driver](https://www.driver.ai/)