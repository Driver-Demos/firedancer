<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Tests the ED25519 point doubling operation using the Cocotb framework.

# Purpose
The code is a test suite for a digital design verification environment using the Cocotb framework. It tests a hardware design under test (DUT) by simulating a clock and toggling a reset signal. The test involves generating random inputs and verifying the DUT's output against expected results. The test uses the `wd_cocotil` and `ref_ed25519` modules to generate random integers and perform elliptic curve point operations, respectively. The test iterates 1024 times, during which it generates random elliptic curve points, performs point doubling, and checks if the DUT's output matches the expected results. The test logs information about the operations and asserts the correctness of the DUT's output, ensuring that the hardware design behaves as expected.
# Imports and Dependencies

---
- `random`
- `cocotb`
- `cocotb.clock.Clock`
- `cocotb.triggers.Timer`
- `cocotb.triggers.RisingEdge`
- `cocotb.triggers.ReadOnly`
- `cocotb.binary.BinaryValue`
- `wd_cocotil`
- `ref_ed25519`


# Functions

---
### test<!-- {{#callable:firedancer/src/wiredancer/sim/ed25519_point_dbl/test.test}} -->
[View Source →](<../../../../../../src/wiredancer/sim/ed25519_point_dbl/test.py#L12>)

Executes a test for a digital circuit using a clock and reset signal, performing point multiplication and addition operations, and verifying output values.
- **Decorators**: `@cocotb.test`
- **Inputs**:
    - `dut`: The device under test (DUT) which is a digital circuit model.
- **Logic and Control Flow**:
    - Initialize the clock signal for the DUT and start it with a 1 ns period.
    - Start the reset signal toggle for the DUT with a 32-cycle duration and active high configuration.
    - Wait for 1024 rising edges of the clock signal to synchronize the test.
    - Initialize variables `W_M`, `es`, and `D` for width, storage, and error count respectively.
    - Iterate 1024 times to perform the test loop.
    - Generate a random integer `m_i` within the range of `W_M`.
    - Select a random point `P0` from predefined options or by multiplying a random integer with a base point `G`.
    - Compute `P2` by adding `P0` to itself using point addition.
    - Store the tuple `(P2, m_i)` in the list `es`.
    - Convert the coordinates of `P0` into 255-bit binary values and assign them to the DUT's input ports.
    - Set the DUT's `m_i` input by shifting `m_i` left by one and setting the least significant bit to 1.
    - Wait for a rising edge of the clock signal.
    - Check if the least significant bit of `dut.m_o` is not '1', increment `D`, assert `D` is less than 100, and continue to the next iteration if true.
    - Pop the first element from `es` to retrieve `P2` and `m_i`.
    - Read the output coordinates and `m_o` from the DUT and shift `m_o` right by one.
    - Log the current iteration, error count, and compare expected and actual values for `m_i`, `x`, `y`, `z`, and `t`.
    - Assert that the expected and actual values for `x`, `y`, `z`, `t`, and `m_i` match.
- **Output**: No explicit return value; the function performs assertions and logs information during execution.



---
Made with ❤️ by [Driver](https://www.driver.ai/)