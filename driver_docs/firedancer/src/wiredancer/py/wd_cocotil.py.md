<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements various functions and coroutines for testing and verifying Ed25519 signatures using cocotb.

# Purpose
The code is a test suite for verifying the functionality of a digital signature verification system using the Ed25519 algorithm. It uses the `cocotb` library to simulate and test the behavior of hardware components in a digital circuit. The code includes several asynchronous functions that monitor and verify the data transactions and operations within the system, such as [`mon_pcie_tr_ext`](<#mon_pcie_tr_ext>), [`mon_sha_pre`](<#mon_sha_pre>), [`mon_sha_modq_meta`](<#mon_sha_modq_meta>), and others. These functions check the correctness of data being processed and ensure that the system adheres to expected behaviors.

The code also defines several utility functions for data manipulation and conversion, such as [`bytes_to_little`](<#bytes_to_little>), [`little_to_str`](<#little_to_str>), and [`random_int`](<#random_int>). It includes functions for building and verifying data structures related to the Ed25519 signature verification process, such as [`build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>) and [`build_ed25519_sigverify_1_o`](<#build_ed25519_sigverify_1_o>). The test suite is designed to be comprehensive, covering various aspects of the signature verification process, including data preparation, transaction monitoring, and result validation. The code is structured to facilitate the testing of the digital signature verification system in a simulated environment, ensuring its reliability and correctness.
# Imports and Dependencies

---
- `random`
- `hashlib`
- `cocotb`
- `cocotb.clock.Clock`
- `cocotb.triggers.Timer`
- `cocotb.triggers.RisingEdge`
- `cocotb.triggers.ReadOnly`
- `cocotb.binary.BinaryValue`
- `cocotb.utils.get_sim_time`
- `ed25519_lib`
- `ref_ed25519`
- `sigverify`


# Global Variables

---
### PCIE\_MAGIC
- **Type**: ``int``
- **Description**: A hexadecimal constant with the value `0xACE0FBAC`. This value is used as a magic number in the code.
- **Use**: Used in the `build_pcie_tr_i` function to construct a block of data for PCIe transactions.


---
### PCIE\_ADDR\_W
- **Type**: `int`
- **Description**: Defines the width of the PCIe address in bits.
- **Use**: Used to specify the bit-width for PCIe address operations.


---
### meta0
- **Type**: ``list``
- **Description**: Contains two integer elements: 16 and 64. This list is used as a base for other lists in the code.
- **Use**: Serves as a foundational list for constructing other lists like `meta1`, `meta6`, and `meta7`.


---
### meta1
- **Type**: `list`
- **Description**: Contains a list of integers that is the result of concatenating the list `meta0` with three additional integers `[256, 256, 256]`. The list `meta0` is defined as `[16, 64]`, so `meta1` becomes `[16, 64, 256, 256, 256]`. This list is used to define other variables such as `meta2`, `meta3`, and `meta4`. 
- **Use**: Used as a base list to define other metadata lists by concatenating additional elements.


---
### meta2
- **Type**: ``list``
- **Description**: Contains a list of integers that is a combination of the list `meta1` and additional integers `[16, 6, 1, 512]`. The list `meta1` itself is derived from `meta0` with additional integers `[256, 256, 256]`. Thus, `meta2` is `[16, 64, 256, 256, 256, 16, 6, 1, 512]`. This list is used to define metadata for operations in the code.
- **Use**: Used in the `extr_meta` function to extract metadata from a given integer `m` based on the bit lengths specified in `meta2`.


---
### meta3
- **Type**: `list`
- **Description**: Contains a list of integers that is a combination of the list `meta1` and additional integers `[1, 4, 1024]`. The list `meta1` itself is derived from `meta0` with additional integers `[256, 256, 256]`. Thus, `meta3` is a list of integers `[16, 64, 256, 256, 256, 1, 4, 1024]`.
- **Use**: Used to store a specific sequence of integers that may represent configuration or parameters for further processing in the code.


---
### meta4
- **Type**: `list`
- **Description**: `meta4` is a list that is created by appending the integer `256` to the list `meta1`. The list `meta1` itself is a combination of the list `meta0` and three additional `256` values.
- **Use**: Used as part of a series of meta lists that likely serve as configuration or parameter sets for other operations in the code.


---
### meta5
- **Type**: `list`
- **Description**: `meta5` is a list that is created by concatenating the list `meta4` with a list containing eight elements, each with the value 256. `meta4` itself is derived from `meta1` by appending a single element with the value 256, where `meta1` is a list that extends `meta0` with three elements, each with the value 256. `meta0` is a list containing the elements 16 and 64.
- **Use**: Used to define a specific configuration or set of parameters by extending `meta4` with additional elements.


---
### meta6
- **Type**: `list`
- **Description**: Contains a list of integers that is a combination of the list `meta0` and five occurrences of the integer 256, followed by the integer 1. The list `meta0` is defined as `[16, 64]`, so `meta6` results in `[16, 64, 256, 256, 256, 256, 256, 1]`.
- **Use**: Used to define a specific configuration or parameter set in the code, likely for a hardware or simulation setup.


---
### meta7
- **Type**: `list`
- **Description**: A list that is created by adding the integer `1` to the list `meta0`. The list `meta0` contains the integers `16` and `64`. Thus, `meta7` becomes `[16, 64, 1]`. This list is a simple extension of `meta0` with an additional element.
- **Use**: Used to store a specific sequence of integers derived from `meta0` with an additional element `1`.


# Functions

---
### get\_cycle<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.get_cycle}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L28>)

Returns the current simulation time in nanoseconds.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the `get_sim_time` function with the argument `'ns'` to get the current simulation time in nanoseconds.
    - Returns the result of the `get_sim_time` function call.
- **Output**: The current simulation time in nanoseconds as returned by `get_sim_time`. 


---
### f1\_write\_32x16<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.f1_write_32x16}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L31>)

Writes a 512-bit data value to a PCIe interface in either a single or split transaction.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `dut`: The device under test (DUT) object that represents the hardware interface.
    - `clk`: The clock signal used to synchronize the write operation.
    - `addr`: The address to which the data will be written.
    - `data`: The 512-bit data value to be written to the PCIe interface.
- **Logic and Control Flow**:
    - Initialize a `BinaryValue` object `b` with 512 bits and set its value to `data`.
    - Check the value of `split`. If `split` is 0, perform a single transaction write.
    - In the single transaction case, set `dut.pcie_v` to 0x3, assign `addr` to `dut.pcie_a`, and split `b` into two 256-bit parts assigned to `dut.pcie_d[0]` and `dut.pcie_d[1]`.
    - Await a rising edge on `clk` and then set `dut.pcie_v` to 0x0 to complete the transaction.
    - If `split` is not 0, perform a split transaction write.
    - In the split transaction case, set `dut.pcie_v` to 0x1, assign `addr` to `dut.pcie_a`, and assign the first 256 bits of `b` to `dut.pcie_d[0]`.
    - Await a rising edge on `clk`, then set `dut.pcie_v` to 0x2, increment `addr` by 32, and assign the second 256 bits of `b` to `dut.pcie_d[1]`.
    - Await another rising edge on `clk` and set `dut.pcie_v` to 0x0 to complete the transaction.
- **Output**: No explicit return value; the function performs write operations on the DUT.


---
### sha512\_modq\_from\_bytes<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.sha512_modq_from_bytes}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L55>)

Computes the SHA-512 hash of the input bytes, converts it to a little-endian integer, and returns the result modulo a predefined constant.
- **Inputs**:
    - `s`: A byte string to hash using SHA-512.
- **Logic and Control Flow**:
    - Compute the SHA-512 hash of the input byte string `s` and store the result in `h`.
    - Define a constant `q` as `2**252 + 27742317777372353535851937790883648493`.
    - Convert the hash `h` to a little-endian integer using the [`bytes_to_little`](<#bytes_to_little>) function.
    - Return the result of the little-endian integer modulo `ref_ed25519.q`.
- **Output**: An integer which is the SHA-512 hash of the input bytes, converted to little-endian, and taken modulo `ref_ed25519.q`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bytes_to_little`](<#bytes_to_little>)


---
### sha512\_modq\_from\_ints<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.sha512_modq_from_ints}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L60>)

Converts a list of integers to a byte array and computes the SHA-512 hash modulo a large prime number.
- **Inputs**:
    - `s`: A list of integers that will be converted to a byte array for hashing.
- **Logic and Control Flow**:
    - Converts the input list of integers `s` into a `bytearray`.
    - Calls the function [`sha512_modq_from_bytes`](<#sha512_modq_from_bytes>) with the `bytearray` as an argument.
    - Returns the result of the [`sha512_modq_from_bytes`](<#sha512_modq_from_bytes>) function.
- **Output**: The result of the SHA-512 hash of the input integers modulo a large prime number.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.sha512_modq_from_bytes`](<#sha512_modq_from_bytes>)


---
### bytes\_to\_little<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.bytes_to_little}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L63>)

Converts a byte sequence to a little-endian integer.
- **Inputs**:
    - `s`: A sequence of bytes to convert to a little-endian integer.
- **Logic and Control Flow**:
    - Initialize an integer `n` to 0.
    - Iterate over each byte in the input sequence `s`.
    - For each byte, shift it left by `i*8` bits, where `i` is the index of the byte, and add the result to `n`.
    - Return the accumulated value `n`.
- **Output**: An integer representing the little-endian conversion of the input byte sequence.


---
### str\_to\_little<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.str_to_little}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L69>)

Converts a string to a little-endian integer representation.
- **Inputs**:
    - `s`: A string to convert to a little-endian integer.
- **Logic and Control Flow**:
    - Initialize an integer `n` to 0.
    - Iterate over each character in the string `s`.
    - For each character, convert it to its ASCII value using `ord()`, shift it left by `i*8` bits, and add it to `n`.
- **Output**: An integer representing the little-endian conversion of the input string.


---
### little\_to\_str<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.little_to_str}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L75>)

Converts a little-endian integer to a string of characters.
- **Inputs**:
    - `n`: An integer representing the little-endian encoded data.
    - `bs`: An integer specifying the number of bytes to process from the integer.
- **Logic and Control Flow**:
    - Initialize an empty string `s`.
    - Iterate over a range of `bs` to process each byte.
    - In each iteration, extract 8 bits from `n` starting at position `i*8` using the [`bits`](<#bits>) function.
    - Convert the extracted bits to a character using `chr` and append it to `s`.
    - Return the constructed string `s`.
- **Output**: A string constructed from the bytes of the input integer `n`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### little\_to\_ints<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.little_to_ints}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L81>)

Converts a given integer into a list of integers, each representing a byte of the original integer.
- **Inputs**:
    - `n`: The integer to convert into bytes.
    - `bs`: The number of bytes to extract from the integer.
- **Logic and Control Flow**:
    - Uses a list comprehension to iterate over a range of size `bs`.
    - For each iteration, calls the [`bits`](<#bits>) function to extract an 8-bit segment from `n`, starting at the bit position `i*8`.
    - Collects the extracted bytes into a list.
- **Output**: A list of integers, each representing a byte extracted from the input integer `n`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### lfsr\_32<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.lfsr_32}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L84>)

Implements a 32-bit Linear Feedback Shift Register (LFSR) operation.
- **Inputs**:
    - `lfsr`: An integer representing the current state of the 32-bit LFSR.
- **Logic and Control Flow**:
    - Calculates the feedback bit `fb` by XORing specific bits of the `lfsr` state: bits at positions 0, 1, 21, and 31.
    - Shifts the `lfsr` state left by one bit and appends the feedback bit `fb` to the least significant bit position.
    - Returns the new state of the LFSR.
- **Output**: An integer representing the updated state of the 32-bit LFSR after the shift and feedback operation.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### log2<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.log2}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L88>)

Calculates the base-2 logarithm of a given number and returns it as an integer.
- **Inputs**:
    - `n`: The number for which to calculate the base-2 logarithm.
- **Logic and Control Flow**:
    - Uses the `math.log` function to calculate the natural logarithm of `n` and divides it by the natural logarithm of 2 to get the base-2 logarithm.
    - Converts the result to an integer using the `int` function.
- **Output**: An integer representing the base-2 logarithm of the input number `n`.


---
### bits<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.bits}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L91>)

Extracts a specified number of bits from an integer starting at a given bit position.
- **Inputs**:
    - `n`: The integer from which to extract bits.
    - `b`: The number of bits to extract.
    - `s`: The starting bit position for extraction.
- **Logic and Control Flow**:
    - Shift the integer `n` right by `s` positions to align the desired bits with the least significant bit.
    - Create a bitmask by shifting 1 left by `b` positions and subtracting 1 to get a mask with `b` least significant bits set to 1.
    - Apply the bitmask to the shifted integer using a bitwise AND operation to extract the desired bits.
- **Output**: Returns an integer representing the extracted bits.


---
### random\_int<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.random_int}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L94>)

Generates a random integer with a specified number of bits.
- **Inputs**:
    - `b`: The number of bits for the random integer, default is 32.
- **Logic and Control Flow**:
    - Initialize a variable `n` to 0.
    - Iterate `b` times, where `b` is the number of bits specified.
    - In each iteration, left-shift `n` by 1 bit.
    - Use `random.randint(0, 1)` to generate a random bit and OR it with `n`.
- **Output**: A random integer with `b` bits.


---
### gen\_blocks\_from\_msg\_str<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.gen_blocks_from_msg_str}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L101>)

Converts a message string into a list of 1024-bit integer blocks with padding and length encoding.
- **Inputs**:
    - `m_str`: A string where each character represents one byte of the message to process.
- **Logic and Control Flow**:
    - Convert each character in `m_str` to its hexadecimal representation and concatenate them to form a hex string `m`.
    - Calculate the length of the hex string `m` and store it in `mlen_c`.
    - Append '80' to `m` to indicate the start of padding, increasing the length by 2 characters.
    - Calculate the total length of the message block including padding (`blen_c`) and determine the required zero padding (`zlen_c`) to make the block length a multiple of 1024 bits.
    - Append the calculated number of zeros to `m` to achieve the required block length.
    - Append the original message length in bits, formatted as a 32-character hexadecimal string, to `m`.
    - Ensure the final length of `m` is a multiple of 1024 bits, raising an assertion error if not.
    - Divide `m` into 1024-bit blocks, convert each block from hexadecimal to an integer, and store them in a list `B`.
- **Output**: A list of integers, each representing a 1024-bit block of the processed message.


---
### random\_tr<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.random_tr}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L132>)

Generates a transaction dictionary with random or specified values and performs signature verification.
- **Inputs**:
    - `src`: The source identifier for the transaction, default is 0.
    - `sha_pre_meta`: Pre-computed SHA pre-meta data, default is None.
    - `sha_modq_meta`: Pre-computed SHA modq meta data, default is None.
    - `tid`: Transaction ID, default is None.
    - `mlen`: Message length, default is None.
    - `sig`: Signature data, default is None.
    - `pub`: Public key data, default is None.
    - `msg`: Message data, default is None.
- **Logic and Control Flow**:
    - If `mlen` is None, set `mlen` to a random integer between 0 and 1280.
    - If `msg` is None, generate a random message of length `mlen`.
    - Initialize a dictionary `tr` to store transaction data.
    - Populate `tr` with random or specified values for various fields such as `dma_addr`, `dma_seq`, `dma_ctrl`, `dma_size`, `dma_chunk`, `time_0`, `time_1`, `time_2`, `time_3`, `err`, `src`, `tid`, `sig_l`, `sig_h`, `pub`, `msg_sz`, `msg_s`.
    - Convert `sig_l`, `pub`, and `msg_s` to integers and store in `sha_msg`.
    - Compute `sha_modq` using [`sha512_modq_from_ints`](<#sha512_modq_from_ints>) on `sha_msg`.
    - Set `sha_pre_meta` and `sha_modq_meta` to provided values or compute them using [`build_sha_pre_meta`](<#build_sha_pre_meta>) and [`build_sha_modq_meta`](<#build_sha_modq_meta>).
    - Build `pcie_tr` using [`build_pcie_tr_i`](<#build_pcie_tr_i>).
    - Perform signature verification using `ref_ed25519.verify` and store the result in `sigverify`.
    - Print the `sigverify` result.
    - Return the transaction dictionary `tr`.
- **Output**: A dictionary `tr` containing transaction data with fields such as `dma_addr`, `dma_seq`, `dma_ctrl`, `dma_size`, `dma_chunk`, `time_0`, `time_1`, `time_2`, `time_3`, `err`, `src`, `tid`, `sig_l`, `sig_h`, `pub`, `msg_sz`, `msg_s`, `sha_msg`, `sha_modq`, `sha_pre_meta`, `sha_modq_meta`, `pcie_tr`, and `sigverify`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.random_int`](<#random_int>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.little_to_ints`](<#little_to_ints>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.sha512_modq_from_ints`](<#sha512_modq_from_ints>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_sha_pre_meta`](<#build_sha_pre_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_sha_modq_meta`](<#build_sha_modq_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_pcie_tr_i`](<#build_pcie_tr_i>)


---
### toggle\_reset<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.toggle_reset}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L180>)

Toggles the reset signal after a specified number of clock cycles.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `clk`: The clock signal to synchronize the reset toggling.
    - `reset`: The reset signal to be toggled.
    - `n`: The number of clock cycles to wait before toggling the reset signal.
    - `active_high`: A boolean indicating if the reset is active high (default is True).
- **Logic and Control Flow**:
    - Set the reset signal to the active state based on the 'active_high' parameter.
    - Wait for 'n' rising edges of the clock signal.
    - Set the reset signal to the inactive state by negating the 'active_high' parameter.
    - Wait for 'n' more rising edges of the clock signal.
- **Output**: No return value; modifies the 'reset' signal in place.


---
### random\_toggle<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.random_toggle}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L188>)

Toggles the value of `s` based on a random probability `p` at each rising edge of the clock `clk`.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `clk`: The clock signal that triggers the toggle operation.
    - `s`: An object with a `value` attribute that will be toggled.
    - `p`: The probability (0-99) that determines the likelihood of `s.value` being set to 1.
- **Logic and Control Flow**:
    - Enters an infinite loop to continuously monitor the clock signal.
    - Waits for a rising edge on the `clk` signal using `await RisingEdge(clk)`.
    - Generates a random integer between 0 and 99 using `random.randint(0, 99)`.
    - Compares the random integer to `p` to decide if `s.value` should be set to 1 (if the random integer is less than `p`) or 0 otherwise.
- **Output**: No return value; modifies `s.value` directly.


---
### build\_meta0<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_meta0}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L193>)

Constructs a 64-bit integer by combining the 'src' and 'tid' fields from the input dictionary 'tr'.
- **Inputs**:
    - `tr`: A dictionary containing at least the keys 'src' and 'tid', which are used to build the meta value.
- **Logic and Control Flow**:
    - Initialize a variable 'm' to 0.
    - Shift the value of 'tr['src']' left by 0 bits and OR it with 'm'.
    - Shift the value of 'tr['tid']' left by 32 bits and OR it with 'm'.
    - Return the resulting value of 'm'.
- **Output**: A 64-bit integer that combines the 'src' and 'tid' fields from the input dictionary.


---
### extr\_meta<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.extr_meta}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L199>)

Extracts specific bit segments from a number based on a list of bit lengths.
- **Inputs**:
    - `m`: A list of integers representing the bit lengths to extract from the number.
    - `n`: An integer from which to extract the bit segments.
- **Logic and Control Flow**:
    - Initialize a variable `s` to 0 to keep track of the starting bit position for extraction.
    - Initialize an empty list `l` to store the extracted bit segments.
    - Iterate over each bit length `b` in the list `m`.
    - For each bit length `b`, call the [`bits`](<#bits>) function to extract a segment of `b` bits from `n`, starting at position `s`, and append the result to the list `l`.
    - Increment `s` by `b` to update the starting position for the next extraction.
    - After processing all bit lengths, return the list `l` as a tuple.
- **Output**: A tuple containing the extracted bit segments from the number `n`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### random\_byte\_error<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.random_byte_error}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L207>)

Introduces a random bit error into a byte array.
- **Inputs**:
    - `bs`: A byte array to introduce a random bit error into.
- **Logic and Control Flow**:
    - Convert the input byte array `bs` into a list `l`.
    - Select a random index `i` within the range of the list `l`.
    - Select a random bit position `j` within a byte (0 to 7).
    - Check if the bit at position `j` in the byte at index `i` is set.
    - If the bit is set, clear it by subtracting `1 << j` from the byte.
    - If the bit is not set, set it by adding `1 << j` to the byte.
    - Return the modified list `l`.
- **Output**: A list of bytes with one random bit error introduced.


---
### build\_pcie\_tr\_i<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_pcie_tr_i}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L239>)

Constructs a list of blocks from a transaction dictionary for PCIe communication.
- **Inputs**:
    - `tr`: A dictionary containing transaction data with keys such as 'src', 'msg_s', 'dma_size', 'dma_ctrl', 'dma_addr', 'dma_seq', 'dma_chunk', 'sig_l', 'sig_h', and 'pub'.
- **Logic and Control Flow**:
    - Initialize an empty list `blks` to store blocks.
    - Create a block `blk` and set its initial value to 0.
    - Set the first block with PCIe magic number, source, message size, DMA size, control, address, sequence, and chunk, then append it to `blks`.
    - Create a second block with signature high and public key, then append it to `blks`.
    - Iterate over the message string `msg_s` in chunks of 64 bytes, creating blocks and appending them to `blks`.
    - If there are remaining bytes after the loop, append the final block to `blks`.
- **Output**: A list of integer blocks representing the transaction data for PCIe communication.


---
### build\_pcie\_tr\_o<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_pcie_tr_o}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L278>)

Converts a transaction dictionary into a list of 512-bit blocks for PCIe transmission.
- **Inputs**:
    - `tr`: A dictionary containing transaction data with keys 'sig_l', 'pub', and 'msg_s'.
- **Logic and Control Flow**:
    - Initialize an empty list 'blks' to store the blocks.
    - Create a 512-bit block 'blk' and set its lower 256 bits to 'tr['sig_l']' and upper 256 bits to 'tr['pub']'.
    - Append the block 'blk' to the list 'blks'.
    - Initialize a new block 'blk' and a byte index 'bi'.
    - Iterate over the message bytes in 'tr['msg_s']'.
    - For each byte, shift it by 'bi*8' and OR it into 'blk'.
    - Increment 'bi' and check if 'bi' equals 64 (512 bits).
    - If 'bi' equals 64, append 'blk' to 'blks', reset 'blk' and 'bi'.
    - After the loop, if 'bi' is not zero, append the remaining 'blk' to 'blks'.
- **Output**: A list of 512-bit blocks representing the transaction data for PCIe transmission.


---
### mon\_pcie\_tr\_ext<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_pcie_tr_ext}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L303>)

Monitors and verifies PCIe transactions by comparing expected and actual data.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) for logging purposes.
    - `dut`: The actual device under test (DUT) to monitor.
    - `clk`: The clock signal to synchronize the monitoring process.
    - `q_i`: An optional queue of expected input transactions.
    - `q_o`: An optional queue of expected output transactions.
    - `do_log`: A boolean flag to enable or disable logging of transaction details.
- **Logic and Control Flow**:
    - Initialize empty lists `refs_i` and `refs_o` to store expected input and output transaction data.
    - Enter an infinite loop to continuously monitor the PCIe transactions.
    - Wait for a rising edge of the clock signal `clk`.
    - If `q_i` is not None and `dut.pcie_v` is '1', process input transactions:
    - - If `refs_i` is empty, pop a transaction from `q_i` and build expected input data using [`build_pcie_tr_i`](<#build_pcie_tr_i>).
    - - Compare the actual data from `dut.pcie_d` with the expected data from `refs_i`.
    - - Log the comparison if `do_log` is True and assert that the data matches.
    - If `dut.o_v` and `dut.o_r` are '1' and `q_o` is not None, process output transactions:
    - - Extract metadata from `dut.o_m0` using [`extr_meta`](<#extr_meta>).
    - - If `refs_o` is empty, pop a transaction from `q_o` and build expected output data using [`build_pcie_tr_o`](<#build_pcie_tr_o>).
    - - Compare the actual output data with the expected data from `refs_o`.
    - - Log the comparison if `do_log` is True and assert that the data matches.
- **Output**: No explicit return value; the function asserts the correctness of PCIe transactions.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_pcie_tr_i`](<#build_pcie_tr_i>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.extr_meta`](<#extr_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_pcie_tr_o`](<#build_pcie_tr_o>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### build\_sha\_pre\_meta<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_sha_pre_meta}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L433>)

Constructs a metadata integer by combining specific fields from the input dictionary `tr` using bitwise operations.
- **Inputs**:
    - `tr`: A dictionary containing keys 'src', 'tid', 'sig_h', 'sig_l', and 'pub', each associated with integer values.
- **Logic and Control Flow**:
    - Initialize an integer `m` to 0.
    - Use bitwise OR and left shift operations to combine the 'src' field into `m`.
    - Combine the 'tid' field into `m` by shifting it 32 bits to the left.
    - Combine the 'sig_h' field into `m` by shifting it 96 bits to the left.
    - Combine the 'sig_l' field into `m` by shifting it 352 bits to the left.
    - Combine the 'pub' field into `m` by shifting it 608 bits to the left.
    - Return the constructed integer `m`.
- **Output**: An integer representing the combined metadata from the input dictionary `tr`.


---
### build\_sha\_pre\_o<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_sha_pre_o}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L442>)

Generates a list of tuples containing transaction metadata and SHA pre-processing blocks.
- **Inputs**:
    - `tr`: A dictionary containing transaction data, including 'src', 'tid', 'sig_l', 'sig_h', 'pub', and 'sha_msg'.
- **Logic and Control Flow**:
    - Calls [`gen_blocks_from_msg_str`](<#gen_blocks_from_msg_str>) with `tr['sha_msg']` to generate SHA pre-processing blocks.
    - Iterates over each block in the generated SHA pre-processing blocks.
    - For each block, creates a tuple with transaction metadata and block-specific data.
    - Includes flags to indicate the first and last block in the sequence.
    - Returns a list of tuples, each containing transaction metadata and a SHA pre-processing block.
- **Output**: A list of tuples, each containing transaction metadata and a SHA pre-processing block.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.gen_blocks_from_msg_str`](<#gen_blocks_from_msg_str>)


---
### mon\_sha\_pre<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_sha_pre}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L456>)

Monitors and verifies SHA pre-processing outputs against expected values in a simulation environment.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The design under test (DUT) object for logging and interaction.
    - `dut`: The device under test (DUT) object for accessing signals.
    - `clk`: The clock signal to synchronize operations.
    - `q_i`: An optional input queue for expected input transactions (default is None).
    - `q_o`: An optional output queue for expected output transactions (default is None).
    - `do_log`: A boolean flag to enable or disable logging of detailed information (default is False).
- **Logic and Control Flow**:
    - Initialize an empty list `q_bo` to store expected output transactions.
    - Enter an infinite loop to continuously monitor the DUT.
    - Wait for a rising edge on the `clk` signal to synchronize operations.
    - Check if the output valid signal `dut.o_v` is '1'.
    - If `q_o` is not None and `q_bo` is empty, pop a transaction from `q_o`, record the current cycle time, and build expected output transactions using [`build_sha_pre_o`](<#build_sha_pre_o>).
    - Log the transaction details if logging is enabled.
    - Extract metadata from the DUT's output using [`extr_meta`](<#extr_meta>) and compare it with the expected values from `q_bo`.
    - Log detailed comparison information if logging is enabled.
    - Assert that all extracted metadata values match the expected values.
- **Output**: No return value; the function performs assertions and logging for verification purposes.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_sha_pre_o`](<#build_sha_pre_o>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.extr_meta`](<#extr_meta>)


---
### build\_sha\_modq\_o<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_sha_modq_o}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L551>)

Extracts specific fields from a transaction dictionary and returns them as a tuple.
- **Inputs**:
    - `tr`: A dictionary representing a transaction with keys such as 'src', 'tid', 'sig_l', 'sig_h', 'pub', and 'sha_modq'.
- **Logic and Control Flow**:
    - Accesses the 'src' field from the input dictionary 'tr'.
    - Accesses the 'tid' field from the input dictionary 'tr'.
    - Accesses the 'sig_l' field from the input dictionary 'tr'.
    - Accesses the 'sig_h' field from the input dictionary 'tr'.
    - Accesses the 'pub' field from the input dictionary 'tr'.
    - Accesses the 'sha_modq' field from the input dictionary 'tr'.
    - Returns a tuple containing the accessed fields in the order: 'src', 'tid', 'sig_l', 'sig_h', 'pub', 'sha_modq'.
- **Output**: A tuple containing the values of 'src', 'tid', 'sig_l', 'sig_h', 'pub', and 'sha_modq' from the input dictionary.


---
### build\_sha\_modq\_meta<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_sha_modq_meta}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L561>)

Constructs a metadata integer by combining several fields from the input dictionary `tr` using bitwise operations.
- **Inputs**:
    - `tr`: A dictionary containing keys 'src', 'tid', 'sig_h', 'sig_l', and 'pub', each associated with an integer value.
- **Logic and Control Flow**:
    - Initialize an integer `m` to 0.
    - Shift the value of `tr['src']` by 0 bits and combine it with `m` using a bitwise OR operation.
    - Shift the value of `tr['tid']` by 32 bits and combine it with `m` using a bitwise OR operation.
    - Shift the value of `tr['sig_h']` by 96 bits and combine it with `m` using a bitwise OR operation.
    - Shift the value of `tr['sig_l']` by 352 bits and combine it with `m` using a bitwise OR operation.
    - Shift the value of `tr['pub']` by 608 bits and combine it with `m` using a bitwise OR operation.
    - Return the final value of `m`.
- **Output**: An integer `m` that represents the combined metadata from the input dictionary `tr`.


---
### build\_sha\_modq\_meta\_i<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_sha_modq_meta_i}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L570>)

Generates metadata tuples for SHA message blocks with transaction details.
- **Inputs**:
    - `tr`: A dictionary containing transaction details, including 'sha_msg', 'tid', and 'sha_modq_meta'.
- **Logic and Control Flow**:
    - Call [`gen_blocks_from_msg_str`](<#gen_blocks_from_msg_str>) with `tr['sha_msg']` to generate blocks from the SHA message string.
    - Iterate over each block index `i` in the list of blocks.
    - For each block, create a tuple containing: a flag indicating if it is the first block, a flag indicating if it is the last block, the total number of blocks, the transaction ID (`tr['tid']`), the SHA modq metadata (`tr['sha_modq_meta']`), and the block itself.
    - Return a list of these tuples.
- **Output**: A list of tuples, each containing metadata for a block of the SHA message.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.gen_blocks_from_msg_str`](<#gen_blocks_from_msg_str>)


---
### mon\_sha\_modq\_meta<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_sha_modq_meta}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L582>)

Monitors and verifies SHA-512 message processing and metadata extraction in a simulation environment.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) object for logging and interaction.
    - `dut`: The device under test (DUT) object for signal access.
    - `clk`: The clock signal to synchronize operations.
    - `q_i`: An optional input queue for incoming transactions.
    - `q_o`: An optional output queue for outgoing transactions.
    - `do_log`: A boolean flag to enable or disable logging.
- **Logic and Control Flow**:
    - Initializes a counter `i_cnt` and an empty list `q_bi` for tracking input transactions.
    - Enters an infinite loop, waiting for a rising edge on the `clk` signal.
    - Asserts that there are no gaps in input transactions by checking `i_cnt` and `dut.i_v`.
    - If both `dut.i_v` and `dut.i_r` are '1', extracts metadata from `dut.i_m` and updates `i_cnt`.
    - If `q_i` is not `None`, processes input transactions by popping from `q_i` and building metadata blocks.
    - Logs and asserts that extracted and expected metadata match if `do_log` is `True`.
    - If `dut.o_v` is '1', processes output transactions by extracting metadata from `dut.o_m` and updating `q_o`.
    - Logs transaction details and asserts that extracted and expected metadata match if `do_log` is `True`.
- **Output**: No explicit return value; the function operates asynchronously and interacts with the DUT.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.extr_meta`](<#extr_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_sha_modq_meta_i`](<#build_sha_modq_meta_i>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_sha_modq_o`](<#build_sha_modq_o>)


---
### mon\_ed25519\_sigverify\_dsdp\_mul<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_ed25519_sigverify_dsdp_mul}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L736>)

Monitors and verifies Ed25519 signature verification using DSDP multiplication in a coroutine loop.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `dut`: The device under test, which is an object representing the hardware module being tested.
    - `clk`: The clock signal used to synchronize the coroutine with the hardware module.
    - `q_i`: An optional input queue containing expected input transactions for verification.
    - `q_o`: An optional output queue containing expected output transactions for verification.
    - `do_print`: A boolean flag to enable or disable printing of debug information.
    - `self_test`: A boolean flag to enable or disable self-testing mode.
- **Logic and Control Flow**:
    - Enters an infinite loop, waiting for a rising edge of the clock signal using `RisingEdge(clk)`.
    - Checks if the input signals `dut.i_v` and `dut.i_r` are both '1', indicating valid input data.
    - If `q_i` is not None, retrieves and removes the transaction from `q_i` using the index `i_m` from `dut.i_m`.
    - Calls `build_ed25519_sigverify_0_o(tr)` to generate expected values for signature verification.
    - Compares expected values with actual values from `dut` and prints debug information if `do_print` is True.
    - Asserts that the expected and actual values match for various components of the signature verification.
    - Checks if the output signal `dut.o_v` is '1', indicating valid output data.
    - If `q_o` is not None, retrieves and removes the expected output transaction from `q_o` using the index `o_m` from `dut.o_m`.
    - Compares expected output data with actual output data from `dut` and prints debug information if `do_print` is True.
    - Asserts that the expected and actual output data match, including a mathematical check for `o_d[3]`.
- **Output**: No return value; the function performs verification and assertions within the coroutine.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### build\_ed25519\_sigverify\_0\_o<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_ed25519_sigverify_0_o}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L873>)

Processes a transaction dictionary to verify an Ed25519 signature and returns a tuple with transaction details and verification results.
- **Inputs**:
    - `tr`: A dictionary containing transaction data, including public key, signature parts, and other related fields.
- **Logic and Control Flow**:
    - Calls `sigverify.ksigverify_split0` with expressions derived from the transaction dictionary and reference Ed25519 parameters to perform signature verification.
    - Evaluates the result of the signature verification process and stores it in a tuple.
    - Returns a tuple containing the source, transaction ID, signature parts, public key, SHA-512 mod q value, and the evaluated signature verification results.
- **Output**: A tuple containing the source, transaction ID, signature parts, public key, SHA-512 mod q value, and the evaluated signature verification results.


---
### mon\_ed25519\_sigverify\_0<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_ed25519_sigverify_0}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L895>)

Monitors and verifies Ed25519 signature verification process by comparing expected and actual outputs.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) instance for logging.
    - `dut`: The DUT instance to monitor.
    - `clk`: The clock signal to synchronize operations.
    - `q_i`: An optional queue for input transactions.
    - `q_o`: An optional queue for output transactions.
    - `do_log`: A boolean flag to enable or disable logging.
- **Logic and Control Flow**:
    - Enters an infinite loop to continuously monitor the DUT.
    - Waits for a rising edge of the clock signal `clk`.
    - Checks if the input signals `i_v` and `i_r` of `dut` are both '1', logs the event if true.
    - Checks if the output signal `o_v` of `dut` is '1', indicating valid output data.
    - Extracts metadata from the output signal `o_m` using [`extr_meta`](<#extr_meta>) function.
    - If `q_o` is not None, retrieves and removes the transaction from `q_o` using the transaction ID `o_tid`.
    - Logs the transaction details and updates the transaction's time.
    - Builds expected output using [`build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>) function.
    - If `do_log` is true, logs the comparison between expected and actual outputs.
    - Asserts that all expected values match the actual output values.
- **Output**: No direct output; it logs information and performs assertions to verify correctness.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.extr_meta`](<#extr_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>)


---
### build\_ed25519\_sigverify\_1\_o<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.build_ed25519_sigverify_1_o}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L1042>)

Performs an Ed25519 signature verification operation using DSDP multiplication and returns a tuple of transformed transaction data.
- **Inputs**:
    - `tr`: A dictionary containing transaction data, including fields like 'src', 'tid', 'sig_l', 'sig_h', 'pub', and 'sha_modq'.
    - `DSDP_WS`: An integer specifying the workspace size for the DSDP multiplication, defaulting to 256.
- **Logic and Control Flow**:
    - Calls [`build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>) with the transaction data `tr` to obtain initial signature verification components.
    - Constructs a tuple `A` using components from the result of [`build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>) and the public key `i_pub`.
    - Assigns `i_h` to `As` and `i_sig_h` to `Gs` for use in the DSDP multiplication.
    - Calls `ed25519_lib.ed25519_dsdp_mul` with `A`, `As`, `Gs`, and `W_S` to perform the DSDP multiplication, storing the result in `Z`.
    - Returns a tuple containing selected fields from `tr` and elements from `Z`.
- **Output**: A tuple containing the source, transaction ID, lower signature, and elements from the DSDP multiplication result, along with `i_Rx` and `i_res`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_ed25519_sigverify_0_o`](<#build_ed25519_sigverify_0_o>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### mon\_ed25519\_sigverify\_1<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_ed25519_sigverify_1}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L1081>)

Monitors and verifies Ed25519 signature operations in a digital system.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) object for logging and interaction.
    - `dut`: The device under test (DUT) object for accessing signals.
    - `clk`: The clock signal to synchronize operations.
    - `q_i`: An optional input queue for transaction data.
    - `q_o`: An optional output queue for transaction data.
    - `do_log`: A boolean flag to enable or disable logging.
    - `self_test`: A boolean flag to enable or disable self-testing mode.
- **Logic and Control Flow**:
    - Initializes an empty list `q_self` and retrieves the `DSDP_WS` value from the DUT.
    - Enters an infinite loop, waiting for a rising edge of the clock signal `clk`.
    - Checks if both `dut.i_v` and `dut.i_r` signals are '1', indicating valid input data.
    - Logs the input event if `self_test` is enabled and extracts various input signals from the DUT.
    - Performs Ed25519 DSDP multiplication using the extracted inputs and appends the result to `q_self`.
    - Checks if `dut.o_v` signal is '1', indicating valid output data.
    - Extracts output metadata using [`extr_meta`](<#extr_meta>) function and compares it with expected values from `q_o`.
    - Logs the output event and performs assertions to verify the correctness of the output data.
- **Output**: No direct output; it logs information and performs assertions to verify the correctness of Ed25519 signature operations.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.extr_meta`](<#extr_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.build_ed25519_sigverify_1_o`](<#build_ed25519_sigverify_1_o>)


---
### mon\_ed25519\_sigverify\_2<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_ed25519_sigverify_2}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L1266>)

Monitors and verifies the output of an Ed25519 signature verification process in a loop.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) object for logging.
    - `dut`: The device under test (DUT) object for accessing signals.
    - `clk`: The clock signal to synchronize the coroutine.
    - `q_i`: An optional input queue for transaction data.
    - `q_o`: An optional output queue for transaction data.
    - `do_log`: A boolean flag to enable or disable logging.
    - `self_test`: A boolean flag to enable or disable self-testing.
- **Logic and Control Flow**:
    - Enters an infinite loop to continuously monitor the DUT.
    - Waits for a rising edge of the clock signal using `await RisingEdge(clk)`.
    - Checks if the output valid signal `dut.o_v` is '1'.
    - Extracts metadata from the DUT output using `extr_meta(meta7, o_m)`.
    - If `q_o` is not None, retrieves and removes the transaction from `q_o` using `o_tid`.
    - Updates the transaction's time with `get_cycle()` and logs the transaction details.
    - Compares expected source, transaction ID, and result with the DUT output.
    - Logs the comparison results if `do_log` is True.
    - Asserts that the expected and actual values for source, transaction ID, and result are equal.
- **Output**: No explicit return value; the function performs monitoring and verification tasks.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.extr_meta`](<#extr_meta>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)


---
### mon\_dma<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.mon_dma}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L1408>)

Monitors and verifies DMA transactions by comparing expected and actual values.
- **Decorators**: `@async`
- **Inputs**:
    - `ddut`: The design under test (DUT) object for logging.
    - `dut`: The device under test (DUT) object containing DMA signals.
    - `clk`: The clock signal to synchronize operations.
    - `q_o`: An optional queue of expected transaction records.
    - `do_log`: A boolean flag to enable or disable logging of comparisons.
- **Logic and Control Flow**:
    - Enters an infinite loop to continuously monitor the DMA signals.
    - Waits for a rising edge on the clock signal using `await RisingEdge(clk)`.
    - Checks if both `dut.dma_v` and `dut.dma_r` signals are asserted (equal to '1').
    - Logs the message 'mon_dma_o' using `ddut._log.info` if the condition is met.
    - If `q_o` is not `None`, pops the first transaction record from `q_o`.
    - Extracts and calculates expected values `e_a`, `e_b`, and `e_d` from the transaction record.
    - Compares expected values with actual values from `dut` and logs the comparison if `do_log` is `True`.
    - Asserts that the expected and actual values for `o_a`, `o_b`, and `o_d` are equal.
- **Output**: No explicit return value; the function performs logging and assertions.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.bits`](<#bits>)


---
### model\_schl\_cpu<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.model_schl_cpu}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L1488>)

Simulates a CPU model for processing hash data and outputs the results based on input conditions.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) for logging and simulation control.
    - `dut`: The device under test (DUT) for accessing and modifying simulation signals.
    - `clk`: The clock signal used to synchronize operations.
    - `do_log`: A boolean flag to enable or disable logging of operations.
- **Logic and Control Flow**:
    - Initialize constants `D`, `W_HASH`, `W_T`, `W_IN_MEM`, and `MAX_INFLIGHT` from the `dut` object.
    - Start a coroutine to randomly toggle the `in_hash_ready` signal with a 50% probability on each clock cycle.
    - Initialize empty lists `ins` and `outs` to store input data and output results respectively.
    - Set `dut.out_hash_valid.value` to 0 to indicate no valid output initially.
    - Enter an infinite loop that waits for a rising edge of the clock signal.
    - Check if both `in_hash_valid` and `in_hash_ready` signals are '1', indicating valid input data is ready.
    - Extract `in_hash_ref` and `in_hash_data` from the `dut`, log the input data, and append `in_hash_data` to the `ins` list.
    - If the `ins` list contains three elements, process them using `sigverify.ksigverify_split0` and append the result to the `outs` list with a delay of `D` cycles.
    - Reset `dut.out_hash_valid.value` to 0 at the start of each loop iteration.
    - Iterate over the `outs` list to check if any output is ready to be processed based on the current cycle count.
    - If an output is ready, remove it from the `outs` list, log the output data, and set the corresponding `dut` output signals.
    - Increment the output address `oa` and check if more outputs are pending; if so, re-append the output to the `outs` list with an additional delay of `MAX_INFLIGHT` cycles.
    - Break the loop after processing an output to wait for the next clock cycle.
- **Output**: No explicit return value; modifies the `dut` signals to reflect the processed output data.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.random_toggle`](<#random_toggle>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)


---
### model\_dsdp<!-- {{#callable:firedancer/src/wiredancer/py/wd_cocotil.model_dsdp}} -->
[View Source →](<../../../../../src/wiredancer/py/wd_cocotil.py#L1605>)

Simulates a digital signal processing operation using the Ed25519 algorithm and updates output values based on clock cycles.
- **Decorators**: `@cocotb.coroutine`
- **Inputs**:
    - `ddut`: The device under test (DUT) for logging and monitoring.
    - `dut`: The actual device under test (DUT) that contains the signals and parameters to be processed.
    - `clk`: The clock signal used to synchronize operations.
    - `do_log`: A boolean flag to enable or disable logging.
- **Logic and Control Flow**:
    - Initialize parameters `N_TH`, `W_M`, and `W_S` from the DUT.
    - Start a coroutine to randomly toggle the `i_r` signal of the DUT.
    - Initialize an empty list `outs` to store output data.
    - Enter an infinite loop that waits for a rising edge of the clock signal.
    - Check if both `i_v` and `i_r` signals of the DUT are '1'.
    - If true, read input values `i_m`, `i_Ax`, `i_Ay`, `i_Az`, `i_At`, `i_As`, and `i_Gs` from the DUT.
    - Perform a multiplication operation using `ed25519_lib.ed25519_dsdp_mul` with the input values and store the result in `Z`.
    - Append a tuple containing the current cycle time plus a delay, `i_m`, and the elements of `Z` to `outs`.
    - Set the `o_v` signal of the DUT to 0.
    - Iterate over the `outs` list to check if the first element's cycle time is less than the current cycle.
    - If true, remove the element from `outs` and extract its values.
    - Convert the extracted values into binary format using `BinaryValue` and assign them to the DUT's output signals.
    - Set the `o_v` signal of the DUT to 1 and break the loop.
- **Output**: No explicit return value; updates the DUT's output signals based on processed input data.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/wd_cocotil.random_toggle`](<#random_toggle>)
    - [`firedancer/src/wiredancer/py/wd_cocotil.get_cycle`](<#get_cycle>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)