<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Reference implementation of Ed25519 signature scheme with test vectors and verification functions.

# Purpose
This Python code is a reference implementation of the Ed25519 digital signature algorithm, as specified in RFC 8032. The code provides functionality for key generation, signing, and verification of messages using elliptic curve cryptography. It includes functions for performing mathematical operations on elliptic curve points, such as [`point_add`](<#point_add>) and [`point_mul`](<#point_mul>), which are essential for the cryptographic computations involved in the Ed25519 algorithm. The code also includes functions for key manipulation, such as [`secret_expand`](<#secret_expand>) and [`secret_to_public`](<#secret_to_public>), which derive public keys from private keys.

The implementation includes test vectors to verify the correctness of the algorithm. These tests use predefined secret keys, public keys, messages, and signatures to ensure that the signing and verification processes work as expected. The [`TEST_VERIF`](<#test_verif>) function is used to run these tests and print the results, confirming whether the verification passes. The code is structured to be executed as a standalone script, with the main block running the test cases when the script is executed directly. This implementation is intended for educational and reference purposes, providing a clear example of how the Ed25519 algorithm operates.
# Imports and Dependencies

---
- `hashlib`


# Global Variables

---
### p
- **Type**: `int`
- **Description**: `p` is a global variable that represents a prime number used as the base field in elliptic curve cryptography. It is defined as `2**255 - 19`, which is a specific prime number used in the Ed25519 signature scheme.
- **Use**: Used as the modulus in various mathematical operations related to elliptic curve point arithmetic and cryptographic functions.


---
### d
- **Type**: `int`
- **Description**: The variable `d` is a curve constant used in elliptic curve cryptography, specifically for the Ed25519 curve. It is calculated as the product of -121665 and the modular inverse of 121666, modulo `p`, where `p` is the prime number defining the base field Z_p.
- **Use**: Used as a constant in elliptic curve operations, particularly in point addition and multiplication functions.


---
### q
- **Type**: `int`
- **Description**: `q` is an integer that represents the group order in the context of elliptic curve cryptography. It is calculated as `2**252 + 27742317777372353535851937790883648493`, which is a large prime number used in the Ed25519 signature scheme.
- **Use**: Used to define the modulus for operations in the Ed25519 signature scheme, ensuring cryptographic security.


---
### modp\_sqrt\_m1
- **Type**: `int`
- **Description**: `modp_sqrt_m1` is an integer that represents the square root of -1 in the finite field defined by the prime `p`, where `p` is `2**255 - 19`. It is calculated using the expression `pow(2, (p-1) // 4, p)`, which computes the modular exponentiation of 2 to the power of `(p-1) // 4` modulo `p`.
- **Use**: Used in the `recover_x` function to compute the square root of `x2` when recovering the x-coordinate from a given y-coordinate on the elliptic curve.


---
### g\_y
- **Type**: `int`
- **Description**: `g_y` is a global variable that represents a y-coordinate in the context of elliptic curve operations. It is calculated as `4 * modp_inv(5) % p`, where `modp_inv` computes the modular inverse of a number modulo `p`, the base field.
- **Use**: Used as part of the base point `G` in elliptic curve operations.


---
### g\_x
- **Type**: `int`
- **Description**: `g_x` is an integer that represents the x-coordinate of the base point on the elliptic curve used in the Ed25519 algorithm. It is calculated by calling the `recover_x` function with `g_y` and a sign bit of 0.
- **Use**: Used to define the base point `G` for elliptic curve operations.


---
### G
- **Type**: `tuple`
- **Description**: The variable `G` is a tuple representing a point on an elliptic curve in extended coordinates. It consists of four elements: `g_x`, `g_y`, `1`, and `g_x * g_y % p`, where `g_x` and `g_y` are the x and y coordinates of the base point, and `p` is the prime number defining the field.
- **Use**: Used as the base point for elliptic curve operations in the Ed25519 signature scheme.


# Functions

---
### sha512<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.sha512}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L8>)

Computes the SHA-512 hash of a given input and returns the binary digest.
- **Inputs**:
    - `s`: A byte-like object to hash using SHA-512.
- **Logic and Control Flow**:
    - Uses the `hashlib.sha512` function to create a SHA-512 hash object from the input `s`.
    - Calls the `digest` method on the hash object to obtain the binary digest of the hash.
- **Output**: Returns the binary digest of the SHA-512 hash of the input `s`.


---
### modp\_inv<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.modp_inv}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L14>)

Calculates the modular inverse of a number in the finite field defined by the prime `p`.
- **Inputs**:
    - `x`: The integer for which to compute the modular inverse.
- **Logic and Control Flow**:
    - Uses the `pow` function to compute the modular inverse of `x` using Fermat's Little Theorem, which states that `x^(p-1) ≡ 1 (mod p)` for a prime `p`, thus `x^(p-2) ≡ x^(-1) (mod p)`.
- **Output**: Returns the modular inverse of `x` modulo `p`.


---
### sha512\_modq<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.sha512_modq}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L23>)

Computes the SHA-512 hash of input `s`, converts it to an integer, and returns the result modulo `q`.
- **Inputs**:
    - `s`: A byte string to hash using SHA-512.
- **Logic and Control Flow**:
    - Call the [`sha512`](<#sha512>) function with input `s` to compute its SHA-512 hash.
    - Convert the resulting hash from bytes to an integer using little-endian byte order.
    - Compute the integer modulo `q` and return the result.
- **Output**: An integer which is the SHA-512 hash of `s` modulo `q`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512`](<#sha512>)


---
### point\_add<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_add}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L29>)

Performs point addition on two elliptic curve points represented in extended coordinates.
- **Inputs**:
    - `P`: A tuple representing the first point in extended coordinates (X, Y, Z, T).
    - `Q`: A tuple representing the second point in extended coordinates (X, Y, Z, T).
- **Logic and Control Flow**:
    - Calculate intermediate values A and B using the coordinates of points P and Q.
    - Calculate intermediate values C and D using the coordinates of points P and Q and the curve constant d.
    - Calculate intermediate values E, F, G, and H using A, B, C, and D.
    - Return a new point as a tuple of four values calculated using E, F, G, and H.
- **Output**: A tuple representing the resulting point in extended coordinates (X, Y, Z, T) after addition.


---
### point\_mul<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_mul}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L38>)

Performs scalar multiplication of a point on an elliptic curve using the double-and-add method.
- **Inputs**:
    - `s`: An integer scalar used to multiply the point.
    - `P`: A tuple representing a point on the elliptic curve in extended coordinates (X, Y, Z, T).
- **Logic and Control Flow**:
    - Initialize Q as the neutral element (0, 1, 1, 0).
    - While the scalar s is greater than 0, check if the least significant bit of s is 1.
    - If the least significant bit of s is 1, add the point P to Q using the [`point_add`](<#point_add>) function.
    - Double the point P by adding it to itself using the [`point_add`](<#point_add>) function.
    - Right shift the scalar s by 1 bit to process the next bit.
    - Return the point Q with each coordinate reduced modulo p.
- **Output**: A tuple representing the resulting point on the elliptic curve after scalar multiplication, with each coordinate reduced modulo p.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_add`](<#point_add>)


---
### point\_equal<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_equal}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L47>)

Checks if two points in extended coordinates are equal by comparing their x and y coordinates after normalizing by their z coordinates.
- **Inputs**:
    - `P`: A tuple representing a point in extended coordinates (X, Y, Z, T).
    - `Q`: A tuple representing another point in extended coordinates (X, Y, Z, T).
- **Logic and Control Flow**:
    - Calculate the difference between the x-coordinate of point P multiplied by the z-coordinate of point Q and the x-coordinate of point Q multiplied by the z-coordinate of point P.
    - Check if the result of the above calculation modulo p is not zero; if so, return False.
    - Calculate the difference between the y-coordinate of point P multiplied by the z-coordinate of point Q and the y-coordinate of point Q multiplied by the z-coordinate of point P.
    - Check if the result of the above calculation modulo p is not zero; if so, return False.
    - If both checks pass, return True.
- **Output**: Returns a boolean indicating whether the two points are equal.


---
### recover\_x<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.recover_x}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L60>)

Computes the x-coordinate from a given y-coordinate and sign bit on an elliptic curve, or returns None if the computation fails.
- **Inputs**:
    - `y`: The y-coordinate of a point on the elliptic curve.
    - `sign`: A boolean indicating the desired parity of the x-coordinate.
- **Logic and Control Flow**:
    - Check if `y` is greater than or equal to `p`; if true, return None.
    - Calculate `x2` as `(y*y-1) * modp_inv(d*y*y+1)`.
    - If `x2` is zero, return None if `sign` is true, otherwise return 0.
    - Compute the square root of `x2` using `pow(x2, (p+3) // 8, p)`.
    - If the square of `x` modulo `p` does not equal `x2`, adjust `x` by multiplying with `modp_sqrt_m1` and take modulo `p`.
    - If the square of `x` modulo `p` still does not equal `x2`, return None.
    - If the parity of `x` does not match `sign`, adjust `x` by subtracting it from `p`.
- **Output**: The x-coordinate corresponding to the given y-coordinate and sign, or None if the computation fails.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.modp_inv`](<#modp_inv>)


---
### point\_compress<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_compress}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L85>)

Compresses a point in extended coordinates to a 32-byte representation.
- **Inputs**:
    - `P`: A tuple representing a point in extended coordinates (X, Y, Z, T).
- **Logic and Control Flow**:
    - Calculate the modular inverse of the Z coordinate using [`modp_inv`](<#modp_inv>).
    - Compute the x-coordinate by multiplying the X coordinate with the inverse of Z and taking modulo p.
    - Compute the y-coordinate by multiplying the Y coordinate with the inverse of Z and taking modulo p.
    - Combine the y-coordinate with the least significant bit of the x-coordinate shifted left by 255 bits.
    - Convert the combined value to a 32-byte little-endian representation.
- **Output**: A 32-byte little-endian representation of the compressed point.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.modp_inv`](<#modp_inv>)


---
### point\_decompress<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.point_decompress}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L91>)

Decompresses a point from a 32-byte compressed representation to its extended coordinates.
- **Inputs**:
    - `s`: A 32-byte compressed representation of a point.
- **Logic and Control Flow**:
    - Check if the length of `s` is not 32 bytes; if not, raise an exception.
    - Convert `s` from bytes to an integer `y` using little-endian byte order.
    - Extract the sign bit from `y` by right-shifting 255 bits.
    - Mask `y` to clear the sign bit, leaving only the y-coordinate value.
    - Call [`recover_x`](<#recover_x>) with `y` and `sign` to compute the x-coordinate `x`.
    - If [`recover_x`](<#recover_x>) returns `None`, return `None` indicating decompression failure.
    - If [`recover_x`](<#recover_x>) returns a valid `x`, return a tuple `(x, y, 1, x*y % p)` representing the point in extended coordinates.
- **Output**: A tuple representing the decompressed point in extended coordinates (X, Y, Z, T) or `None` if decompression fails.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.recover_x`](<#recover_x>)


---
### secret\_expand<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.secret_expand}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L105>)

Expands a 32-byte secret key into a tuple containing a modified integer and a hash digest.
- **Inputs**:
    - `secret`: A 32-byte secret key that the function will expand.
- **Logic and Control Flow**:
    - Check if the length of `secret` is not 32 bytes; if true, raise an exception with the message 'Bad size of private key'.
    - Compute the SHA-512 hash of `secret` and store it in `h`.
    - Convert the first 32 bytes of `h` to a little-endian integer and store it in `a`.
    - Apply bitwise operations on `a` to clear the 3 least significant bits and set the 254th bit.
    - Return a tuple containing the modified integer `a` and the remaining bytes of `h` starting from the 32nd byte.
- **Output**: A tuple containing a modified integer derived from the secret and the remaining bytes of the SHA-512 hash.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512`](<#sha512>)


---
### secret\_to\_public<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.secret_to_public}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L114>)

Converts a secret key into a public key using elliptic curve point multiplication and compression.
- **Inputs**:
    - `secret`: A 32-byte private key that needs conversion to a public key.
- **Logic and Control Flow**:
    - Calls [`secret_expand`](<#secret_expand>) to expand the secret key into a scalar `a` and a dummy value.
    - Performs elliptic curve point multiplication of `a` with the base point `G` using [`point_mul`](<#point_mul>).
    - Compresses the resulting elliptic curve point into a public key using [`point_compress`](<#point_compress>).
- **Output**: A 32-byte public key derived from the input secret key.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.secret_expand`](<#secret_expand>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_compress`](<#point_compress>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](<#point_mul>)


---
### sign<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.sign}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L119>)

Generates a digital signature for a given message using a secret key based on the Ed25519 algorithm.
- **Inputs**:
    - `secret`: A 32-byte private key used to generate the signature.
    - `msg`: The message to sign, provided as a byte string.
- **Logic and Control Flow**:
    - Expand the secret key using [`secret_expand`](<#secret_expand>) to obtain `a` and `prefix`.
    - Compute the public key `A` by multiplying `a` with the base point `G` and compressing the result using [`point_compress`](<#point_compress>).
    - Calculate the random value `r` by hashing the concatenation of `prefix` and `msg` using [`sha512_modq`](<#sha512_modq>).
    - Compute the point `R` by multiplying `r` with the base point `G`.
    - Compress the point `R` to obtain `Rs` using [`point_compress`](<#point_compress>).
    - Calculate the hash `h` by hashing the concatenation of `Rs`, `A`, and `msg` using [`sha512_modq`](<#sha512_modq>).
    - Compute the scalar `s` as `(r + h * a) % q`.
    - Return the concatenation of `Rs` and the 32-byte little-endian representation of `s`.
- **Output**: A 64-byte signature, which is the concatenation of the compressed point `Rs` and the scalar `s`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.secret_expand`](<#secret_expand>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_compress`](<#point_compress>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](<#point_mul>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512_modq`](<#sha512_modq>)


---
### verify2<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.verify2}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L130>)

Verifies a digital signature using a public key and a message.
- **Inputs**:
    - `public`: A 32-byte public key used for verification.
    - `msg`: The message that was signed.
    - `signature`: A 64-byte signature to verify.
    - `h`: An optional precomputed hash value; if not provided, it is computed within the function.
- **Logic and Control Flow**:
    - Check if the length of `public` is 32 bytes; if not, raise an exception.
    - Check if the length of `signature` is 64 bytes; if not, raise an exception.
    - Decompress the `public` key to get point `A`; if decompression fails, return `False`.
    - Extract the first 32 bytes of `signature` as `Rs` and decompress it to get point `R`; if decompression fails, return `False`.
    - Convert the remaining 32 bytes of `signature` to an integer `s`; if `s` is greater than or equal to `q`, return `False`.
    - If `h` is not provided, compute it using [`sha512_modq`](<#sha512_modq>) with `Rs`, `public`, and `msg`.
    - Compute `sB` by multiplying `s` with the base point `G`.
    - Compute `hA` by multiplying `h` with point `A`.
    - Add points `R` and `hA`, and check if the result is equal to `sB` using [`point_equal`](<#point_equal>).
    - Return the result of the equality check.
- **Output**: Returns `True` if the signature is valid, otherwise `False`.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_decompress`](<#point_decompress>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512_modq`](<#sha512_modq>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](<#point_mul>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_equal`](<#point_equal>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_add`](<#point_add>)


---
### verify<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.verify}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L151>)

Verifies a digital signature using the Ed25519 algorithm.
- **Inputs**:
    - `public`: The public key used for verification, expected to be 32 bytes long.
    - `msg`: The message that was signed.
    - `signature`: The digital signature to verify, expected to be 64 bytes long.
    - `h`: An optional precomputed hash value; if not provided, it is computed within the function.
- **Logic and Control Flow**:
    - Check if the length of the public key is 32 bytes; raise an exception if not.
    - Check if the length of the signature is 64 bytes; raise an exception if not.
    - Decompress the public key using [`point_decompress`](<#point_decompress>); return False if decompression fails.
    - Extract the first 32 bytes of the signature as `Rs` and decompress it; return False if decompression fails.
    - Convert the remaining bytes of the signature to an integer `s`; return False if `s` is greater than or equal to `q`.
    - If `h` is not provided, compute it using [`sha512_modq`](<#sha512_modq>) with `Rs`, `public`, and `msg`.
    - Compute `P0` as the result of multiplying `s` with the base point `G`.
    - Compute `P1` as the result of multiplying `h` with the decompressed public key `A`.
    - Add `P0` and `P1` to get `P0P1`.
    - Compute `An` as the negation of the x-coordinates of `A` and `G`.
    - Initialize `Z` as the neutral element (0, 1, 1, 0).
    - Iterate over each bit of `s` and `h` from 255 to 0, updating `Z` by doubling it and conditionally adding `G`, `An`, or `T` based on the bits.
    - Return the result of comparing `Z` and `R` using [`point_equal`](<#point_equal>).
- **Output**: Returns a boolean indicating whether the signature is valid for the given public key and message.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_decompress`](<#point_decompress>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.sha512_modq`](<#sha512_modq>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_mul`](<#point_mul>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_add`](<#point_add>)
    - [`firedancer/src/wiredancer/py/ref_ed25519.point_equal`](<#point_equal>)


---
### TEST\_VERIF<!-- {{#callable:firedancer/src/wiredancer/py/ref_ed25519.TEST_VERIF}} -->
[View Source →](<../../../../../src/wiredancer/py/ref_ed25519.py#L201>)

Prints test information and verifies a digital signature using a public key, message, and signature.
- **Inputs**:
    - `n`: An integer representing the test number.
    - `keyP`: A byte array representing the public key.
    - `msg`: A byte array representing the message.
    - `sigt`: A byte array representing the signature.
- **Logic and Control Flow**:
    - Prints a blank line for separation.
    - Prints the test number using the input `n`.
    - Prints the public key in hexadecimal format, split into two lines for readability.
    - Prints the message in hexadecimal format, with each line containing 16 bytes.
    - Prints the signature in hexadecimal format, split into four lines for readability.
    - Calls the [`verify`](<#verify>) function with `keyP`, `msg`, and `sigt` to check if the signature is valid.
    - Prints the result of the verification process.
    - Asserts that the verification result is true, raising an exception if it is not.
- **Output**: No return value; the function prints output to the console and raises an exception if verification fails.
- **Functions Called**:
    - [`firedancer/src/wiredancer/py/ref_ed25519.verify`](<#verify>)



---
Made with ❤️ by [Driver](https://www.driver.ai/)