<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a system for managing account-conflict graphs in a transaction processing environment, using data structures and algorithms to handle graph traversal, memory optimization, and transaction scheduling.

# Purpose
The code defines a module for managing a directed acyclic graph (DAG) structure used to track account conflicts in a transaction processing system. The primary purpose of this module is to handle the dependencies and execution order of transactions based on account access patterns. The DAG is constructed as a union of account-conflict graphs, where each graph represents dependencies between transactions accessing the same account. The module uses a combination of successor and sibling pointers to manage nodes in the graph, allowing for efficient traversal and modification without dynamic memory allocation.

Key components include the `fd_rdisp_txn` structure, which represents a transaction node in the DAG, and the `acct_info` structure, which maintains metadata for account addresses. The module also defines several macros and helper functions for managing edges and nodes within the DAG. The code includes mechanisms for adding, promoting, and demoting blocks of transactions, as well as functions for updating the execution state of transactions based on their dependencies. The module is designed to optimize performance by minimizing memory latency through bit-packing and efficient cache usage. It provides a detailed implementation of transaction scheduling and conflict resolution in a high-performance transaction processing environment.
# Imports and Dependencies

---
- `fd_rdisp.h`
- `math.h`
- `../../util/tmpl/fd_pool.c`
- `../../util/tmpl/fd_slist.c`
- `../../util/tmpl/fd_dlist.c`
- `../../util/tmpl/fd_map_chain.c`
- `../../util/tmpl/fd_prq.c`


# Data Structures

---
### fd\_rdisp\_txn
- **Type**: ``struct``
- **Members**:
    - ``in_degree``: Stores the total number of edges with this node as their destination in the DAG.
    - ``score``: Represents the scheduling priority of the transaction, with integer and fractional parts.
    - ``edge_cnt_etc``: A union field that encodes block number, concurrency lane, and read/write counts.
    - ``unstaged_next``: Used as a pointer when the transaction is unstaged.
    - ``free_next``: Used as a pointer when the transaction is free.
    - ``block_idx``: Stores a pointer back to the block when the transaction is in a zombie state.
    - ``edges``: An array of edges representing links to other nodes in the DAG.
- **Description**: Represents a transaction as a node in a directed acyclic graph (DAG) for account conflict management. The structure includes fields for tracking the transaction's dependencies (`in_degree`), scheduling priority (`score`), and various states and transitions (`edge_cnt_etc`, `unstaged_next`, `free_next`, `block_idx`). The `edges` array holds the connections to other transactions, facilitating the management of read and write operations across accounts. This structure is crucial for determining when a transaction can be executed based on its dependencies and urgency.


---
### fd\_rdisp\_txn\_t
- **Type**: ``struct``
- **Members**:
    - ``in_degree``: Stores the total number of incoming edges to this node across all account DAGs.
    - ``score``: Indicates the scheduling priority of the transaction, with a lower value being more urgent.
    - ``edge_cnt_etc``: A bit-packed field containing various metadata about the transaction, including block number and concurrency lane.
    - ``unstaged_next``: Used to link unstaged transactions in a list when the transaction is unstaged.
    - ``free_next``: Used to link free transactions in a list when the transaction is free.
    - ``block_idx``: Stores the index of the block when the transaction is in a zombie state.
    - ``edges``: An array of edges representing connections to other nodes in the DAG, with special handling for writable and readable accounts.
- **Description**: Represents a transaction as a node in a directed acyclic graph (DAG) for account-conflict management. It maintains information about the transaction's dependencies and scheduling priority, using fields like `in_degree` to track incoming edges and `score` to determine urgency. The `edge_cnt_etc` field encodes various metadata, while the `edges` array stores connections to other nodes, facilitating the management of account conflicts in a transaction pool. The structure supports different states, such as unstaged, free, and zombie, with corresponding fields to manage these states.


---
### acct\_info
- **Type**: ``struct``
- **Members**:
    - ``key``: Stores the account address key.
    - ``next``: Holds the index of the next element in the map chain.
    - ``prev``: Holds the index of the previous element in the map chain.
    - ``last_reference``: Array of pointers to the last node in the DAG for each staging lane.
    - ``free_ll_next``: Index of the next element in the free list when not active.
    - ``free_ll_prev``: Index of the previous element in the free list when not active.
    - ``flags``: Bitfield flags indicating the state of the account.
    - ``last_ref``: Stores the last reference index for the account.
    - ``ema_refs``: Stores the exponential moving average of references to the account.
- **Description**: Represents metadata for a single account address's conflict graph DAG, managing its state transitions between FREE, ACTIVE, and CACHED. It includes fields for managing its position in a map chain, tracking the last reference in a directed acyclic graph (DAG), and maintaining an exponential moving average (EMA) of references to optimize transaction dispatching.


---
### acct\_info\_t
- **Type**: ``struct``
- **Members**:
    - ``key``: Stores the account address key for the conflict graph DAG.
    - ``next``: Points to the next node in the map chain.
    - ``prev``: Points to the previous node in the map chain.
    - ``last_reference``: Holds pointers to the last node in the DAG for each staging lane.
    - ``free_ll_next``: Points to the next node in the free list when not active.
    - ``free_ll_prev``: Points to the previous node in the free list when not active.
    - ``flags``: Contains bitfields indicating the state of the account (e.g., last reference was a write).
    - ``last_ref``: Records the last transaction index that referenced this account.
    - ``ema_refs``: Stores an exponentially moving average of references to this account.
- **Description**: `acct_info_t` is a node in a map chain that contains metadata for a single account address's conflict graph DAG. It manages the state transitions between FREE, ACTIVE, and CACHED, and maintains information about the last node in the DAG for each staging lane. The structure also tracks the last reference index and an exponentially moving average of references to estimate the probability of future references. The `flags` field helps manage the state of the account, such as whether the last reference was a write or if there are any writers.


---
### pending\_prq\_ele
- **Type**: ``struct``
- **Members**:
    - `score`: A `float` value where a lower score indicates higher scheduling priority.
    - `linear_block_number`: An `unsigned int` representing the linear block number.
    - `txn_idx`: An `unsigned int` representing the transaction index.
- **Description**: Represents an element in a priority queue for pending transactions, where the `score` determines the urgency of scheduling, and the `linear_block_number` and `txn_idx` are used for identifying the transaction's position and order in the block.


---
### pending\_prq\_ele\_t
- **Type**: ``struct``
- **Members**:
    - `score`: Stores a float value where a lower score indicates higher scheduling priority.
    - `linear_block_number`: Stores a 32-bit unsigned integer representing the linear block number.
    - `txn_idx`: Stores a 32-bit unsigned integer representing the transaction index.
- **Description**: Represents an element in a priority queue for pending transactions, where the `score` determines the scheduling priority, and `linear_block_number` and `txn_idx` provide additional transaction metadata.


---
### fd\_rdisp\_blockinfo
- **Type**: ``struct``
- **Members**:
    - ``block``: A tag for the block, represented by `FD_RDISP_BLOCK_TAG_T`.
    - ``linear_block_number``: A linear number assigned to the block.
    - ``insert_ready``: A flag indicating if the block is ready for insertion.
    - ``schedule_ready``: A flag indicating if the block is ready for scheduling.
    - ``staged``: A flag indicating if the block is staged.
    - ``staging_lane``: Indicates the staging lane, ignored if `staged` is 0.
    - ``last_insert_was_serializing``: A flag indicating if the last insert was serializing.
    - ``inserted_cnt``: The count of inserted transactions.
    - ``dispatched_cnt``: The count of dispatched transactions.
    - ``completed_cnt``: The count of completed transactions.
    - ``last_serializing``: The index of the last serializing transaction.
    - ``map_chain_next``: The next element in the map chain.
    - ``ll_next``: The next element in the linked list.
    - ``ll``: A linked list used only when unstaged, of type `unstaged_txn_ll_t`.
    - ``zombie_list``: A list of zombie transactions, of type `zombie_dlist_t`.
- **Description**: Represents metadata about transactions for each slot, including flags for readiness and staging, counts of transactions in various states, and linked list structures for managing unstaged and zombie transactions.


---
### fd\_rdisp\_blockinfo\_t
- **Type**: ``struct``
- **Members**:
    - ``block``: Stores the block tag for the transaction block.
    - ``linear_block_number``: Holds the linear block number for the transaction block.
    - ``insert_ready``: Indicates if the block is ready for insertion.
    - ``schedule_ready``: Indicates if the block is ready for scheduling.
    - ``staged``: Indicates if the block is staged.
    - ``staging_lane``: Stores the staging lane number, ignored if `staged` is 0.
    - ``last_insert_was_serializing``: Indicates if the last insert was serializing.
    - ``inserted_cnt``: Counts the number of inserted transactions.
    - ``dispatched_cnt``: Counts the number of dispatched transactions.
    - ``completed_cnt``: Counts the number of completed transactions.
    - ``last_serializing``: Stores the index of the last serializing transaction.
    - ``map_chain_next``: Stores the next index in the map chain.
    - ``ll_next``: Stores the next index in the linked list.
    - ``ll``: Used only when unstaged, represents a linked list of unstaged transactions.
    - ``zombie_list``: Represents a list of zombie transactions.
- **Description**: Maintains metadata about transactions for each slot, including block tags, counts of inserted, dispatched, and completed transactions, and flags for insertion and scheduling readiness. It also manages linked lists for unstaged and zombie transactions.


---
### fd\_rdisp\_unstaged
- **Type**: ``struct``
- **Members**:
    - ``block``: Stores a block tag of type `FD_RDISP_BLOCK_TAG_T`.
    - ``writable_cnt``: Counts the number of writable accounts.
    - ``readonly_cnt``: Counts the number of readonly accounts.
    - ``keys``: Holds an array of account addresses with a maximum size of `MAX_ACCT_PER_TXN`.
- **Description**: Represents an unstaged transaction in a block, containing metadata about the transaction's accounts, including the number of writable and readonly accounts, and their respective addresses. This structure is used to manage transactions that have not yet been staged for execution.


---
### fd\_rdisp\_unstaged\_t
- **Type**: ``struct``
- **Members**:
    - ``block``: Stores the block tag associated with the unstaged transaction.
    - ``writable_cnt``: Counts the number of writable accounts in the transaction.
    - ``readonly_cnt``: Counts the number of readonly accounts in the transaction.
    - ``keys``: Holds the account addresses involved in the transaction, with a maximum of 64.
- **Description**: Represents an unstaged transaction in a conflict graph, maintaining information about the block it belongs to, the number of writable and readonly accounts, and the account addresses involved. This structure is used to manage transactions that have not yet been staged for execution, allowing for the organization and tracking of account conflicts in a transaction processing system.


---
### per\_lane\_info\_t
- **Type**: ``struct``
- **Members**:
    - ``pending``: Pointer to a `pending_prq_ele_t` structure.
    - ``linear_block_number``: Stores the linear block number as an unsigned long.
    - ``block_ll``: Array of `block_slist_t` with a single element.
    - ``inserted_cnt``: Count of inserted elements as an unsigned long.
    - ``dispatched_cnt``: Count of dispatched elements as an unsigned long.
    - ``completed_cnt``: Count of completed elements as an unsigned long.
- **Description**: `per_lane_info_t` is a structure that holds information related to a specific lane in a dispatch system. It includes a pointer to pending elements, a linear block number, a single-element array of block lists, and counters for inserted, dispatched, and completed elements. This structure is used to manage and track the state of operations within a particular lane.


---
### fd\_rdisp
- **Type**: ``struct``
- **Members**:
    - ``depth``: Stores the depth of the pool.
    - ``block_depth``: Stores the depth of the block pool.
    - ``global_insert_cnt``: Counts the total number of global insertions.
    - ``unstaged_lblk_num``: Tracks the number of unstaged logical block numbers.
    - ``pool``: Pointer to an array of `fd_rdisp_txn_t` representing a transaction pool.
    - ``unstaged``: Pointer to an array of `fd_rdisp_unstaged_t` with additional information parallel to `pool`.
    - ``blockmap``: Pointer to a `block_map_t` representing a map chain.
    - ``block_pool``: Pointer to an array of `fd_rdisp_blockinfo_t` for block metadata.
    - ``free_lanes``: Bitmask indicating free lanes.
    - ``lanes``: Array of `per_lane_info_t` for lane-specific information.
    - ``acct_map``: Pointer to an `acct_map_t` for account mapping.
    - ``free_acct_map``: Pointer to an `acct_map_t` for free account mapping.
    - ``acct_pool``: Pointer to an array of `acct_info_t` for account information.
    - ``free_acct_dlist``: Array of `free_dlist_t` for managing free account lists.
- **Description**: Manages a pool of transactions and blocks, handling their insertion, staging, and scheduling. It maintains maps and lists for account and block management, and uses bitmasks and arrays to track the state and availability of resources. The structure is designed to efficiently manage and schedule transactions in a distributed system, optimizing for memory usage and performance.


---
### fd\_rdisp\_t
- **Type**: ``struct``
- **Members**:
    - `depth`: Stores the depth of the transaction pool.
    - `block_depth`: Stores the depth of the block pool.
    - `global_insert_cnt`: Tracks the global count of inserted transactions.
    - `unstaged_lblk_num`: Tracks the number of unstaged linear blocks.
    - `pool`: Pointer to an array of `fd_rdisp_txn_t` representing the transaction pool.
    - `unstaged`: Pointer to an array of `fd_rdisp_unstaged_t` for additional unstaged transaction information.
    - `blockmap`: Pointer to a map chain for block information.
    - `block_pool`: Pointer to a pool of `fd_rdisp_blockinfo_t` for block metadata.
    - `free_lanes`: Bitmask indicating free lanes for staging.
    - `lanes`: Array of `per_lane_info_t` structures for managing lane-specific information.
    - `acct_map`: Pointer to a map of account information.
    - `free_acct_map`: Pointer to a map of free account information.
    - `acct_pool`: Pointer to an array of `acct_info_t` for account metadata.
    - `free_acct_dlist`: Doubly linked list for managing free account information.
- **Description**: Represents a data structure for managing a directed acyclic graph (DAG) of transactions with account conflict resolution. It maintains pools and maps for transactions, blocks, and accounts, allowing for efficient insertion, staging, and scheduling of transactions. The structure uses bit-packing and linked lists to optimize memory usage and performance, particularly in scenarios with high memory latency. It supports operations for adding, removing, and promoting blocks, as well as managing transaction dependencies and execution readiness.


# Functions

---
### fd\_rdisp\_align<!-- {{#callable:fd_rdisp_align}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L493>)

Returns the constant value 128UL.
- **Inputs**: None
- **Logic and Control Flow**:
    - The function does not take any inputs.
    - It directly returns the constant value 128UL without any computation or condition checks.
- **Output**: An unsigned long integer with the value 128UL.


---
### fd\_rdisp\_footprint<!-- {{#callable:fd_rdisp_footprint}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L495>)

Calculates the memory footprint required for a `fd_rdisp_t` structure based on given depth and block depth parameters.
- **Inputs**:
    - `depth`: The depth of the transaction pool, which must be between 2 and `FD_RDISP_MAX_DEPTH`.
    - `block_depth`: The depth of the block pool, which must be between 4 and `FD_RDISP_MAX_BLOCK_DEPTH`.
- **Logic and Control Flow**:
    - Checks if `depth` and `block_depth` are within valid ranges; returns 0 if not.
    - Estimates the number of chains for block and account maps using `block_map_chain_cnt_est` and `acct_map_chain_cnt_est`.
    - Initializes a layout variable `l` with `FD_LAYOUT_INIT`.
    - Appends various components to the layout `l` using `FD_LAYOUT_APPEND`, calculating their alignments and sizes based on the input parameters.
    - Returns the finalized layout size using `FD_LAYOUT_FINI`.
- **Output**: Returns the total memory footprint in bytes as an unsigned long integer.
- **Functions Called**:
    - [`fd_rdisp_align`](<#fd_rdisp_align>)


---
### fd\_rdisp\_new<!-- {{#callable:fd_rdisp_new}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L518>)

Initializes and allocates memory for a new `fd_rdisp_t` structure with specified depth, block depth, and seed.
- **Inputs**:
    - `mem`: Pointer to the memory location where the `fd_rdisp_t` structure will be initialized.
    - `depth`: The depth of the transaction pool, must be between 2 and `FD_RDISP_MAX_DEPTH`.
    - `block_depth`: The depth of the block pool, must be between 4 and `FD_RDISP_MAX_BLOCK_DEPTH`.
    - `seed`: A seed value used for initializing hash functions in the block and account maps.
- **Logic and Control Flow**:
    - Checks if `depth` and `block_depth` are within valid ranges; returns `0UL` if not.
    - Calculates `chain_cnt`, `acct_depth`, and `acct_chain_cnt` based on `depth` and `block_depth`.
    - Initializes scratch memory allocation with `FD_SCRATCH_ALLOC_INIT`.
    - Allocates memory for `fd_rdisp_t`, transaction pool, unstaged transactions, block map, block pool, pending priority queue, account map, free account map, and account pool using `FD_SCRATCH_ALLOC_APPEND`.
    - Finalizes memory allocation with `FD_SCRATCH_ALLOC_FINI`.
    - Initializes `fd_rdisp_t` fields such as `depth`, `block_depth`, `global_insert_cnt`, and `unstaged_lblk_num`.
    - Initializes transaction pool with `pool_new` and sets all `in_degree` to `IN_DEGREE_FREE`.
    - Clears memory for unstaged transactions using `memset`.
    - Initializes block map and block pool with `block_map_new` and `block_pool_new`.
    - Initializes zombie lists for each block in the block pool.
    - Sets `free_lanes` to `0xF` and initializes each lane's pending queue and counters.
    - Initializes account maps with `acct_map_new` using hashed seeds.
    - Initializes free account list and populates it with account pool indices.
- **Output**: Returns a pointer to the newly initialized `fd_rdisp_t` structure.
- **Functions Called**:
    - [`fd_rdisp_align`](<#fd_rdisp_align>)


---
### fd\_rdisp\_join<!-- {{#callable:fd_rdisp_join}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L584>)

Initializes and joins various components of a `fd_rdisp_t` structure using a given memory block.
- **Inputs**:
    - `mem`: A pointer to a memory block that contains the `fd_rdisp_t` structure to be initialized and joined.
- **Logic and Control Flow**:
    - Cast `mem` to a `fd_rdisp_t` pointer and store it in `disp`.
    - Retrieve `depth` and `block_depth` from `disp`.
    - Calculate `chain_cnt` and `acct_chain_cnt` using `block_depth` and `acct_depth` using `depth`.
    - Initialize scratch allocation with `FD_SCRATCH_ALLOC_INIT`.
    - Append various components to the scratch allocation using `FD_SCRATCH_ALLOC_APPEND`, including `_pool`, `_unstaged`, `_bmap`, `_bpool`, `_pending`, `_acct_map`, `_freea_map`, and `apool`.
    - Finalize the scratch allocation with `FD_SCRATCH_ALLOC_FINI`.
    - Join the pool, unstaged, block map, and block pool components using `pool_join`, `block_map_join`, and `block_pool_join`.
    - Iterate over `block_depth+1` to join zombie lists for each block pool element using `zombie_dlist_join`.
    - Iterate over 4 lanes to join pending priority queues using `pending_prq_join`.
    - Join account maps and free account maps using `acct_map_join`.
    - Join the free account dlist using `free_dlist_join`.
    - Return the `disp` pointer.
- **Output**: A pointer to the initialized and joined `fd_rdisp_t` structure.
- **Functions Called**:
    - [`fd_rdisp_align`](<#fd_rdisp_align>)


---
### free\_lane<!-- {{#callable:free_lane}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L626>)

Releases a staging lane in the dispatcher and resets its associated counters and block list.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` structure representing the dispatcher.
    - ``staging_lane``: An unsigned long integer representing the index of the staging lane to free.
- **Logic and Control Flow**:
    - Set the bit corresponding to `staging_lane` in `disp->free_lanes` to indicate the lane is free.
    - Retrieve the `per_lane_info_t` structure for the specified `staging_lane`.
    - Assert that the pending priority queue count for the lane is zero using `FD_TEST`.
    - Reset the `linear_block_number`, `inserted_cnt`, `dispatched_cnt`, and `completed_cnt` fields of the lane to zero.
    - Delete the block list associated with the lane using `block_slist_delete` and `block_slist_leave`.
- **Output**: This function does not return a value.


---
### alloc\_lane<!-- {{#callable:alloc_lane}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L639>)

Clears the bit corresponding to `staging_lane` in `disp->free_lanes` and initializes a new block singly-linked list for the specified lane.
- **Inputs**:
    - `disp`: A pointer to an `fd_rdisp_t` structure representing the dispatcher.
    - `staging_lane`: An unsigned long integer representing the lane to allocate.
- **Logic and Control Flow**:
    - Clear the bit corresponding to `staging_lane` in `disp->free_lanes` using bitwise AND with the negation of `1<<staging_lane`.
    - Initialize a new block singly-linked list for the lane specified by `staging_lane` using `block_slist_new` and `block_slist_join`.
- **Output**: No return value; the function modifies the `disp` structure in place.


---
### fd\_rdisp\_suggest\_staging\_lane<!-- {{#callable:fd_rdisp_suggest_staging_lane}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L646>)

Suggests a staging lane for a block based on its status and availability of lanes.
- **Inputs**:
    - ``disp``: A pointer to a `fd_rdisp_t` structure that contains the dispatching system's state.
    - ``parent_block``: A `FD_RDISP_BLOCK_TAG_T` representing the parent block for which a staging lane is being suggested.
    - ``duplicate``: An integer indicating whether the block is a duplicate (non-zero if true).
- **Logic and Control Flow**:
    - Check if `duplicate` is true; if so, return `FD_RDISP_UNSTAGED`.
    - Query the block map for `parent_block` to find its corresponding block information.
    - If the block is found, is insert-ready, and is staged, return its `staging_lane`.
    - If there are free lanes available, return the least significant bit of `free_lanes` as the suggested lane.
    - If no conditions are met, return `FD_RDISP_UNSTAGED`.
- **Output**: Returns an `ulong` representing the suggested staging lane or `FD_RDISP_UNSTAGED` if no suitable lane is found.


---
### fd\_rdisp\_add\_block<!-- {{#callable:fd_rdisp_add_block}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L667>)

Adds a new block to the dispatcher, ensuring it is not already present and assigning it to a staging lane if applicable.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` dispatcher structure where the block will be added.
    - ``new_block``: The tag of the new block to be added.
    - ``staging_lane``: The lane where the block should be staged, or `FD_RDISP_UNSTAGED` if it should not be staged.
- **Logic and Control Flow**:
    - Check if there is a free block in the block pool; if not, return -1.
    - Check if the block is already in the block map; if it is, return -1.
    - Acquire a block from the block pool and set its block tag to `new_block`.
    - Insert the block into the block map.
    - Set the block's `insert_ready` flag to 1.
    - Determine if the block is staged based on `staging_lane` and set the `staged` and `staging_lane` fields accordingly.
    - Initialize various counters and flags in the block to zero.
    - If `staging_lane` is `FD_RDISP_UNSTAGED`, set the block's `schedule_ready` flag, assign a linear block number, and join it to the unstaged transaction linked list.
    - If `staging_lane` is not `FD_RDISP_UNSTAGED`, assign a linear block number, determine if the block is schedule ready, and allocate the lane if it is free.
    - If the block list for the staging lane is not empty, set the `insert_ready` flag of the last block in the list to 0.
    - Push the block to the tail of the block list for the staging lane.
- **Output**: Returns 0 on success, or -1 if the block could not be added due to pool constraints or duplication.
- **Functions Called**:
    - [`alloc_lane`](<#alloc_lane>)


---
### fd\_rdisp\_remove\_block<!-- {{#callable:fd_rdisp_remove_block}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L708>)

Removes a block from the dispatcher system, ensuring it is ready and all transactions are completed before removal.
- **Inputs**:
    - ``disp``: A pointer to the dispatcher (`fd_rdisp_t`) from which the block will be removed.
    - ``block_tag``: The tag (`FD_RDISP_BLOCK_TAG_T`) identifying the block to be removed.
- **Logic and Control Flow**:
    - Retrieve the block information from the block map using `block_tag`.
    - If the block is not found, return -1 indicating failure.
    - Verify that the block is ready for scheduling, all transactions are completed, and the zombie list is empty.
    - If the block is staged, retrieve the staging lane and block list, then remove the block from the head of the list.
    - If the block list is not empty after removal, set the next block's `schedule_ready` to 1; otherwise, free the lane.
    - If the block is not staged, remove it from the unstaged transaction list.
    - Release the block index from the block pool and remove the block from the block map.
    - Return 0 indicating success.
- **Output**: Returns 0 on successful removal of the block, or -1 if the block cannot be removed.
- **Functions Called**:
    - [`free_lane`](<#free_lane>)


---
### fd\_rdisp\_abandon\_block<!-- {{#callable:fd_rdisp_abandon_block}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L737>)

Abandons a block in the dispatcher by completing all pending transactions and releasing resources.
- **Inputs**:
    - ``disp``: A pointer to the dispatcher structure `fd_rdisp_t` that manages the block and transactions.
    - ``block_tag``: The tag identifying the block to abandon, of type `FD_RDISP_BLOCK_TAG_T`.
- **Logic and Control Flow**:
    - Retrieve the block information from the block map using `block_tag`.
    - If the block is not found, return -1 indicating failure.
    - Ensure the block is ready for scheduling and all dispatched transactions are completed.
    - While there are incomplete transactions, get the next ready transaction and complete it.
    - While there are transactions in the zombie list, complete them.
    - If the block is staged, remove it from the staging lane and free the lane if empty.
    - If the block is not staged, delete it from the unstaged transaction list.
    - Release the block index from the block pool and remove the block from the block map.
    - Return 0 indicating success.
- **Output**: Returns 0 on success, or -1 if the block is not found.
- **Functions Called**:
    - [`fd_rdisp_get_next_ready`](<#fd_rdisp_get_next_ready>)
    - [`fd_rdisp_complete_txn`](<#fd_rdisp_complete_txn>)
    - [`free_lane`](<#free_lane>)


---
### fd\_rdisp\_promote\_block<!-- {{#callable:fd_rdisp_promote_block}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L784>)

Promotes an unstaged block to a staged block in a specified staging lane, updating its status and processing its transactions.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` structure representing the dispatcher.
    - ``block_tag``: The tag identifying the block to promote.
    - ``staging_lane``: The index of the staging lane where the block will be promoted.
- **Logic and Control Flow**:
    - Retrieve the block information from the block map using `block_tag`.
    - Check if the block is NULL or already staged; if so, return -1.
    - Set the block's `staged` status to 1 and update its `staging_lane`, `insert_ready`, and `schedule_ready` fields.
    - If the staging lane is free, allocate it using [`alloc_lane`](<#alloc_lane>).
    - If the block list in the lane is not empty, set the `insert_ready` of the last block to 0.
    - Push the block to the tail of the block list in the lane and update its `linear_block_number`.
    - Iterate over the transactions in the block's linked list, updating their `in_degree` and `edge_cnt_etc` fields.
    - Add edges for writable and readonly accounts using [`add_edges`](<#add_edges>).
    - If a transaction's `in_degree` becomes 0, insert it into the pending priority queue.
    - Delete the block's linked list of unstaged transactions.
    - Update the lane's `inserted_cnt`, `dispatched_cnt`, and `completed_cnt` with the block's respective counts.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success, or -1 if the block is NULL or already staged.
- **Functions Called**:
    - [`alloc_lane`](<#alloc_lane>)
    - [`add_edges`](<#add_edges>)


---
### fd\_rdisp\_demote\_block<!-- {{#callable:fd_rdisp_demote_block}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L841>)

Demotes a block from a staged state to an unstaged state in the dispatcher.
- **Inputs**:
    - ``disp``: A pointer to the dispatcher structure `fd_rdisp_t`.
    - ``block_tag``: The tag identifying the block to be demoted, of type `FD_RDISP_BLOCK_TAG_T`.
- **Logic and Control Flow**:
    - Retrieve the block information from the block map using `block_tag`.
    - Check if the block is `NULL`, not staged, or not schedule ready; return -1 if any of these conditions are true.
    - Ensure the block's `completed_cnt` equals `inserted_cnt`; log an error if not.
    - Retrieve the staging lane of the block and set the block's `staged` status to 0.
    - Update the lane's counters by subtracting the block's counters from them.
    - Assign a new linear block number to the block from `disp->unstaged_lblk_num`.
    - Verify the block is the head of the staging lane and remove it from the head of the block list.
    - Join the block to the unstaged transaction linked list.
    - If the block list is not empty, set the new head's `schedule_ready` to 1; otherwise, free the lane.
    - Return 0 to indicate success.
- **Output**: Returns 0 on success, or -1 if the block cannot be demoted due to invalid conditions.
- **Functions Called**:
    - [`free_lane`](<#free_lane>)


---
### fd\_rdisp\_rekey\_block<!-- {{#callable:fd_rdisp_rekey_block}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L874>)

Rekeys a block in the dispatcher by replacing its old tag with a new tag.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` structure representing the dispatcher.
    - ``new_tag``: The new block tag to assign to the block.
    - ``old_tag``: The current block tag of the block to be rekeyed.
- **Logic and Control Flow**:
    - Retrieve the block pool from the dispatcher structure `disp`.
    - Check if a block with `new_tag` already exists in the block map; if it does, return -1 indicating failure.
    - Query the block map for a block with `old_tag`; if not found, return -1 indicating failure.
    - Update the block's tag to `new_tag`.
    - Insert the block back into the block map with the new tag.
    - Return 0 indicating success.
- **Output**: Returns 0 on success, or -1 if a block with `new_tag` already exists or if `old_tag` does not exist.


---
### update\_ema<!-- {{#callable:update_ema}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L895>)

Calculates and updates the Exponential Moving Average (EMA) for an account reference based on the global insertion count.
- **Inputs**:
    - ``info``: A pointer to an `acct_info_t` structure containing the account's last reference and EMA value.
    - ``global_insert_cnt``: An unsigned long integer representing the current global insertion count.
- **Logic and Control Flow**:
    - If `FD_RDISP_DISABLE_EMA` is defined, the function returns 0.0f immediately without performing any calculations.
    - Defines a constant `ALPHA` with a value of 0.005f, which is used in the EMA calculation.
    - Calculates `delta` as the difference between `global_insert_cnt` and `info->last_ref`, masked with `0xFFFFFFUL` to handle overflow of the 24-bit `last_ref`.
    - Computes the new EMA value `ema_refs` using the formula: `ALPHA + powf(1.0f - ALPHA, (float)delta) * info->ema_refs`.
    - Updates `info->ema_refs` with the newly calculated EMA value.
    - Updates `info->last_ref` with the lower 24 bits of `global_insert_cnt`.
    - Returns the updated EMA value `ema_refs`.
- **Output**: Returns a float representing the updated EMA value for the account reference.


---
### add\_edges<!-- {{#callable:add_edges}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L929>)

Adds edges to a transaction in a directed acyclic graph (DAG) based on account addresses and transaction properties.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` structure representing the dispatcher context.
    - ``ele``: A pointer to the `fd_rdisp_txn_t` structure representing the transaction to which edges are added.
    - ``addrs``: A pointer to an array of `fd_acct_addr_t` structures representing the account addresses involved in the transaction.
    - ``addr_cnt``: The number of account addresses in the `addrs` array.
    - ``lane``: An unsigned integer representing the concurrency lane for the transaction.
    - ``writable``: An integer indicating whether the transaction writes to the accounts (non-zero if writable).
    - ``update_score``: An integer indicating whether to update the transaction's score based on the estimated probability of non-conflict (non-zero if updating).
- **Logic and Control Flow**:
    - Initialize `acct_idx` and `edge_idx` based on the transaction's `edge_cnt_etc` field.
    - Iterate over each account address in `addrs`.
    - For each address, query the account map to find or create an `acct_info_t` entry.
    - If the account is not found in the active map, check the free map and transition the account to the active state if necessary.
    - Update the transaction's score based on the estimated probability of non-conflict if `writable` and `update_score` are set.
    - Determine the type of edge to add (write or read) and update the DAG structure accordingly, handling four cases: write-write, read-write, write-read, and read-read.
    - Update the transaction's `in_degree` and the account's last reference and flags.
    - Increment `edge_idx` and `acct_idx` for the next iteration.
    - Update the transaction's `edge_cnt_etc` field to reflect the number of addresses processed.
- **Output**: No return value; the function modifies the transaction and dispatcher context in place.
- **Functions Called**:
    - [`update_ema`](<#update_ema>)


---
### add\_unstaged\_edges<!-- {{#callable:add_unstaged_edges}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1090>)

Adds unstaged edges to a transaction, updating the unstaged structure and optionally adjusting the transaction's score based on account information.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` structure, which contains the dispatcher state and resources.
    - ``ele``: A pointer to the `fd_rdisp_txn_t` structure, representing the transaction to which edges are being added.
    - ``unstaged``: A pointer to the `fd_rdisp_unstaged_t` structure, which holds information about unstaged transactions.
    - ``addr``: A pointer to an array of `fd_acct_addr_t` structures, representing the account addresses involved in the transaction.
    - ``addr_cnt``: An unsigned long integer indicating the number of account addresses in the `addr` array.
    - ``writable``: An integer flag indicating whether the accounts are writable (non-zero) or read-only (zero).
    - ``update_score``: An integer flag indicating whether to update the transaction's score based on account information (non-zero) or not (zero).
- **Logic and Control Flow**:
    - Calculate the base index for the unstaged keys array using the sum of `writable_cnt` and `readonly_cnt` from the `unstaged` structure.
    - Assert that if `writable` is true, `readonly_cnt` in `unstaged` is zero, ensuring writable accounts are processed first.
    - Iterate over each account address in the `addr` array, updating the `unstaged->keys` array starting from the calculated base index.
    - If `update_score` is true, query the account map for each address to find its index, and update the transaction's score using the EMA (Exponential Moving Average) of account references.
    - Update the count of writable or read-only accounts in the `unstaged` structure based on the `writable` flag.
- **Output**: None (void function).
- **Functions Called**:
    - [`update_ema`](<#update_ema>)


---
### fd\_rdisp\_add\_txn<!-- {{#callable:fd_rdisp_add_txn}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1115>)

Adds a transaction to a dispatcher, handling both staged and unstaged blocks, and updates the transaction's dependencies and score.
- **Inputs**:
    - ``disp``: A pointer to the dispatcher (`fd_rdisp_t`) where the transaction will be added.
    - ``insert_block``: The block tag (`FD_RDISP_BLOCK_TAG_T`) where the transaction should be inserted.
    - ``txn``: A constant pointer to the transaction (`fd_txn_t`) to be added.
    - ``payload``: A constant pointer to the payload data associated with the transaction.
    - ``alts``: A constant pointer to alternative account addresses (`fd_acct_addr_t`) that may be involved in the transaction.
    - ``serializing``: An integer flag indicating if the transaction is serializing.
- **Logic and Control Flow**:
    - Query the block map to find the block associated with `insert_block` and check if it is ready for insertion.
    - Check if there is space in the transaction pool; if not, return 0.
    - Acquire an index from the transaction pool and initialize the transaction at that index.
    - Retrieve immediate account addresses from the transaction using `fd_txn_get_acct_addrs`.
    - If the block is unstaged, set the transaction's in-degree to `IN_DEGREE_UNSTAGED` and score to 0.999, then add unstaged edges for writable and readonly accounts.
    - If the block is staged, set the transaction's in-degree to 0 and score to 0.999, then add edges for writable and readonly accounts using the staging lane.
    - Update the block's `last_serializing` and `last_insert_was_serializing` based on the `serializing` flag.
    - Increment the block's `inserted_cnt` and the dispatcher's `global_insert_cnt`.
    - If the block is staged and the transaction's in-degree is 0, insert the transaction into the pending priority queue for the staging lane.
    - Return the index of the transaction in the pool.
- **Output**: Returns the index of the transaction in the pool as an unsigned long integer, or 0 if the transaction could not be added.
- **Functions Called**:
    - [`add_unstaged_edges`](<#add_unstaged_edges>)
    - [`add_edges`](<#add_edges>)


---
### fd\_rdisp\_get\_next\_ready<!-- {{#callable:fd_rdisp_get_next_ready}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1198>)

Retrieves the next transaction index that is ready for dispatch from a specified block in a dispatcher.
- **Inputs**:
    - ``disp``: A pointer to a `fd_rdisp_t` structure representing the dispatcher.
    - ``schedule_block``: A `FD_RDISP_BLOCK_TAG_T` value representing the block tag to schedule.
- **Logic and Control Flow**:
    - Query the block information from the dispatcher's block map using `schedule_block`.
    - If the block is not found or not ready for scheduling, return 0.
    - If the block is staged, check if there are pending transactions in the staging lane and if the block number and score conditions are met.
    - If conditions are met, retrieve the transaction index from the pending queue, update its in-degree, and remove it from the queue.
    - If the block is not staged, check if the dispatched count equals the completed count and if there are unstaged transactions.
    - If conditions are met, retrieve the transaction index from the unstaged transaction list and update its in-degree.
    - Increment the block's dispatched count.
    - Return the transaction index.
- **Output**: Returns the index of the next transaction ready for dispatch, or 0 if no transaction is ready.


---
### fd\_rdisp\_complete\_txn<!-- {{#callable:fd_rdisp_complete_txn}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1227>)

Completes a transaction in a distributed dispatcher system, updating its state and managing its dependencies.
- **Inputs**:
    - ``disp``: A pointer to the `fd_rdisp_t` structure representing the dispatcher system.
    - ``txn_idx``: The index of the transaction to complete within the dispatcher's transaction pool.
    - ``reclaim``: An integer flag indicating whether to reclaim the transaction's resources after completion.
- **Logic and Control Flow**:
    - Retrieve the transaction from the pool using `txn_idx` and initialize `block` to `NULL`.
    - Check if the transaction is unstaged and dispatched (`IN_DEGREE_UNSTAGED_DISPATCHED`); if so, update the block's completed count and remove the transaction from the unstaged list.
    - If the transaction is staged and dispatched (`IN_DEGREE_DISPATCHED`), iterate over its edges to update account information and manage dependencies, potentially transitioning accounts from ACTIVE to CACHED state.
    - If the transaction is a zombie (`IN_DEGREE_ZOMBIE`), ensure `reclaim` is true, remove it from the zombie list, and prepare for resource release.
    - If `reclaim` is true, release the transaction's resources and mark it as free; otherwise, mark it as a zombie and add it to the zombie list.
- **Output**: The function does not return a value; it modifies the state of the dispatcher and its transactions in place.


---
### fd\_rdisp\_staging\_lane\_info<!-- {{#callable:fd_rdisp_staging_lane_info}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1409>)

Retrieves information about the staging lanes in a dispatcher and updates the output array with the blocks ready for insertion and scheduling.
- **Inputs**:
    - ``disp``: A pointer to a constant `fd_rdisp_t` structure representing the dispatcher.
    - ``out_sched``: An array of `fd_rdisp_staging_lane_info_t` structures with a static size of 4, used to store the information about the blocks ready for insertion and scheduling in each lane.
- **Logic and Control Flow**:
    - Iterate over the four possible staging lanes (indexed from 0 to 3).
    - For each lane, check if the lane is not free by evaluating the bitmask `disp->free_lanes & (1<<i)`.
    - If the lane is not free, retrieve the block list associated with the lane using `disp->lanes[i].block_ll`.
    - Update `out_sched[i].insert_ready_block` with the block at the tail of the block list using `block_slist_ele_peek_tail`.
    - Update `out_sched[i].schedule_ready_block` with the block at the head of the block list using `block_slist_ele_peek_head`.
    - Return a bitmask representing the lanes that are not free by inverting `disp->free_lanes` and masking with `0xFUL`.
- **Output**: Returns a `ulong` bitmask indicating which of the four lanes are not free.


---
### fd\_rdisp\_verify<!-- {{#callable:fd_rdisp_verify}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1422>)

Verifies the integrity of the account and block maps and checks the correctness of in-degree counts for transactions in a dispatch structure.
- **Inputs**:
    - ``disp``: A pointer to a `fd_rdisp_t` structure representing the dispatch structure to verify.
    - ``scratch``: A pointer to an array of unsigned integers used as temporary storage during verification.
- **Logic and Control Flow**:
    - Calculate `acct_depth` as `disp->depth * MAX_ACCT_PER_TXN` and `block_depth` as `disp->block_depth`.
    - Verify the account map `disp->acct_map` and free account map `disp->free_acct_map` using `acct_map_verify`, ensuring they are consistent with `acct_depth + 1UL` and `disp->acct_pool`.
    - Verify the block map `disp->blockmap` using `block_map_verify`, ensuring it is consistent with `block_depth + 1UL` and `disp->block_pool`.
    - Initialize the `scratch` array to zero, except for `scratch[0]` which is set to `UINT_MAX`.
    - Iterate over each transaction in `disp->pool` from index 1 to `disp->depth + 1UL`.
    - For each transaction, skip if `in_degree` is `IN_DEGREE_FREE`, `IN_DEGREE_UNSTAGED_DISPATCHED`, `IN_DEGREE_UNSTAGED`, or `IN_DEGREE_ZOMBIE`.
    - For each transaction, calculate `w_cnt` and `r_cnt` from `edge_cnt_etc`, and iterate over its edges.
    - For each edge, if it is not the last edge, traverse child and sibling links to update `scratch` for child transactions.
    - After processing all transactions, verify that each transaction's `in_degree` matches the expected value in `scratch`.
- **Output**: No return value; the function performs verification and asserts correctness using `FD_TEST`.


---
### fd\_rdisp\_leave<!-- {{#callable:fd_rdisp_leave}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1484>)

Returns the input `fd_rdisp_t` pointer without modification.
- **Inputs**:
    - `disp`: A pointer to an `fd_rdisp_t` structure, representing a dispatcher object.
- **Logic and Control Flow**:
    - The function takes a single argument, `disp`, which is a pointer to an `fd_rdisp_t` structure.
    - It returns the same pointer `disp` without any modification.
- **Output**: The function returns the same `fd_rdisp_t` pointer that was passed as input.


---
### fd\_rdisp\_delete<!-- {{#callable:fd_rdisp_delete}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L1485>)

Returns the input memory pointer without modification.
- **Inputs**:
    - ``mem``: A pointer to a memory block that the function will return.
- **Logic and Control Flow**:
    - The function takes a single input parameter, `mem`.
    - It returns the `mem` parameter without any changes.
- **Output**: The function returns the same pointer that was passed as the input argument `mem`.


# Function Declarations (Public API)

---
### add\_edges<!-- {{#callable_declaration:add_edges}} -->
[View Source →](<../../../../../src/discof/replay/fd_rdisp.c#L774>)

Adds edges to a transaction in a conflict graph.
- **Description**: Use this function to add edges to a transaction node within a conflict graph, which is part of a directed acyclic graph (DAG) structure. This function updates the transaction's in-degree and edge count based on the provided account addresses. It must be called with all writable accounts first, and it can update the transaction's score based on the likelihood of conflicts. Ensure that the dispatcher and transaction are properly initialized before calling this function.
- **Inputs**:
    - `disp`: A pointer to the dispatcher structure (`fd_rdisp_t`). Must not be null. The caller retains ownership.
    - `ele`: A pointer to the transaction node (`fd_rdisp_txn_t`) to which edges will be added. Must not be null. The caller retains ownership.
    - `addrs`: A pointer to an array of account addresses (`fd_acct_addr_t const *`). Must not be null. The caller retains ownership.
    - `addr_cnt`: The number of account addresses in the `addrs` array. Must be a non-negative value.
    - `lane`: An unsigned integer representing the concurrency lane. Valid values depend on the system's configuration.
    - `writable`: An integer indicating whether the accounts are writable (non-zero) or read-only (zero).
    - `update_score`: An integer indicating whether to update the transaction's score based on conflict probability (non-zero) or not (zero).
- **Output**: None
- **See Also**: [`add_edges`](<#add_edges>)  (Implementation)



---
Made with ❤️ by [Driver](https://www.driver.ai/)