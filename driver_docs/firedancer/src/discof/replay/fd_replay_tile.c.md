<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a replay tile for processing blockchain data, managing transactions, and coordinating with other components in a distributed system.

# Purpose
The code is a C module for a replay tile in a distributed ledger system. It is responsible for processing and replaying transactions from a blockchain network. The module handles various tasks such as managing the state of the blockchain, processing incoming data fragments (shreds), and coordinating with other components like the scheduler, transaction cache, and account database.

Key components of the module include structures for managing input and output links, replay state, and block identifiers. The module processes different types of messages, such as genesis, snapshot, execution, and tower updates, to maintain the blockchain's state. It also handles the scheduling and execution of transactions, manages leader election, and ensures the integrity of the blockchain through hash comparisons. The module is designed to work within a larger system, interacting with other tiles and components to maintain the distributed ledger's consistency and performance.
# Imports and Dependencies

---
- `fd_replay_tile.h`
- `fd_sched.h`
- `fd_exec.h`
- `fd_vote_tracker.h`
- `../../flamenco/accdb/fd_accdb_sync.h`
- `generated/fd_replay_tile_seccomp.h`
- `../genesis/fd_genesi_tile.h`
- `../poh/fd_poh.h`
- `../poh/fd_poh_tile.h`
- `../tower/fd_tower_tile.h`
- `../resolv/fd_resolv_tile.h`
- `../restore/utils/fd_ssload.h`
- `../../disco/tiles.h`
- `../../disco/fd_txn_m.h`
- `../../disco/store/fd_store.h`
- `../../discof/reasm/fd_reasm.h`
- `../../disco/keyguard/fd_keyload.h`
- `../../util/pod/fd_pod.h`
- `../../flamenco/accdb/fd_accdb_admin.h`
- `../../flamenco/accdb/fd_accdb_user.h`
- `../../flamenco/rewards/fd_rewards.h`
- `../../flamenco/leaders/fd_multi_epoch_leaders.h`
- `../../flamenco/progcache/fd_progcache_admin.h`
- `../../disco/metrics/fd_metrics.h`
- `../../flamenco/runtime/fd_runtime.h`
- `../../flamenco/runtime/fd_runtime_stack.h`
- `../../flamenco/fd_flamenco_base.h`
- `../../flamenco/runtime/sysvar/fd_sysvar_epoch_schedule.h`
- `../../flamenco/runtime/tests/fd_dump_pb.h`
- `errno.h`
- `../../util/tmpl/fd_map_chain.c`
- `../../disco/stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_replay
- **Type**: `fd_topo_run_tile_t`
- **Description**: Defines a global variable that represents a tile configuration for the replay tile in a distributed system. It includes function pointers and parameters for initializing and running the replay tile.
- **Use**: Used to configure and manage the execution of the replay tile in the system.


# Data Structures

---
### fd\_replay\_in\_link
- **Type**: ``struct``
- **Members**:
    - ``mem``: Pointer to a workspace of type `fd_wksp_t`.
    - ``chunk0``: Unsigned long integer representing the initial chunk.
    - ``wmark``: Unsigned long integer representing the watermark.
    - ``mtu``: Unsigned long integer representing the maximum transmission unit.
- **Description**: The `fd_replay_in_link` structure is used to manage input links in a replay system, holding information about memory workspace, initial chunk, watermark, and maximum transmission unit for data handling.


---
### fd\_replay\_in\_link\_t
- **Type**: ``struct``
- **Members**:
    - ``mem``: Pointer to a workspace memory area.
    - ``chunk0``: Initial chunk index in the workspace.
    - ``wmark``: Watermark indicating the limit of valid data in the workspace.
    - ``mtu``: Maximum transmission unit size for data chunks.
- **Description**: The `fd_replay_in_link_t` structure is used to manage input links in a replay tile, providing information about the memory workspace, initial chunk index, watermark, and maximum transmission unit size. This structure facilitates the handling of data chunks within the replay process, ensuring that data is processed within defined limits and memory constraints.


---
### fd\_replay\_out\_link
- **Type**: ``struct``
- **Members**:
    - ``idx``: Index of the output link.
    - ``mem``: Pointer to the memory workspace.
    - ``chunk0``: Initial chunk index for the data cache.
    - ``wmark``: Watermark for the data cache.
    - ``chunk``: Current chunk index for the data cache.
- **Description**: The `fd_replay_out_link` structure manages the output link for replay operations, including memory workspace and data cache indices. It holds information about the index of the output link, the memory workspace pointer, and the chunk indices for managing data flow in the replay process.


---
### fd\_replay\_out\_link\_t
- **Type**: ``struct``
- **Members**:
    - ``idx``: Index of the output link.
    - ``mem``: Pointer to the memory workspace.
    - ``chunk0``: Initial chunk index in the memory workspace.
    - ``wmark``: Watermark indicating the maximum chunk index.
    - ``chunk``: Current chunk index in the memory workspace.
- **Description**: `fd_replay_out_link_t` is a structure that represents an output link in the replay tile system. It contains information about the memory workspace, including the index of the output link, pointers to the memory, and chunk indices for managing data flow. This structure is used to facilitate communication and data transfer between different components in the system.


---
### fd\_block\_id\_ele
- **Type**: ``struct``
- **Members**:
    - ``block_id``: A hash representing the block ID.
    - ``slot``: An unsigned long indicating the slot, set to `FD_SLOT_NULL` if not initialized.
    - ``next_``: An unsigned long used for linking in a map or list.
- **Description**: Defines an element in a block ID map, serving as a translation layer between block IDs and bank indices. It includes a block ID, a slot number, and a linking field for map operations.


---
### fd\_block\_id\_ele\_t
- **Type**: ``struct``
- **Members**:
    - ``block_id``: A hash representing the block ID.
    - ``slot``: An unsigned long indicating the slot number, set to `FD_SLOT_NULL` if not initialized.
    - ``next_``: An unsigned long used for linking in a map or list.
- **Description**: `fd_block_id_ele_t` is a structure used to map block IDs to bank indices in a blockchain system. It contains a block ID represented by a hash, a slot number indicating the position in the blockchain, and a `next_` field for linking elements in a map or list. This structure serves as a translation layer between block IDs and bank indices, facilitating the management and retrieval of blockchain data.


---
### fd\_replay\_tile
- **Type**: ``struct``
- **Members**:
    - ``wksp``: Pointer to a workspace structure.
    - ``tx_metadata_storage``: Integer flag to enable log collector.
    - ``accdb_admin``: Array of one admin account database structure.
    - ``accdb``: Array of one user account database structure.
    - ``progcache_admin``: Array of one program cache admin structure.
    - ``txncache``: Pointer to a transaction cache structure.
    - ``store``: Pointer to a store structure.
    - ``banks``: Pointer to a banks structure.
    - ``has_identity_vote_rooted``: Flag indicating if a vote signature has been rooted.
    - ``reasm``: Pointer to a reassembler structure.
    - ``sched``: Pointer to a scheduler structure.
    - ``enable_bank_hash_cmp``: Flag to enable bank hash comparison.
    - ``bank_hash_cmp``: Pointer to a bank hash comparison structure.
    - ``exec_cnt``: Count of executions.
    - ``exec_out``: Array of one replay output link structure for execution.
    - ``vote_tracker``: Pointer to a vote tracker structure.
    - ``has_genesis_hash``: Flag indicating if the genesis hash is present.
    - ``genesis_hash``: Array of 32 unsigned characters for the genesis hash.
    - ``hard_forks_cnt``: Count of hard forks.
    - ``hard_forks``: Array of hard fork identifiers.
    - ``expected_shred_version``: Expected shred version.
    - ``ipecho_shred_version``: Shred version from IP echo.
    - ``consensus_root``: Hash of the most recent block to reach max lockout.
    - ``consensus_root_slot``: Slot number of the consensus root.
    - ``consensus_root_bank_idx``: Bank index of the consensus root.
    - ``published_root_slot``: Slot number of the published root.
    - ``published_root_bank_idx``: Bank index of the published root.
    - ``block_id_len``: Length of the block ID array.
    - ``block_id_arr``: Pointer to an array of block ID elements.
    - ``block_id_map``: Pointer to a block ID map structure.
    - ``capture_ctx``: Pointer to a capture context structure.
    - ``capture_file``: Pointer to a file for capture.
    - ``is_booted``: Flag indicating if the runtime has been booted.
    - ``vote_tower_out_idx``: Index of the next vote tower to publish.
    - ``vote_tower_out_len``: Number of vote towers in the buffer.
    - ``vote_tower_out``: Array of vote tower structures.
    - ``mleaders``: Pointer to a multi-epoch leaders structure.
    - ``identity_pubkey``: Array of one public key for identity.
    - ``is_leader``: Flag indicating if the node is currently the leader.
    - ``recv_poh``: Flag indicating if a PoH message has been received.
    - ``recv_block_id``: Flag indicating if a block ID has been received.
    - ``next_leader_slot``: Slot number for the next leader.
    - ``next_leader_tickcount``: Tick count for the next leader.
    - ``highwater_leader_slot``: Highwater mark for the leader slot.
    - ``reset_slot``: Slot number for reset.
    - ``reset_bank``: Pointer to a bank structure for reset.
    - ``reset_block_id``: Hash of the reset block ID.
    - ``reset_timestamp_nanos``: Timestamp in nanoseconds for reset.
    - ``slot_duration_nanos``: Duration of a slot in nanoseconds.
    - ``slot_duration_ticks``: Duration of a slot in ticks.
    - ``leader_bank``: Pointer to a bank structure for the leader.
    - ``resolv_tile_cnt``: Count of resolution tiles.
    - ``in_kind``: Array of 64 integers indicating input kinds.
    - ``in``: Array of 64 replay input link structures.
    - ``replay_out``: Array of one replay output link structure.
    - ``stake_out``: Array of one stake output link structure.
    - ``gui_enabled``: Flag indicating if the GUI is enabled.
    - ``block_dump_ctx``: Pointer to a block dump context structure.
    - ``metrics``: Structure containing various metrics.
    - ``mleaders_mem``: Memory for multi-epoch leaders, aligned to a specific boundary.
    - ``runtime_stack``: Runtime stack structure.
- **Description**: The `fd_replay_tile` structure is a complex data structure used in a blockchain system to manage and process replay operations. It contains various pointers to other structures such as workspaces, account databases, program caches, transaction caches, and banks. It also includes flags and counters for managing the state of the replay process, such as whether the node has seen a vote signature rooted, whether the runtime has been booted, and the current leader status. The structure manages input and output links for replay operations, tracks metrics, and handles the publishing of vote towers and slot completions. It is designed to handle complex operations related to block replay, including managing forks, publishing roots, and processing transactions.


---
### fd\_replay\_tile\_t
- **Type**: ``struct``
- **Members**:
    - ``wksp``: Pointer to a workspace used by the replay tile.
    - ``tx_metadata_storage``: Flag to enable transaction metadata storage.
    - ``accdb_admin``: Array of one `fd_accdb_admin_t` for account database administration.
    - ``accdb``: Array of one `fd_accdb_user_t` for account database usage.
    - ``progcache_admin``: Array of one `fd_progcache_admin_t` for program cache administration.
    - ``txncache``: Pointer to a transaction cache.
    - ``store``: Pointer to a store for managing data.
    - ``banks``: Pointer to a bank structure for managing banks.
    - ``has_identity_vote_rooted``: Flag indicating if a vote signature has been rooted.
    - ``reasm``: Pointer to a reassembler for FEC sets.
    - ``sched``: Pointer to a scheduler for managing tasks.
    - ``enable_bank_hash_cmp``: Flag to enable bank hash comparison.
    - ``bank_hash_cmp``: Pointer to a bank hash comparison structure.
    - ``exec_cnt``: Count of execution tiles.
    - ``exec_out``: Array of one `fd_replay_out_link_t` for sending work to execution tiles.
    - ``vote_tracker``: Pointer to a vote tracker for tracking votes.
    - ``has_genesis_hash``: Flag indicating if the genesis hash is set.
    - ``genesis_hash``: Array of 32 unsigned characters for storing the genesis hash.
    - ``hard_forks_cnt``: Count of hard forks.
    - ``hard_forks``: Array of hard fork identifiers.
    - ``expected_shred_version``: Expected shred version.
    - ``ipecho_shred_version``: Shred version from ipecho.
    - ``consensus_root``: Hash of the most recent block to reach consensus.
    - ``consensus_root_slot``: Slot number of the consensus root.
    - ``consensus_root_bank_idx``: Bank index of the consensus root.
    - ``published_root_slot``: Slot number of the published root.
    - ``published_root_bank_idx``: Bank index of the published root.
    - ``block_id_len``: Length of the block ID array.
    - ``block_id_arr``: Pointer to an array of block ID elements.
    - ``block_id_map``: Pointer to a map of block IDs to bank indices.
    - ``capture_ctx``: Pointer to a capture context for capturing data.
    - ``capture_file``: File pointer for capture output.
    - ``is_booted``: Flag indicating if the runtime has been booted.
    - ``vote_tower_out_idx``: Index of the next vote tower to publish.
    - ``vote_tower_out_len``: Number of vote towers in the buffer.
    - ``vote_tower_out``: Array of vote towers to be published.
    - ``mleaders``: Pointer to a multi-epoch leaders structure.
    - ``identity_pubkey``: Array of one public key for identity.
    - ``is_leader``: Flag indicating if the tile is currently the leader.
    - ``recv_poh``: Flag indicating if a PoH message has been received.
    - ``recv_block_id``: Flag indicating if a block ID has been received.
    - ``next_leader_slot``: Slot number for the next leader.
    - ``next_leader_tickcount``: Tick count for the next leader slot.
    - ``highwater_leader_slot``: Highest slot number for which the tile has been leader.
    - ``reset_slot``: Slot number for resetting the leader state.
    - ``reset_bank``: Pointer to the bank used for resetting the leader state.
    - ``reset_block_id``: Block ID used for resetting the leader state.
    - ``reset_timestamp_nanos``: Timestamp in nanoseconds for resetting the leader state.
    - ``slot_duration_nanos``: Duration of a slot in nanoseconds.
    - ``slot_duration_ticks``: Duration of a slot in ticks.
    - ``leader_bank``: Pointer to the bank used when the tile is leader.
    - ``resolv_tile_cnt``: Count of resolution tiles.
    - ``in_kind``: Array of input kinds for the tile.
    - ``in``: Array of input links for the tile.
    - ``replay_out``: Array of one output link for replay.
    - ``stake_out``: Array of one output link for stake.
    - ``gui_enabled``: Flag indicating if the GUI is enabled.
    - ``block_dump_ctx``: Pointer to a block dump context for backtesting.
    - ``metrics``: Structure containing various metrics for the replay tile.
    - ``mleaders_mem``: Memory for multi-epoch leaders, aligned to a specific boundary.
    - ``runtime_stack``: Runtime stack for the replay tile.
- **Description**: The `fd_replay_tile_t` structure is a complex data structure used in a replay tile for managing and processing blockchain data. It contains various members for handling workspaces, transaction metadata, account databases, program caches, transaction caches, and banks. The structure also includes flags and pointers for managing leader states, capturing data, and tracking votes. Additionally, it has members for handling input and output links, metrics, and runtime stacks. The structure is designed to facilitate the replay of blockchain data, manage leader transitions, and ensure the integrity and consistency of the blockchain state.


# Functions

---
### fd\_block\_id\_ele\_get\_idx<!-- {{#callable:fd_block_id_ele_get_idx}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L131>)

Calculates the index of an element in an array of `fd_block_id_ele_t` structures.
- **Inputs**:
    - `ele_arr`: A pointer to the first element of an array of `fd_block_id_ele_t` structures.
    - `ele`: A pointer to a specific `fd_block_id_ele_t` element within the array `ele_arr`.
- **Logic and Control Flow**:
    - Subtracts the pointer `ele_arr` from the pointer `ele` to determine the index of `ele` within `ele_arr`.
- **Output**: Returns the index of the element `ele` within the array `ele_arr` as an `ulong`.


---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L404>)

Returns a constant value of 128UL.
- **Inputs**: None
- **Logic and Control Flow**:
    - The function is defined as `static inline` and `FD_FN_CONST`, indicating it is a constant function that returns a fixed value.
    - The function body contains a single return statement that returns the value `128UL`.
- **Output**: The function outputs an unsigned long integer with the value 128UL.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L408>)

Calculates the memory footprint required for various components of a replay tile based on the given topology tile configuration.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure that contains configuration details for the replay tile, including the maximum number of live slots and whether block dumping to protobuf is enabled.
- **Logic and Control Flow**:
    - Estimate the number of chains using `fd_block_id_map_chain_cnt_est` based on `tile->replay.max_live_slots`.
    - Initialize the layout with `FD_LAYOUT_INIT`.
    - Append the size and alignment of `fd_replay_tile_t` to the layout using `FD_LAYOUT_APPEND`.
    - Append the size and alignment of an array of `fd_block_id_ele_t` with length `tile->replay.max_live_slots` to the layout.
    - Append the alignment and footprint of a block ID map using `fd_block_id_map_align` and `fd_block_id_map_footprint` with the estimated chain count.
    - Append the alignment and footprint of a transaction cache using `fd_txncache_align` and `fd_txncache_footprint` with `tile->replay.max_live_slots`.
    - Append the alignment and footprint of a reassembler using `fd_reasm_align` and `fd_reasm_footprint` with a fixed size of `1 << 20`.
    - Append the alignment and footprint of a scheduler using [`fd_sched_align`](<fd_sched.c.md#fd_sched_align>) and [`fd_sched_footprint`](<fd_sched.c.md#fd_sched_footprint>) with `tile->replay.max_live_slots`.
    - Append the alignment and footprint of a vote tracker using [`fd_vote_tracker_align`](<fd_vote_tracker.c.md#fd_vote_tracker_align>) and [`fd_vote_tracker_footprint`](<fd_vote_tracker.c.md#fd_vote_tracker_footprint>).
    - Append the alignment and footprint of a capture context using `fd_capture_ctx_align` and `fd_capture_ctx_footprint`.
    - If `tile->replay.dump_block_to_pb` is true, append the alignment and footprint of a block dump context using `fd_block_dump_context_align` and `fd_block_dump_context_footprint`.
    - Finalize the layout with `FD_LAYOUT_FINI` using [`scratch_align`](<#scratch_align>).
    - Return the calculated layout size `l`.
- **Output**: Returns an `ulong` representing the total memory footprint required for the replay tile components.
- **Functions Called**:
    - [`fd_sched_align`](<fd_sched.c.md#fd_sched_align>)
    - [`fd_sched_footprint`](<fd_sched.c.md#fd_sched_footprint>)
    - [`fd_vote_tracker_align`](<fd_vote_tracker.c.md#fd_vote_tracker_align>)
    - [`fd_vote_tracker_footprint`](<fd_vote_tracker.c.md#fd_vote_tracker_footprint>)
    - [`scratch_align`](<#scratch_align>)


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L431>)

Copies various metrics from the `ctx` structure to the `REPLAY` metrics system and updates several gauges and counters.
- **Inputs**:
    - `ctx`: A pointer to a `fd_replay_tile_t` structure containing metrics and state information.
- **Logic and Control Flow**:
    - Copies histogram metrics from `ctx->metrics` to the `REPLAY` metrics system using `FD_MHIST_COPY` for different wait and work metrics.
    - Sets the `ROOT_SLOT` gauge using `FD_MGAUGE_SET`, checking if `ctx->consensus_root_slot` is `ULONG_MAX` to set it to 0 if true.
    - Determines the `leader_slot` by checking if `ctx->leader_bank` is non-null and retrieves the slot using `fd_bank_slot_get`; otherwise, sets it to 0.
    - Sets the `LEADER_SLOT` and `NEXT_LEADER_SLOT` gauges based on whether `ctx->leader_bank` is non-null, using `FD_MGAUGE_SET`.
    - Sets the `RESET_SLOT` gauge, checking if `ctx->reset_slot` is `ULONG_MAX` to set it to 0 if true.
    - Calculates the number of live banks by subtracting the number of free banks from the maximum number of banks in the pool, and sets the `LIVE_BANKS` gauge.
    - Sets the `SLOTS_TOTAL` and `TRANSACTIONS_TOTAL` counters using `FD_MCNT_SET` with values from `ctx->metrics`.
- **Output**: This function does not return a value.


---
### generate\_stake\_weight\_msg<!-- {{#callable:generate_stake_weight_msg}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L461>)

Generates a stake weight message for a given epoch using epoch schedule and vote states.
- **Inputs**:
    - `epoch`: The current epoch for which the stake weight message is generated.
    - `epoch_schedule`: A pointer to the `fd_epoch_schedule_t` structure containing the schedule of slots per epoch and warmup status.
    - `epoch_stakes`: A pointer to the `fd_vote_states_t` structure containing the vote states for the epoch.
    - `stake_weight_msg_out`: A pointer to an unsigned long where the generated stake weight message will be stored.
- **Logic and Control Flow**:
    - Cast `stake_weight_msg_out` to `fd_stake_weight_msg_t` and assign it to `stake_weight_msg`.
    - Set the `epoch`, `start_slot`, `slot_cnt`, `excluded_stake`, and `vote_keyed_lsched` fields of `stake_weight_msg`.
    - Check if the warmup condition and epoch are less than the active epoch for testnet or mainnet, and set `vote_keyed_lsched` to 0 if true.
    - Initialize an iterator for `epoch_stakes` and iterate through each vote state.
    - For each vote state with a non-zero stake, copy the stake and public keys to `stake_weights`.
    - Count the number of staked vote states and store it in `staked_cnt`.
    - Sort the `stake_weights` by stake and vote in place.
    - Return the size of the stake weight message using `fd_stake_weight_msg_sz`.
- **Output**: Returns the size of the generated stake weight message as an unsigned long.


---
### publish\_stake\_weights<!-- {{#callable:publish_stake_weights}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L500>)

Publishes stake weights for the current or next epoch based on the bank's epoch schedule and vote states.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains context information for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing data.
    - ``bank``: A pointer to the `fd_bank_t` structure, representing the bank for which stake weights are being published.
    - ``current_epoch``: An integer indicating whether the current epoch is being processed (non-zero) or not (zero).
- **Logic and Control Flow**:
    - Query the epoch schedule from the bank using `fd_bank_epoch_schedule_query`.
    - Determine the current epoch using `fd_slot_to_epoch` with the bank's slot.
    - Based on `current_epoch`, lock the previous vote states using either `fd_bank_vote_states_prev_locking_query` or `fd_bank_vote_states_prev_prev_locking_query`.
    - Convert the chunk to a local address using `fd_chunk_to_laddr` to prepare for the stake weights message.
    - Generate the stake weight message using [`generate_stake_weight_msg`](<#generate_stake_weight_msg>), which calculates the size of the message.
    - Publish the stake weights using `fd_stem_publish` with the calculated size and signature.
    - Update the chunk for the next message using `fd_dcache_compact_next`.
    - Unlock the vote states using either `fd_bank_vote_states_prev_end_locking_query` or `fd_bank_vote_states_prev_prev_end_locking_query` based on `current_epoch`.
    - Initialize and finalize the multi-epoch leaders stake message using `fd_multi_epoch_leaders_stake_msg_init` and `fd_multi_epoch_leaders_stake_msg_fini`.
- **Output**: No return value; the function performs operations to publish stake weights.
- **Functions Called**:
    - [`generate_stake_weight_msg`](<#generate_stake_weight_msg>)


---
### fd\_replay\_out\_vote\_tower\_from\_funk<!-- {{#callable:fd_replay_out_vote_tower_from_funk}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L543>)

Copies the state of a vote account from the Funk database into a `fd_replay_tower_t` structure.
- **Inputs**:
    - `accdb`: A pointer to the `fd_accdb_user_t` structure representing the account database.
    - `xid`: A pointer to the `fd_funk_txn_xid_t` structure representing the transaction context for consistent reads.
    - `pubkey`: A pointer to the `fd_pubkey_t` structure representing the public key of the vote account to retrieve.
    - `stake`: An unsigned long integer representing the stake amount associated with the vote account.
    - `vote_tower_out`: A pointer to the `fd_replay_tower_t` structure to populate with vote state information.
- **Logic and Control Flow**:
    - Initialize the `vote_tower_out` structure by setting its memory to zero and assigning the `pubkey` and `stake` values.
    - Enter an infinite loop to attempt to copy the vote account state from the Funk database.
    - Clear the `acc` field of `vote_tower_out` to zero.
    - Use `fd_accdb_peek` to attempt to retrieve the vote account data from the database using `accdb`, `xid`, and `pubkey->uc`.
    - If the account is not found, log a warning and return -1.
    - Retrieve the size of the account data using `fd_accdb_ref_data_sz`.
    - If the data size exceeds the capacity of `vote_tower_out->acc`, log a warning and return -1.
    - Copy the account data into `vote_tower_out->acc` and set `vote_tower_out->acc_sz` to the data size.
    - If `fd_accdb_peek_test` returns true, break the loop; otherwise, pause and retry.
- **Output**: Returns 0 on success, or -1 if the vote account is not found or the data size is too large.


---
### buffer\_vote\_towers<!-- {{#callable:buffer_vote_towers}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L592>)

Buffers vote account towers that need to be published at the end of a slot into the `ctx->vote_tower_out` buffer.
- **Inputs**:
    - ``ctx``: A pointer to `fd_replay_tile_t` structure, which holds the context for the replay tile.
    - ``xid``: A constant pointer to `fd_funk_txn_xid_t`, representing the transaction context for consistent reads.
    - ``bank``: A pointer to `fd_bank_t`, representing the bank from which vote states are queried.
- **Logic and Control Flow**:
    - Initialize `ctx->vote_tower_out_idx` and `ctx->vote_tower_out_len` to zero.
    - Query the previous vote states from the bank using `fd_bank_vote_states_prev_locking_query`.
    - Initialize a vote states iterator with `fd_vote_states_iter_init`.
    - Iterate over the vote states using a loop until `fd_vote_states_iter_done` returns true.
    - For each vote state, check if the stake is zero and skip if true.
    - Check if `ctx->vote_tower_out_len` exceeds the maximum allowed (`FD_REPLAY_TOWER_VOTE_ACC_MAX-1UL`) and log an error if true.
    - Call [`fd_replay_out_vote_tower_from_funk`](<#fd_replay_out_vote_tower_from_funk>) to populate the vote tower buffer with the current vote state, incrementing `ctx->vote_tower_out_len` if successful.
    - Log a debug message if [`fd_replay_out_vote_tower_from_funk`](<#fd_replay_out_vote_tower_from_funk>) fails to get the vote state.
    - End the vote states query with `fd_bank_vote_states_prev_end_locking_query`.
- **Output**: No return value; the function modifies the `ctx->vote_tower_out` buffer in place.
- **Functions Called**:
    - [`fd_replay_out_vote_tower_from_funk`](<#fd_replay_out_vote_tower_from_funk>)


---
### publish\_next\_vote\_tower<!-- {{#callable:publish_next_vote_tower}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L626>)

Publishes the next vote tower from the buffer to the tower tile.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile, including the vote tower buffer and its current index.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing data to the stem.
- **Logic and Control Flow**:
    - Checks if the current vote tower index (`ctx->vote_tower_out_idx`) is at the start of the buffer (`som`) or at the end of the buffer (`eom`).
    - Retrieves the current vote tower state from the buffer using the current index and stores it in the `vote_state` variable.
    - Publishes the vote state to the stem using `fd_stem_publish`, with metadata indicating whether it is the start or end of the message.
    - Updates the chunk pointer in `ctx->replay_out` to the next available chunk using `fd_dcache_compact_next`.
    - Increments the vote tower index (`ctx->vote_tower_out_idx`) to point to the next vote tower in the buffer.
- **Output**: No return value; the function operates by side effects, updating the context and publishing data.


---
### replay\_block\_start<!-- {{#callable:replay_block_start}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L644>)

Initializes a new block for replay by setting up the bank and transaction context, cloning from a parent bank, and preparing runtime state.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context, which contains the state and configuration for the replay process.
    - ``stem``: A pointer to the `fd_stem_context_t`, which is used for publishing and managing data flow between components.
    - ``bank_idx``: An unsigned long integer representing the index of the bank to be initialized.
    - ``parent_bank_idx``: An unsigned long integer representing the index of the parent bank from which the new bank will be cloned.
    - ``slot``: An unsigned long integer representing the slot number for the new block.
- **Logic and Control Flow**:
    - Record the current wallclock time as `before`.
    - Query the bank at `bank_idx` and check if it is initialized; log a critical error if not.
    - Set the `preparation_begin_nanos` of the bank to `before`.
    - Query the parent bank at `parent_bank_idx` and check if it is frozen; log a critical error if not.
    - Clone the bank from the parent bank and set the slot and parent slot.
    - Attach a child transaction cache to the bank.
    - Create a new transaction ID (`xid`) for the block and attach it to the account and program caches.
    - If `ctx->capture_ctx` is not null, set the capture slot.
    - Initialize various bank parameters such as shred count, execution fees, and tick height.
    - Compute the maximum tick height and log a critical error if computation fails.
    - Set the bank flags based on `ctx->tx_metadata_storage`.
    - Check for an epoch boundary and publish stake weights if necessary.
    - Prepare the bank for execution and return the bank.
- **Output**: Returns a pointer to the initialized `fd_bank_t` structure for the new block.
- **Functions Called**:
    - [`publish_stake_weights`](<#publish_stake_weights>)


---
### publish\_slot\_completed<!-- {{#callable:publish_slot_completed}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L733>)

Publishes the completion of a slot by updating metrics, preparing slot information, and sending it to the stem for further processing.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing data.
    - ``bank``: A pointer to the `fd_bank_t` structure, representing the bank associated with the slot being completed.
    - ``is_initial``: An integer flag indicating whether this is the initial slot (non-zero if true, zero otherwise).
- **Logic and Control Flow**:
    - Retrieve the slot number from the bank using `fd_bank_slot_get`.
    - Get the block ID element from the context's block ID array using the bank's index.
    - Initialize `parent_block_id` to zero; if `is_initial` is false, set it to the parent block ID from the context's block ID array.
    - Query the bank hash and block hash using `fd_bank_bank_hash_query` and `fd_blockhashes_peek_last`, respectively, and ensure they are valid.
    - If `is_initial` is false, finalize the transaction cache fork using `fd_txncache_finalize_fork`.
    - Query the epoch schedule and calculate the epoch and slot index using `fd_slot_to_epoch`.
    - Update the context's metrics for total slots and transactions using `fd_bank_txn_count_get`.
    - Prepare the `fd_replay_slot_completed_t` structure with slot information, including slot number, root slot, epoch, block height, parent slot, block IDs, hashes, and transaction count.
    - Set timing information in the `slot_info` structure using bank's timing fields and `fd_log_wallclock`.
    - If the GUI is enabled, increment the bank's reference count and set the bank index in `slot_info`.
    - Determine the parent bank index and increment its reference count if the GUI is enabled.
    - Publish the slot completion information using `fd_stem_publish`.
    - Update the chunk pointer in the context's replay output link using `fd_dcache_compact_next`.
- **Output**: No return value; the function operates by side effects, updating the context and publishing data.


---
### replay\_block\_finalize<!-- {{#callable:replay_block_finalize}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L800>)

Finalizes a replay block by updating bank state, processing end-of-block tasks, and handling bank hash comparisons.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages.
    - ``bank``: A pointer to the `fd_bank_t` structure, representing the bank to finalize.
- **Logic and Control Flow**:
    - Set the `last_transaction_finished_nanos` field of `bank` to the current wall clock time.
    - If `ctx->capture_ctx` is not NULL, flush the capture context using `fd_solcap_writer_flush`.
    - Ensure the bank is not frozen by checking `bank->flags` against `FD_BANK_FLAGS_FROZEN`.
    - Retrieve the slot and transaction ID (`xid`) for the bank.
    - Set the Proof of History (PoH) hash in the bank using [`fd_sched_get_poh`](<fd_sched.c.md#fd_sched_get_poh>) and `fd_bank_poh_set`.
    - Set the shred count in the bank using [`fd_sched_get_shred_cnt`](<fd_sched.c.md#fd_sched_get_shred_cnt>) and `fd_bank_shred_cnt_set`.
    - Execute end-of-block processing with `fd_runtime_block_execute_finalize`.
    - Mark the bank as frozen using `fd_banks_mark_bank_frozen`.
    - Buffer vote towers for all vote accounts using [`buffer_vote_towers`](<#buffer_vote_towers>).
    - Perform bank hash comparison and update the watermark if hashes match using `fd_bank_hash_cmp_check`.
    - Publish the slot completion using [`publish_slot_completed`](<#publish_slot_completed>).
    - If block dumping is enabled, dump the block to a file and reset the dumping context using `fd_dump_block_to_protobuf` and `fd_block_dump_context_reset`.
- **Output**: No return value; the function operates by side effects on the provided structures.
- **Functions Called**:
    - [`fd_sched_get_poh`](<fd_sched.c.md#fd_sched_get_poh>)
    - [`fd_sched_get_shred_cnt`](<fd_sched.c.md#fd_sched_get_shred_cnt>)
    - [`buffer_vote_towers`](<#buffer_vote_towers>)
    - [`publish_slot_completed`](<#publish_slot_completed>)


---
### prepare\_leader\_bank<!-- {{#callable:prepare_leader_bank}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L884>)

Prepares a new leader bank for a given slot by cloning from a parent bank and setting up necessary transaction and execution contexts.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context, which contains the state and configuration for the replay tile.
    - ``slot``: An unsigned long integer representing the slot number for which the leader bank is being prepared.
    - ``now``: A long integer representing the current time in nanoseconds, used for setting timestamps in the leader bank.
    - ``parent_block_id``: A constant pointer to an `fd_hash_t` structure representing the block ID of the parent block.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages and managing the stem context.
- **Logic and Control Flow**:
    - Check that the current context is not already a leader by asserting `ctx->leader_bank` is `NULL`.
    - Query the parent block ID map to find the parent bank index using `fd_block_id_map_ele_query`.
    - Retrieve the parent bank using `fd_banks_bank_query` and verify its existence.
    - Create a new leader bank using `fd_banks_new_bank` and verify its creation.
    - Clone the new leader bank from the parent bank using `fd_banks_clone_from_parent`.
    - Set various properties of the leader bank, including slot, parent slot, transaction cache fork ID, execution fees, priority fees, and shred count.
    - Set the tick height and update the block height of the leader bank.
    - Compute the maximum tick height for the leader bank using `fd_runtime_compute_max_tick_height`.
    - Set flags for execution recording if `tx_metadata_storage` is enabled.
    - Process any potential epoch boundary changes using `fd_runtime_block_pre_execute_process_new_epoch`.
    - Prepare the leader bank for execution using `fd_runtime_block_execute_prepare`.
    - Increment the reference count of the leader bank to indicate it is in use.
- **Output**: Returns a pointer to the newly prepared leader bank (`fd_bank_t *`).
- **Functions Called**:
    - [`fd_block_id_ele_get_idx`](<#fd_block_id_ele_get_idx>)
    - [`publish_stake_weights`](<#publish_stake_weights>)


---
### fini\_leader\_bank<!-- {{#callable:fini_leader_bank}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L965>)

Finalizes the leader bank by marking it as frozen, processing end-of-block tasks, and resetting leadership state.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages.
- **Logic and Control Flow**:
    - Check that `ctx->leader_bank` is not `NULL`, `ctx->is_leader` is true, and both `ctx->recv_block_id` and `ctx->recv_poh` are set.
    - Set `ctx->leader_bank->last_transaction_finished_nanos` to the current wall clock time using `fd_log_wallclock()`.
    - Mark the leader bank as frozen by calling `fd_banks_mark_bank_frozen` with `ctx->banks` and `ctx->leader_bank`.
    - Retrieve the current slot from `ctx->leader_bank` using `fd_bank_slot_get`.
    - Add the completed block to the scheduler using [`fd_sched_block_add_done`](<fd_sched.c.md#fd_sched_block_add_done>) with the scheduler, leader bank index, parent index, and current slot.
    - Retrieve the transaction map from `ctx->accdb->funk` using `fd_funk_txn_map`.
    - Check if the transaction map is valid; if not, log an error using `FD_LOG_ERR`.
    - Create a transaction ID (`xid`) using the current slot and leader bank index.
    - Finalize the block execution by calling `fd_runtime_block_execute_finalize` with the leader bank, account database, transaction ID, capture context, and a flag set to 0.
    - Query the bank hash using `fd_bank_bank_hash_query` and ensure it is valid using `FD_TEST`.
    - Lock the bank hash comparison using `fd_bank_hash_cmp_lock`, insert the bank hash into the comparison structure, and attempt to move the watermark forward.
    - Iterate over slots from the current watermark to the current slot, checking each slot's hash comparison result using `fd_bank_hash_cmp_check`.
    - Log a warning if a mismatch is found, break if not ready, and update the watermark if a match is found.
    - Unlock the bank hash comparison using `fd_bank_hash_cmp_unlock`.
    - Publish the slot completion using [`publish_slot_completed`](<#publish_slot_completed>) with the context, stem, leader bank, and a flag set to 0.
    - Buffer the vote towers using [`buffer_vote_towers`](<#buffer_vote_towers>) with the context, transaction ID, and leader bank.
    - Decrement the reference count of the leader bank.
    - Reset the leader state by setting `ctx->leader_bank`, `ctx->recv_block_id`, `ctx->recv_poh`, and `ctx->is_leader` to 0 or `NULL`.
- **Output**: No return value; the function operates by modifying the state of the `ctx` and `stem` structures.
- **Functions Called**:
    - [`fd_sched_block_add_done`](<fd_sched.c.md#fd_sched_block_add_done>)
    - [`publish_slot_completed`](<#publish_slot_completed>)
    - [`buffer_vote_towers`](<#buffer_vote_towers>)


---
### publish\_root\_advanced<!-- {{#callable:publish_root_advanced}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1040>)

Advances the root of the consensus by sending the child of the consensus root to avoid data races.
- **Inputs**:
    - ``ctx``: A pointer to `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``stem``: A pointer to `fd_stem_context_t` structure, which is used for publishing messages.
- **Logic and Control Flow**:
    - Queries the consensus root bank using `fd_banks_bank_query` with `ctx->consensus_root_bank_idx`.
    - Checks if the consensus root bank is `NULL` and logs a critical error if true.
    - Checks if the `child_idx` of the consensus root bank is `ULONG_MAX` and returns if true.
    - Queries the child bank of the consensus root bank using `fd_banks_bank_query` with `consensus_root_bank->child_idx`.
    - Checks if the child bank is `NULL` and logs a critical error if true.
    - Increments the reference count of the child bank by `ctx->resolv_tile_cnt`.
    - Prepares a message of type `fd_replay_root_advanced_t` and sets its `bank_idx` to the index of the child bank.
    - Publishes the message using `fd_stem_publish` with the appropriate parameters.
    - Updates `ctx->replay_out->chunk` using `fd_dcache_compact_next`.
- **Output**: No return value; the function performs operations to advance the root and publish a message.


---
### init\_funk<!-- {{#callable:init_funk}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1084>)

Initializes the account database and program cache, ensuring they are correctly set up and synchronized.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_replay_tile_t` structure representing the context for the replay tile.
    - ``bank_slot``: An unsigned long integer representing the bank slot to verify against the account database's state.
- **Logic and Control Flow**:
    - Retrieve the `fd_funk_t` instance from the account database admin context.
    - Check if the shared memory for the account database is joined; log a critical error if not.
    - Retrieve the last published transaction ID from the account database and compare it with `bank_slot`; log a critical error if they do not match.
    - Check if the last published transaction is frozen; log a critical error if it is.
    - Verify that the program cache's shared memory is joined; log a critical error if not.
    - Clear the program cache and synchronize it with the account database by attaching and advancing the transaction from the funk root to the last published transaction.
- **Output**: No return value; the function performs initialization and validation tasks, logging critical errors if any checks fail.


---
### init\_after\_snapshot<!-- {{#callable:init_after_snapshot}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1117>)

Initializes the replay tile context after a snapshot is loaded, refreshing stake delegations and setting up consensus structures.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which holds the context for the replay tile.
- **Logic and Control Flow**:
    - Queries the boot bank using `fd_banks_bank_query` with `FD_REPLAY_BOOT_BANK_IDX` and checks if the bank is NULL, logging a critical error if so.
    - Initializes a transaction ID `xid` using the bank's slot and index.
    - Calls [`init_funk`](<#init_funk>) to perform pre-flight checks and synchronize the account database and program cache with the bank's slot.
    - Queries the root stake delegations using `fd_banks_stake_delegations_root_query` and refreshes them with `fd_stake_delegations_refresh`.
    - Recalculates partitioned rewards using `fd_rewards_recalculate_partitioned_rewards`.
    - Checks if the snapshot slot is zero, indicating a genesis-specific setup, and performs necessary operations like updating leaders and preparing block execution.
    - Initializes consensus structures by iterating over vote states, updating total stake, and setting the watermark.
    - Flushes the capture context if it exists.
- **Output**: No return value; the function operates on the `ctx` structure to update its state.
- **Functions Called**:
    - [`init_funk`](<#init_funk>)


---
### maybe\_become\_leader<!-- {{#callable:maybe_become_leader}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1179>)

Determines if the current context should transition to a leader state based on various conditions and updates the context accordingly.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_replay_tile_t` structure representing the current replay context.
    - ``stem``: A pointer to a `fd_stem_context_t` structure used for publishing messages.
- **Logic and Control Flow**:
    - Checks if the context is booted using `FD_TEST` on `ctx->is_booted`.
    - Returns 0 if the context is already a leader, the next leader slot is `ULONG_MAX`, the identity vote is not rooted, or the replay output index is `ULONG_MAX`.
    - Verifies that `ctx->next_leader_slot` is greater than `ctx->reset_slot` using `FD_TEST`.
    - Gets the current tick count using `fd_tickcount()` and returns 0 if it is less than `ctx->next_leader_tickcount`.
    - Checks if a prior leader is still publishing their slot and delays if necessary, unless the delay risks being skipped by the next leader.
    - Calculates the maximum active descendant slot and checks if it is greater than or equal to `ctx->reset_slot` and less than `ctx->next_leader_slot`.
    - If conditions are met, sets the context to leader state, prepares the leader bank, and publishes a message indicating the transition to leader.
    - Updates `ctx->next_leader_slot` and `ctx->next_leader_tickcount` to `ULONG_MAX` and `LONG_MAX`, respectively.
    - Returns 1 to indicate the context has become a leader.
- **Output**: Returns 1 if the context successfully transitions to a leader state, otherwise returns 0.
- **Functions Called**:
    - [`prepare_leader_bank`](<#prepare_leader_bank>)


---
### process\_poh\_message<!-- {{#callable:process_poh_message}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1288>)

Updates the Proof of History (PoH) hash in the leader bank and sets a flag indicating receipt of the PoH message.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context structure, which contains the state and configuration for the replay tile.
    - ``slot_ended``: A pointer to a `fd_poh_leader_slot_ended_t` structure, which contains information about the slot that has ended, including the slot number and the block hash.
- **Logic and Control Flow**:
    - Checks if the context is booted, the node is a leader, and the leader bank is not NULL using `FD_TEST` assertions.
    - Verifies that the `highwater_leader_slot` is greater than or equal to the slot in `slot_ended` and that `next_leader_slot` is greater than `highwater_leader_slot`.
    - Copies the block hash from `slot_ended` into the PoH hash of the leader bank using `memcpy`.
    - Sets the `recv_poh` flag in the context to 1, indicating that the PoH message has been received.
- **Output**: No return value; the function updates the state of the `ctx` structure.


---
### publish\_reset<!-- {{#callable:publish_reset}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1308>)

Publishes a reset signal with updated slot and block information to the stem context.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing data.
    - ``bank``: A constant pointer to the `fd_bank_t` structure, representing the bank from which slot and block information is retrieved.
- **Logic and Control Flow**:
    - Check if `ctx->replay_out->idx` is `ULONG_MAX`; if true, return immediately.
    - Retrieve the last block hash from the bank's block hash queue using `fd_blockhashes_peek_last`.
    - Convert the memory chunk in `ctx->replay_out` to a `fd_poh_reset_t` structure pointer.
    - Set the `timestamp` field of `reset` to the current wall clock time using `fd_log_wallclock`.
    - Set the `completed_slot` field of `reset` to the slot number obtained from the bank using `fd_bank_slot_get`.
    - Set the `hashcnt_per_tick`, `ticks_per_slot`, and `tick_duration_ns` fields of `reset` using values obtained from the bank.
    - Copy the `completed_blockhash` from the retrieved block hash into `reset->completed_blockhash`.
    - Determine the `max_microblocks_in_slot` based on `reset->hashcnt_per_tick` and `ticks_per_slot`.
    - Set the `next_leader_slot` field of `reset` to `ctx->next_leader_slot`.
    - Publish the reset signal using `fd_stem_publish` with the appropriate parameters.
    - Update `ctx->replay_out->chunk` using `fd_dcache_compact_next`.
- **Output**: No return value; the function performs its operations by modifying the provided context and publishing data.


---
### boot\_genesis<!-- {{#callable:boot_genesis}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1340>)

Initializes the genesis state for a replay tile by setting up the initial bank, processing genesis data, and preparing the system for block production.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure representing the replay tile context.
    - ``stem``: A pointer to the `fd_stem_context_t` structure used for publishing data.
    - ``in_idx``: An unsigned long integer representing the index of the input link.
    - ``chunk``: An unsigned long integer representing the chunk of data to process.
- **Logic and Control Flow**:
    - Sets `ctx->has_identity_vote_rooted` to 1 to avoid circular dependencies during bootstrapping.
    - Retrieves the `lthash` and `genesis_hash` from the input memory using `fd_chunk_to_laddr`.
    - Casts the genesis data to `fd_genesis_solana_global_t` using `fd_type_pun`.
    - Queries the initial bank using `fd_banks_bank_query` and verifies it with `FD_TEST`.
    - Initializes a non-rooted transaction with `fd_funk_txn_xid_set_root` and `fd_accdb_attach_child`.
    - Reads the genesis data into the runtime using `fd_runtime_read_genesis`.
    - Advances the account database root with `fd_accdb_advance_root`.
    - Attaches a child to the transaction cache with `fd_txncache_attach_child`.
    - Finalizes the transaction cache fork with `fd_txncache_finalize_fork`.
    - Publishes stake weights for the current and next epoch using [`publish_stake_weights`](<#publish_stake_weights>).
    - Calls [`init_after_snapshot`](<#init_after_snapshot>) to set up the slot bank needed for blockstore initialization.
    - Initializes the store for the genesis case using `fd_store_exacq`, `fd_store_insert`, and `fd_store_exrel`.
    - Sets various consensus and reset parameters in the `ctx` structure.
    - Determines the next leader slot and tick count using `fd_multi_epoch_leaders_get_next_slot`.
    - Sets `ctx->is_booted` to 1 and calls [`maybe_become_leader`](<#maybe_become_leader>) to potentially start block production.
    - Inserts the initial block ID into the reassembler with `fd_reasm_insert`.
    - Inserts the initial block ID into the block ID map with `fd_block_id_map_ele_insert`.
    - Publishes the slot completion, root advancement, and reset using [`publish_slot_completed`](<#publish_slot_completed>), [`publish_root_advanced`](<#publish_root_advanced>), and [`publish_reset`](<#publish_reset>).
- **Output**: This function does not return a value; it modifies the state of the `ctx` and related structures to initialize the genesis state.
- **Functions Called**:
    - [`publish_stake_weights`](<#publish_stake_weights>)
    - [`init_after_snapshot`](<#init_after_snapshot>)
    - [`fd_sched_block_add_done`](<fd_sched.c.md#fd_sched_block_add_done>)
    - [`maybe_become_leader`](<#maybe_become_leader>)
    - [`publish_slot_completed`](<#publish_slot_completed>)
    - [`publish_root_advanced`](<#publish_root_advanced>)
    - [`publish_reset`](<#publish_reset>)


---
### on\_snapshot\_message<!-- {{#callable:on_snapshot_message}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1432>)

Handles snapshot messages to initialize and manage the replay state of a blockchain node.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which holds the context for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages.
    - ``in_idx``: An unsigned long integer representing the index of the input source.
    - ``chunk``: An unsigned long integer representing the chunk of data being processed.
    - ``sig``: An unsigned long integer representing the signature of the message.
- **Logic and Control Flow**:
    - Extracts the message type from the signature using `fd_ssmsg_sig_message` function.
    - If the message is `FD_SSMSG_DONE`, it indicates the snapshot is loaded, and the function initializes the replay state, sets `ctx->is_booted` to 1, and performs various setup tasks such as querying the bank, setting the snapshot slot, and publishing stake weights.
    - If the message is `FD_SSMSG_MANIFEST_FULL` or `FD_SSMSG_MANIFEST_INCREMENTAL`, it processes the snapshot manifest, checks the chunk range, and recovers the snapshot data using `fd_ssload_recover`.
    - If the message type is unknown, it logs an error and returns.
- **Output**: No explicit return value; the function modifies the state of the `ctx` and interacts with the `stem` to publish messages.
- **Functions Called**:
    - [`publish_stake_weights`](<#publish_stake_weights>)
    - [`fd_sched_block_add_done`](<fd_sched.c.md#fd_sched_block_add_done>)
    - [`init_after_snapshot`](<#init_after_snapshot>)
    - [`publish_slot_completed`](<#publish_slot_completed>)
    - [`publish_root_advanced`](<#publish_root_advanced>)


---
### dispatch\_task<!-- {{#callable:dispatch_task}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1544>)

Processes a task based on its type, either executing a transaction or verifying a transaction signature, and updates the relevant bank and execution context.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages.
    - ``task``: A pointer to the `fd_sched_task_t` structure, which represents the task to be dispatched.
- **Logic and Control Flow**:
    - Check the `task_type` of the `task` to determine the type of task to process.
    - If the task type is `FD_SCHED_TT_TXN_EXEC`, retrieve the transaction using [`fd_sched_get_txn`](<fd_sched.c.md#fd_sched_get_txn>), query the bank using `fd_banks_bank_query`, and increment the bank's reference count.
    - If the `capture_ctx` is set and `dump_block_to_pb` is enabled, collect the transaction for block dumping using `fd_dump_block_to_protobuf_collect_tx`.
    - If the bank's `first_transaction_scheduled_nanos` is not set, set it to the current wall clock time using `fd_log_wallclock`.
    - Prepare an execution message by copying the transaction data and setting the bank and transaction indices, then publish the message using `fd_stem_publish`.
    - Update the execution output chunk using `fd_dcache_compact_next`.
    - If the task type is `FD_SCHED_TT_TXN_SIGVERIFY`, perform similar steps as for `FD_SCHED_TT_TXN_EXEC`, but for signature verification tasks.
    - If the task type is not recognized, log a critical error using `FD_LOG_CRIT`.
- **Output**: This function does not return a value; it performs actions based on the task type and updates the execution context.
- **Functions Called**:
    - [`fd_sched_get_txn`](<fd_sched.c.md#fd_sched_get_txn>)


---
### replay<!-- {{#callable:replay}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1600>)

Executes scheduled tasks for a replay tile, handling block start, block end, transaction execution, and signature verification.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_replay_tile_t` structure representing the replay tile context.
    - ``stem``: A pointer to a `fd_stem_context_t` structure representing the stem context.
- **Logic and Control Flow**:
    - Checks if the replay tile is booted; if not, returns 0.
    - Initializes `charge_busy` to 0 and declares a `fd_sched_task_t` array `task` with one element.
    - Checks if there is a ready task using [`fd_sched_task_next_ready`](<fd_sched.c.md#fd_sched_task_next_ready>); if not, returns `charge_busy`.
    - Sets `charge_busy` to 1 if a task is ready.
    - Uses a switch statement to handle different task types: `FD_SCHED_TT_BLOCK_START`, `FD_SCHED_TT_BLOCK_END`, `FD_SCHED_TT_TXN_EXEC`, `FD_SCHED_TT_TXN_SIGVERIFY`, and a default case for unexpected task types.
    - For `FD_SCHED_TT_BLOCK_START`, calls [`replay_block_start`](<#replay_block_start>) and marks the task as done.
    - For `FD_SCHED_TT_BLOCK_END`, queries the bank, finalizes the block if not dead, and marks the task as done.
    - For `FD_SCHED_TT_TXN_EXEC` and `FD_SCHED_TT_TXN_SIGVERIFY`, calls [`dispatch_task`](<#dispatch_task>).
    - Logs a critical error for unexpected task types.
- **Output**: Returns an integer indicating whether the replay tile was busy (1) or not (0).
- **Functions Called**:
    - [`fd_sched_task_next_ready`](<fd_sched.c.md#fd_sched_task_next_ready>)
    - [`replay_block_start`](<#replay_block_start>)
    - [`fd_sched_task_done`](<fd_sched.c.md#fd_sched_task_done>)
    - [`replay_block_finalize`](<#replay_block_finalize>)
    - [`dispatch_task`](<#dispatch_task>)


---
### process\_fec\_set<!-- {{#callable:process_fec_set}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1641>)

Processes a Forward Error Correction (FEC) set by linking it to the store, updating bank indices, and scheduling it for execution if applicable.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_replay_tile_t` structure, which contains the context for the replay tile, including store, banks, and metrics.
    - ``reasm_fec``: A pointer to a `fd_reasm_fec_t` structure, representing the FEC set to be processed, including its key, slot, and indices.
- **Logic and Control Flow**:
    - Get the current wall clock time and store it in `now`.
    - Acquire a shared lock on the store and attempt to link the FEC set using its key and CMR; log a warning if linking fails.
    - Record the time taken for acquiring and releasing the lock in the metrics.
    - Update `reasm_fec` with the correct parent bank index using `fd_reasm_parent`.
    - If `reasm_fec` belongs to a leader, set its bank index to the leader's bank index; otherwise, if `fec_set_idx` is 0, allocate a new bank index for a new slot; otherwise, use the parent bank index.
    - If the slot is complete, update the block ID map with the new block ID and slot, removing any existing entry for the bank index if necessary.
    - If `reasm_fec` is a leader, set `ctx->recv_block_id` to 1 and return.
    - Prepare a `fd_sched_fec_t` structure with details from `reasm_fec` and query the store for the FEC set.
    - If the FEC set is not found in the store, log a warning and return.
    - Sample the time taken for reading from the store in the metrics.
    - Set additional fields in `sched_fec` and attempt to ingest it into the scheduler; if ingestion fails, mark the bank as dead.
- **Output**: No return value; the function operates by side effects on the input structures and logs warnings if necessary.
- **Functions Called**:
    - [`fd_sched_fec_ingest`](<fd_sched.c.md#fd_sched_fec_ingest>)


---
### funk\_publish<!-- {{#callable:funk_publish}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1758>)

Publishes all transactions up to and including a specified watermark in the account and program cache databases.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context, which contains the state and configuration for the replay tile.
    - ``slot``: An unsigned long integer representing the slot number up to which transactions should be published.
    - ``bank_idx``: An unsigned long integer representing the bank index associated with the slot to be published.
- **Logic and Control Flow**:
    - Initialize a `fd_funk_txn_xid_t` structure `xid` with `slot` and `bank_idx` values.
    - Log a debug message indicating the slot being published.
    - Call `fd_accdb_advance_root` to publish transactions in the account database up to the specified `xid`.
    - Call `fd_progcache_txn_advance_root` to publish transactions in the program cache up to the specified `xid`.
- **Output**: No return value; the function performs operations to publish transactions in the databases.


---
### advance\_published\_root<!-- {{#callable:advance_published_root}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1772>)

Advances the published root in the replay tile context by updating the root bank index and slot, and publishing the new root to various components.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context and state for the replay tile.
- **Logic and Control Flow**:
    - Queries the block ID element for the consensus root from the block ID map using `fd_block_id_map_ele_query`.
    - Checks if the block ID element is found; if not, logs a critical error.
    - Retrieves the target bank index using [`fd_block_id_ele_get_idx`](<#fd_block_id_ele_get_idx>).
    - Notifies the scheduler of the new root using [`fd_sched_root_notify`](<fd_sched.c.md#fd_sched_root_notify>).
    - Checks if the identity vote has been seen on a bank that should be rooted; if not, queries the root bank and updates the `has_identity_vote_rooted` flag if the identity vote is present.
    - Prepares to advance the root using `fd_banks_advance_root_prepare` and retrieves the advanceable root index.
    - Queries the bank for the advanceable root index and checks its validity.
    - Locks the store exclusively and publishes the advanceable root block ID using `fd_store_publish`.
    - Samples metrics for store publish wait and work times.
    - Retrieves the advanceable root slot and publishes it using [`funk_publish`](<#funk_publish>).
    - Advances the root in the transaction cache, scheduler, banks, and reassembler using respective functions.
    - Updates the context's published root slot and bank index with the new values.
    - Returns 1 to indicate successful advancement.
- **Output**: Returns 1 if the published root is successfully advanced, otherwise returns 0 if preparation fails.
- **Functions Called**:
    - [`fd_block_id_ele_get_idx`](<#fd_block_id_ele_get_idx>)
    - [`fd_sched_root_notify`](<fd_sched.c.md#fd_sched_root_notify>)
    - [`funk_publish`](<#funk_publish>)
    - [`fd_sched_advance_root`](<fd_sched.c.md#fd_sched_advance_root>)


---
### after\_credit<!-- {{#callable:after_credit}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1824>)

Handles post-credit operations in a replay tile, including publishing vote towers, managing leadership transitions, processing FEC sets, and advancing the published root.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, representing the context of the replay tile.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, representing the context of the stem.
    - ``opt_poll_in``: A pointer to an integer that indicates whether polling for fragments should continue.
    - ``charge_busy``: A pointer to an integer that indicates whether the function has performed any operations that should be considered as 'busy' work.
- **Logic and Control Flow**:
    - If the context is not booted, return immediately.
    - Check if there are any outstanding vote towers to publish; if so, publish them and set `charge_busy` to 1, then return.
    - Attempt to become a leader; if successful, set `charge_busy` to 1 and return.
    - Check if there is a ready FEC set in the reassembler; if so, process it and set `charge_busy` to 1, then return.
    - If the context is a leader and has received both the PoH hash and block ID, finalize the leader bank, set `charge_busy` to 1, and return.
    - If the published root is not caught up to the consensus root, attempt to advance the published root; if successful, set `charge_busy` to 1 and return.
    - Call the [`replay`](<#replay>) function to process any remaining tasks, updating `charge_busy` and `opt_poll_in` accordingly.
- **Output**: The function does not return a value but modifies the state of the inputs, particularly `opt_poll_in` and `charge_busy`, to indicate the next steps in the replay process.
- **Functions Called**:
    - [`publish_next_vote_tower`](<#publish_next_vote_tower>)
    - [`maybe_become_leader`](<#maybe_become_leader>)
    - [`fd_sched_can_ingest`](<fd_sched.c.md#fd_sched_can_ingest>)
    - [`process_fec_set`](<#process_fec_set>)
    - [`fini_leader_bank`](<#fini_leader_bank>)
    - [`advance_published_root`](<#advance_published_root>)
    - [`replay`](<#replay>)


---
### before\_frag<!-- {{#callable:before_frag}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1925>)

Checks if the input fragment is of type `IN_KIND_SHRED` and ensures that the reassembler has space to insert more FEC sets.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile.
    - ``in_idx``: An unsigned long integer representing the index of the input fragment.
    - ``seq``: An unsigned long integer representing the sequence number of the fragment, marked as unused with `FD_PARAM_UNUSED`.
    - ``sig``: An unsigned long integer representing the signature of the fragment, marked as unused with `FD_PARAM_UNUSED`.
- **Logic and Control Flow**:
    - Checks if the input fragment type at `in_idx` is `IN_KIND_SHRED` using `ctx->in_kind[in_idx]`.
    - If the fragment type is `IN_KIND_SHRED`, it checks if the reassembler (`ctx->reasm`) has space to insert more FEC sets using `fd_reasm_free(ctx->reasm)`.
    - If the reassembler is full (i.e., `fd_reasm_free(ctx->reasm)` returns false), the function returns -1, indicating that no more fragments can be processed until space is available.
    - If the reassembler has space, the function returns 0, indicating that the fragment can be processed.
- **Output**: Returns 0 if the reassembler has space for more FEC sets, otherwise returns -1 if the reassembler is full.


---
### process\_solcap\_account\_update<!-- {{#callable:process_solcap_account_update}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1944>)

Processes an account update message for Solana capture by querying the bank and writing account data if conditions are met.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context structure, which contains the state and configuration for the replay tile.
    - ``msg``: A constant pointer to the `fd_capture_ctx_account_update_msg_t` structure, which contains the account update message details, including the bank index, public key, account info, and data size.
- **Logic and Control Flow**:
    - Query the bank using `fd_banks_bank_query` with the bank index from `msg`.
    - If the bank is NULL, log a critical error indicating an invariant violation.
    - Check if the capture context and capture are valid; if not, return immediately.
    - Check if the bank slot is less than the capture start slot; if so, return immediately.
    - Calculate the pointer to the account data by offsetting the `msg` pointer by the size of `fd_capture_ctx_account_update_msg_t`.
    - Write the account data using `fd_solcap_write_account` with the capture context, public key, account info, account data, and data size from `msg`.
- **Output**: No return value; the function performs operations based on the input message and context.


---
### process\_exec\_task\_done<!-- {{#callable:process_exec_task_done}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L1960>)

Handles the completion of an execution task by updating the bank's reference count, marking transactions as done, and managing bank states based on execution results.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context structure, which contains the state and configuration for the replay tile.
    - ``msg``: A pointer to the `fd_exec_task_done_msg_t` structure, which contains information about the completed execution task, including the bank index and transaction details.
    - ``sig``: An unsigned long integer representing the signature of the task, which indicates the type of task completed and the execution tile index.
- **Logic and Control Flow**:
    - Checks if `sig` is zero; if so, calls [`process_solcap_account_update`](<#process_solcap_account_update>) to handle account updates and returns.
    - Extracts the execution tile index from `sig`.
    - Queries the bank using `msg->bank_idx` and decrements its reference count.
    - Switches based on the task type encoded in `sig` to handle transaction execution or signature verification.
    - For `FD_EXEC_TT_TXN_EXEC`, checks if the identity vote has been rooted; if not, queries the vote tracker and updates the bank if the vote transaction is seen.
    - Marks the transaction as done in the scheduler and checks for errors; if errors exist and the bank is not dead, marks the bank as dead and abandons the block.
    - If the bank is dead and its reference count is zero, marks the bank as frozen.
    - For `FD_EXEC_TT_TXN_SIGVERIFY`, marks the signature verification task as done and checks for errors; if errors exist and the bank is not dead, marks the bank as dead and abandons the block.
    - If the bank is dead and its reference count is zero, marks the bank as frozen.
    - Logs a critical error if an unexpected task type is encountered.
- **Output**: No direct output; the function modifies the state of the bank and scheduler based on the task completion.
- **Functions Called**:
    - [`process_solcap_account_update`](<#process_solcap_account_update>)
    - [`fd_sched_get_txn`](<fd_sched.c.md#fd_sched_get_txn>)
    - [`fd_vote_tracker_query_sig`](<fd_vote_tracker.c.md#fd_vote_tracker_query_sig>)
    - [`fd_sched_task_done`](<fd_sched.c.md#fd_sched_task_done>)
    - [`fd_sched_block_abandon`](<fd_sched.c.md#fd_sched_block_abandon>)


---
### process\_tower\_update<!-- {{#callable:process_tower_update}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2029>)

Updates the replay tile's context with new tower slot information and potentially triggers leadership actions.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure representing the replay tile's context.
    - ``stem``: A pointer to the `fd_stem_context_t` structure used for publishing messages.
    - ``msg``: A constant pointer to the `fd_tower_slot_done_t` structure containing the new tower slot information.
- **Logic and Control Flow**:
    - Update `ctx->reset_block_id`, `ctx->reset_slot`, and `ctx->reset_timestamp_nanos` with values from `msg` and the current wall clock time.
    - Calculate `min_leader_slot` based on `msg->reset_slot` and `ctx->highwater_leader_slot`.
    - Determine `ctx->next_leader_slot` using `fd_multi_epoch_leaders_get_next_slot` with `min_leader_slot`.
    - Set `ctx->next_leader_tickcount` based on `ctx->next_leader_slot` and `ctx->slot_duration_ticks`.
    - Query `fd_block_id_map_ele_query` to find the block ID element for `msg->reset_block_id`.
    - Retrieve the bank associated with `reset_bank_idx` and update `ctx->reset_bank`.
    - If `msg->new_root` is true, verify `msg->root_slot` is less than or equal to `msg->reset_slot`.
    - If `ctx->replay_out->idx` is not `ULONG_MAX`, prepare and publish a `fd_poh_reset_t` message with the reset information.
    - Log the tower update details using `FD_LOG_INFO`.
    - Call [`maybe_become_leader`](<#maybe_become_leader>) to potentially trigger leadership actions.
    - If `msg->new_root` is true, update `ctx->consensus_root_slot`, `ctx->consensus_root`, and `ctx->consensus_root_bank_idx`, then call [`publish_root_advanced`](<#publish_root_advanced>).
    - Calculate the distance from the current bank to the consensus root bank and update the `ROOT_DISTANCE` metric.
- **Output**: This function does not return a value; it updates the state of the replay tile's context and may publish messages.
- **Functions Called**:
    - [`fd_block_id_ele_get_idx`](<#fd_block_id_ele_get_idx>)
    - [`maybe_become_leader`](<#maybe_become_leader>)
    - [`publish_root_advanced`](<#publish_root_advanced>)


---
### process\_fec\_complete<!-- {{#callable:process_fec_complete}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2115>)

Inserts a Forward Error Correction (FEC) set into the reassembler context using data from a shred buffer.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context, which contains the reassembler and other state information.
    - ``shred_buf``: A constant pointer to an unsigned character buffer containing the shred data to be processed.
- **Logic and Control Flow**:
    - Casts `shred_buf` to a `fd_shred_t` pointer to access shred data.
    - Extracts `merkle_root`, `chained_merkle_root`, and `is_leader_fec` from `shred_buf` using offsets.
    - Determines `data_complete` and `slot_complete` flags from the shred's data flags.
    - Asserts that the `merkle_root` is not already in the reassembler using `fd_reasm_query`.
    - Checks if the shred is the first in the slot and adjusts `chained_merkle_root` if necessary.
    - Inserts the FEC set into the reassembler using `fd_reasm_insert` with the extracted and computed values.
- **Output**: No return value; the function modifies the reassembler state in `ctx`.


---
### process\_resolv\_slot\_completed<!-- {{#callable:process_resolv_slot_completed}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2134>)

Decrements the reference count of a bank identified by `bank_idx` in the context `ctx`.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` structure, which contains the context for the replay tile, including the banks.
    - ``bank_idx``: An unsigned long integer representing the index of the bank whose reference count is to be decremented.
- **Logic and Control Flow**:
    - Queries the bank from the `ctx->banks` using `bank_idx` to get a pointer to the `fd_bank_t` structure.
    - Asserts that the bank is not NULL using `FD_TEST`.
    - Decrements the `refcnt` field of the bank structure.
- **Output**: No return value; the function operates by side effect on the bank's reference count.


---
### process\_vote\_txn\_sent<!-- {{#callable:process_vote_txn_sent}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2142>)

Adds a sent vote transaction to the vote tracker if the identity vote has not been rooted.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_replay_tile_t` structure, which contains the context for the replay tile, including the vote tracker and a flag indicating if the identity vote has been rooted.
    - ``txnm``: A pointer to a `fd_txn_m_t` structure, representing the transaction metadata that includes the payload size and the transaction payload.
- **Logic and Control Flow**:
    - Checks if the identity vote has not been rooted by evaluating `ctx->has_identity_vote_rooted`.
    - If the identity vote has not been rooted, it extracts the payload from the transaction metadata `txnm`.
    - Allocates memory for a transaction and attempts to parse the transaction from the payload using `fd_txn_parse`.
    - If parsing fails, logs a critical error message indicating the transaction could not be parsed.
    - If parsing succeeds, inserts the transaction's signature into the vote tracker using [`fd_vote_tracker_insert`](<fd_vote_tracker.c.md#fd_vote_tracker_insert>).
- **Output**: No return value; the function operates by modifying the state of the `ctx` and logging errors if necessary.
- **Functions Called**:
    - [`fd_vote_tracker_insert`](<fd_vote_tracker.c.md#fd_vote_tracker_insert>)


---
### maybe\_verify\_shred\_version<!-- {{#callable:maybe_verify_shred_version}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2159>)

Verifies the shred version in the context of a replay tile, ensuring it matches expected values or calculates it based on the genesis hash and hard forks.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_replay_tile_t` structure containing the context for the replay tile, including expected shred version, ipecho shred version, genesis hash, and hard forks.
- **Logic and Control Flow**:
    - Checks if both `expected_shred_version` and `ipecho_shred_version` are set in `ctx` and logs an error if they do not match.
    - If `has_genesis_hash` is true, `hard_forks_cnt` is not `ULONG_MAX`, and either `expected_shred_version` or `ipecho_shred_version` is set, it calculates the expected shred version using the genesis hash and hard forks.
    - Initializes a `running_hash` with the `genesis_hash` and iterates over `hard_forks` to compute a hash for each fork.
    - For each hard fork, it updates the `running_hash` using SHA-256 and counts the occurrences of each fork value.
    - Calculates a final XOR of the `running_hash` values, adjusts it, and compares it to the `expected_shred_version`, logging an error if they do not match.
- **Output**: No return value; logs errors if shred version mismatches are detected.


---
### returnable\_frag<!-- {{#callable:returnable_frag}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2215>)

Processes a fragment based on its type and updates the context accordingly.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_replay_tile_t` context structure, which holds the state and configuration for the replay tile.
    - ``in_idx``: An index indicating which input link the fragment is from.
    - ``seq``: A sequence number for the fragment, not used in this function.
    - ``sig``: A signature or identifier for the fragment, used to determine specific actions for some fragment types.
    - ``chunk``: The chunk index within the input link's memory where the fragment data is located.
    - ``sz``: The size of the fragment data, used to validate the fragment.
    - ``ctl``: Control flags for the fragment, not used in this function.
    - ``tsorig``: The original timestamp of the fragment, not used in this function.
    - ``tspub``: The publication timestamp of the fragment, not used in this function.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages.
- **Logic and Control Flow**:
    - Ignores `seq`, `ctl`, `tsorig`, and `tspub` as they are not used in the function.
    - Checks if the fragment size `sz` is non-zero and if the `chunk` is within valid range; logs an error if not.
    - Switches on the `in_kind` of the input link to determine the type of fragment and processes it accordingly.
    - For `IN_KIND_GENESIS`, processes genesis-related fragments and updates the genesis hash.
    - For `IN_KIND_IPECHO`, updates the shred version and verifies it.
    - For `IN_KIND_SNAP`, processes snapshot messages and verifies the shred version.
    - For `IN_KIND_EXEC`, processes execution task completion messages.
    - For `IN_KIND_POH`, processes proof-of-history messages.
    - For `IN_KIND_RESOLV`, processes slot completion messages from the resolver.
    - For `IN_KIND_TOWER`, processes tower update messages.
    - For `IN_KIND_SHRED`, processes FEC complete messages if the size matches the expected size.
    - For `IN_KIND_VTXN`, processes vote transaction sent messages.
    - For `IN_KIND_GUI`, decrements the reference count of a bank queried by signature.
    - Logs an error if the `in_kind` is unhandled.
- **Output**: Returns 0 after processing the fragment.
- **Functions Called**:
    - [`boot_genesis`](<#boot_genesis>)
    - [`maybe_verify_shred_version`](<#maybe_verify_shred_version>)
    - [`on_snapshot_message`](<#on_snapshot_message>)
    - [`process_exec_task_done`](<#process_exec_task_done>)
    - [`process_poh_message`](<#process_poh_message>)
    - [`process_resolv_slot_completed`](<#process_resolv_slot_completed>)
    - [`process_tower_update`](<#process_tower_update>)
    - [`process_fec_complete`](<#process_fec_complete>)
    - [`process_vote_txn_sent`](<#process_vote_txn_sent>)


---
### out1<!-- {{#callable:out1}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2299>)

Finds and returns the output link with the specified name from a given topology and tile.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the tile.
    - `name`: A constant character pointer representing the name of the output link to find.
- **Logic and Control Flow**:
    - Initialize `idx` to `ULONG_MAX` to indicate no link found initially.
    - Iterate over the output links of the tile using a loop from 0 to `tile->out_cnt`.
    - For each link, retrieve the link from `topo->links` using the index from `tile->out_link_id`.
    - Compare the link's name with the input `name` using `strcmp`.
    - If a match is found, check if `idx` is already set; if so, log an error indicating multiple links with the same name.
    - Set `idx` to the current index if it is the first match found.
    - After the loop, check if `idx` is still `ULONG_MAX`; if so, return a default `fd_replay_out_link_t` with `idx` set to `ULONG_MAX`.
    - If a valid `idx` is found, retrieve the memory workspace and calculate `chunk0` and `wmark` using `fd_dcache_compact_chunk0` and `fd_dcache_compact_wmark`.
    - Return a `fd_replay_out_link_t` structure with the found index, memory workspace, `chunk0`, `wmark`, and `chunk` initialized to `chunk0`.
- **Output**: A `fd_replay_out_link_t` structure containing the index, memory workspace, `chunk0`, `wmark`, and `chunk` of the found output link, or default values if not found.


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2322>)

Initializes the `fd_replay_tile_t` context with necessary configurations and loads the identity public key from a specified path.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure, representing the topology of the system.
    - ``tile``: A pointer to the `fd_topo_tile_t` structure, representing the specific tile configuration within the topology.
- **Logic and Control Flow**:
    - Allocate memory for the `fd_replay_tile_t` context using the scratch allocator.
    - Check if the `identity_key_path` in `tile->replay` is set; if not, log an error and terminate.
    - Load the identity public key from the specified `identity_key_path` using `fd_keyload_load` and store it in `ctx->identity_pubkey`.
- **Output**: No return value; the function initializes the context and logs an error if the identity key path is not set.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2335>)

Initializes the unprivileged components of a replay tile in a distributed system.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology of the system.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the specific tile to initialize.
- **Logic and Control Flow**:
    - Allocate scratch memory for various components using `FD_SCRATCH_ALLOC_INIT` and `FD_SCRATCH_ALLOC_APPEND`.
    - Join the store and banks components using `fd_store_join` and `fd_banks_join` respectively, ensuring they are valid with `FD_TEST`.
    - Initialize the bank pool and set the initial bank slot using `fd_banks_init_bank` and `fd_bank_slot_set`.
    - Set initial values for consensus root, published root, and expected shred version.
    - Modify the bank's cluster version and enable features using `fd_bank_cluster_version_modify` and `fd_features_enable_cleaned_up`.
    - Join various components like `fd_accdb_admin`, `fd_accdb_user`, `fd_progcache_admin`, `fd_txncache`, `fd_capture_ctx`, and `fd_block_dump_ctx` using their respective join functions.
    - Initialize the scheduler and reassembler using [`fd_sched_join`](<fd_sched.c.md#fd_sched_join>) and `fd_reasm_join`.
    - Set up input links and output links using `fd_topo_link_t` and `fd_topo_wksp_t` structures.
    - Initialize metrics and join histogram functions using `fd_histf_join`.
    - Finalize scratch allocation and check for overflow using `FD_SCRATCH_ALLOC_FINI`.
- **Output**: No return value; the function initializes components in place.
- **Functions Called**:
    - [`fd_sched_align`](<fd_sched.c.md#fd_sched_align>)
    - [`fd_sched_footprint`](<fd_sched.c.md#fd_sched_footprint>)
    - [`fd_vote_tracker_align`](<fd_vote_tracker.c.md#fd_vote_tracker_align>)
    - [`fd_vote_tracker_footprint`](<fd_vote_tracker.c.md#fd_vote_tracker_footprint>)
    - [`fd_sched_join`](<fd_sched.c.md#fd_sched_join>)
    - [`fd_sched_new`](<fd_sched.c.md#fd_sched_new>)
    - [`fd_vote_tracker_join`](<fd_vote_tracker.c.md#fd_vote_tracker_join>)
    - [`fd_vote_tracker_new`](<fd_vote_tracker.c.md#fd_vote_tracker_new>)
    - [`out1`](<#out1>)
    - [`scratch_footprint`](<#scratch_footprint>)


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2549>)

Populates a seccomp filter policy for a replay tile and returns the instruction count.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, which is unused in this function.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, which is unused in this function.
    - ``out_cnt``: An unsigned long integer representing the number of output filters.
    - ``out``: A pointer to an array of `sock_filter` structures where the seccomp filter policy will be populated.
- **Logic and Control Flow**:
    - Calls [`populate_sock_filter_policy_fd_replay_tile`](<generated/fd_replay_tile_seccomp.h.md#populate_sock_filter_policy_fd_replay_tile>) with `out_cnt`, `out`, and the file descriptor of the log file to populate the seccomp filter policy.
    - Returns the value of `sock_filter_policy_fd_replay_tile_instr_cnt`.
- **Output**: Returns an unsigned long integer representing the number of instructions in the seccomp filter policy.
- **Functions Called**:
    - [`populate_sock_filter_policy_fd_replay_tile`](<generated/fd_replay_tile_seccomp.h.md#populate_sock_filter_policy_fd_replay_tile>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../src/discof/replay/fd_replay_tile.c#L2559>)

Populates an array with file descriptors that are allowed for use, including standard error and a log file descriptor if available.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, which is unused in this function.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, which is unused in this function.
    - ``out_fds_cnt``: The maximum number of file descriptors that can be stored in the `out_fds` array.
    - ``out_fds``: A pointer to an array of integers where the allowed file descriptors will be stored.
- **Logic and Control Flow**:
    - Check if `out_fds_cnt` is less than 2; if so, log an error and terminate the program.
    - Initialize `out_cnt` to 0 to keep track of the number of file descriptors added to `out_fds`.
    - Add the file descriptor for standard error (2) to the `out_fds` array and increment `out_cnt`.
    - Check if the log file descriptor is not -1 using `fd_log_private_logfile_fd()`; if true, add it to the `out_fds` array and increment `out_cnt`.
    - Return the number of file descriptors added to `out_fds` (stored in `out_cnt`).
- **Output**: Returns the number of file descriptors added to the `out_fds` array.



---
Made with ❤️ by [Driver](https://www.driver.ai/)