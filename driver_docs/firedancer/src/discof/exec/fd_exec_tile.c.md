<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Executes single transactions by identifying the correct bank and account database, committing results, and updating the bank.

# Purpose
The code defines a module responsible for executing transactions within a distributed system. It is part of a larger framework that manages transaction execution, verification, and communication between different components, such as banks and replay tiles. The primary structure, `fd_exec_tile_ctx_t`, encapsulates the context for executing transactions, including data structures for managing transaction execution, capturing runtime execution for debugging, and handling communication links with other components. The module includes functions for initializing the execution context, managing memory allocations, and handling transaction execution and verification.

The code also defines several static functions to manage the execution process, including [`metrics_write`](<#metrics_write>), which updates performance metrics, and [`returnable_frag`](<#returnable_frag>), which processes incoming transaction fragments. The [`unprivileged_init`](<#unprivileged_init>) function sets up the execution context, including memory allocations and link validations. The module uses a callback mechanism to handle transaction execution and communication with other components, such as publishing transaction results and account updates. The code is designed to be integrated into a larger system, as indicated by the inclusion of various headers and the use of external data structures and functions.
# Imports and Dependencies

---
- `../../disco/tiles.h`
- `generated/fd_exec_tile_seccomp.h`
- `../../util/pod/fd_pod_format.h`
- `../../discof/replay/fd_exec.h`
- `../../flamenco/runtime/context/fd_capture_ctx.h`
- `../../flamenco/runtime/fd_bank.h`
- `../../flamenco/runtime/fd_runtime.h`
- `../../disco/metrics/fd_metrics.h`
- `../../funk/fd_funk.h`
- `../../disco/stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_execor
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a structure for executing a tile in a topology. It includes configuration and function pointers for managing execution, security, and resource allocation.
- **Use**: Used to configure and manage the execution of a tile in a distributed system.


# Data Structures

---
### link\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``idx``: An unsigned long integer that likely serves as an index or identifier.
    - ``mem``: A pointer to a `fd_wksp_t` structure, representing a memory workspace.
    - ``chunk``: An unsigned long integer representing a chunk or segment of data.
    - ``chunk0``: An unsigned long integer representing the initial chunk or starting point.
    - ``wmark``: An unsigned long integer representing a watermark or boundary.
- **Description**: The `link_ctx_t` structure is used to manage and track data segments within a memory workspace. It includes an index (`idx`) for identification, a pointer to a memory workspace (`mem`), and several unsigned long integers (`chunk`, `chunk0`, `wmark`) to manage data chunks and boundaries within the workspace.


---
### fd\_exec\_tile\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``tile_idx``: Stores the index of the tile.
    - ``replay_in``: An array of `link_ctx_t` for replay input link context.
    - ``exec_replay_out``: An array of `link_ctx_t` for execution replay output link context.
    - ``exec_sig_out``: An array of `link_ctx_t` for execution signature output link context.
    - ``sha_mem``: An array of `fd_sha512_t` for storing SHA-512 hash memory.
    - ``sha_lj``: An array of pointers to `fd_sha512_t` for local join SHA-512 hashes.
    - ``bank_hash_cmp``: A pointer to `fd_bank_hash_cmp_t` for bank hash comparison.
    - ``exec_spad``: A pointer to `fd_spad_t` for execution scratchpad.
    - ``exec_spad_wksp``: A pointer to `fd_wksp_t` for execution scratchpad workspace.
    - ``txn_ctx``: A pointer to `fd_exec_txn_ctx_t` for transaction context.
    - ``capture_ctx``: A pointer to `fd_capture_ctx_t` for capturing context during execution.
    - ``solcap_publish_buffer_ptr``: A pointer to an unsigned character buffer for solcap publishing.
    - ``account_updates_flushed``: Stores the number of account updates flushed.
    - ``banks``: A pointer to `fd_banks_t` for bank management.
    - ``funk``: An array of `fd_funk_t` for funk transaction management.
    - ``progcache``: An array of `fd_progcache_t` for program cache management.
    - ``txncache``: A pointer to `fd_txncache_t` for transaction cache management.
    - ``pending_txn_finalized_msg``: An integer indicating if a transaction finalized message is pending.
    - ``txn_idx``: Stores the index of the transaction.
- **Description**: `fd_exec_tile_ctx_t` is a structure that manages the execution context for a transaction tile in a distributed system. It includes various link contexts for input and output, memory for SHA-512 hashes, pointers to bank and transaction contexts, and buffers for capturing and publishing data. The structure facilitates the execution of transactions by maintaining necessary state and resources, such as bank handles, transaction caches, and program caches, and it supports debugging and runtime execution capture.


# Functions

---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L74>)

Returns a constant alignment value of 128.
- **Inputs**: None
- **Logic and Control Flow**:
    - The function is defined as `static inline`, indicating it is intended for use within the same translation unit and suggests potential inlining by the compiler.
    - The function is marked with `FD_FN_CONST`, suggesting that it does not read or modify any global state and always returns the same result when called with the same parameters.
    - The function body contains a single return statement that returns the unsigned long integer value `128UL`.
- **Output**: An unsigned long integer with the value 128.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L79>)

Calculates the memory footprint required for various execution contexts and caches based on the given tile configuration.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure that contains configuration details for the execution tile, including the maximum number of live slots.
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT`.
    - Append the size and alignment of `fd_exec_tile_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the size and alignment of the capture context using `fd_capture_ctx_align` and `fd_capture_ctx_footprint`.
    - Append the size and alignment of the transaction cache using `fd_txncache_align` and `fd_txncache_footprint`, which depends on `tile->exec.max_live_slots`.
    - Append the size and alignment of the program cache scratch space using `FD_PROGCACHE_SCRATCH_ALIGN` and `FD_PROGCACHE_SCRATCH_FOOTPRINT`.
    - Finalize the layout with `FD_LAYOUT_FINI` using [`scratch_align`](<#scratch_align>) and return the result.
- **Output**: Returns an `ulong` representing the total memory footprint required.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L89>)

Updates the execution metrics in the program cache with the current values from the context.
- **Inputs**:
    - `ctx`: A pointer to `fd_exec_tile_ctx_t`, which contains the execution context including the program cache and its metrics.
- **Logic and Control Flow**:
    - Retrieve the `progcache` from the `ctx` structure.
    - Set the `EXEC` metrics for `PROGCACHE_MISSES`, `PROGCACHE_HITS`, `PROGCACHE_FILLS`, `PROGCACHE_FILL_TOT_SZ`, `PROGCACHE_INVALIDATIONS`, and `PROGCACHE_DUP_INSERTS` using the corresponding values from `progcache->metrics`.
- **Output**: No return value; the function updates metrics in place.


---
### returnable\_frag<!-- {{#callable:returnable_frag}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L100>)

Processes transaction fragments by verifying the signature and executing the transaction if valid, then updates the transaction state and publishes results.
- **Inputs**:
    - `ctx`: A pointer to the `fd_exec_tile_ctx_t` structure, which contains the execution context for the tile.
    - `in_idx`: An unsigned long integer representing the index of the input link.
    - `seq`: An unsigned long integer representing the sequence number, which is unused in this function.
    - `sig`: An unsigned long integer representing the signature of the transaction.
    - `chunk`: An unsigned long integer representing the memory chunk where the transaction data is stored.
    - `sz`: An unsigned long integer representing the size of the transaction data.
    - `ctl`: An unsigned long integer representing control information, which is unused in this function.
    - `tsorig`: An unsigned long integer representing the original timestamp, which is unused in this function.
    - `tspub`: An unsigned long integer representing the publication timestamp, which is unused in this function.
    - `stem`: A pointer to the `fd_stem_context_t` structure, which is used for publishing results.
- **Logic and Control Flow**:
    - Check if the lower 32 bits of `sig` match `ctx->tile_idx`; if not, return 0.
    - Verify if `in_idx` matches `ctx->replay_in->idx`; if not, log a critical error.
    - Check if `chunk` is within the valid range defined by `ctx->replay_in->chunk0` and `ctx->replay_in->wmark`; if not, log an error.
    - Extract the upper 32 bits of `sig` to determine the transaction type.
    - If the transaction type is `FD_EXEC_TT_TXN_EXEC`, execute the transaction, commit the results, and publish the transaction signature if successful.
    - If the transaction type is `FD_EXEC_TT_TXN_SIGVERIFY`, verify the transaction signature and publish the verification result.
    - Log a critical error if the transaction type is unexpected.
- **Output**: Always returns 0, indicating the function does not produce a meaningful return value.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L167>)

Initializes the execution context for a tile in a distributed system, setting up memory allocations, links, and various components required for transaction processing.
- **Inputs**:
    - `topo`: A pointer to the `fd_topo_t` structure representing the topology of the system.
    - `tile`: A pointer to the `fd_topo_tile_t` structure representing the specific tile to initialize.
- **Logic and Control Flow**:
    - Allocate and validate memory for various components such as `fd_exec_tile_ctx_t`, capture context, transaction cache, and program cache using `FD_SCRATCH_ALLOC_APPEND` and `FD_SCRATCH_ALLOC_FINI` functions.
    - Check if the allocated memory matches the expected footprint using [`scratch_footprint`](<#scratch_footprint>) and log an error if there is a mismatch.
    - Initialize SHA512 contexts for transaction signature verification by joining each SHA context to the memory allocated for it.
    - Set up input and output links for the tile by finding the appropriate links in the topology and configuring memory and chunk settings for each link.
    - Join the banks, spad, and bank hash comparison components to the execution context using their respective join functions and log errors if any join fails.
    - Join the funk, progcache, and txncache components to the execution context, ensuring that each join is successful and logging critical errors if not.
    - Allocate and set up the transaction context (`txn_ctx`) using the spad allocator, joining necessary components and logging errors if any join fails.
    - Initialize the capture context if required by the tile's configuration, setting up directories and buffers for capturing transaction data.
    - Set the `pending_txn_finalized_msg` flag to 0, indicating no pending transaction finalization messages.
- **Output**: No return value; the function initializes the execution context for the specified tile.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)
    - [`scratch_footprint`](<#scratch_footprint>)


---
### publish\_next\_capture\_ctx\_account\_update<!-- {{#callable:publish_next_capture_ctx_account_update}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L341>)

Publishes the next account update event from the capture context to the replay tile.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_exec_tile_ctx_t` structure, which contains the execution context including the capture context and buffer pointers.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages to the replay tile.
- **Logic and Control Flow**:
    - Check if `ctx->capture_ctx` is NULL; if so, return immediately.
    - Copy the account update event from `ctx->solcap_publish_buffer_ptr` to the output buffer at `ctx->exec_replay_out->mem`.
    - Advance the `solcap_publish_buffer_ptr` by the size of the account update message.
    - Copy additional data from `solcap_publish_buffer_ptr` to the output buffer and advance the pointer by the data size.
    - Publish the account update event using `fd_stem_publish` with the calculated message size.
    - Update `ctx->exec_replay_out->chunk` using `fd_dcache_compact_next` to prepare for the next message.
    - Increment `ctx->account_updates_flushed` to track the number of updates published.
    - If all account updates have been published, reset the buffer pointers and lengths in `ctx->capture_ctx`.
- **Output**: No return value; the function modifies the state of `ctx` and publishes data to the replay tile.


---
### publish\_txn\_finalized\_msg<!-- {{#callable:publish_txn_finalized_msg}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L384>)

Publishes a transaction finalized message to the replay tile and updates the execution context.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_exec_tile_ctx_t` structure, which contains the execution context for the transaction.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing messages.
- **Logic and Control Flow**:
    - Convert the chunk in `ctx->exec_replay_out` to a local address and assign it to `msg`.
    - Set `msg->bank_idx` to `ctx->txn_ctx->bank_idx`.
    - Set `msg->txn_exec->txn_idx` to `ctx->txn_idx`.
    - Determine if there was an execution error by checking `ctx->txn_ctx->flags` and set `msg->txn_exec->err` accordingly.
    - Log a warning if there was an execution error.
    - Publish the message using `fd_stem_publish` with the appropriate parameters.
    - Update `ctx->exec_replay_out->chunk` using `fd_dcache_compact_next`.
    - Set `ctx->pending_txn_finalized_msg` to 0.
- **Output**: No return value; the function updates the execution context and publishes a message.


---
### after\_credit<!-- {{#callable:after_credit}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L402>)

Handles the publication of account updates or transaction finalized messages and controls the polling state.
- **Inputs**:
    - `ctx`: A pointer to `fd_exec_tile_ctx_t`, which contains the execution context and state information.
    - `stem`: A pointer to `fd_stem_context_t`, which is used for publishing messages.
    - `opt_poll_in`: A pointer to an integer that indicates whether polling should continue.
    - `charge_busy`: An unused integer pointer parameter.
- **Logic and Control Flow**:
    - Checks if there are outstanding account updates to send by evaluating `ctx->capture_ctx` and comparing `ctx->account_updates_flushed` with `ctx->capture_ctx->account_updates_len`.
    - If there are outstanding updates, calls [`publish_next_capture_ctx_account_update`](<#publish_next_capture_ctx_account_update>) to send them and sets `*opt_poll_in` to 0 to stop further polling.
    - If there are no outstanding updates but there is a pending transaction finalized message (`ctx->pending_txn_finalized_msg` is true), calls [`publish_txn_finalized_msg`](<#publish_txn_finalized_msg>) to send the message and sets `*opt_poll_in` to 0.
- **Output**: No return value; modifies `*opt_poll_in` to control polling behavior.
- **Functions Called**:
    - [`publish_next_capture_ctx_account_update`](<#publish_next_capture_ctx_account_update>)
    - [`publish_txn_finalized_msg`](<#publish_txn_finalized_msg>)


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L421>)

Populates a seccomp filter policy for an execution tile and returns the instruction count.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, marked as unused.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, marked as unused.
    - ``out_cnt``: An unsigned long integer representing the count of output filters.
    - ``out``: A pointer to an array of `struct sock_filter` where the seccomp filter policy will be populated.
- **Logic and Control Flow**:
    - Calls [`populate_sock_filter_policy_fd_exec_tile`](<generated/fd_exec_tile_seccomp.h.md#populate_sock_filter_policy_fd_exec_tile>) with `out_cnt`, `out`, and the file descriptor from `fd_log_private_logfile_fd()` to populate the seccomp filter policy.
    - Returns the value of `sock_filter_policy_fd_exec_tile_instr_cnt`.
- **Output**: Returns an unsigned long integer representing the instruction count of the seccomp filter policy.
- **Functions Called**:
    - [`populate_sock_filter_policy_fd_exec_tile`](<generated/fd_exec_tile_seccomp.h.md#populate_sock_filter_policy_fd_exec_tile>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../src/discof/exec/fd_exec_tile.c#L430>)

Populates an array with file descriptors that are allowed for use, specifically `stderr` and optionally a logfile descriptor.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, marked as unused.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, marked as unused.
    - ``out_fds_cnt``: The maximum number of file descriptors that can be stored in the `out_fds` array.
    - ``out_fds``: An array of integers where the allowed file descriptors will be stored.
- **Logic and Control Flow**:
    - Check if `out_fds_cnt` is less than 2; if true, log an error and terminate.
    - Initialize `out_cnt` to 0.
    - Assign the file descriptor for `stderr` (2) to `out_fds[0]` and increment `out_cnt`.
    - Check if the logfile descriptor is valid (not -1); if true, assign it to `out_fds[out_cnt]` and increment `out_cnt`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array.



---
Made with ❤️ by [Driver](https://www.driver.ai/)