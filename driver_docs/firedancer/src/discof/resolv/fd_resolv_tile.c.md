<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements a transaction resolution tile with blockhash management, transaction stashing, and address lookup table handling.

# Purpose
The code is a C source file that implements a transaction resolution module within a larger system. It is designed to handle and process transactions, specifically focusing on managing blockhashes and resolving address lookup tables. The module includes several components, such as data structures for managing blockhashes (`blockhash_t`, `blockhash_map_t`), transaction stashing (`fd_stashed_txn_m_t`), and context management (`fd_resolv_ctx_t`). It uses various utility templates for managing maps, pools, and doubly linked lists, which are included from external files.

The primary functionality of the code revolves around maintaining a ring buffer of recent blockhashes to determine the validity of incoming transactions based on their blockhashes. It also handles the resolution of address lookup tables from a database cache, which is crucial for executing transactions that reference external accounts. The module interfaces with other components of the system, such as replay and pack modules, through defined input and output contexts. It also includes mechanisms for handling transaction bundles and durable nonce transactions, ensuring that only valid and executable transactions are forwarded for further processing. The code is structured to be part of a larger system, with specific functions for initialization, metrics collection, and transaction processing callbacks.
# Imports and Dependencies

---
- `fd_resolv_tile.h`
- `../../disco/fd_txn_m.h`
- `../../disco/topo/fd_topo.h`
- `../replay/fd_replay_tile.h`
- `generated/fd_resolv_tile_seccomp.h`
- `../../disco/metrics/fd_metrics.h`
- `../../flamenco/accdb/fd_accdb_sync.h`
- `../../flamenco/runtime/fd_alut_interp.h`
- `../../flamenco/runtime/fd_system_ids_pp.h`
- `../../flamenco/runtime/fd_bank.h`
- `../../util/pod/fd_pod_format.h`
- `../../util/simd/fd_avx.h`
- `../../util/tmpl/fd_map.c`
- `../../util/tmpl/fd_pool.c`
- `../../util/tmpl/fd_dlist.c`
- `../../util/tmpl/fd_map_chain.c`
- `../../disco/stem/fd_stem.c`


# Global Variables

---
### null\_blockhash
- **Type**: ``blockhash_t``
- **Description**: A constant variable of type `blockhash_t` initialized with all zero values. It represents a block hash with no valid data.
- **Use**: Used as a null or invalid key in block hash maps to signify an empty or uninitialized state.


---
### fd\_tile\_resolv
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a `fd_topo_run_tile_t` structure named `fd_tile_resolv` with various function pointers and properties for managing a tile in a topology. The structure includes fields for the tile's name, security policies, memory alignment, footprint, initialization, and execution.
- **Use**: Used to configure and manage the execution of a tile named 'resolv' within a topology.


# Data Structures

---
### blockhash
- **Type**: ``struct``
- **Members**:
    - ``b``: An array of 32 unsigned characters (`uchar`) representing the block hash.
- **Description**: Represents a block hash as an array of 32 bytes, typically used to store cryptographic hash values in blockchain applications.


---
### blockhash\_t
- **Type**: ``struct``
- **Members**:
    - ``b``: An array of 32 unsigned characters representing the block hash.
- **Description**: `blockhash_t` is a structure that contains a single member, `b`, which is an array of 32 unsigned characters. This structure is used to represent a block hash, which is a fixed-size hash value typically used in blockchain systems to uniquely identify a block of transactions.


---
### blockhash\_map
- **Type**: ``struct``
- **Members**:
    - ``key``: A `blockhash_t` type that serves as the key in the map.
    - ``slot``: An `ulong` type that represents the slot associated with the key.
- **Description**: Maps a `blockhash_t` key to a slot number, which helps track the expiration of transactions based on their blockhash.


---
### blockhash\_map\_t
- **Type**: ``struct``
- **Members**:
    - ``key``: A `blockhash_t` structure that serves as the key in the map.
    - ``slot``: An `ulong` that represents the slot associated with the blockhash.
- **Description**: Maps a `blockhash_t` key to a slot number, which helps track the expiration of transactions based on their blockhashes.


---
### fd\_stashed\_txn\_m\_t
- **Type**: ``struct``
- **Members**:
    - ``pool_next``: Stores the next index in the pool when the transaction is released.
    - ``lru_next``: Stores the next index in the LRU list when the transaction is acquired.
    - ``lru_prev``: Stores the previous index in the LRU list.
    - ``map_next``: Stores the next index in the map chain.
    - ``map_prev``: Stores the previous index in the map chain.
    - ``blockhash``: Points to a `blockhash_t` structure representing the block hash.
    - ``_``: Stores transaction data with a size defined by `FD_TPU_PARSED_MTU` and aligned to `fd_txn_m_t`.
- **Description**: `fd_stashed_txn_m_t` is a structure used to manage transactions in a pool, LRU list, and map chain. It uses a union to store either `pool_next` or `lru_next`, depending on whether the transaction is released or acquired, optimizing memory usage. The structure also includes pointers for managing the transaction's position in a map chain and a pointer to a block hash. The transaction data is stored in an aligned array, ensuring efficient memory access.


---
### fd\_resolv\_in\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``kind``: An integer that specifies the type of input context.
    - ``mem``: A pointer to a `fd_wksp_t` structure, representing a memory workspace.
    - ``chunk0``: An unsigned long that indicates the starting chunk index in the memory workspace.
    - ``wmark``: An unsigned long that represents the watermark or upper limit for chunk processing.
    - ``mtu``: An unsigned long that specifies the maximum transmission unit size for the context.
- **Description**: The `fd_resolv_in_ctx_t` structure defines an input context for a resolution process, containing information about the type of input, associated memory workspace, and parameters for chunk processing such as starting index, watermark, and maximum transmission unit size.


---
### fd\_resolv\_out\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``mem``: Pointer to a `fd_wksp_t` workspace.
    - ``chunk0``: Initial chunk index in the workspace.
    - ``wmark``: Watermark indicating the upper limit of chunk usage.
    - ``chunk``: Current chunk index in the workspace.
- **Description**: `fd_resolv_out_ctx_t` is a structure that manages output context for resolution operations, including memory workspace, chunk indices, and watermark for chunk management.


---
### fd\_resolv\_ctx\_t
- **Type**: ``struct``
- **Members**:
    - ``round_robin_idx``: Stores the current index for round-robin processing.
    - ``round_robin_cnt``: Stores the total count for round-robin processing.
    - ``bundle_failed``: Indicates if the current bundle has failed.
    - ``bundle_id``: Stores the identifier for the current bundle.
    - ``blockhash_map``: Pointer to a map of blockhashes.
    - ``flushing_slot``: Stores the slot number currently being flushed.
    - ``flush_pool_idx``: Stores the index of the pool being flushed.
    - ``banks``: Pointer to a collection of banks.
    - ``bank``: Pointer to the current bank.
    - ``accdb``: Array of account database users.
    - ``pool``: Pointer to a pool of stashed transactions.
    - ``map_chain``: Pointer to a chain map of transactions.
    - ``lru_list``: List for least recently used transactions.
    - ``completed_slot``: Stores the last completed slot number.
    - ``blockhash_ring_idx``: Index for the blockhash ring buffer.
    - ``blockhash_ring``: Ring buffer storing recent blockhashes.
    - ``_rooted_slot_msg``: Stores the message for rooted slot advancement.
    - ``_completed_slot_msg``: Stores the message for slot completion.
    - ``metrics``: Structure for storing various metrics.
    - ``in``: Array of input contexts for resolution.
    - ``out_pack``: Output context for packing.
    - ``out_replay``: Output context for replaying.
- **Description**: `fd_resolv_ctx_t` is a complex data structure used in a transaction resolution context. It manages various aspects of transaction processing, including round-robin scheduling, bundle management, blockhash mapping, and transaction stashing. It also handles input and output contexts for transaction packing and replaying, and maintains metrics for performance monitoring. The structure is designed to facilitate efficient transaction processing and management in a distributed system.


# Functions

---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L178>)

Returns the alignment requirement of the `fd_resolv_ctx_t` structure.
- **Inputs**: None
- **Logic and Control Flow**:
    - Calls the `alignof` operator on `fd_resolv_ctx_t` to determine its alignment requirement.
    - Returns the result of the `alignof` operation.
- **Output**: An `ulong` representing the alignment requirement of the `fd_resolv_ctx_t` structure.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L183>)

Calculates the memory footprint required for a scratch space based on various alignment and size requirements.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure, which is not used in the function.
- **Logic and Control Flow**:
    - Initialize a variable `l` with `FD_LAYOUT_INIT` to start the layout calculation.
    - Append the size and alignment of `fd_resolv_ctx_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the alignment and footprint of a pool with `1UL<<16UL` elements to `l`.
    - Append the alignment and footprint of a map chain with `8192UL` elements to `l`.
    - Append the alignment and footprint of a map to `l`.
    - Finalize the layout calculation with `FD_LAYOUT_FINI` using `scratch_align()` and return the result.
- **Output**: Returns an `ulong` representing the total memory footprint required for the scratch space.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### metrics\_write<!-- {{#callable:metrics_write}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L194>)

Updates various metrics in the `fd_resolv_ctx_t` context using predefined macros.
- **Inputs**:
    - `ctx`: A pointer to an `fd_resolv_ctx_t` structure containing the metrics to update.
- **Logic and Control Flow**:
    - Use the `FD_MCNT_SET` macro to update the `BLOCKHASH_EXPIRED` metric with the value from `ctx->metrics.blockhash_expired`.
    - Use the `FD_MCNT_ENUM_COPY` macro to copy the `LUT_RESOLVED` metrics from `ctx->metrics.lut`.
    - Use the `FD_MCNT_ENUM_COPY` macro to copy the `STASH_OPERATION` metrics from `ctx->metrics.stash`.
    - Use the `FD_MCNT_SET` macro to update the `TRANSACTION_BUNDLE_PEER_FAILURE` metric with the value from `ctx->metrics.bundle_peer_failure`.
    - Use the `FD_MCNT_SET` macro to update the `DB_RACES` metric with the value from `ctx->metrics.db_race`.
- **Output**: None (void function).


---
### before\_frag<!-- {{#callable:before_frag}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L203>)

Determines if a fragment should be processed based on its sequence number and context kind.
- **Inputs**:
    - `ctx`: A pointer to `fd_resolv_ctx_t`, which contains context information including input kind and round-robin parameters.
    - `in_idx`: An unsigned long integer representing the index of the input context to check.
    - `seq`: An unsigned long integer representing the sequence number of the fragment.
    - `sig`: An unsigned long integer representing a signal, which is not used in this function.
- **Logic and Control Flow**:
    - Ignores the `sig` parameter as it is not used in the function.
    - Checks if the input kind at `ctx->in[in_idx]` is `IN_KIND_REPLAY`; if true, returns 0, indicating the fragment should not be processed.
    - Calculates `seq % ctx->round_robin_cnt` and compares it to `ctx->round_robin_idx`; returns the result of this comparison as a boolean (0 or 1).
- **Output**: Returns 0 if the input kind is `IN_KIND_REPLAY` or if the sequence number modulo the round-robin count equals the round-robin index; otherwise, returns 1.


---
### during\_frag<!-- {{#callable:during_frag}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L215>)

Handles data processing based on the input kind, either copying data for deduplication or updating context messages for replay.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_resolv_ctx_t` structure that holds context information for processing.
    - ``in_idx``: An index indicating which input context to use from the `ctx->in` array.
    - ``seq``: A sequence number, marked as unused in this function.
    - ``sig``: A signal value, marked as unused in this function.
    - ``chunk``: A chunk identifier used to locate data in memory.
    - ``sz``: The size of the data to process.
    - ``ctl``: A control value, marked as unused in this function.
- **Logic and Control Flow**:
    - Checks if `chunk` is within the valid range defined by `ctx->in[in_idx].chunk0` and `ctx->in[in_idx].wmark`, and if `sz` is less than or equal to `ctx->in[in_idx].mtu`; logs an error if not.
    - Switches on `ctx->in[in_idx].kind` to determine processing type.
    - For `IN_KIND_DEDUP`, copies data from the source chunk to the destination chunk using `fd_memcpy`.
    - For `IN_KIND_REPLAY`, updates context messages based on the `sig` value, either setting `_rooted_slot_msg` or `_completed_slot_msg`.
    - Logs an error if `ctx->in[in_idx].kind` is unknown.
- **Output**: No return value; the function operates by modifying the context `ctx` and logging errors if necessary.


---
### peek\_alut<!-- {{#callable:peek_alut}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L249>)

Reads a single address lookup table from the database cache and updates the interpreter state accordingly.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_resolv_ctx_t` structure, which contains context information for the resolution process.
    - ``txnm``: A pointer to the `fd_txn_m_t` structure, representing the transaction metadata.
    - ``interp``: A pointer to the `fd_alut_interp_t` structure, which is used to interpret address lookup tables.
    - ``alut_idx``: An unsigned long integer representing the index of the address lookup table to be read.
- **Logic and Control Flow**:
    - Initialize a transaction ID (`xid`) using the bank slot from the context's bank.
    - Store the current state of the interpreter (`interp`) including `ro_indir_cnt`, `rw_indir_cnt`, and `alut_idx`.
    - Retrieve the transaction and its payload from `txnm`.
    - Get the address lookup table (`addr_lut`) from the transaction using `alut_idx` and load the associated public key (`addr_lut_acc`).
    - Enter a loop to attempt to read the address lookup table from the database cache.
    - Use `fd_accdb_peek` to get a peek at the account database with the given `xid` and `addr_lut_acc`.
    - If the peek fails, set the error code to `FD_RUNTIME_TXN_ERR_ADDRESS_LOOKUP_TABLE_NOT_FOUND` and exit the loop.
    - If the peek succeeds, call `fd_alut_interp_next` to update the interpreter with the account data.
    - Test the peek result with `fd_accdb_peek_test` and drop the peek with `fd_accdb_peek_drop`.
    - If the peek test is successful, exit the loop.
    - If the peek test fails, restore the old interpreter state, increment the database race metric, and retry.
- **Output**: Returns an integer error code, where 0 indicates success and non-zero indicates an error occurred during the address lookup table read process.


---
### peek\_aluts<!-- {{#callable:peek_aluts}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L301>)

Reads address lookup tables from a database cache and updates metrics based on the result.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_resolv_ctx_t` structure that contains the context for the resolution process.
    - ``txnm``: A pointer to a `fd_txn_m_t` structure representing the transaction metadata.
- **Logic and Control Flow**:
    - Unpack the transaction context to retrieve transaction details, payload, and address lookup table count.
    - Retrieve the current slot and query the system variable cache for slot hashes.
    - Initialize an interpreter for address lookup table processing.
    - Iterate over each address lookup table index and call [`peek_alut`](<#peek_alut>) to process each table.
    - If an error occurs during processing, break the loop.
    - Delete the interpreter and release the slot hashes from the system variable cache.
    - Determine the appropriate metrics index based on the error code and update the metrics in the context.
- **Output**: Returns an integer error code indicating the success or type of error encountered during the address lookup table processing.
- **Functions Called**:
    - [`peek_alut`](<#peek_alut>)


---
### publish\_txn<!-- {{#callable:publish_txn}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L339>)

Publishes a transaction by copying it from a stashed location, resolving address lookup tables if necessary, and updating the output context.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_resolv_ctx_t` structure, which contains context information for transaction resolution.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, which is used for publishing the transaction.
    - ``stashed``: A pointer to the `fd_stashed_txn_m_t` structure, which contains the stashed transaction data to be published.
- **Logic and Control Flow**:
    - Convert the stashed transaction to a local address using `fd_chunk_to_laddr` and copy it to `txnm` using `fd_memcpy`.
    - Set the `reference_slot` of `txnm` to `ctx->flushing_slot`.
    - Check if the transaction has additional address lookup tables (`addr_table_adtl_cnt`).
    - If additional address lookup tables exist and `ctx->bank` is not set, increment the `NO_BANK_DROP` metric and return 0.
    - If additional address lookup tables exist, call [`peek_aluts`](<#peek_aluts>) to resolve them; if it fails, return 0.
    - Calculate the realized size of the transaction using `fd_txn_m_realized_footprint`.
    - Get the current timestamp using `fd_tickcount` and `fd_frag_meta_ts_comp`.
    - Publish the transaction using `fd_stem_publish` with the calculated parameters.
    - Update `ctx->out_pack->chunk` using `fd_dcache_compact_next` to prepare for the next transaction.
    - Return 1 to indicate successful publication.
- **Output**: Returns 1 if the transaction is successfully published, otherwise returns 0 if there is an error in processing.
- **Functions Called**:
    - [`peek_aluts`](<#peek_aluts>)


---
### after\_credit<!-- {{#callable:after_credit}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L367>)

Manages the processing of a transaction after it has been credited, updating metrics and releasing resources.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_resolv_ctx_t` structure that holds the context for the resolution process.
    - ``stem``: A pointer to a `fd_stem_context_t` structure used for publishing transactions.
    - ``opt_poll_in``: A pointer to an integer that will be set to 0, indicating no polling is needed.
    - ``charge_busy``: A pointer to an integer that will be set to 1, indicating the system is busy.
- **Logic and Control Flow**:
    - Check if `ctx->flush_pool_idx` is equal to `ULONG_MAX`; if true, return immediately.
    - Set `*charge_busy` to 1 and `*opt_poll_in` to 0.
    - Calculate the next index in the chain using `map_chain_idx_next_const` and store it in `next`.
    - Remove the current index from the map chain using `map_chain_idx_remove_fast`.
    - Attempt to publish the transaction using [`publish_txn`](<#publish_txn>); if successful, increment the published metric, otherwise increment the removed metric.
    - Remove the current index from the LRU list using `lru_list_idx_remove`.
    - Release the current index in the pool using `pool_idx_release`.
    - Update `ctx->flush_pool_idx` to the value of `next`.
- **Output**: No return value; the function modifies the state of the input pointers and context.
- **Functions Called**:
    - [`publish_txn`](<#publish_txn>)


---
### fd\_resolv\_is\_durable\_nonce<!-- {{#callable:fd_resolv_is_durable_nonce}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L392>)

Determines if a transaction is a durable nonce transaction by checking specific conditions in its first instruction.
- **Inputs**:
    - `txn`: A pointer to a `fd_txn_t` structure representing the transaction to check.
    - `payload`: A pointer to a constant unsigned character array representing the transaction payload.
- **Logic and Control Flow**:
    - Check if the transaction's instruction count is zero; if so, return 0.
    - Retrieve the first instruction and its associated program ID from the transaction.
    - Compare the program ID with the system program ID to ensure it matches the SystemProgram nonceAdvance instruction; if not, return 0.
    - Verify that the first instruction has exactly three accounts and a data size of four bytes; if not, return 0.
    - Load a four-byte unsigned integer from the payload at the data offset of the first instruction and check if it equals 4; if so, return 1.
- **Output**: Returns 1 if the transaction may be a durable nonce transaction, otherwise returns 0.


---
### after\_frag<!-- {{#callable:after_frag}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L410>)

Processes transaction fragments by handling replay signals, managing blockhashes, and forwarding transactions based on their validity and context.
- **Inputs**:
    - ``ctx``: A pointer to the `fd_resolv_ctx_t` structure, which holds the context for resolution operations.
    - ``in_idx``: An index indicating the input source within the context.
    - ``seq``: A sequence number for the fragment, though it is not used in the function.
    - ``sig``: A signal indicating the type of replay event, such as `REPLAY_SIG_SLOT_COMPLETED` or `REPLAY_SIG_ROOT_ADVANCED`.
    - ``sz``: The size of the fragment, though it is not used in the function.
    - ``tsorig``: The original timestamp of the fragment.
    - ``_tspub``: A timestamp for publication, though it is not used in the function.
    - ``stem``: A pointer to the `fd_stem_context_t` structure, used for publishing transactions.
- **Logic and Control Flow**:
    - Checks if the input kind is `IN_KIND_REPLAY`; if true, processes replay signals.
    - For `REPLAY_SIG_SLOT_COMPLETED`, updates the blockhash ring and map, and sets the completed slot.
    - For `REPLAY_SIG_ROOT_ADVANCED`, updates the bank and sends a slot completed message back to replay.
    - If the input kind is not `IN_KIND_REPLAY`, processes the transaction by checking blockhash validity and bundle membership.
    - If the transaction is part of a bundle and the bundle has failed, increments the bundle peer failure metric and returns.
    - Queries the blockhash map to determine the reference slot for the transaction.
    - If the blockhash is not found and the transaction is not a durable nonce or bundle member, stashes the transaction for later processing.
    - If the transaction has address table lookups, attempts to resolve them; if unsuccessful, marks the bundle as failed and returns.
    - Publishes the transaction if it is valid and updates the output chunk.
- **Output**: No return value; the function modifies the context and potentially publishes transactions.
- **Functions Called**:
    - [`fd_resolv_is_durable_nonce`](<#fd_resolv_is_durable_nonce>)
    - [`peek_aluts`](<#peek_aluts>)


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L576>)

Initializes the unprivileged context for a tile in a topology, setting up memory allocations, data structures, and input/output configurations.
- **Inputs**:
    - ``topo``: A pointer to the `fd_topo_t` structure representing the topology configuration.
    - ``tile``: A pointer to the `fd_topo_tile_t` structure representing the specific tile to initialize.
- **Logic and Control Flow**:
    - Allocate scratch memory for the tile using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_INIT`.
    - Initialize a `fd_resolv_ctx_t` context structure within the allocated scratch memory.
    - Set up round-robin counters and initialize various context fields to default values.
    - Join and initialize a memory pool and map chain for transaction management.
    - Initialize an LRU list for transaction caching and ensure it is joined correctly.
    - Clear the blockhash ring and metrics structures using `memset`.
    - Join a blockhash map for managing blockhash entries.
    - Configure input links by iterating over `tile->in_cnt` and setting up memory and chunk configurations for each input link.
    - Configure output links for packing and replay by setting up memory and chunk configurations.
    - Join the account database using `fd_accdb_user_join` and verify the join was successful.
    - Query and join the banks object using `fd_pod_queryf_ulong` and `fd_banks_join`, ensuring the join was successful.
    - Finalize scratch memory allocation with `FD_SCRATCH_ALLOC_FINI` and check for overflow errors.
- **Output**: No return value; the function initializes the context in place.
- **Functions Called**:
    - [`scratch_footprint`](<#scratch_footprint>)


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L647>)

Populates a seccomp filter with allowed system call policies for a specific tile.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, representing the topology configuration.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, representing the tile configuration.
    - ``out_cnt``: An unsigned long integer representing the count of output filters to populate.
    - ``out``: A pointer to a `struct sock_filter` array where the function will store the populated seccomp filters.
- **Logic and Control Flow**:
    - Ignores the `topo` and `tile` inputs as they are not used in the function body.
    - Calls [`populate_sock_filter_policy_fd_resolv_tile`](<generated/fd_resolv_tile_seccomp.h.md#populate_sock_filter_policy_fd_resolv_tile>) with `out_cnt`, `out`, and the file descriptor obtained from `fd_log_private_logfile_fd()`.
    - Returns the value of `sock_filter_policy_fd_resolv_tile_instr_cnt`.
- **Output**: Returns an unsigned long integer representing the count of instructions in the seccomp filter policy.
- **Functions Called**:
    - [`populate_sock_filter_policy_fd_resolv_tile`](<generated/fd_resolv_tile_seccomp.h.md#populate_sock_filter_policy_fd_resolv_tile>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../src/discof/resolv/fd_resolv_tile.c#L659>)

Populates an array with file descriptors for `stderr` and optionally a logfile, returning the count of populated descriptors.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure, which is not used in this function.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure, which is not used in this function.
    - ``out_fds_cnt``: The maximum number of file descriptors that can be stored in the `out_fds` array.
    - ``out_fds``: An array of integers where the function will store the allowed file descriptors.
- **Logic and Control Flow**:
    - Ignore the `topo` and `tile` parameters as they are not used.
    - Check if `out_fds_cnt` is less than 2; if so, log an error and terminate the program.
    - Initialize `out_cnt` to 0 to keep track of the number of file descriptors added.
    - Add the file descriptor for `stderr` (which is 2) to the `out_fds` array and increment `out_cnt`.
    - Check if the logfile file descriptor is valid (not -1); if valid, add it to the `out_fds` array and increment `out_cnt`.
    - Return the value of `out_cnt`, which is the number of file descriptors added to `out_fds`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array as an unsigned long integer.



---
Made with ❤️ by [Driver](https://www.driver.ai/)