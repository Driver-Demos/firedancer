<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements the `fd_tower_tile` structure and related functions for managing voting and replay processes in a distributed system.

# Purpose
The code defines a C module that implements a component of a distributed system, specifically a "tower" tile. This module is responsible for managing voting and consensus processes within a distributed ledger or blockchain system. It includes several key structures and functions that handle the initialization, state management, and processing of voting data. The `fd_tower_tile_t` structure is central to this module, encapsulating the state and configuration necessary for the tower's operation, including public keys, epoch and ghost data, and replay tower information.

The module includes functions for initializing the tower from genesis or snapshot data, updating the state based on replayed slots, and managing the voting process. It interacts with other components through various input and output channels, as indicated by the `fd_topo_t` and `fd_topo_tile_t` structures. The code also includes mechanisms for handling secure computing policies and file descriptor management, ensuring that the tower operates within defined security constraints. The module is designed to be integrated into a larger system, as indicated by the inclusion of the `fd_stem.c` file, which provides a framework for running the tile within the system's topology.
# Imports and Dependencies

---
- `fd_tower_tile.h`
- `generated/fd_tower_tile_seccomp.h`
- `../genesis/fd_genesi_tile.h`
- `../replay/fd_replay_tile.h`
- `../../choreo/ghost/fd_ghost.h`
- `../../choreo/tower/fd_tower.h`
- `../../choreo/voter/fd_voter.h`
- `../../disco/keyguard/fd_keyload.h`
- `../../disco/topo/fd_topo.h`
- `../../discof/restore/utils/fd_ssmsg.h`
- `../../ballet/lthash/fd_lthash.h`
- `../../flamenco/fd_flamenco_base.h`
- `../../flamenco/runtime/fd_system_ids.h`
- `errno.h`
- `fcntl.h`
- `../../disco/stem/fd_stem.c`


# Global Variables

---
### fd\_tile\_tower
- **Type**: ``fd_topo_run_tile_t``
- **Description**: Defines a structure for a tile in the topology with specific initialization and execution functions. It includes function pointers for security and file descriptor population, memory alignment, and footprint calculations.
- **Use**: Used to configure and manage the execution of a tile named 'tower' in the system's topology.


# Data Structures

---
### fd\_tower\_tile\_in
- **Type**: ``struct``
- **Members**:
    - ``mem``: Pointer to a `fd_wksp_t` structure, representing a memory workspace.
    - ``chunk0``: Unsigned long integer indicating the starting chunk index.
    - ``wmark``: Unsigned long integer representing the watermark or limit for processing.
    - ``mtu``: Unsigned long integer specifying the maximum transmission unit size.
- **Description**: Represents an input tile in a tower structure, containing memory workspace and configuration parameters for chunk processing and data transmission.


---
### fd\_tower\_tile\_in\_t
- **Type**: ``struct``
- **Members**:
    - ``mem``: Pointer to a workspace memory structure.
    - ``chunk0``: Initial chunk index for data processing.
    - ``wmark``: Watermark indicating the boundary for data processing.
    - ``mtu``: Maximum transmission unit size for data chunks.
- **Description**: `fd_tower_tile_in_t` is a structure that manages input data processing parameters for a tower tile. It includes a pointer to the workspace memory, initial chunk index, watermark for data processing boundaries, and the maximum transmission unit size for data chunks.


---
### fd\_tower\_tile
- **Type**: ``struct``
- **Members**:
    - ``identity_key``: An array of `fd_pubkey_t` representing the identity key.
    - ``vote_acc``: An array of `fd_pubkey_t` representing the vote account.
    - ``initialized``: An integer indicating if the structure is initialized.
    - ``checkpt_fd``: An integer file descriptor for checkpoint operations.
    - ``restore_fd``: An integer file descriptor for restore operations.
    - ``epoch``: A pointer to `fd_epoch_t` representing the epoch.
    - ``ghost``: A pointer to `fd_ghost_t` representing the ghost state.
    - ``scratch``: A pointer to `fd_tower_t` used for temporary storage.
    - ``tower``: A pointer to `fd_tower_t` representing the tower state.
    - ``voters``: A pointer to `uchar` representing the voters.
    - ``ts``: A long integer representing the tower timestamp.
    - ``manifest``: An `fd_snapshot_manifest_t` representing the snapshot manifest.
    - ``replay_slot_info``: An `fd_replay_slot_completed_t` representing replay slot information.
    - ``replay_towers_cnt``: An unsigned long integer representing the count of replay towers.
    - ``replay_towers``: An array of `fd_replay_tower_t` representing replay towers.
    - ``vote_towers``: An array of pointers to `fd_tower_t` representing vote towers.
    - ``vote_keys``: An array of `fd_pubkey_t` representing vote keys.
    - ``vote_state``: An array of `uchar` representing the vote state.
    - ``in_kind``: An array of integers representing the kind of input.
    - ``in``: An array of `fd_tower_tile_in_t` representing input data.
    - ``out_mem``: A pointer to `fd_wksp_t` representing output memory.
    - ``out_chunk0``: An unsigned long integer representing the initial output chunk.
    - ``out_wmark``: An unsigned long integer representing the output watermark.
    - ``out_chunk``: An unsigned long integer representing the current output chunk.
- **Description**: Represents a data structure for managing tower tiles, including identity and vote keys, file descriptors for checkpoint and restore operations, epoch and ghost state pointers, and arrays for managing replay towers, vote towers, and input/output data.


---
### fd\_tower\_tile\_t
- **Type**: ``struct``
- **Members**:
    - ``identity_key``: An array of `fd_pubkey_t` representing the identity key.
    - ``vote_acc``: An array of `fd_pubkey_t` representing the vote account.
    - ``initialized``: An integer indicating if the structure is initialized.
    - ``checkpt_fd``: An integer file descriptor for checkpoint operations.
    - ``restore_fd``: An integer file descriptor for restore operations.
    - ``epoch``: A pointer to `fd_epoch_t` representing the epoch.
    - ``ghost``: A pointer to `fd_ghost_t` representing the ghost state.
    - ``scratch``: A pointer to `fd_tower_t` used as scratch space.
    - ``tower``: A pointer to `fd_tower_t` representing the tower state.
    - ``voters``: A pointer to `uchar` representing the voters.
    - ``ts``: A long integer representing the tower timestamp.
    - ``manifest``: An `fd_snapshot_manifest_t` representing the snapshot manifest.
    - ``replay_slot_info``: An `fd_replay_slot_completed_t` representing replay slot information.
    - ``replay_towers_cnt``: An unsigned long integer representing the count of replay towers.
    - ``replay_towers``: An array of `fd_replay_tower_t` representing replay towers.
    - ``vote_towers``: An array of pointers to `fd_tower_t` representing vote towers.
    - ``vote_keys``: An array of `fd_pubkey_t` representing vote keys.
    - ``vote_state``: An array of `uchar` representing the vote state.
    - ``in_kind``: An array of integers representing the kind of input.
    - ``in``: An array of `fd_tower_tile_in_t` representing input data.
    - ``out_mem``: A pointer to `fd_wksp_t` representing output memory.
    - ``out_chunk0``: An unsigned long integer representing the initial output chunk.
    - ``out_wmark``: An unsigned long integer representing the output watermark.
    - ``out_chunk``: An unsigned long integer representing the current output chunk.
- **Description**: `fd_tower_tile_t` is a complex data structure that manages the state and operations of a tower in a distributed system. It includes fields for identity and vote keys, initialization status, file descriptors for checkpoint and restore operations, and pointers to various components such as epoch, ghost, and tower states. The structure also maintains arrays for replay towers, vote towers, and vote states, as well as input and output configurations. It is designed to handle the processing of votes and snapshots in a distributed environment, ensuring synchronization and consistency across different components.


# Functions

---
### scratch\_align<!-- {{#callable:scratch_align}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L73>)

Returns a constant alignment value of 128.
- **Inputs**: None
- **Logic and Control Flow**:
    - The function is defined as `static inline` and is marked with `FD_FN_CONST`, indicating it always returns the same value and has no side effects.
    - The function body contains a single return statement that returns the constant value `128UL`.
- **Output**: A constant unsigned long integer value of 128.


---
### scratch\_footprint<!-- {{#callable:scratch_footprint}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L78>)

Calculates the memory footprint required for a `fd_tower_tile_t` structure and its associated components.
- **Inputs**:
    - `tile`: A pointer to a `fd_topo_tile_t` structure, which is not used in the function.
- **Logic and Control Flow**:
    - Initialize `l` with `FD_LAYOUT_INIT`.
    - Append the size and alignment of `fd_tower_tile_t` to `l` using `FD_LAYOUT_APPEND`.
    - Append the size and alignment of the epoch component using `fd_epoch_align` and `fd_epoch_footprint` with `FD_REPLAY_TOWER_VOTE_ACC_MAX`.
    - Append the size and alignment of the ghost component using `fd_ghost_align` and `fd_ghost_footprint` with `FD_BLOCK_MAX`.
    - Append the size and alignment of the tower component using `fd_tower_align` and `fd_tower_footprint`.
    - Append the size and alignment of the vote towers using `fd_tower_align` and `fd_tower_footprint` multiplied by `FD_REPLAY_TOWER_VOTE_ACC_MAX`.
    - Finalize the layout with `FD_LAYOUT_FINI` using [`scratch_align`](<#scratch_align>) and return the result.
- **Output**: Returns an `ulong` representing the total memory footprint required.
- **Functions Called**:
    - [`scratch_align`](<#scratch_align>)


---
### update\_ghost<!-- {{#callable:update_ghost}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L91>)

Updates the ghost state with the latest vote account states from replay towers.
- **Inputs**:
    - `ctx`: A pointer to an `fd_tower_tile_t` structure that contains the context for the tower tile, including epoch voters, replay towers, vote towers, and ghost state.
- **Logic and Control Flow**:
    - Retrieve the list of epoch voters using `fd_epoch_voters` with the current epoch from `ctx`.
    - Iterate over each replay tower in `ctx->replay_towers` up to `ctx->replay_towers_cnt`.
    - For each replay tower, retrieve the public key, voter state, and corresponding vote tower.
    - Query the epoch voters for the current replay tower's public key using `fd_epoch_voters_query`.
    - If the voter is not found, log a critical error indicating a potential epoch boundary crossing without an updated epoch voter list.
    - Update the voter's stake with the stake from the replay tower.
    - If the voter state has no votes, continue to the next replay tower.
    - Peek the last vote from the current vote tower and get the root slot from the voter state.
    - If the last vote is valid and greater than or equal to the ghost root slot, query the ghost for the vote slot.
    - If the vote slot is not found in the ghost, log a critical error indicating an invariant violation.
    - Replay the vote in the ghost using `fd_ghost_replay_vote`.
    - If the voter's root is valid and greater than or equal to the ghost root slot, query the ghost for the root slot.
    - If the root slot is not found in the ghost, log a critical error indicating an invariant violation.
    - Root the vote in the ghost using `fd_ghost_rooted_vote`.
- **Output**: No return value; the function updates the ghost state and logs errors if any invariant violations occur.


---
### replay\_slot\_completed<!-- {{#callable:replay_slot_completed}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L153>)

Processes the completion of a replay slot by updating vote towers, ghost state, and preparing a vote transaction.
- **Inputs**:
    - ``ctx``: A pointer to `fd_tower_tile_t` structure containing context information for the tower.
    - ``slot_info``: A pointer to `fd_replay_slot_completed_t` structure containing information about the completed slot.
    - ``tsorig``: An unsigned long integer representing the original timestamp.
    - ``stem``: A pointer to `fd_stem_context_t` structure used for publishing the fragment.
- **Logic and Control Flow**:
    - Checks if `ctx->replay_towers_cnt` is zero and logs a warning if true, then returns.
    - Iterates over `ctx->replay_towers_cnt` to update vote towers and keys, and initializes the tower if it is empty.
    - Inserts the vote account states into the ghost and updates it using [`update_ghost`](<#update_ghost>).
    - Prepares the output fragment by determining the next vote slot and root, and populating the vote transaction.
    - Determines the next slot to reset the leader pipeline and publishes the fragment using `fd_stem_publish`.
- **Output**: No return value; the function updates the context and publishes a fragment.
- **Functions Called**:
    - [`update_ghost`](<#update_ghost>)


---
### init\_genesis<!-- {{#callable:init_genesis}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L242>)

Initializes the genesis state by setting up the ghost context and processing stake accounts to update epoch voters and total stake.
- **Inputs**:
    - ``ctx``: A pointer to a `fd_tower_tile_t` structure that holds the context for the tower tile, including ghost and epoch information.
    - ``genesis``: A pointer to a `fd_genesis_solana_global_t` structure that contains the genesis data, including accounts and their lengths.
- **Logic and Control Flow**:
    - Initialize `manifest_block_id` with a fixed value and call `fd_ghost_init` to initialize the ghost context with this block ID.
    - Retrieve the epoch voters using `fd_epoch_voters` and join the genesis accounts using `fd_genesis_solana_accounts_join`.
    - Iterate over each account in the genesis accounts.
    - For each account, check if the account owner is not the stake program ID using `memcmp`. If not, continue to the next account.
    - Join the account data using `fd_solana_account_data_join` and attempt to decode it into a `fd_stake_state_v2_t` structure using `fd_bincode_decode_static`. Log an error if decoding fails.
    - Check if the decoded stake state is a valid stake and if the delegation stake is non-zero. If not, continue to the next account.
    - Retrieve the voter public key from the stake state and insert it into the epoch voters using `fd_epoch_voters_insert`.
    - Update the voter's stake and add it to the total stake in the epoch context.
- **Output**: No return value; the function modifies the `ctx` structure to update the ghost context and epoch voters.


---
### snapshot\_done<!-- {{#callable:snapshot_done}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L274>)

Initializes epoch voters using the stakes from the snapshot manifest for the current epoch.
- **Inputs**:
    - ``ctx``: A pointer to an `fd_tower_tile_t` structure representing the context for the operation.
    - ``manifest``: A pointer to a constant `fd_snapshot_manifest_t` structure containing the snapshot data, including epoch stakes.
- **Logic and Control Flow**:
    - Initialize `manifest_block_id` with a fixed value and call `fd_ghost_init` to initialize the ghost state with the manifest's slot and block ID.
    - Retrieve the epoch voters from the context's epoch using `fd_epoch_voters`.
    - Access the stakes for the current epoch from `manifest->epoch_stakes[1]`.
    - Iterate over each vote stake in `epoch_stakes->vote_stakes`.
    - For each vote stake, if the stake is non-zero, retrieve the public key and insert it into the epoch voters using `fd_epoch_voters_insert`.
    - Set the voter's stake and initialize its vote slots to `FD_SLOT_NULL`.
    - Accumulate the total stake in the context's epoch.
- **Output**: No return value; the function modifies the `ctx` structure to update epoch voters and total stake.


---
### returnable\_frag<!-- {{#callable:returnable_frag}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L320>)

Processes input fragments based on their type (genesis, snapshot, or replay) and updates the context accordingly.
- **Inputs**:
    - `ctx`: Pointer to a `fd_tower_tile_t` structure that holds the context for processing.
    - `in_idx`: Index of the input source in the `ctx->in` array.
    - `seq`: Sequence number of the fragment (unused in the function).
    - `sig`: Signature of the fragment indicating its type or state.
    - `chunk`: Chunk index within the input memory to process.
    - `sz`: Size of the fragment.
    - `ctl`: Control flags for the fragment.
    - `tsorig`: Original timestamp of the fragment.
    - `tspub`: Publication timestamp of the fragment (unused in the function).
    - `stem`: Pointer to a `fd_stem_context_t` structure used for publishing fragments.
- **Logic and Control Flow**:
    - Checks if the input kind at `in_idx` is `IN_KIND_GENESIS` and if the signature is `GENESI_SIG_BOOTSTRAP_COMPLETED`, then initializes the genesis context and sets `ctx->initialized` to 1.
    - If the input kind is `IN_KIND_SNAP`, checks if the signature indicates a snapshot completion (`FD_SSMSG_DONE`), then calls [`snapshot_done`](<#snapshot_done>) and sets `ctx->initialized` to 1.
    - For `IN_KIND_SNAP`, if the signature does not indicate completion, checks if the chunk is within valid range and copies the snapshot manifest to `ctx->manifest`.
    - If the input kind is `IN_KIND_REPLAY`, checks if the chunk is within valid range and if `ctx->initialized` is not set, returns 1 to indicate waiting for initialization.
    - For `IN_KIND_REPLAY`, if the signature is `REPLAY_SIG_SLOT_COMPLETED`, copies replay slot information to `ctx->replay_slot_info`.
    - For `IN_KIND_REPLAY`, if the signature is `REPLAY_SIG_VOTE_STATE`, checks control flags for start of message, updates replay towers, and calls [`replay_slot_completed`](<#replay_slot_completed>) if end of message is detected.
    - Logs an error if the input kind is unexpected.
- **Output**: Returns 0 on successful processing or 1 if waiting for initialization is required.
- **Functions Called**:
    - [`init_genesis`](<#init_genesis>)
    - [`snapshot_done`](<#snapshot_done>)
    - [`replay_slot_completed`](<#replay_slot_completed>)


---
### privileged\_init<!-- {{#callable:privileged_init}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L376>)

Initializes a `fd_tower_tile_t` context with identity and vote keys, and sets up file descriptors for checkpoint and restore operations.
- **Inputs**:
    - ``topo``: A pointer to an `fd_topo_t` structure, representing the topology configuration.
    - ``tile``: A pointer to an `fd_topo_tile_t` structure, representing the tile configuration.
- **Logic and Control Flow**:
    - Allocate scratch memory for the `fd_tower_tile_t` context using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_INIT`.
    - Append a `fd_tower_tile_t` structure to the scratch memory using `FD_SCRATCH_ALLOC_APPEND`.
    - Check if the `identity_key_path` in `tile->tower` is set; log an error if it is not.
    - Load the identity key from the specified path using `fd_keyload_load` and store it in `ctx->identity_key`.
    - Attempt to decode the `vote_acc_path` as a base58 encoded public key using `fd_base58_decode_32`.
    - If decoding fails, load the vote account key from the specified path using `fd_keyload_load` and store it in `ctx->vote_acc`.
    - Construct file paths for checkpoint and restore operations using `fd_cstr_printf_check`.
    - Open a file for writing at the checkpoint path with `open`; log an error if it fails.
    - Open a file for reading at the restore path with `open`; log a warning if it fails and the error is not `ENOENT`.
- **Output**: No return value; the function initializes the context and sets up file descriptors.


---
### unprivileged\_init<!-- {{#callable:unprivileged_init}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L408>)

Initializes the unprivileged context for a tower tile by setting up memory allocations and configuring input and output links.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology configuration.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the tile configuration.
- **Logic and Control Flow**:
    - Allocate scratch memory using `fd_topo_obj_laddr` to get the local address of the tile object ID.
    - Initialize the scratch allocator with `FD_SCRATCH_ALLOC_INIT`.
    - Allocate memory for `fd_tower_tile_t` context and other components like epoch, ghost, tower, and vote towers using `FD_SCRATCH_ALLOC_APPEND`.
    - Join the newly created epoch, ghost, and tower objects to the context using `fd_epoch_join`, `fd_ghost_join`, and `fd_tower_join`.
    - Initialize the `vote_towers` array by joining each newly created tower object.
    - Set `ctx->initialized` to 0 and `ctx->replay_towers_cnt` to 0.
    - Verify that the number of input links is less than the maximum allowed by checking `tile->in_cnt`.
    - For each input link, determine its kind (genesis, snap, or replay) and configure the input memory, MTU, chunk0, and watermark using `fd_dcache_compact_chunk0` and `fd_dcache_compact_wmark`.
    - Configure the output memory, chunk0, and watermark using the first output link's dcache object ID.
- **Output**: No return value; the function initializes the context for further operations.


---
### populate\_allowed\_seccomp<!-- {{#callable:populate_allowed_seccomp}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L460>)

Populates a seccomp filter policy for a tower tile using the provided topology and tile information.
- **Inputs**:
    - `topo`: A pointer to a `fd_topo_t` structure representing the topology of the system.
    - `tile`: A pointer to a `fd_topo_tile_t` structure representing the specific tile within the topology.
    - `out_cnt`: An unsigned long integer representing the count of output filters to populate.
    - `out`: A pointer to an array of `sock_filter` structures where the seccomp filter policy will be populated.
- **Logic and Control Flow**:
    - Retrieve the local address of the tile object using `fd_topo_obj_laddr` and store it in `scratch`.
    - Initialize a scratch allocator with `FD_SCRATCH_ALLOC_INIT` using the `scratch` pointer.
    - Allocate memory for a `fd_tower_tile_t` context using `FD_SCRATCH_ALLOC_APPEND`.
    - Call [`populate_sock_filter_policy_fd_tower_tile`](<generated/fd_tower_tile_seccomp.h.md#populate_sock_filter_policy_fd_tower_tile>) with the output count, output filter array, and file descriptors from the context to populate the seccomp filter policy.
    - Return the instruction count from `sock_filter_policy_fd_tower_tile_instr_cnt`.
- **Output**: Returns the number of instructions in the populated seccomp filter policy as an unsigned long integer.
- **Functions Called**:
    - [`populate_sock_filter_policy_fd_tower_tile`](<generated/fd_tower_tile_seccomp.h.md#populate_sock_filter_policy_fd_tower_tile>)


---
### populate\_allowed\_fds<!-- {{#callable:populate_allowed_fds}} -->
[View Source →](<../../../../../src/discof/tower/fd_tower_tile.c#L473>)

Populates an array with file descriptors that are allowed for a specific tile in a topology.
- **Inputs**:
    - ``topo``: A pointer to a `fd_topo_t` structure representing the topology.
    - ``tile``: A pointer to a `fd_topo_tile_t` structure representing the tile within the topology.
    - ``out_fds_cnt``: An unsigned long integer specifying the maximum number of file descriptors that can be stored in `out_fds`.
    - ``out_fds``: A pointer to an integer array where the allowed file descriptors will be stored.
- **Logic and Control Flow**:
    - Allocate scratch memory for the tile using `fd_topo_obj_laddr` and `FD_SCRATCH_ALLOC_INIT`.
    - Append a `fd_tower_tile_t` context to the scratch memory using `FD_SCRATCH_ALLOC_APPEND`.
    - Check if `out_fds_cnt` is less than 4; if so, log an error using `FD_LOG_ERR`.
    - Initialize `out_cnt` to 0 and set `out_fds[0]` to 2, which represents `stderr`.
    - Check if the log file descriptor is valid using `fd_log_private_logfile_fd` and add it to `out_fds` if valid.
    - Check if `ctx->checkpt_fd` is valid and add it to `out_fds` if valid.
    - Check if `ctx->restore_fd` is valid and add it to `out_fds` if valid.
    - Return the count of file descriptors added to `out_fds`.
- **Output**: Returns the number of file descriptors added to the `out_fds` array.



---
Made with ❤️ by [Driver](https://www.driver.ai/)