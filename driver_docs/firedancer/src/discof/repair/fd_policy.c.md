<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

Implements functions for managing and manipulating deduplication and peer policies in a repair system.

# Purpose
The code defines a set of functions for managing a policy related to deduplication and peer management in a networked environment. It is part of a larger system, as indicated by the inclusion of headers such as `fd_policy.h` and `fd_metrics.h`. The primary functionality revolves around creating, joining, leaving, and deleting a policy object, which is represented by the `fd_policy_t` structure. This structure manages deduplication maps, pools, and least recently used (LRU) lists, as well as peer maps and lists for fast and slow peers.

The code provides functions to handle deduplication ([`dedup_evict`](<#dedup_evict>), [`dedup_next`](<#dedup_next>)) and peer selection ([`fd_policy_peer_select`](<#fd_policy_peer_select>)). It also includes mechanisms to insert, query, and remove peers, as well as update request and response statistics for peers. The policy is used to manage network communication, ensuring that duplicate messages are not processed and that peers are selected based on latency and other criteria. The code is designed to be part of a larger system, likely involving network communication and data synchronization, and it provides a structured way to manage deduplication and peer interactions within that system.
# Imports and Dependencies

---
- `fd_policy.h`
- `../../disco/metrics/fd_metrics.h`


# Functions

---
### fd\_policy\_new<!-- {{#callable:fd_policy_new}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L9>)

Initializes a new policy structure in shared memory with deduplication and peer management components.
- **Inputs**:
    - `shmem`: Pointer to shared memory where the policy structure will be initialized.
    - `dedup_max`: Maximum number of deduplication entries.
    - `peer_max`: Maximum number of peer entries.
    - `seed`: Seed value for deduplication map initialization.
- **Logic and Control Flow**:
    - Check if `shmem` is NULL; if so, log a warning and return NULL.
    - Check if `shmem` is aligned according to [`fd_policy_align`](<fd_policy.h.md#fd_policy_align>); if not, log a warning and return NULL.
    - Calculate the memory footprint required for the policy structure using [`fd_policy_footprint`](<fd_policy.h.md#fd_policy_footprint>).
    - Initialize the shared memory to zero using `fd_memset`.
    - Calculate the logarithm base 2 of the next power of two for `peer_max` using `fd_ulong_find_msb`.
    - Initialize scratch memory allocation with `FD_SCRATCH_ALLOC_INIT`.
    - Allocate memory for the policy structure and its components using `FD_SCRATCH_ALLOC_APPEND`.
    - Verify that the allocated memory matches the expected footprint using `FD_SCRATCH_ALLOC_FINI`.
    - Initialize the deduplication map, pool, and LRU components using their respective `new` functions.
    - Initialize the peer map, pool, and lists (fast and slow) using their respective `new` functions.
    - Set initial values for `iterf.ele_idx`, `turbine_slot0`, `tsreset`, and `nonce` in the policy structure.
    - Return the pointer to the shared memory.
- **Output**: Returns the pointer to the initialized shared memory if successful, or NULL if there is an error.
- **Functions Called**:
    - [`fd_policy_align`](<fd_policy.h.md#fd_policy_align>)
    - [`fd_policy_footprint`](<fd_policy.h.md#fd_policy_footprint>)


---
### fd\_policy\_join<!-- {{#callable:fd_policy_join}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L52>)

Initializes and validates a `fd_policy_t` structure from a shared memory policy object.
- **Inputs**:
    - `shpolicy`: A pointer to a shared memory policy object that needs to be joined and validated.
- **Logic and Control Flow**:
    - Cast `shpolicy` to a `fd_policy_t` pointer named `policy`.
    - Check if `policy` is NULL; if so, log a warning and return NULL.
    - Check if `policy` is aligned according to [`fd_policy_align`](<fd_policy.h.md#fd_policy_align>); if not, log a warning and return NULL.
    - Retrieve the workspace containing `policy` using `fd_wksp_containing`; if not found, log a warning and return NULL.
    - Join the deduplication map, pool, and LRU components of `policy` using their respective join functions.
    - Join the peer map, pool, and fast/slow lists of `policy` using their respective join functions.
    - Initialize the peer selection iterator and stage for `policy`.
    - Return the initialized `policy`.
- **Output**: A pointer to the initialized and validated `fd_policy_t` structure, or NULL if validation fails.
- **Functions Called**:
    - [`fd_policy_align`](<fd_policy.h.md#fd_policy_align>)


---
### fd\_policy\_leave<!-- {{#callable:fd_policy_leave}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L86>)

Returns the input `policy` pointer if it is not NULL, otherwise logs a warning and returns NULL.
- **Inputs**:
    - `policy`: A pointer to a constant `fd_policy_t` structure that represents the policy to leave.
- **Logic and Control Flow**:
    - Check if the `policy` pointer is NULL using `FD_UNLIKELY`.
    - If `policy` is NULL, log a warning message 'NULL policy' and return NULL.
    - If `policy` is not NULL, cast it to a `void *` and return it.
- **Output**: A `void *` pointer to the `policy` if it is not NULL, otherwise NULL.


---
### fd\_policy\_delete<!-- {{#callable:fd_policy_delete}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L97>)

Validates the input policy pointer and returns it if valid, otherwise logs a warning and returns NULL.
- **Inputs**:
    - `policy`: A pointer to a policy object that needs to be validated and potentially deleted.
- **Logic and Control Flow**:
    - Check if the `policy` pointer is NULL using `FD_UNLIKELY`; if true, log a warning and return NULL.
    - Check if the `policy` pointer is aligned according to `fd_policy_align()` using `FD_UNLIKELY`; if not aligned, log a warning and return NULL.
    - If both checks pass, return the `policy` pointer.
- **Output**: Returns the `policy` pointer if it is non-NULL and properly aligned; otherwise, returns NULL.
- **Functions Called**:
    - [`fd_policy_align`](<fd_policy.h.md#fd_policy_align>)


---
### dedup\_evict<!-- {{#callable:dedup_evict}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L115>)

Evicts the least recently used element from the deduplication policy's LRU list and removes it from the map and pool.
- **Inputs**:
    - `policy`: A pointer to an `fd_policy_t` structure that contains the deduplication policy data.
- **Logic and Control Flow**:
    - Call `fd_policy_dedup_lru_ele_pop_head` to remove the least recently used element from the LRU list.
    - Call `fd_policy_dedup_map_ele_remove` to remove the element from the deduplication map using its key.
    - Call `fd_policy_dedup_pool_ele_release` to release the element back to the pool.
- **Output**: No output is returned as the function is of type `void`.


---
### dedup\_next<!-- {{#callable:dedup_next}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L123>)

Checks if a key is deduplicated based on a timestamp and updates the deduplication data structures accordingly.
- **Inputs**:
    - ``policy``: A pointer to the `fd_policy_t` structure, which contains deduplication data structures.
    - ``key``: An unsigned long integer representing the key to check for deduplication.
    - ``now``: A long integer representing the current timestamp.
- **Logic and Control Flow**:
    - Queries the deduplication map for an element with the given `key`.
    - If the element is not found, checks if there is space in the deduplication pool; if not, evicts an element.
    - Acquires a new element from the pool, sets its `key` and `req_ts`, and inserts it into the deduplication map and LRU list.
    - Checks if the current time `now` is less than the element's `req_ts` plus a timeout value.
    - If the condition is true, returns 1 indicating the key is deduplicated.
    - If the condition is false, updates the element's `req_ts` to `now` and returns 0.
- **Output**: Returns 1 if the key is deduplicated within the timeout period, otherwise returns 0.
- **Functions Called**:
    - [`dedup_evict`](<#dedup_evict>)


---
### ts\_ms<!-- {{#callable:ts_ms}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L142>)

Converts a wallclock time in nanoseconds to milliseconds.
- **Inputs**:
    - `wallclock`: A `long` integer representing the wallclock time in nanoseconds.
- **Logic and Control Flow**:
    - Casts the `wallclock` input from `long` to `ulong`.
    - Divides the casted `wallclock` value by 1,000,000 to convert nanoseconds to milliseconds.
- **Output**: Returns the converted time as an `ulong` representing milliseconds.


---
### passes\_throttle\_threshold<!-- {{#callable:passes_throttle_threshold}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L146>)

Determines if a block passes the throttle threshold based on its slot and timing constraints.
- **Inputs**:
    - ``policy``: A pointer to an `fd_policy_t` structure that contains policy configurations.
    - ``ele``: A pointer to an `fd_forest_blk_t` structure representing a block in the forest.
- **Logic and Control Flow**:
    - Check if the block's slot is less than the policy's `turbine_slot0`; if true, return 1.
    - Calculate the current duration of the block from the first shred received until now.
    - Calculate the tick plus buffer time using the estimated buffered tick received and a defined buffer time.
    - Compare the current duration with the tick plus buffer; if the current duration is greater or equal, increment the repair metric and return 1.
    - If none of the conditions are met, return 0.
- **Output**: Returns 1 if the block passes the throttle threshold, otherwise returns 0.


---
### fd\_policy\_peer\_select<!-- {{#callable:fd_policy_peer_select}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L162>)

Selects the next peer identity from a list based on latency criteria and updates the selection iterator.
- **Inputs**:
    - ``policy``: A pointer to an `fd_policy_t` structure that contains peer selection and latency information.
- **Logic and Control Flow**:
    - Initialize `best_dlist` and `worst_dlist` from `policy->peers.fast` and `policy->peers.slow`, respectively.
    - Determine the current `dlist` based on the latency stage from `bucket_stages` and `policy->peers.select.stage`.
    - Enter a loop to check if the current iterator is done using `fd_peer_dlist_iter_done`.
    - If the iterator is done, update the selection stage and reinitialize the iterator with `fd_peer_dlist_iter_fwd_init`.
    - Select the current peer using `fd_peer_dlist_iter_ele` and update the iterator with `fd_peer_dlist_iter_fwd_next`.
- **Output**: A pointer to the `fd_pubkey_t` structure representing the selected peer's identity.


---
### fd\_policy\_next<!-- {{#callable:fd_policy_next}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L180>)

Determines the next repair message to send based on the current state of the policy, forest, and repair structures.
- **Inputs**:
    - ``policy``: A pointer to an `fd_policy_t` structure that manages deduplication and peer selection.
    - ``forest``: A pointer to an `fd_forest_t` structure representing the current state of the forest.
    - ``repair``: A pointer to an `fd_repair_t` structure used to create repair messages.
    - ``now``: A long integer representing the current time in nanoseconds.
    - ``highest_known_slot``: An unsigned long integer representing the highest known slot number.
- **Logic and Control Flow**:
    - Initialize `pool` and `subtrees` from the `forest` structure.
    - Return `NULL` if the forest root is `ULONG_MAX` or if no peers are available in the policy's peer pool.
    - Convert `now` to milliseconds and store in `now_ms`.
    - If the forest has subtrees, iterate over them to find orphans and attempt to create a repair message for each orphan if it is not deduplicated.
    - Reset the policy's iterator if the time since the last reset exceeds 100 ms or if the frontier version has changed.
    - Retrieve the current element from the forest pool using the policy's iterator index.
    - If the element is `NULL`, return `NULL` as all shreds are known.
    - Enter a loop to attempt to make a repair request, checking if the current element passes the throttle threshold.
    - If the element's shred index is `UINT_MAX`, attempt to create a repair message for the highest shred if it is not deduplicated and the slot is less than `highest_known_slot`.
    - Otherwise, attempt to create a repair message for the current shred if it is not deduplicated.
    - Advance the policy's iterator to the next element in the forest.
    - If no request was made, return `NULL`; otherwise, return the created repair message.
- **Output**: Returns a pointer to an `fd_repair_msg_t` structure representing the next repair message to send, or `NULL` if no message is needed.
- **Functions Called**:
    - [`ts_ms`](<#ts_ms>)
    - [`fd_policy_dedup_key`](<fd_policy.h.md#fd_policy_dedup_key>)
    - [`dedup_next`](<#dedup_next>)
    - [`fd_policy_peer_select`](<#fd_policy_peer_select>)
    - [`fd_policy_reset`](<#fd_policy_reset>)
    - [`passes_throttle_threshold`](<#passes_throttle_threshold>)
    - [`fd_repair_highest_shred`](<fd_repair.c.md#fd_repair_highest_shred>)
    - [`fd_repair_shred`](<fd_repair.c.md#fd_repair_shred>)


---
### fd\_policy\_peer\_insert<!-- {{#callable:fd_policy_peer_insert}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L287>)

Inserts a new peer into the policy's peer map if it does not already exist and there is capacity.
- **Inputs**:
    - ``policy``: A pointer to the `fd_policy_t` structure where the peer will be inserted.
    - ``key``: A constant pointer to the `fd_pubkey_t` structure representing the public key of the peer.
    - ``addr``: A constant pointer to the `fd_ip4_port_t` structure containing the IP address and port of the peer.
- **Logic and Control Flow**:
    - Query the peer map in `policy` using `key` to check if the peer already exists.
    - If the peer does not exist and the peer map has not reached its maximum capacity, insert the peer into the map.
    - Initialize the peer's key, IP address, port, and various counters and timestamps to zero.
    - Acquire a peer element from the peer pool and set its identity to `key`.
    - Push the peer element to the tail of the slow peer list in `policy`.
    - Return the newly inserted peer.
- **Output**: A constant pointer to the `fd_policy_peer_t` structure representing the inserted peer, or `NULL` if the peer already exists or the map is full.


---
### fd\_policy\_peer\_query<!-- {{#callable:fd_policy_peer_query}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L314>)

Queries the peer map in the policy for a peer associated with a given public key.
- **Inputs**:
    - ``policy``: A pointer to an `fd_policy_t` structure that contains the peer map to query.
    - ``key``: A pointer to a constant `fd_pubkey_t` structure representing the public key of the peer to query.
- **Logic and Control Flow**:
    - Calls the function `fd_policy_peer_map_query` with the peer map from the `policy`, the dereferenced `key`, and `NULL` as arguments.
    - Returns the result of the `fd_policy_peer_map_query` function call.
- **Output**: A pointer to an `fd_policy_peer_t` structure representing the queried peer, or `NULL` if the peer is not found.


---
### fd\_policy\_peer\_remove<!-- {{#callable:fd_policy_peer_remove}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L319>)

Removes a peer from the policy's peer map and pool based on the given public key.
- **Inputs**:
    - ``policy``: A pointer to the `fd_policy_t` structure that contains the peer map and pool.
    - ``key``: A constant pointer to the `fd_pubkey_t` structure representing the public key of the peer to remove.
- **Logic and Control Flow**:
    - Query the peer map using the provided `key` to find the corresponding `fd_policy_peer_t` structure.
    - If the peer is not found, return 0 indicating failure to remove.
    - Retrieve the peer element from the peer pool using the peer's pool index.
    - Remove the peer from the peer map.
    - Check if the current iterator in the peer selection process is on the peer to be removed; if so, advance the iterator to the next element in the appropriate latency list.
    - Determine the latency bucket for the peer based on its total latency and response count.
    - Remove the peer element from the determined latency bucket.
    - Release the peer element back to the peer pool.
    - Return 1 indicating successful removal.
- **Output**: Returns an integer: 1 if the peer was successfully removed, 0 if the peer was not found.
- **Functions Called**:
    - [`fd_policy_peer_latency_bucket`](<fd_policy.h.md#fd_policy_peer_latency_bucket>)


---
### fd\_policy\_peer\_request\_update<!-- {{#callable:fd_policy_peer_request_update}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L338>)

Updates the request count and timestamps for a peer in the policy.
- **Inputs**:
    - ``policy``: A pointer to the `fd_policy_t` structure that contains the peer information.
    - ``to``: A constant pointer to the `fd_pubkey_t` structure representing the peer's public key.
- **Logic and Control Flow**:
    - Query the peer using [`fd_policy_peer_query`](<#fd_policy_peer_query>) with the given `policy` and `to` key.
    - If the peer is found (`FD_LIKELY`), increment the peer's request count (`req_cnt`).
    - Update the peer's last request timestamp (`last_req_ts`) with the current tick count from `fd_tickcount()`.
    - If the peer's first request timestamp (`first_req_ts`) is zero (`FD_UNLIKELY`), set it to the current tick count.
- **Output**: No return value (void function).
- **Functions Called**:
    - [`fd_policy_peer_query`](<#fd_policy_peer_query>)


---
### fd\_policy\_peer\_response\_update<!-- {{#callable:fd_policy_peer_response_update}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L348>)

Updates the response statistics for a peer in the policy based on the round-trip time (RTT) of a response.
- **Inputs**:
    - ``policy``: A pointer to the `fd_policy_t` structure that contains the peer information.
    - ``to``: A constant pointer to the `fd_pubkey_t` structure representing the public key of the peer whose response statistics are to be updated.
    - ``rtt``: A long integer representing the round-trip time in nanoseconds for the response.
- **Logic and Control Flow**:
    - Query the peer associated with the given public key `to` using [`fd_policy_peer_query`](<#fd_policy_peer_query>).
    - If the peer is found, get the current time using `fd_tickcount()`.
    - Determine the previous latency bucket for the peer using [`fd_policy_peer_latency_bucket`](<fd_policy.h.md#fd_policy_peer_latency_bucket>).
    - Increment the peer's response count `res_cnt`.
    - If `first_resp_ts` is zero, set it to the current time `now`.
    - Update `last_resp_ts` to the current time `now`.
    - Add the round-trip time `rtt` to the peer's total latency `total_lat`.
    - Determine the new latency bucket for the peer using [`fd_policy_peer_latency_bucket`](<fd_policy.h.md#fd_policy_peer_latency_bucket>).
    - If the previous and new latency buckets differ, remove the peer from the previous bucket and add it to the new bucket using `fd_peer_dlist_ele_remove` and `fd_peer_dlist_ele_push_tail`.
- **Output**: No return value; the function updates the peer's response statistics in the policy.
- **Functions Called**:
    - [`fd_policy_peer_query`](<#fd_policy_peer_query>)
    - [`fd_policy_peer_latency_bucket`](<fd_policy.h.md#fd_policy_peer_latency_bucket>)


---
### fd\_policy\_reset<!-- {{#callable:fd_policy_reset}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L368>)

Resets the iteration state and timestamp of a policy object using a given forest.
- **Inputs**:
    - ``policy``: A pointer to an `fd_policy_t` structure that will be reset.
    - ``forest``: A pointer to an `fd_forest_t` structure used to initialize the policy's iterator.
- **Logic and Control Flow**:
    - Initialize the `iterf` field of the `policy` structure by calling `fd_forest_iter_init` with the `forest` parameter.
    - Set the `tsreset` field of the `policy` structure to the current wall clock time in milliseconds by calling [`ts_ms`](<#ts_ms>) with the result of `fd_log_wallclock()`.
- **Output**: No return value (void function).
- **Functions Called**:
    - [`ts_ms`](<#ts_ms>)


---
### fd\_policy\_set\_turbine\_slot0<!-- {{#callable:fd_policy_set_turbine_slot0}} -->
[View Source →](<../../../../../src/discof/repair/fd_policy.c#L374>)

Sets the `turbine_slot0` field of a `fd_policy_t` structure to a specified slot value.
- **Inputs**:
    - `policy`: A pointer to a `fd_policy_t` structure whose `turbine_slot0` field will be set.
    - `slot`: An unsigned long integer representing the slot value to set in the `turbine_slot0` field.
- **Logic and Control Flow**:
    - Assigns the value of `slot` to the `turbine_slot0` field of the `policy` structure.
- **Output**: No return value.



---
Made with ❤️ by [Driver](https://www.driver.ai/)